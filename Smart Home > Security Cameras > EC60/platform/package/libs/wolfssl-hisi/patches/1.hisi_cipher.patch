diff -uNar a/wolfcrypt/src/aes.c b/wolfcrypt/src/aes.c
--- a/wolfcrypt/src/aes.c	2017-05-05 06:06:26.000000000 +0800
+++ b/wolfcrypt/src/aes.c	2017-06-14 17:57:00.681138137 +0800
@@ -9,7 +9,24 @@
  * http://www.wolfssl.com
  */
 
-
+#ifdef BOARD_HI3518EV200
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <stdarg.h>
+
+#include "hi_type.h"
+#include "hi_unf_cipher.h"
+#include "hi_mmz_api.h"
+
+#define COLOR_NONE              "\033[0000m"
+#define COLOR_GREEN             "\033[0;32m"
+#define COLOR_YELLOW            "\033[1;33m"
+#define COLOR_RED               "\033[0;31m"
+static void cayssl_debug_do(const char *func, int line, const char * format,...);
+#define cayssl_debug(arg...)  cayssl_debug_do(__FUNCTION__, __LINE__, ##arg)
+#endif
 
 #ifdef HAVE_CONFIG_H
     #include <config.h>
@@ -607,6 +624,25 @@
     /* for 128-bit blocks, Rijndael never uses more than 10 rcon values */
 };
 
+#ifdef BOARD_HI3518EV200
+//static inline int printBuffer(HI_CHAR *string, HI_U8 *pu8Input, HI_U32 u32Length);
+#define printBuffer(a,b,c) 
+
+typedef struct hisi_aes_cipher
+{
+    ALIGN16 word32 key[60];
+    ALIGN16 word32 iv[AES_BLOCK_SIZE / sizeof(word32)];
+
+    /* hisi sdk */
+    HI_HANDLE cipher_handle;
+    HI_U32    input_addr_phy;
+    HI_U8     *input_addr_vir;
+    HI_U32    output_addr_phy;
+    HI_U8     *output_addr_vir;
+} HISI_AES_CIPHER;
+static HISI_AES_CIPHER g_hisi_aes;
+#endif
+
 static const word32 Te[4][256] = {
 {
     0xc66363a5U, 0xf87c7c84U, 0xee777799U, 0xf67b7b8dU,
@@ -2270,7 +2306,7 @@
 
         return 0;
     }
-
+	
     #ifdef HAVE_AES_DECRYPT
     int wc_AesCbcDecrypt(Aes* aes, byte* out, const byte* in, word32 sz)
     {
@@ -2719,6 +2755,264 @@
     #endif /* HAVE_AES_DECRYPT */
 
 #else
+    #ifdef BOARD_HI3518EV200//add cipher
+
+    static void cayssl_debug_do(const char *func, int line, const char * format,...)
+    {
+        int lenStd = 0;
+        char msgStd[5*1024] = {0};
+        va_list ap_list;
+
+        va_start(ap_list, format);
+        sprintf(msgStd, COLOR_GREEN"[%s]"COLOR_NONE"[%s:%d] "COLOR_YELLOW, "cyassl", func, line);
+        lenStd = strlen(msgStd);
+        vsnprintf(msgStd + lenStd, sizeof(msgStd) - lenStd, format,ap_list);
+        
+        if(access("/etc/rwdir/debug.1", F_OK) == 0){
+            FILE *fd_out = NULL;
+            fd_out = fopen("/dev/console", "w");
+            if(!fd_out){
+                ;
+            }else{
+                fprintf(fd_out, "%s"COLOR_NONE, msgStd);
+                fclose(fd_out);
+            }
+        }
+        if(access("/etc/rwdir/debug.2", F_OK) == 0){
+            fprintf(stdout, "%s"COLOR_NONE, msgStd);
+        }
+        
+        va_end(ap_list);
+        return;
+    }
+    
+    static void print_macro()
+    {    
+        #ifdef HAVE_AESGCM
+        cayssl_debug(" HAVE_AESGCM \n");
+        #endif
+
+        #ifdef GCM_TABLE
+        cayssl_debug(" GCM_TABLE \n");
+        #endif
+
+        #ifdef CYASSL_AESNI
+        cayssl_debug(" CYASSL_AESNI \n");
+        #endif
+
+        #ifdef HAVE_CAVIUM
+        cayssl_debug(" HAVE_CAVIUM \n");
+        #endif
+
+        #ifdef CYASSL_AES_COUNTER
+        cayssl_debug(" CYASSL_AES_COUNTER \n");
+        #endif
+
+        #ifdef CYASSL_PIC32MZ_CRYPT
+        cayssl_debug(" CYASSL_PIC32MZ_CRYPT \n");
+        #endif
+
+        cayssl_debug("end print_macro\n");
+    }
+
+    static HI_S32 cipher_config_init(HISI_AES_CIPHER* aes, int rounds)
+    {
+        HI_S32 s32Ret = 0;
+        HI_UNF_CIPHER_CTRL_S CipherCtrl;
+        
+        memset(&CipherCtrl, 0, sizeof(HI_UNF_CIPHER_CTRL_S));
+        CipherCtrl.enAlg = HI_UNF_CIPHER_ALG_AES;
+        CipherCtrl.enWorkMode = HI_UNF_CIPHER_WORK_MODE_CBC;
+        CipherCtrl.enBitWidth = HI_UNF_CIPHER_BIT_WIDTH_128BIT;
+        CipherCtrl.enKeySrc = HI_UNF_CIPHER_KEY_SRC_USER;
+        if (10 == rounds)
+        {
+            CipherCtrl.enKeyLen = HI_UNF_CIPHER_KEY_AES_128BIT;
+        }
+        else if (12 == rounds)
+        {
+            CipherCtrl.enKeyLen = HI_UNF_CIPHER_KEY_AES_192BIT;
+        }
+        else if (14 == rounds)
+        {
+            CipherCtrl.enKeyLen = HI_UNF_CIPHER_KEY_AES_256BIT;
+        }
+
+        //mode == HI_UNF_CIPHER_WORK_MODE_CBC
+        CipherCtrl.stChangeFlags.bit1IV = 1;  //must set for CBC , CFB mode
+        memcpy(CipherCtrl.u32IV, aes->iv, 16);
+
+        //HI_UNF_CIPHER_KEY_SRC_USER == enKeySrc
+        memcpy(CipherCtrl.u32Key, aes->key, 32);   
+        //printBuffer("key of HI_UNF_CIPHER_ConfigHandle", CipherCtrl.u32Key, 32);
+
+        s32Ret = HI_UNF_CIPHER_ConfigHandle(aes->cipher_handle, &CipherCtrl);
+        if(0 != s32Ret){
+            cayssl_debug("HI_UNF_CIPHER_ConfigHandle err\n");
+            return -1;  
+        }
+
+        return 0;
+    }
+
+    static int reverse_key(word32 a[])
+    {
+        a[0] = ByteReverseWord32(a[0]);
+        a[1] = ByteReverseWord32(a[1]);
+        a[2] = ByteReverseWord32(a[2]);
+        a[3] = ByteReverseWord32(a[3]);
+        a[4] = ByteReverseWord32(a[4]);
+        a[5] = ByteReverseWord32(a[5]);
+        a[6] = ByteReverseWord32(a[6]);
+        a[7] = ByteReverseWord32(a[7]);
+    }
+
+    static HI_S32 cipher_config_ecb_init(HISI_AES_CIPHER* aes)
+    {
+        HI_S32 s32Ret = 0;
+        HI_UNF_CIPHER_CTRL_S CipherCtrl;
+        
+        memset(&CipherCtrl, 0, sizeof(HI_UNF_CIPHER_CTRL_S));
+        CipherCtrl.enAlg = HI_UNF_CIPHER_ALG_AES;
+        CipherCtrl.enWorkMode = HI_UNF_CIPHER_WORK_MODE_ECB;
+        CipherCtrl.enBitWidth = HI_UNF_CIPHER_BIT_WIDTH_128BIT;
+        CipherCtrl.enKeyLen = HI_UNF_CIPHER_KEY_AES_128BIT;
+        CipherCtrl.enKeySrc = HI_UNF_CIPHER_KEY_SRC_USER;
+
+        //mode == HI_UNF_CIPHER_WORK_MODE_CBC
+        // CipherCtrl.stChangeFlags.bit1IV = 1;  //must set for CBC , CFB mode
+        // memcpy(CipherCtrl.u32IV, aes->iv, 16);
+
+        //HI_UNF_CIPHER_KEY_SRC_USER == enKeySrc
+        memcpy(CipherCtrl.u32Key, aes->key, 16);   
+        //printBuffer("key of HI_UNF_CIPHER_ConfigHandle", CipherCtrl.u32Key, 32);
+
+        s32Ret = HI_UNF_CIPHER_ConfigHandle(aes->cipher_handle, &CipherCtrl);
+        if(0 != s32Ret){
+            cayssl_debug("HI_UNF_CIPHER_ConfigHandle err\n");
+            return -1;  
+        }
+
+        return 0;
+    }
+
+    static HI_S32 cipher_init(HISI_AES_CIPHER *aes)
+    {
+        int buf_len = 30*1024;
+        int cached = 0;
+
+        HI_S32 s32Ret = HI_UNF_CIPHER_Init();
+        if(HI_SUCCESS != s32Ret)
+        {
+            return -1;    
+        }
+        s32Ret = HI_UNF_CIPHER_CreateHandle(&(aes->cipher_handle));
+        if(HI_SUCCESS != s32Ret)
+        {
+            HI_UNF_CIPHER_DeInit();
+            return -2;    
+        }
+
+        aes->input_addr_phy = (HI_U32)HI_MMZ_New(buf_len, 0, NULL, "CIPHER_BufIn_cyassl");
+        if (0 == aes->input_addr_phy)
+        {
+            cayssl_debug("Error: Get phyaddr for input failed!\n");
+            goto __CIPHER_EXIT__;
+        }
+        aes->input_addr_vir = HI_MMZ_Map(aes->input_addr_phy, cached);
+
+        aes->output_addr_phy = (HI_U32)HI_MMZ_New(buf_len, 0, NULL, "CIPHER_BufOut_cyassl");
+        if (0 == aes->output_addr_phy)
+        {
+            cayssl_debug("Error: Get phyaddr for outPut failed!\n");
+            goto __CIPHER_EXIT__;
+        }
+        aes->output_addr_vir = HI_MMZ_Map(aes->output_addr_phy, cached);
+        return 0;
+
+__CIPHER_EXIT__:
+        cayssl_debug("something error, __CIPHER_EXIT__\n");
+        if (aes->input_addr_phy> 0)
+        {
+            HI_MMZ_Unmap(aes->input_addr_phy);
+            HI_MMZ_Delete(aes->input_addr_phy);
+        }
+        if (aes->output_addr_phy > 0)
+        {
+            HI_MMZ_Unmap(aes->output_addr_phy);
+            HI_MMZ_Delete(aes->output_addr_phy);
+        }  
+        HI_UNF_CIPHER_DestroyHandle(aes->cipher_handle);
+        HI_UNF_CIPHER_DeInit();
+        return -1;
+    }
+
+    
+    // static inline int printBuffer(HI_CHAR *string, HI_U8 *pu8Input, HI_U32 u32Length)
+    // {
+    //     #if 1
+    //     HI_U32 i = 0;
+        
+    //     if ( NULL != string )
+    //     {
+    //         printf("%s\n", string);
+    //     }
+
+    //     for ( i = 0 ; i < u32Length; i++ )
+    //     {
+    //         if( (i % 16 == 0) && (i != 0)) printf("\n");
+    //         printf("0x%02x ", pu8Input[i]);
+    //     }
+    //     printf("\n");
+    //     #endif
+
+    //     return HI_SUCCESS;
+    // }
+
+    int wc_AesCbcEncrypt(Aes* aes, byte* out, const byte* in, word32 sz)
+    {
+        //cayssl_debug("sz:%d, dd rounds: %d\n", sz,aes->rounds);
+        memcpy(g_hisi_aes.key, aes->key, sizeof(aes->key));
+        printBuffer("ori key:", aes->key, sizeof(aes->key));
+        memcpy(g_hisi_aes.iv, aes->reg, sizeof(aes->reg));
+        printBuffer("ori iv:", aes->reg, sizeof(aes->reg));
+
+        /* hisi encrypt */
+        static int init = 0;
+        if (0 == init)
+        {
+            //cayssl_debug("start aes init\n");
+            if (cipher_init(&g_hisi_aes) < 0)
+            {
+                cayssl_debug("cipher_init error\n");
+                return -1;
+            }
+            init = 1;
+        }
+
+        #ifdef LITTLE_ENDIAN_ORDER
+        reverse_key(g_hisi_aes.key);
+        printBuffer("reverse_key:", g_hisi_aes.key, 16);
+        #endif
+
+        if(cipher_config_init(&g_hisi_aes, aes->rounds) != 0){
+            cayssl_debug("cipher_config_init error\n");
+            return -1;
+        }
+        
+        memcpy(g_hisi_aes.input_addr_vir, in, sz);
+
+        if(HI_UNF_CIPHER_Encrypt(g_hisi_aes.cipher_handle, g_hisi_aes.input_addr_phy, g_hisi_aes.output_addr_phy, sz) != 0){
+            cayssl_debug("Cipher encrypt failed\n");
+            return -1;
+        }
+
+        printBuffer("hisi encrypt", g_hisi_aes.output_addr_vir, sz);
+
+        memcpy(out, g_hisi_aes.output_addr_vir, sz);
+        return 0;
+    }
+    #else
     int wc_AesCbcEncrypt(Aes* aes, byte* out, const byte* in, word32 sz)
     {
         word32 blocks = sz / AES_BLOCK_SIZE;
@@ -2802,6 +3096,7 @@
 
         return 0;
     }
+    #endif
 
     #ifdef HAVE_AES_DECRYPT
     int wc_AesCbcDecrypt(Aes* aes, byte* out, const byte* in, word32 sz)
