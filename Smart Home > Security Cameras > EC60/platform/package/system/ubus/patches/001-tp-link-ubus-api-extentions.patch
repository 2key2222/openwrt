diff -purBbN a/CMakeLists.txt b/CMakeLists.txt
--- a/CMakeLists.txt	2015-12-21 11:34:30.000000000 +0800
+++ b/CMakeLists.txt	2017-12-27 09:30:40.598258426 +0800
@@ -19,7 +19,7 @@ IF(APPLE)
   LINK_DIRECTORIES(/opt/local/lib)
 ENDIF()
 
-ADD_LIBRARY(ubus SHARED libubus.c libubus-io.c libubus-obj.c libubus-sub.c libubus-req.c)
+ADD_LIBRARY(ubus SHARED libubus.c libubus-io.c libubus-obj.c libubus-sub.c libubus-req.c libubus-ext.c)
 TARGET_LINK_LIBRARIES(ubus ubox)
 
 ADD_EXECUTABLE(ubusd ubusd.c ubusd_id.c ubusd_obj.c ubusd_proto.c ubusd_event.c)
@@ -41,7 +41,7 @@ INSTALL(TARGETS ubusd
 	RUNTIME DESTINATION sbin
 )
 
-INSTALL(FILES ubusmsg.h ubus_common.h libubus.h DESTINATION include)
+INSTALL(FILES ubusmsg.h ubus_common.h libubus.h libubus-ext.h DESTINATION include)
 
 # FIXME: this works but certainly can be done better:
 SET(UBUSD_BINARY "${CMAKE_INSTALL_PREFIX}/sbin/ubusd")
diff -purBbN a/libubus-ext.c b/libubus-ext.c
--- a/libubus-ext.c	1970-01-01 08:00:00.000000000 +0800
+++ b/libubus-ext.c	2017-12-27 09:30:03.779219663 +0800
@@ -0,0 +1,549 @@
+/*
+ * Copyright (C) 2010-2017 TP-Link Technologies Co., Ltd.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+/**************************************************************************************************/
+/*                                      INCLUDE_FILES                                             */
+/**************************************************************************************************/
+
+#include <libubox/uloop.h>
+#include <libubox/blobmsg.h>
+#include "libubus.h"
+#include "libubus-ext.h"
+
+/**************************************************************************************************/
+/*                                      TYPES                                                     */
+/**************************************************************************************************/
+
+enum {
+	UBUS_CALL_FLAG_NEW   = 0,
+	UBUS_CALL_FLAG_ASYNC = 1,
+	UBUS_CALL_FLAG_REPLY = 2
+};
+
+struct ubus_caller {
+	struct ubus_request req;
+	ubus_app_caller_handler cb;
+	struct ubus_app* app;
+	struct uloop_timeout tmo;
+};
+
+/**************************************************************************************************/
+/*                                      LOCAL_FUNCTIONS                                           */
+/**************************************************************************************************/
+static void ubus_call_free(struct ubus_call*c)
+{
+	list_del(&c->list);
+	free(c->method);
+	free(c->msg);
+	free(c);
+}
+
+static void ubus_call_defer(struct ubus_call*c, struct list_head *list)
+{
+	if (c->flag & UBUS_CALL_FLAG_ASYNC) {
+
+	} else {
+		struct blob_buf b = {NULL};
+		static unsigned int cookie = 0x10000;
+
+		blobmsg_buf_init(&b);
+		c->cookie = cookie++;
+		blobmsg_add_u32(&b, "cookie", c->cookie);
+		ubus_send_reply(c->ctx, &c->req, b.head);
+		ubus_complete_deferred_request(c->ctx, &c->req, 0);
+		blob_buf_free(&b);
+
+		c->flag |= UBUS_CALL_FLAG_ASYNC;
+		list_add_tail(&c->list, list);
+	}
+}
+
+static struct ubus_call* ubus_call_new(struct ubus_app* app, struct ubus_request_data *req, const char *method, struct blob_attr *attr)
+{
+	struct ubus_call*call = NULL, *found = NULL;
+	struct ubus_context *ctx = &app->ubus_conn.ctx;
+
+	if (!strcmp(method, "query_cookie") || !strcmp(method, "query_cookie.async")) {
+		struct blob_buf b = {NULL};
+		struct blobmsg (
+			blobmsg_int32 cookie,
+		) (data, attr, false);
+
+		blobmsg_buf_init(&b);
+
+		if (data.cookie) {
+			unsigned int cookie = blobmsg_get_u32(data.cookie);
+			list_for_each_entry(call, &app->ubus_call, list) {
+				if (call->cookie == cookie) {
+					found = call;
+					break;
+				}
+			}
+
+			if (!found) {
+				blobmsg_add_u32(&b, "error_code", -1);
+				blobmsg_add_string(&b, "msg", "Cookie not found!");
+				ubus_send_reply(ctx, req, b.head);
+			} else {
+				if (call->msg) {
+					ubus_send_reply(ctx, req, call->msg);
+					ubus_call_free(call);
+				} else {
+					blobmsg_add_u32(&b, "cookie", cookie);
+					blobmsg_add_string(&b, "msg", "Busying!");
+					ubus_send_reply(ctx, req, b.head);
+				}
+			}
+		} else {
+			blobmsg_add_u32(&b, "error_code", -1);
+			blobmsg_add_string(&b, "msg", "No cookie value!");
+			ubus_send_reply(ctx, req, b.head);
+		}
+
+		blob_buf_free(&b);
+
+		return NULL;
+	}
+
+	call = malloc(sizeof(*call));
+	memset(call, 0, sizeof(*call));
+	call->ctx = ctx;
+	call->msg = NULL;
+	call->cookie = 0;
+	call->flag = UBUS_CALL_FLAG_NEW;
+	call->method = strdup(method);
+	INIT_LIST_HEAD(&call->list);
+	ubus_defer_request(ctx, req, &call->req);
+
+	return call;
+}
+
+static void ubus_call_timeout(struct uloop_timeout *tmo)
+{
+	int msec;
+	struct timespec ts;
+	struct ubus_call* call = NULL, *nextcall = NULL;
+	struct ubus_app* app = container_of(tmo, struct ubus_app, ubus_call_tmo);
+
+	clock_gettime(CLOCK_MONOTONIC, &ts);
+	msec = ts.tv_sec*1000 + ts.tv_nsec/1000000 - app->ubus_call_timeout;
+	list_for_each_entry_safe(call, nextcall, &app->ubus_call, list) {
+		if (call->msg) {
+			if (call->time < msec) {
+				ubus_call_free(call);
+			}
+		}
+	}
+	uloop_timeout_set(&app->ubus_call_tmo, app->ubus_call_timeout);
+}
+
+static void ubus_call_cleanup(struct ubus_app* app)
+{
+	struct ubus_call* call = NULL, *nextcall = NULL;
+	list_for_each_entry_safe(call, nextcall, &app->ubus_call, list) {
+		ubus_call_free(call);
+	}
+}
+
+static void ubus_caller_timeout(struct uloop_timeout *tmo)
+{
+	struct ubus_caller* inv = container_of(tmo, struct ubus_caller, tmo);
+	ubus_abort_request(inv->req.ctx, &inv->req);
+	if (inv->cb) {
+		inv->cb(inv->app, NULL, UBUS_STATUS_TIMEOUT, inv->req.priv);
+		inv->cb = NULL;
+	}
+	free(inv);
+}
+
+static void ubus_caller_data_cb(struct ubus_request *req, int type, struct blob_attr *msg)
+{
+	struct ubus_caller* inv = container_of(req, struct ubus_caller, req);
+	if (inv->cb) {
+		inv->cb(inv->app, msg, 0, inv->req.priv);
+		inv->cb = NULL;
+	}
+	uloop_timeout_cancel(&inv->tmo);
+}
+
+static void ubus_caller_complete_cb(struct ubus_request *req, int ret)
+{
+	struct ubus_caller* inv = container_of(req, struct ubus_caller, req);
+	if (inv->cb) {
+		inv->cb(inv->app, NULL, ret, inv->req.priv);
+		inv->cb = NULL;
+	}
+	uloop_timeout_cancel(&inv->tmo);
+	free(inv);
+}
+
+static int ubus_invoke_cb(struct ubus_context *ctx, struct ubus_object *obj,
+				  struct ubus_request_data *req, const char *method,
+				  struct blob_attr *msg)
+{
+	int i = 0;
+	struct ubus_app* app = container_of(ctx, struct ubus_app, ubus_conn.ctx);
+	struct ubus_call* call = ubus_call_new(app, req, method, msg);
+
+	if (call) {
+		const char* suffix = method + strlen(method) - 6;
+		if (suffix > method && !memcmp(suffix, ".async", 7)) {
+			ubus_call_defer(call, &app->ubus_call);
+			call->method[suffix - method] = 0;
+		}
+		for (i = 0; i < app->n_api; i++) {
+			if (!app->apis[i].method || !strcmp(app->apis[i].method, call->method)) {
+				if (app->apis[i].cb && !app->apis[i].cb(app, call, msg)) {
+					return 0;
+				}
+				break;
+			}
+		}
+		if (!strcmp(method, "help") || !strcmp(method, ".")) {
+			void *array = NULL;
+			struct blob_buf b = {NULL};
+
+			blobmsg_buf_init(&b);
+			array = blobmsg_open_array(&b, "apis");
+			if (array) {
+				for (i = 0; i < app->n_api; i++) {
+					blobmsg_add_string(&b, NULL, app->apis[i].method ? app->apis[i].method : "*");
+				}
+				blobmsg_close_array(&b, array);
+			}
+			array = blobmsg_open_array(&b, "evts");
+			if (array) {
+				for (i = 0; i < app->n_evt; i++) {
+					blobmsg_add_string(&b, NULL, app->evts[i].event ? app->evts[i].event : "*");
+				}
+				blobmsg_close_array(&b, array);
+			}
+			ubus_app_reply(call, b.head);
+			blob_buf_free(&b);
+		} else {
+			ubus_app_reply(call, NULL);
+		}
+	}
+
+	return 0;
+}
+static void ubus_events_cb(struct ubus_context *ctx, struct ubus_event_handler *ev,
+				     const char *type, struct blob_attr *msg)
+{
+	int i = 0;
+	struct ubus_app* app = container_of(ev, struct ubus_app, ubus_events);
+
+	for (i = 0; i < app->n_evt; i++) {
+		if (app->evts[i].event) {
+			if (!strcmp(app->evts[i].event, "*")) {
+				if (app->evts[i].cb) {
+					((void (*)(struct ubus_app*,struct blob_attr*,const char*))app->evts[i].cb)(app, msg, type);
+				}
+			} else if (!strcmp(app->evts[i].event, type)) {
+				if (app->evts[i].cb) {
+					app->evts[i].cb(app, msg);
+				}
+				break;
+			}
+		}
+	}
+}
+
+static void ubus_register_events(struct uloop_timeout *tmo)
+{
+	int i = 0;
+	struct ubus_app* app = container_of(tmo, struct ubus_app, ubus_tmo);
+
+	for (i = 0; i < app->n_evt; i++) {
+		if (app->evts[i].event && app->evts[i].cb && ubus_register_event_handler(&app->ubus_conn.ctx, &app->ubus_events, app->evts[i].event) != 0) {
+			uloop_timeout_set(tmo, 1000);
+			break;
+		}
+	}
+}
+
+static void ubus_register_objects(struct ubus_context *ctx)
+{
+	static void (*ucloud_ubus_conn_lost)(struct ubus_context *ctx) = NULL;
+	struct ubus_app* app = container_of(ctx, struct ubus_app, ubus_conn.ctx);
+
+	if (ucloud_ubus_conn_lost) {
+		uloop_timeout_set(&app->ubus_tmo, 1100);
+		ucloud_ubus_conn_lost(ctx);
+	} else {
+		ucloud_ubus_conn_lost = ctx->connection_lost;
+		ctx->connection_lost = ubus_register_objects;
+		if (app->ubus_objects.methods) {
+			ubus_add_object(ctx, &app->ubus_objects);
+		}
+		app->ubus_tmo.cb = ubus_register_events;
+		app->ubus_tmo.cb(&app->ubus_tmo);
+	}
+}
+
+/**************************************************************************************************/
+/*                                      GLOBAL_FUNCTIONS                                          */
+/**************************************************************************************************/
+void* ubus_app_invoke(struct ubus_app* app, const char* module, const char* method,
+	struct blob_attr *msg, int timeout, ubus_app_caller_handler cb, void* priv)
+{
+	int ret = UBUS_STATUS_NOT_FOUND;
+	struct ubus_caller *inv = malloc(sizeof(*inv));
+	struct ubus_context *ctx = &app->ubus_conn.ctx;
+
+	memset(inv, 0, sizeof(*inv));
+
+	inv->cb = cb;
+	inv->app = app;
+	inv->tmo.cb = ubus_caller_timeout;
+
+	if (module) {
+		ret = ubus_invoke_async_new(ctx, module, method, msg, &inv->req);
+	} else if (!timeout) {
+		ret = ubus_invoke_async(ctx, app->ubus_objects.id, method, msg, &inv->req);
+	} else {
+		ret = UBUS_STATUS_NOT_SUPPORTED;
+	}
+
+	if (ret != UBUS_STATUS_OK) {
+		free(inv);
+		inv = NULL;
+	} else {
+		inv->req.priv = priv;
+		inv->req.data_cb = ubus_caller_data_cb;
+		inv->req.complete_cb = ubus_caller_complete_cb;
+		ubus_complete_request_async(ctx, &inv->req);
+		if (timeout > 0) {
+			ubus_complete_request(inv->req.ctx, &inv->req, timeout);
+		} else {
+			uloop_timeout_set(&inv->tmo, app->ubus_call_timeout);
+		}
+	}
+
+	return inv;
+}
+
+void ubus_app_cancel(void* call)
+{
+	struct ubus_caller *inv = call;
+	if (inv) {
+		ubus_abort_request(inv->req.ctx, &inv->req);
+		uloop_timeout_cancel(&inv->tmo);
+		free(inv);
+	}
+}
+
+void ubus_app_refresh(void* call, int timeout)
+{
+	struct ubus_caller *inv = call;
+	if (inv) {
+		uloop_timeout_set(&inv->tmo, timeout);
+	}
+}
+
+void ubus_app_reply(struct ubus_call*c, struct blob_attr *msg)
+{
+	if (c->flag & UBUS_CALL_FLAG_REPLY) {
+		
+	} else {
+		struct blob_buf b = {NULL};
+
+		if (!msg) {
+			blobmsg_buf_init(&b);
+			blobmsg_add_u32(&b, "error_code", -1);
+			blobmsg_add_string(&b, "msg", "Method not found!");
+		}
+		c->flag |= UBUS_CALL_FLAG_REPLY;
+		if (c->flag & UBUS_CALL_FLAG_ASYNC) {
+			struct timespec ts;
+			clock_gettime(CLOCK_MONOTONIC, &ts);
+			c->time = ts.tv_sec + ts.tv_nsec / 1000000;
+			c->msg = blob_memdup(msg?msg:b.head);
+		} else {
+			ubus_send_reply(c->ctx, &c->req, msg?msg:b.head);
+			ubus_complete_deferred_request(c->ctx, &c->req, 0);
+			ubus_call_free(c);
+		}
+		if (!msg) {
+			blob_buf_free(&b);
+		}
+	}
+}
+
+int ubus_app_event(struct ubus_app* app, const char* event, struct blob_attr *msg)
+{
+	struct ubus_caller *inv = malloc(sizeof(*inv));
+	struct ubus_context *ctx = &app->ubus_conn.ctx;
+	struct blob_buf b = {NULL};
+
+	memset(inv, 0, sizeof(*inv));
+
+	inv->app = app;
+	inv->tmo.cb = ubus_caller_timeout;
+	
+	blobmsg_buf_init(&b);
+	blobmsg_add_string(&b, "id", event);
+	if (msg) {
+		blobmsg_add_field(&b, BLOBMSG_TYPE_TABLE, "data", blob_data(msg), blob_len(msg));
+	} else {
+		void *table = blobmsg_open_table(&b, "data");
+		if (table) {
+			blobmsg_close_table(&b, table);
+		}
+	}
+
+	if (ubus_invoke_async(ctx, UBUS_SYSTEM_OBJECT_EVENT, "send", b.head, &inv->req)) {
+		free(inv);
+		inv = NULL;
+	} else {
+		inv->req.priv = NULL;
+		inv->req.data_cb = ubus_caller_data_cb;
+		inv->req.complete_cb = ubus_caller_complete_cb;
+		ubus_complete_request_async(ctx, &inv->req);
+		uloop_timeout_set(&inv->tmo, app->ubus_call_timeout);
+	}
+	blob_buf_free(&b);
+
+	return inv?0:-1;
+}
+
+int ubus_app_syslog2(struct ubus_app* app, int level, const char *format, ...)
+{
+	char msg[256];
+	int len = sizeof(msg);
+	struct ubus_caller *inv = malloc(sizeof(*inv));
+	struct ubus_context *ctx = &app->ubus_conn.ctx;
+	struct blob_buf b = {NULL};
+	void *table = NULL;
+	va_list arg;
+
+	va_start(arg, format);
+	len = vsnprintf(msg, len, format, arg);
+	va_end(arg);
+
+	memset(inv, 0, sizeof(*inv));
+	inv->app = app;
+	inv->tmo.cb = ubus_caller_timeout;
+	
+	blobmsg_buf_init(&b);
+	blobmsg_add_string(&b, "id", "syslog");
+	table = blobmsg_open_table(&b, "data");
+	if (table) {
+		blobmsg_add_u32(&b, "level", level);
+		blobmsg_add_string(&b, "message", msg);
+		blobmsg_close_table(&b, table);
+	}
+
+	if (ubus_invoke_async(ctx, UBUS_SYSTEM_OBJECT_EVENT, "send", b.head, &inv->req)) {
+		free(inv);
+		inv = NULL;
+	} else {
+		inv->req.priv = NULL;
+		inv->req.data_cb = ubus_caller_data_cb;
+		inv->req.complete_cb = ubus_caller_complete_cb;
+		ubus_complete_request_async(ctx, &inv->req);
+		uloop_timeout_set(&inv->tmo, app->ubus_call_timeout);
+	}
+	blob_buf_free(&b);
+
+	return inv?0:-1;
+}
+
+int ubus_app_syslog(struct ubus_app* app, int level, const char *mod, const char *submod, const char *format, ...)
+{
+	char msg[256];
+	int len = sizeof(msg);
+	struct ubus_caller *inv = malloc(sizeof(*inv));
+	struct ubus_context *ctx = &app->ubus_conn.ctx;
+	struct blob_buf b = {NULL};
+	void *table = NULL;
+	va_list arg;
+
+	va_start(arg, format);
+	len = vsnprintf(msg, len, format, arg);
+	va_end(arg);
+
+	memset(inv, 0, sizeof(*inv));
+	inv->app = app;
+	inv->tmo.cb = ubus_caller_timeout;
+	
+	blobmsg_buf_init(&b);
+	blobmsg_add_string(&b, "id", "syslog");
+	table = blobmsg_open_table(&b, "data");
+	if (table) {
+		blobmsg_add_u32(&b, "level", level);
+		blobmsg_add_string(&b, "message", msg);
+		if (mod) {
+			blobmsg_add_string(&b, "module", mod);
+		}
+		if (submod) {
+			blobmsg_add_string(&b, "submod", submod);
+		}
+		blobmsg_close_table(&b, table);
+	}
+
+	if (ubus_invoke_async(ctx, UBUS_SYSTEM_OBJECT_EVENT, "send", b.head, &inv->req)) {
+		free(inv);
+		inv = NULL;
+	} else {
+		inv->req.priv = NULL;
+		inv->req.data_cb = ubus_caller_data_cb;
+		inv->req.complete_cb = ubus_caller_complete_cb;
+		ubus_complete_request_async(ctx, &inv->req);
+		uloop_timeout_set(&inv->tmo, app->ubus_call_timeout);
+	}
+	blob_buf_free(&b);
+
+	return inv?0:-1;
+}
+void ubus_app_init(struct ubus_app* app, const char* name, struct ubus_app_api *api, int napi, struct ubus_app_evt *evt, int nevt)
+{
+	memset(app, 0, sizeof(*app));
+
+	app->method_types.n_methods = 1;
+	app->method_types.methods = &app->fakemethods;
+	app->methods.name = NULL;
+	app->methods.handler = ubus_invoke_cb;
+	app->fakemethods.name = "*";
+	app->fakemethods.handler = ubus_invoke_cb;
+	app->ubus_objects.name = name;
+	app->ubus_objects.type = &app->method_types;
+	app->ubus_objects.methods = &app->methods;
+	app->ubus_objects.n_methods = 1;
+	app->ubus_events.cb = ubus_events_cb;
+	app->ubus_conn.cb = ubus_register_objects;
+
+	app->apis = api;
+	app->n_api = napi;
+	app->evts = evt;
+	app->n_evt = nevt;
+
+	INIT_LIST_HEAD(&app->ubus_call);
+	app->ubus_call_timeout = 20000;
+	app->ubus_call_tmo.cb = ubus_call_timeout;
+	uloop_timeout_set(&app->ubus_call_tmo, app->ubus_call_timeout);
+
+	ubus_auto_connect(&app->ubus_conn);
+}
+
+void ubus_app_deinit(struct ubus_app* app)
+{
+	ubus_call_cleanup(app);
+	uloop_timeout_cancel(&app->ubus_tmo);
+	uloop_timeout_cancel(&app->ubus_call_tmo);
+	uloop_timeout_cancel(&app->ubus_conn.timer);
+	ubus_shutdown(&app->ubus_conn.ctx);
+}
diff -purBbN a/libubus-ext.h b/libubus-ext.h
--- a/libubus-ext.h	1970-01-01 08:00:00.000000000 +0800
+++ b/libubus-ext.h	2017-12-27 09:29:16.591164320 +0800
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) 2010-2017 TP-Link Technologies Co., Ltd.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef __LIBUBUS_EXT_H
+#define __LIBUBUS_EXT_H
+
+#include <libubox/uloop.h>
+#include <libubox/blobmsg.h>
+#include "libubus.h"
+
+struct ubus_app;
+struct ubus_call;
+
+typedef int (*ubus_app_api_handler)(struct ubus_app *app, struct ubus_call *call, struct blob_attr *msg);
+typedef void (*ubus_app_evt_handler)(struct ubus_app *app, struct blob_attr *msg);
+typedef void (*ubus_app_caller_handler)(struct ubus_app *app, struct blob_attr *msg, int ret, void *priv);
+
+struct ubus_app_api {
+	const char *method;
+	ubus_app_api_handler cb;
+};
+
+struct ubus_app_evt {
+	const char *event;
+	ubus_app_evt_handler cb;
+};
+
+struct ubus_app {
+	struct uloop_timeout ubus_tmo;
+	struct ubus_auto_conn ubus_conn;
+	struct ubus_event_handler ubus_events;
+	struct ubus_method methods, fakemethods;
+	struct ubus_object ubus_objects;
+	struct ubus_object_type method_types;
+
+	int n_api;
+	int n_evt;
+	struct ubus_app_api *apis;
+	struct ubus_app_evt *evts;
+
+	struct list_head ubus_call;
+	unsigned int ubus_call_timeout;
+	struct uloop_timeout ubus_call_tmo;
+};
+
+struct ubus_call {
+	struct ubus_request_data req;
+	struct ubus_context *ctx;
+	struct blob_attr *msg;
+	char* method;
+	unsigned int flag;
+	unsigned int cookie;
+	unsigned int time;
+	struct list_head list;
+};
+
+void ubus_app_init(struct ubus_app* app, const char* name, struct ubus_app_api *api, int napi, struct ubus_app_evt*evt, int nevt);
+void ubus_app_deinit(struct ubus_app* app);
+void ubus_app_reply(struct ubus_call*c, struct blob_attr *msg);
+void* ubus_app_invoke(struct ubus_app* app, const char* module, const char* method,
+			struct blob_attr *msg, int timeout, ubus_app_caller_handler cb, void* priv);
+void ubus_app_cancel(void* call);
+void ubus_app_refresh(void* call, int timeout);
+int ubus_app_event(struct ubus_app* app, const char* event, struct blob_attr *msg);
+static inline int ubus_app_event_sync(struct ubus_app* app, const char* event, struct blob_attr *msg)
+{
+	return ubus_send_event(&app->ubus_conn.ctx, event, msg);
+}
+
+int ubus_app_syslog2(struct ubus_app* app, int level, const char *format, ...);
+int ubus_app_syslog(struct ubus_app* app, int level, const char *mod, const char *submod, const char *format, ...);
+static inline int ubus_app_syslog1(struct ubus_app* app, struct blob_attr *msg)
+{
+	return ubus_app_event(app, "syslog", msg);
+}
+
+/****************************************************************************************************************************************
+ *   Usage of libubus extenstion API:
+ *
+ *static void ubus_caller_test2(struct ubus_app* app, struct blob_attr *msg, int ret, void *priv)
+ *{
+ *	ubus_app_reply(priv, msg);
+ *}
+ *
+ *static void ubus_caller_test(struct ubus_app* app, struct blob_attr *msg, int ret, void *priv)
+ *{
+ *	ubus_app_invoke(app, "client_mgmt", "get_ARP", NULL, 0, ubus_caller_test2, priv);
+ *}
+ *
+ *int demo_api_handler(struct ubus_app*app, struct ubus_call*call, struct blob_attr *msg)
+ *{
+ *	ubus_app_invoke(app, "service", "haha", NULL, 0, ubus_caller_test, call);
+ *
+ *	return 0;
+ *}
+ *
+ *int demo_api_handler1(struct ubus_app*app, struct ubus_call*call, struct blob_attr *msg)
+ *{
+ *	return -1;
+ *}
+ *
+ *void demo_evt_handler(struct ubus_app*app, struct blob_attr *msg)
+ *{
+ *	printf("test\n");
+ *}
+ *
+ *struct ubus_app_api demo_apis[] = {
+ *	{"test", demo_api_handler},
+ *	{"test1", demo_api_handler1}
+ *};
+ *
+ *struct ubus_app_evt demo_evts[] = {
+ *	{"test", demo_evt_handler}
+ *};
+ *
+ * struct ubus_app ubus = {0};
+ *
+ * ubus_app_init(&ubus, "demo", demo_apis, ARRAY_SIZE(demo_apis), demo_evts, ARRAY_SIZE(demo_evts));
+ *
+ ****************************************************************************************************************************************/
+#endif
