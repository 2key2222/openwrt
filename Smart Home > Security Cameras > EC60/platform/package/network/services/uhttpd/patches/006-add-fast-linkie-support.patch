--- a/lua.c
+++ b/lua.c
@@ -1,3 +1,4 @@
+#define FASTEN_LINKIE 1
 /*
  * uhttpd - Tiny single-threaded httpd
  *
@@ -37,6 +38,569 @@ static struct config *_conf;
 
 static lua_State *_L;
 
+#ifdef FASTEN_LINKIE
+
+#include <sys/types.h>          /* See NOTES */
+#include <sys/socket.h>
+#include <arpa/inet.h>
+#include <uci.h>
+#include <unistd.h>
+#include <ctype.h>
+#include <cJSON.h>
+#include <md5.h>
+
+struct linkie_ctx {
+	int fd;		/* socket fd for communication with linkied */
+};
+
+static struct linkie_ctx *fast_linkie_ctx = NULL;
+char dev_usr[128] = "";
+char dev_password[128] = "";
+
+static const unsigned char l_enB64[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
+"abcdefghijklmnopqrstuvwxyz0123456789+/=";
+static const unsigned char l_deB64_[] = 
+{
+	/*	+	$	$	$	/	0	1	2	3	4	5	6	7	8	9	$	*/
+	62,	0,	0,	0,	63,	52,	53,	54,	55,	56,	57,	58,	59,	60,	61,	0,
+	/*	$	$	=	$	$	$	A	B	C	D	E	F	G	H	I	J	*/
+	0,	0,	0,	0,	0,	0,	0,	1,	2,	3,	4,	5,	6,	7,	8,	9,
+	/*	K	L	M	N	O	P	Q	R	S	T	U	V	W	X	Y	Z	*/
+	10,	11,	12,	13,	14,	15,	16,	17,	18,	19,	20,	21,	22,	23,	24,	25,
+	/*	$	$	$	$	$	$	a	b	c	d	e	f	g	h	i	j	*/
+	0,	0,	0,	0,	0,	0,	26,	27,	28,	29,	30,	31,	32,	33,	34,	35,
+	/*	k	l	m	n	o	p	q	r	s	t	u	v	w	x	y	z	*/
+	36,	37,	38,	39,	40,	41,	42,	43,	44,	45,	46,	47,	48,	49,	50,	51
+};
+
+static const unsigned char* l_deB64 = l_deB64_ - '+';
+
+static int decode_base64(unsigned char* src, int len, unsigned char* dst)
+{
+	while (len >= 4)
+	{
+		unsigned char b0 = src[0], b1 = src[1], b2 = src[2], b3 = src[3];
+
+		if (b0 == '+' || b0 == '=' || (b0 >= '/' && b0 <= '9') || (b0 >= 'A' && b0 <= 'Z') || (b0 >= 'a' && b0 <= 'z'))
+		{
+			dst[0] = ((l_deB64[b0] << 2) & 0xFC) | ((l_deB64[b1] >> 4) & 0x03);
+			dst[1] = ((l_deB64[b1] << 4) & 0xF0) | ((l_deB64[b2] >> 2) & 0x0F);
+			dst[2] = ((l_deB64[b2] << 6) & 0xC0) | ((l_deB64[b3] >> 0) & 0x3F);
+			dst += 3;
+			src += 4;
+			len -= 4;
+		}
+		else
+		{
+			src ++;
+			len --;
+		}
+	}
+	switch (len)
+	{
+		case 1:
+			*dst ++ = ((l_deB64[src[0]] << 2) & 0xFC);
+			*dst ++ = 0;
+			*dst ++ = 0;
+			break;
+
+		case 2:
+			*dst ++ = ((l_deB64[src[0]] << 2) & 0xFC) | ((l_deB64[src[1]] >> 4) & 0x03);
+			*dst ++ = ((l_deB64[src[1]] << 4) & 0xF0);
+			*dst ++ = 0;
+			break;
+
+		case 3:
+			*dst ++ = ((l_deB64[src[0]] << 2) & 0xFC) | ((l_deB64[src[1]] >> 4) & 0x03);
+			*dst ++ = ((l_deB64[src[1]] << 4) & 0xF0) | ((l_deB64[src[2]] >> 2) & 0x0F);
+			*dst ++ = ((l_deB64[src[2]] << 6) & 0xC0);
+			break;
+
+		default:
+			break;
+	}
+
+	*dst = 0;
+
+	return 0;
+}
+
+static int encode_base64(unsigned char* src, int len, unsigned char* dst)
+{
+	while (len >= 3)
+	{
+		dst[0] = l_enB64[src[0] >> 2];
+		dst[1] = l_enB64[((src[1] & 0xF0) >> 4) | ((src[0] & 0x03) << 4)];
+		dst[2] = l_enB64[((src[2] & 0xC0) >> 6) | ((src[1] & 0x0F) << 2)];
+		dst[3] = l_enB64[src[2] & 0x3F];
+		src += 3;
+		dst += 4;
+		len -= 3;
+	}
+	if (2 == len)
+	{
+		dst[0] = l_enB64[src[0] >> 2];
+		dst[1] = l_enB64[((src[1] & 0xF0) >> 4) | ((src[0] & 0x03) << 4)];
+		dst[2] = l_enB64[(src[1] & 0x0F) << 2];
+		dst[3] = '=';
+		dst += 4;
+	}
+	else if (1 == len)
+	{
+		dst[0] = l_enB64[src[0] >> 2];
+		dst[1] = l_enB64[(src[0] & 0x03) << 4];
+		dst[2] = dst[3] = '=';
+		dst += 4;
+	}
+	*dst ++ = 0;
+
+	return 0;
+}
+
+/* blen is the size of buf; slen is the length of src.  The input-string need
+ ** not be, and the output string will not be, null-terminated.  Returns the
+ ** length of the decoded string, -1 on buffer overflow, -2 on malformed string. */
+static int urldecode(char *buf, int blen, const char *src, int slen)
+{
+	int i = 0;
+	int len = 0;
+
+#define hex(x) \
+	(((x) <= '9') ? ((x) - '0') : \
+	 (((x) <= 'F') ? ((x) - 'A' + 10) : \
+	  ((x) - 'a' + 10)))
+
+	for (i = 0; (i < slen) && (len < blen); i++)
+	{
+		if (src[i] != '%') {
+			buf[len++] = src[i];
+			continue;
+		}
+
+		if (i + 2 >= slen || !isxdigit(src[i + 1]) || !isxdigit(src[i + 2]))
+			return -2;
+
+		buf[len++] = (char)(16 * hex(src[i+1]) + hex(src[i+2]));
+		i += 2;
+	}
+	buf[len] = 0;
+	return (i == slen) ? len : -1;
+
+}
+
+static struct linkie_ctx *uh_fast_linkie_init(void)
+{
+	struct linkie_ctx *ctx_ptr = NULL;
+	struct sockaddr_in linkied_addr;
+	int ret;
+
+	ctx_ptr = malloc(sizeof(struct linkie_ctx));
+	if (ctx_ptr == NULL) {
+		//printf("alloc memory for linkie_ctx error\n");
+		return NULL;
+	}
+
+	ctx_ptr->fd = socket(AF_INET, SOCK_DGRAM, 0);
+	if (ctx_ptr->fd <= 0) {
+		//printf("could not socket a fd for linkied\n");
+		free(ctx_ptr);
+		return NULL;
+	}
+
+	linkied_addr.sin_family = AF_INET;
+	linkied_addr.sin_port = htons(9999);
+	linkied_addr.sin_addr.s_addr = inet_addr("127.0.0.1");
+
+	ret = connect(ctx_ptr->fd, (struct sockaddr *) &linkied_addr, sizeof(struct sockaddr));
+	if (ret != 0) {
+		close(ctx_ptr->fd);
+		free(ctx_ptr);
+		return NULL;
+	}
+
+	return ctx_ptr;
+}
+
+static int uh_fast_linkie_recv(int s_fd, char *buf, int buf_len)
+{
+	static struct pollfd pfd = {};
+	int data_len = 0;
+	int len = buf_len;
+	int r;
+
+	pfd.fd = s_fd;
+	pfd.events = POLLIN;
+
+	while(len > 0) {
+		r = read(s_fd, buf, len);
+		if (r < 0) {
+			if (errno == EWOULDBLOCK || errno == EAGAIN) {
+				pfd.revents = 0;
+				poll(&pfd, 1, 1000);
+				if (pfd.revents & POLLIN)
+					continue;
+			}
+			if (errno == EINTR)
+				continue;
+
+			if (!data_len)
+				data_len = -1;
+			break;
+		}
+		if (!r)
+			break;
+		data_len += r;
+		if (len >= buf_len && r != buf_len)
+			break;
+		len -= r;
+	}
+	return data_len;
+}
+
+#if 0
+static void echo_print(int t)
+{
+	char cmd[256] = {};
+
+	sprintf(cmd, "echo %d > /dev/console", t);
+	system(cmd);
+}
+//static long long __get_time_us(void){	struct timeval t = {};	gettimeofday(&t, NULL);	return t.tv_sec * 1000000 + t.tv_usec;}
+
+static void echo_print_str(char *str)
+{
+	char cmd[256] = {};
+
+	sprintf(cmd, "echo %s > /dev/console", str);
+	system(cmd);
+}
+#endif
+
+static int get_usrinfo(void)
+{
+
+	struct uci_context *ctx;
+	struct uci_package *p = NULL;
+	struct uci_section *s;
+	struct uci_option *o;
+	ctx = uci_alloc_context();
+	uci_load(ctx, "account", &p);
+	if (p == NULL) {
+		uci_free_context(ctx);
+		return -1;
+	}
+
+	s = uci_lookup_section(ctx, p, "account");
+	if (s) {
+		o = uci_lookup_option(ctx, s, "user");
+		strncpy(dev_usr, o->v.string, 128);
+		o = uci_lookup_option(ctx, s, "password");
+		strncpy(dev_password, o->v.string, 128);
+	}
+	uci_unload(ctx, p);
+	uci_free_context(ctx);
+	return 0;
+}
+
+#ifdef UBUS_RELOAD_CONFIG
+static struct ubus_context *ubus_ctx;
+
+enum {
+    RELOAD_ID,
+    __RELOAD_MAX
+};
+
+static int uci_reload(struct ubus_context *ctx, struct ubus_object *obj,
+		      struct ubus_request_data *req, const char *method,
+		      struct blob_attr *msg)
+{
+	get_usrinfo();
+	return 0;
+}
+
+static const struct ubus_method uhttpd_methods[] = {
+	UBUS_METHOD_NOARG("reload", uci_reload)
+};
+
+static struct ubus_object_type uhttpd_object_type =
+	UBUS_OBJECT_TYPE("uhttpd", uhttpd_methods);
+
+static struct ubus_object uhttpd_object = {
+	.name = "uhttpd",
+	.type = &uhttpd_object_type,
+	.methods = uhttpd_methods,
+	.n_methods = ARRAY_SIZE(uhttpd_methods),
+};
+#endif
+
+static int do_auth(struct client *cl, struct path_info *pi)
+{
+
+	char realm[256] = {};
+	char realm_decode[256] = {};
+	char ipc_auth_password[128] = {};
+	char *ptr = NULL;
+	int len = 0;
+	int usr_len = 0;
+	struct blob_attr *cur;
+	int rem;
+ 
+	blob_for_each_attr(cur, cl->hdr.head, rem) {
+		if (!strncasecmp(blobmsg_name(cur), "authorization", 13)) {
+			strncpy(realm, (char *)blobmsg_data(cur), 256);
+			len = strlen(realm);
+		}
+	}
+
+	usr_len = strlen(dev_usr);
+	if (len > 6 && len > usr_len) {
+		char *tmp = NULL;
+
+		/* Pass the 'Basic ' */
+		ptr = realm + 6;
+		decode_base64((unsigned char *)ptr, strlen(ptr), (unsigned char *)realm_decode);
+		ptr = realm_decode;
+		tmp = strstr(ptr, dev_usr);
+		if (tmp == ptr) {
+			/* Pass user name and ':' */
+			ptr = ptr + usr_len + 1;
+			encode_base64((unsigned char *)ptr, strlen(ptr), (unsigned char *)ipc_auth_password);
+			if (!strcmp(ipc_auth_password, dev_password)) {
+				return 0;
+			}
+			else {
+				char rpt_auth_password[128] = {};
+				struct MD5Context md5_ctx;
+				unsigned char digest[16] = {};
+				int i = 0;
+				/* keep compatible with RE and IPC */
+
+				MD5Init(&md5_ctx);
+				MD5Update(&md5_ctx, ptr, strlen(ptr));
+				MD5Final(digest, &md5_ctx);
+
+				for (; i < 16; i++) {
+					sprintf(rpt_auth_password + 2 * i, "%02X", *(digest + i));
+				}
+				if (!strcasecmp(rpt_auth_password, dev_password)) {
+					return 0;
+				}
+			}
+		}
+	}
+	return -1;
+}
+
+static void simple_decode(uint8_t *buf, int len)
+{
+    uint8_t seed = 0xAB, tmp;
+    int i;
+
+    for (i = 0; i < len; i++){
+        tmp = buf[i] ^ seed;
+        seed = buf[i];
+        buf[i] = tmp;
+    }
+}
+
+static void simple_encode(uint8_t *buf, int len)
+{
+    uint8_t seed = 0xAB;
+    int i;
+
+    for (i = 0; i < len; i++){
+        buf[i] = buf[i] ^ seed;
+        seed = buf[i];
+    }
+}
+
+static cJSON *auth_err(void)
+{
+	cJSON *auth_obj = cJSON_CreateObject();
+	if (auth_obj) {
+		cJSON_AddNumberToObject(auth_obj, "err_code", -10007);
+		cJSON_AddStringToObject(auth_obj, "err_msg",  "Unauthorized Error");
+	}
+	return auth_obj;
+}
+static cJSON *auth_err_cmd(cJSON *module_req)
+{
+	cJSON *cmd_req = module_req->child;
+	cJSON *resp = NULL;
+
+	resp = cJSON_CreateObject();
+	if (!resp) {
+		return NULL;
+	}
+
+	while (cmd_req) {
+		cJSON *tmp_resp = NULL;
+
+		tmp_resp = auth_err();
+		if (tmp_resp) {
+			cJSON_AddItemToObject(resp, cmd_req->string, tmp_resp);
+		}
+		else {
+			cJSON_Delete(resp);
+			resp = NULL;
+			return NULL;
+		}
+		cmd_req = cmd_req->next;
+	}
+	return resp;
+}
+
+
+static cJSON * auth_err_request(cJSON *linkie_req)
+{
+	int i = 0;
+	int module_Count = 0;
+	cJSON *node = NULL;
+	cJSON *linkie_res = NULL;
+	cJSON *modules_res = NULL;
+
+	/*make res object*/
+	linkie_res = cJSON_CreateObject();
+	if (!linkie_res) {
+		goto ENDS;
+	}
+
+	/*get modules*/
+	modules_res = cJSON_CreateArray();
+	if (!modules_res) {
+		cJSON_Delete(linkie_res);
+		linkie_res = NULL;
+		goto ENDS;
+	}
+	node = linkie_req->child;
+	while (node) {
+		cJSON_AddItemToArray(modules_res, cJSON_CreateString(node->string));
+		node = node->next;
+	}
+
+	/*handle every module*/
+	module_Count = cJSON_GetArraySize(modules_res);
+	for (i  = 0; i < module_Count; i++){
+		cJSON *module_res = cJSON_GetArrayItem(modules_res, i);
+		cJSON *module_req = NULL;
+		cJSON *mod_resp = NULL;
+
+		const char *module_name = module_res->valuestring;
+		module_req = cJSON_GetObjectItem(linkie_req, module_name);
+		mod_resp = auth_err_cmd(module_req);
+		if (mod_resp == NULL) {
+			cJSON_Delete(linkie_res);
+			cJSON_Delete(modules_res);
+			modules_res = NULL;
+			linkie_res = NULL;
+			return NULL;
+		}
+		else {
+			cJSON_AddItemToObject(linkie_res, module_name, mod_resp);
+		}
+	}
+	cJSON_Delete(modules_res);
+	modules_res = NULL;
+ENDS:
+	return linkie_res;
+}
+
+static int auth_err_handle(char *request, int req_len, char *response, int *resp_len)
+{
+	char *resp_js_str = NULL;
+	cJSON *req = NULL;
+	cJSON *resp = NULL;
+	int ret = 0;
+
+	req = cJSON_Parse(request);
+	if (NULL == req) {
+		return -1;
+	}
+
+	resp = auth_err_request(req);
+	if (!resp) {
+		ret = -1;
+		goto ENDS;
+	}
+	resp_js_str = cJSON_PrintUnformatted(resp);
+	if (!resp_js_str) {
+		ret = -1;
+		goto ENDS;
+	}
+	*resp_len = strlen(resp_js_str);
+	strncpy(response, resp_js_str, *resp_len);
+
+ENDS:
+	if (resp_js_str) {
+		free(resp_js_str);
+		resp_js_str = NULL;
+	}
+
+	if (resp) {
+		cJSON_Delete(resp);
+		resp = NULL;
+	}
+	if (req) {
+		cJSON_Delete(req);
+		req = NULL;
+	}
+	return ret;
+}
+
+static int fast_linkie_main(struct client *cl, struct path_info *pi, char *url)
+{
+	int path_len, prefix_len;
+	char *str;
+
+	char request_buf[4096] = {};
+	char request_buf1[4096] = {};
+	char request_buf2[4096] = {};
+	char response_buf[65535] = {};
+	char response_buf1[65535] = {};
+	int len = 0;
+
+	prefix_len = strlen(conf.lua_prefix);
+	path_len = strlen(url);
+	str = strchr(url, '?');
+	if (str) {
+		if (*(str + 1))
+			pi->query = str + 1;
+		path_len = str - url;
+	}
+	if (path_len > prefix_len) {
+		if (!strncmp(url + prefix_len, "/LINKIE", 7)) {
+			/* Do auth */			
+			len = uh_fast_linkie_recv(STDIN_FILENO, request_buf, 4096);
+
+			len = urldecode(request_buf1, 4096, request_buf, len);
+			decode_base64((unsigned char *)(request_buf1 + 8), len - 8, (unsigned char *)request_buf2);
+			//len = uh_b64decode(request_buf2, 4096, request_buf1 + 8, len - 8);
+			if (do_auth(cl, pi) != 0) {
+				simple_decode((unsigned char *)request_buf2, len - 8);
+				if (-1 == auth_err_handle(request_buf2, len - 8, response_buf, &len)) {
+					return -1;
+				}
+				else {
+					simple_encode((unsigned char *)response_buf, len);
+				}
+			}
+			else {
+				write(fast_linkie_ctx->fd, request_buf2, len - 8);
+				len = uh_fast_linkie_recv(fast_linkie_ctx->fd, response_buf, 65535);
+			}
+			encode_base64((unsigned char *)response_buf, len, (unsigned char *)response_buf1);
+
+			printf("Status: 200\r\nExpires: 0\r\nContent-Type: application/json\r\n"
+					"Cache-Control: no-cache\r\n\r\n%s\r\n", response_buf1);
+			return 0;
+		}
+	}
+	return -1;
+
+}
+
+#endif /* FASTEN_LINKIE */
+
 static int uh_lua_recv(lua_State *L)
 {
 	static struct pollfd pfd = {
@@ -146,13 +710,11 @@ static lua_State *uh_lua_state_init(void
 	const char *status;
 	lua_State *L;
 	int ret;
-
 	L = luaL_newstate();
 	luaL_openlibs(L);
 
 	/* build uhttpd api table */
 	lua_newtable(L);
-
 	lua_pushcfunction(L, uh_lua_send);
 	lua_setfield(L, -2, "send");
 
@@ -211,8 +773,15 @@ static void lua_main(struct client *cl,
 	int path_len, prefix_len;
 	char *str;
 	int rem;
-
+	
 	signal(SIGCHLD, (__sighandler_t)wait);
+
+#ifdef FASTEN_LINKIE
+	if (0 == fast_linkie_main(cl, pi, url)) {
+		exit(1);
+	}
+#endif
+	
 	lua_getglobal(L, UH_LUA_CB);
 
 	/* new env table for this request */
@@ -268,11 +837,12 @@ static void lua_main(struct client *cl,
 static void lua_handle_request(struct client *cl, char *url, struct path_info *pi)
 {
 	static struct path_info _pi;
-
 	pi = &_pi;
 	pi->name = conf.lua_prefix;
 	pi->phys = conf.lua_handler;
-
+#ifdef FASTEN_LINKIE
+	get_usrinfo();
+#endif
 	if (!ops->create_process(cl, pi, url, lua_main)) {
 		ops->client_error(cl, 500, "Internal Server Error",
 				  "Failed to create CGI process: %s", strerror(errno));
@@ -292,13 +862,34 @@ static struct dispatch_handler lua_dispa
 
 static int lua_plugin_init(const struct uhttpd_ops *o, struct config *c)
 {
+#ifdef UBUS_RELOAD_CONFIG
+	const char *ubus_socket = "/var/run/ubus.sock";
+	int ret = 0;
+
+	ubus_ctx = ubus_connect(ubus_socket);
+	if (!ubus_ctx) {
+		fprintf(stderr, "Failed to connect to ubus\n");
+		return -1;
+	}
+	ubus_add_uloop(ubus_ctx);
+	ret = ubus_add_object(ubus_ctx, &uhttpd_object);
+	if (ret) {
+		fprintf(stderr, "Failed to add object: %s\n", ubus_strerror(ret));
+		ubus_free(ubus_ctx);
+		return -1;
+	}
+#endif
 	ops = o;
 	_conf = c;
 	_L = uh_lua_state_init();
 	ops->dispatch_add(&lua_dispatch);
+#ifdef FASTEN_LINKIE
+	fast_linkie_ctx = uh_fast_linkie_init();
+#endif
 	return 0;
 }
 
 struct uhttpd_plugin uhttpd_plugin = {
 	.init = lua_plugin_init,
 };
+
