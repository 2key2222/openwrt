From 935eec88a8e973203b8c2ebbceb4bef3058e7d05 Mon Sep 17 00:00:00 2001
From: Yelena <yelena@marvell.com>
Date: Tue, 8 Nov 2016 09:49:10 +0200
Subject: [PATCH 1075/2241] net dsa: support new switch mv88e6341

Change-Id: I4c906475f616077642c4869d6df9c52bc9e26556
Signed-off-by: Yelena <yelena@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/33612
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Wilson Ding <dingwei@marvell.com>
---
 drivers/net/dsa/mv88e6xxx.c | 36 +++++++++++++++++++++++++-----------
 drivers/net/dsa/mv88e6xxx.h | 13 ++++++++++++-
 2 files changed, 37 insertions(+), 12 deletions(-)

diff --git a/drivers/net/dsa/mv88e6xxx.c b/drivers/net/dsa/mv88e6xxx.c
index ee06055..2738278 100644
--- a/drivers/net/dsa/mv88e6xxx.c
+++ b/drivers/net/dsa/mv88e6xxx.c
@@ -2684,6 +2684,12 @@ static int mv88e6xxx_setup_port(struct mv88e6xxx_priv_state *ps, int port)
 				PORT_PCS_CTRL_LINK_UP |
 				PORT_PCS_CTRL_DUPLEX_FULL |
 				PORT_PCS_CTRL_FORCE_DUPLEX;
+			if (mv88e6xxx_6352_family(ps)) {
+				/* configure RGMII Delay on cpu / dsa port */
+				reg |= PORT_PCS_CTRL_FORCE_SPEED |
+					PORT_PCS_CTRL_RGMII_DELAY_TXCLK |
+					PORT_PCS_CTRL_RGMII_DELAY_RXCLK;
+			}
 			if (mv88e6xxx_6065_family(ps))
 				reg |= PORT_PCS_CTRL_100;
 			else
@@ -3170,8 +3176,7 @@ int mv88e6xxx_mdio_page_read(struct dsa_switch *ds, int port, int page, int reg)
 	return ret;
 }
 
-int mv88e6xxx_mdio_page_write(struct dsa_switch *ds, int port, int page,
-			      int reg, int val)
+int mv88e6xxx_mdio_page_write(struct dsa_switch *ds, int port, int page, int reg, int val)
 {
 	struct mv88e6xxx_priv_state *ps = ds_to_priv(ds);
 	int ret;
@@ -3183,11 +3188,14 @@ int mv88e6xxx_mdio_page_write(struct dsa_switch *ds, int port, int page,
 	return ret;
 }
 
-static int mv88e6xxx_port_to_mdio_addr(struct mv88e6xxx_priv_state *ps,
-				       int port)
+static int mv88e6xxx_port_to_mdio_addr(struct mv88e6xxx_priv_state *ps, int port)
 {
-	if (port >= 0 && port < ps->info->num_ports)
-		return port;
+	if (port >= 0 && port < ps->info->num_ports) {
+		if (mv88e6xxx_has(ps, MV88E6XXX_FLAG_PHY_ADDR))
+			return (port + 0x10);
+		else
+			return port;
+	}
 	return -EINVAL;
 }
 
@@ -3213,8 +3221,7 @@ static int mv88e6xxx_mdio_read(struct mii_bus *bus, int port, int regnum)
 	return ret;
 }
 
-static int mv88e6xxx_mdio_write(struct mii_bus *bus, int port, int regnum,
-				u16 val)
+static int mv88e6xxx_mdio_write(struct mii_bus *bus, int port, int regnum, u16 val)
 {
 	struct mv88e6xxx_priv_state *ps = bus->priv;
 	int addr = mv88e6xxx_port_to_mdio_addr(ps, port);
@@ -3236,8 +3243,7 @@ static int mv88e6xxx_mdio_write(struct mii_bus *bus, int port, int regnum,
 	return ret;
 }
 
-static int mv88e6xxx_mdio_register(struct mv88e6xxx_priv_state *ps,
-				   struct device_node *np)
+static int mv88e6xxx_mdio_register(struct mv88e6xxx_priv_state *ps, struct device_node *np)
 {
 	static int index;
 	struct mii_bus *bus;
@@ -3274,6 +3280,7 @@ static int mv88e6xxx_mdio_register(struct mv88e6xxx_priv_state *ps,
 		dev_err(ps->dev, "Cannot register MDIO bus (%d)\n", err);
 		goto out;
 	}
+
 	ps->mdio_bus = bus;
 
 	return 0;
@@ -3584,6 +3591,14 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
 		.num_ports = 7,
 		.flags = MV88E6XXX_FLAGS_FAMILY_6352,
 	},
+	[MV88E6341] = {
+		.prod_num = PORT_SWITCH_ID_PROD_NUM_6341,
+		.family = MV88E6XXX_FAMILY_6352,
+		.name = "Marvell 88E6341",
+		.num_databases = 4096,
+		.num_ports = 6,
+		.flags = MV88E6XXX_FLAGS_FAMILY_6352 | MV88E6XXX_FLAG_PHY_ADDR,
+	},
 };
 
 static const struct mv88e6xxx_info *
@@ -3637,7 +3652,6 @@ static const char *mv88e6xxx_drv_probe(struct device *dsa_dev,
 	ps->info = info;
 	ps->dev = dsa_dev;
 	mutex_init(&ps->smi_mutex);
-
 	err = mv88e6xxx_mdio_register(ps, NULL);
 	if (err)
 		return NULL;
diff --git a/drivers/net/dsa/mv88e6xxx.h b/drivers/net/dsa/mv88e6xxx.h
index 8221c3c..428882f 100644
--- a/drivers/net/dsa/mv88e6xxx.h
+++ b/drivers/net/dsa/mv88e6xxx.h
@@ -57,6 +57,7 @@
 #define PORT_PCS_CTRL		0x01
 #define PORT_PCS_CTRL_RGMII_DELAY_RXCLK	BIT(15)
 #define PORT_PCS_CTRL_RGMII_DELAY_TXCLK	BIT(14)
+#define PORT_PCS_CTRL_FORCE_SPEED	BIT(13)
 #define PORT_PCS_CTRL_FC		BIT(7)
 #define PORT_PCS_CTRL_FORCE_FC		BIT(6)
 #define PORT_PCS_CTRL_LINK_UP		BIT(5)
@@ -83,6 +84,7 @@
 #define PORT_SWITCH_ID_PROD_NUM_6185	0x1a7
 #define PORT_SWITCH_ID_PROD_NUM_6240	0x240
 #define PORT_SWITCH_ID_PROD_NUM_6321	0x310
+#define PORT_SWITCH_ID_PROD_NUM_6341	0x340
 #define PORT_SWITCH_ID_PROD_NUM_6352	0x352
 #define PORT_SWITCH_ID_PROD_NUM_6350	0x371
 #define PORT_SWITCH_ID_PROD_NUM_6351	0x375
@@ -355,6 +357,7 @@ enum mv88e6xxx_model {
 	MV88E6240,
 	MV88E6320,
 	MV88E6321,
+	MV88E6341,
 	MV88E6350,
 	MV88E6351,
 	MV88E6352,
@@ -369,7 +372,7 @@ enum mv88e6xxx_family {
 	MV88E6XXX_FAMILY_6185,	/* 6108 6121 6122 6131 6152 6155 6182 6185 */
 	MV88E6XXX_FAMILY_6320,	/* 6320 6321 */
 	MV88E6XXX_FAMILY_6351,	/* 6171 6175 6350 6351 */
-	MV88E6XXX_FAMILY_6352,	/* 6172 6176 6240 6352 */
+	MV88E6XXX_FAMILY_6352,	/* 6172 6176 6240 6341 6352 */
 };
 
 enum mv88e6xxx_cap {
@@ -433,6 +436,12 @@ enum mv88e6xxx_cap {
 	 * The VTU is used to program 802.1Q VLANs. See GLOBAL_VTU_OP.
 	 */
 	MV88E6XXX_CAP_VTU,
+
+	/* Switch internal PHY SMI address conversion.
+	 * Most of switch internal PHY SMI address are equal to switch port ID
+	 * However Some switch internal PHY SMI addressis are (0x10 + port ID)
+	 */
+	MV88E6XXX_PHY_ADDR_CONVERT,
 };
 
 /* Bitmask of capabilities */
@@ -449,6 +458,8 @@ enum mv88e6xxx_cap {
 #define MV88E6XXX_FLAG_TEMP_LIMIT	BIT(MV88E6XXX_CAP_TEMP_LIMIT)
 #define MV88E6XXX_FLAG_VLANTABLE	BIT(MV88E6XXX_CAP_VLANTABLE)
 #define MV88E6XXX_FLAG_VTU		BIT(MV88E6XXX_CAP_VTU)
+#define MV88E6XXX_FLAG_PHY_ADDR		BIT(MV88E6XXX_PHY_ADDR_CONVERT)
+
 
 #define MV88E6XXX_FLAGS_FAMILY_6095	\
 	(MV88E6XXX_FLAG_ATU |		\
-- 
2.7.4

