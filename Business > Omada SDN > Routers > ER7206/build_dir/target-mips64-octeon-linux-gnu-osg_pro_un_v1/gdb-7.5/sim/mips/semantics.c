/* This file is part of GDB.

   Copyright 2002, 2007 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.

   --

   This file was generated by the program igen */

#ifndef SEMANTICS_C
#define SEMANTICS_C


#include "sim-inline.c"

#if C_REVEALS_MODULE_P (ITABLE_INLINE)
#include "itable.c"
#else
#include "itable.h"
#endif

#if C_REVEALS_MODULE_P (IDECODE_INLINE)
#include "idecode.c"
#else
#include "idecode.h"
#endif

#if C_REVEALS_MODULE_P (SUPPORT_INLINE)
#include "support.c"
#else
#include "support.h"
#endif

#include "semantics.h"


EXTERN_SEMANTICS\
(instruction_address)
semantic_RSVD_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_RSVD_SPECIAL
#undef RSVD_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX RSVD_SPECIAL
#undef MY_NAME
#define MY_NAME "RSVD_SPECIAL"

  /* Extraction: RSVD
       #define do-not-use-icache
       6.0x0,5.*,5.*,5.*,5.OP,6.0x5 */

#undef OP
#define OP ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#line 70 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.*,5.*,5.*,5.OP,6.0x5 */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 95 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "rsvd %ld", \
                    (long) OP);
#line 87 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_RSVD_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 97 "./mips.igen"
    SignalException (ReservedInstruction, instruction_0);
  }
#line 115 "semantics.c"
  return nia;
  /* Extraction: RSVD
       #undef do-not-use-icache
       6.0x0,5.*,5.*,5.*,5.OP,6.0x5 */

#undef OP
#line 122 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SYSCALL_SPECIAL (SIM_DESC sd,
                          instruction_word instruction_0,
                          instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SYSCALL_SPECIAL
#undef SYSCALL_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SYSCALL_SPECIAL
#undef MY_NAME
#define MY_NAME "SYSCALL_SPECIAL"

  /* Extraction: SYSCALL
       #define do-not-use-icache
       6.0x0,20.CODE,6.0xc */

#undef CODE
#define CODE ((unsigned) EXTRACTED32 (instruction_0, 25, 6)) /* cache - extraction */
#line 145 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,20.CODE,6.0xc */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3787 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "syscall %#lx", \
                    (unsigned long) CODE);
#line 162 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SYSCALL_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3801 "./mips.igen"
    SignalException (SystemCall, instruction_0);
  }
#line 190 "semantics.c"
  return nia;
  /* Extraction: SYSCALL
       #undef do-not-use-icache
       6.0x0,20.CODE,6.0xc */

#undef CODE
#line 197 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BREAK_SPECIAL (SIM_DESC sd,
                        instruction_word instruction_0,
                        instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BREAK_SPECIAL
#undef BREAK_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX BREAK_SPECIAL
#undef MY_NAME
#define MY_NAME "BREAK_SPECIAL"

  /* Extraction: BREAK
       #define do-not-use-icache
       6.0x0,20.CODE,6.0xd */

#undef CODE
#define CODE ((unsigned) EXTRACTED32 (instruction_0, 25, 6)) /* cache - extraction */
#line 220 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,20.CODE,6.0xd */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1085 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "break %#lx", \
                    (unsigned long) CODE);
#line 237 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BREAK_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1099 "./mips.igen"
    /* Check for some break instruction which are reserved for use by the simulator.  */
    unsigned int break_code = instruction_0 & HALT_INSTRUCTION_MASK;
    if (break_code == (HALT_INSTRUCTION  & HALT_INSTRUCTION_MASK) ||
        break_code == (HALT_INSTRUCTION2 & HALT_INSTRUCTION_MASK))
      {
        sim_engine_halt (SD, CPU, NULL, cia,
                         sim_exited, (unsigned int)(A0 & 0xFFFFFFFF));
      }
    else if (break_code == (BREAKPOINT_INSTRUCTION  & HALT_INSTRUCTION_MASK) ||
             break_code == (BREAKPOINT_INSTRUCTION2 & HALT_INSTRUCTION_MASK))
      {
        if (STATE & simDELAYSLOT)
          PC = cia - 4; /* reference the branch instruction */
        else
          PC = cia;
        SignalException (BreakPoint, instruction_0);
      }

    else
      {
        /* If we get this far, we're not an instruction reserved by the sim.  Raise
    	 the exception. */
        SignalException (BreakPoint, instruction_0);
      }
  }
#line 288 "semantics.c"
  return nia;
  /* Extraction: BREAK
       #undef do-not-use-icache
       6.0x0,20.CODE,6.0xd */

#undef CODE
#line 295 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TGE_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TGE_SPECIAL
#undef TGE_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX TGE_SPECIAL
#undef MY_NAME
#define MY_NAME "TGE_SPECIAL"

  /* Extraction: TGE
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x30 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef CODE
#define CODE ((unsigned) EXTRACTED32 (instruction_0, 15, 6)) /* cache - extraction */
#line 322 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.CODE,6.0x30 */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3842 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tge r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 340 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TGE_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3854 "./mips.igen"
    if ((signed_word) GPR[RS] >= (signed_word) GPR[RT])
      SignalException (Trap, instruction_0);
  }
#line 369 "semantics.c"
  return nia;
  /* Extraction: TGE
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x30 */

#undef RS
#undef RT
#undef CODE
#line 378 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TGEU_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TGEU_SPECIAL
#undef TGEU_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX TGEU_SPECIAL
#undef MY_NAME
#define MY_NAME "TGEU_SPECIAL"

  /* Extraction: TGEU
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x31 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef CODE
#define CODE ((unsigned) EXTRACTED32 (instruction_0, 15, 6)) /* cache - extraction */
#line 405 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.CODE,6.0x31 */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3896 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tgeu r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 423 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TGEU_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3908 "./mips.igen"
    if ((unsigned_word) GPR[RS] >= (unsigned_word) GPR[RT])
      SignalException (Trap, instruction_0);
  }
#line 452 "semantics.c"
  return nia;
  /* Extraction: TGEU
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x31 */

#undef RS
#undef RT
#undef CODE
#line 461 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TLT_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TLT_SPECIAL
#undef TLT_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX TLT_SPECIAL
#undef MY_NAME
#define MY_NAME "TLT_SPECIAL"

  /* Extraction: TLT
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x32 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef CODE
#define CODE ((unsigned) EXTRACTED32 (instruction_0, 15, 6)) /* cache - extraction */
#line 488 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.CODE,6.0x32 */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3914 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tlt r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 506 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TLT_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3926 "./mips.igen"
    if ((signed_word) GPR[RS] < (signed_word) GPR[RT])
      SignalException (Trap, instruction_0);
  }
#line 535 "semantics.c"
  return nia;
  /* Extraction: TLT
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x32 */

#undef RS
#undef RT
#undef CODE
#line 544 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TLTU_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TLTU_SPECIAL
#undef TLTU_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX TLTU_SPECIAL
#undef MY_NAME
#define MY_NAME "TLTU_SPECIAL"

  /* Extraction: TLTU
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x33 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef CODE
#define CODE ((unsigned) EXTRACTED32 (instruction_0, 15, 6)) /* cache - extraction */
#line 571 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.CODE,6.0x33 */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3968 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tltu r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 589 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TLTU_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3980 "./mips.igen"
    if ((unsigned_word) GPR[RS] < (unsigned_word) GPR[RT])
      SignalException (Trap, instruction_0);
  }
#line 618 "semantics.c"
  return nia;
  /* Extraction: TLTU
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x33 */

#undef RS
#undef RT
#undef CODE
#line 627 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TEQ_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TEQ_SPECIAL
#undef TEQ_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX TEQ_SPECIAL
#undef MY_NAME
#define MY_NAME "TEQ_SPECIAL"

  /* Extraction: TEQ
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x34 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef CODE
#define CODE ((unsigned) EXTRACTED32 (instruction_0, 15, 6)) /* cache - extraction */
#line 654 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.CODE,6.0x34 */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3806 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "teq r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 672 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TEQ_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3818 "./mips.igen"
    if ((signed_word) GPR[RS] == (signed_word) GPR[RT])
      SignalException (Trap, instruction_0);
  }
#line 701 "semantics.c"
  return nia;
  /* Extraction: TEQ
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x34 */

#undef RS
#undef RT
#undef CODE
#line 710 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TNE_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TNE_SPECIAL
#undef TNE_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX TNE_SPECIAL
#undef MY_NAME
#define MY_NAME "TNE_SPECIAL"

  /* Extraction: TNE
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x36 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef CODE
#define CODE ((unsigned) EXTRACTED32 (instruction_0, 15, 6)) /* cache - extraction */
#line 737 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.CODE,6.0x36 */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3986 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tne r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 755 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TNE_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3998 "./mips.igen"
    if ((signed_word) GPR[RS] != (signed_word) GPR[RT])
      SignalException (Trap, instruction_0);
  }
#line 784 "semantics.c"
  return nia;
  /* Extraction: TNE
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.CODE,6.0x36 */

#undef RS
#undef RT
#undef CODE
#line 793 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SLLV_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SLLV_SPECIAL
#undef SLLV_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SLLV_SPECIAL
#undef MY_NAME
#define MY_NAME "SLLV_SPECIAL"

  /* Extraction: SLLV
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x4 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 820 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x4 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3393 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sllv r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RT, \
                    (long) RS);
#line 844 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SLLV_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3407 "./mips.igen"
    do_sllv (SD_, RS, RT, RD);
  }
#line 872 "semantics.c"
  return nia;
  /* Extraction: SLLV
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x4 */

#undef RS
#undef RT
#undef RD
#line 881 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SRLV_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SRLV_SPECIAL
#undef SRLV_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SRLV_SPECIAL
#undef MY_NAME
#define MY_NAME "SRLV_SPECIAL"

  /* Extraction: SRLV
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x6 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 908 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x6 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3618 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "srlv r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RT, \
                    (long) RS);
#line 932 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SRLV_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3632 "./mips.igen"
    do_srlv (SD_, RS, RT, RD);
  }
#line 960 "semantics.c"
  return nia;
  /* Extraction: SRLV
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x6 */

#undef RS
#undef RT
#undef RD
#line 969 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SRAV_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SRAV_SPECIAL
#undef SRAV_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SRAV_SPECIAL
#undef MY_NAME
#define MY_NAME "SRAV_SPECIAL"

  /* Extraction: SRAV
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x7 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 996 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x7 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3558 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "srav r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RT, \
                    (long) RS);
#line 1020 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SRAV_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3572 "./mips.igen"
    do_srav (SD_, RS, RT, RD);
  }
#line 1048 "semantics.c"
  return nia;
  /* Extraction: SRAV
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x7 */

#undef RS
#undef RT
#undef RD
#line 1057 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MOVZ_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MOVZ_SPECIAL
#undef MOVZ_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX MOVZ_SPECIAL
#undef MY_NAME
#define MY_NAME "MOVZ_SPECIAL"

  /* Extraction: MOVZ
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0xa */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 1084 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0xa */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2614 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "movz r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 1108 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MOVZ_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2623 "./mips.igen"
    if (GPR[RT] == 0)
      {
        GPR[RD] = GPR[RS];
        TRACE_ALU_RESULT (GPR[RD]);
      }
  }
#line 1140 "semantics.c"
  return nia;
  /* Extraction: MOVZ
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0xa */

#undef RS
#undef RT
#undef RD
#line 1149 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MOVN_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MOVN_SPECIAL
#undef MOVN_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX MOVN_SPECIAL
#undef MY_NAME
#define MY_NAME "MOVN_SPECIAL"

  /* Extraction: MOVN
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0xb */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 1176 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0xb */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2595 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "movn r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 1200 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MOVN_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2604 "./mips.igen"
    if (GPR[RT] != 0)
      {
        GPR[RD] = GPR[RS];
        TRACE_ALU_RESULT (GPR[RD]);
      }
  }
#line 1232 "semantics.c"
  return nia;
  /* Extraction: MOVN
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0xb */

#undef RS
#undef RT
#undef RD
#line 1241 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_DSLLV_SPECIAL (SIM_DESC sd,
                        instruction_word instruction_0,
                        instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_DSLLV_SPECIAL
#undef DSLLV_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX DSLLV_SPECIAL
#undef MY_NAME
#define MY_NAME "DSLLV_SPECIAL"

  /* Extraction: DSLLV
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x14 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 1268 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x14 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1699 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "dsllv r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RT, \
                    (long) RS);
#line 1292 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_DSLLV_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1708 "./mips.igen"
    check_u64 (SD_, instruction_0);
    do_dsllv (SD_, RS, RT, RD);
  }
#line 1321 "semantics.c"
  return nia;
  /* Extraction: DSLLV
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x14 */

#undef RS
#undef RT
#undef RD
#line 1330 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_DSRLV_SPECIAL (SIM_DESC sd,
                        instruction_word instruction_0,
                        instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_DSRLV_SPECIAL
#undef DSRLV_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX DSRLV_SPECIAL
#undef MY_NAME
#define MY_NAME "DSRLV_SPECIAL"

  /* Extraction: DSRLV
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x16 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 1357 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x16 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1827 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "dsrlv r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RT, \
                    (long) RS);
#line 1381 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_DSRLV_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1836 "./mips.igen"
    check_u64 (SD_, instruction_0);
    do_dsrlv (SD_, RS, RT, RD);
  }
#line 1410 "semantics.c"
  return nia;
  /* Extraction: DSRLV
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x16 */

#undef RS
#undef RT
#undef RD
#line 1419 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_DSRAV_SPECIAL (SIM_DESC sd,
                        instruction_word instruction_0,
                        instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_DSRAV_SPECIAL
#undef DSRAV_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX DSRAV_SPECIAL
#undef MY_NAME
#define MY_NAME "DSRAV_SPECIAL"

  /* Extraction: DSRAV
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x17 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 1446 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x17 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1762 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "dsrav r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RT, \
                    (long) RS);
#line 1470 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_DSRAV_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1771 "./mips.igen"
    check_u64 (SD_, instruction_0);
    do_dsrav (SD_, RS, RT, RD);
  }
#line 1499 "semantics.c"
  return nia;
  /* Extraction: DSRAV
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x17 */

#undef RS
#undef RT
#undef RD
#line 1508 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ADD_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ADD_SPECIAL
#undef ADD_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX ADD_SPECIAL
#undef MY_NAME
#define MY_NAME "ADD_SPECIAL"

  /* Extraction: ADD
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x20 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 1535 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x20 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 508 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "add r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 1559 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ADD_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 522 "./mips.igen"
    if (NotWordValue (GPR[RS]) || NotWordValue (GPR[RT]))
      Unpredictable ();
    TRACE_ALU_INPUT2 (GPR[RS], GPR[RT]);
    {
      ALU32_BEGIN (GPR[RS]);
      ALU32_ADD (GPR[RT]);
      ALU32_END (GPR[RD]);   /* This checks for overflow.  */
    }
    TRACE_ALU_RESULT (GPR[RD]);
  }
#line 1595 "semantics.c"
  return nia;
  /* Extraction: ADD
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x20 */

#undef RS
#undef RT
#undef RD
#line 1604 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ADDU_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ADDU_SPECIAL
#undef ADDU_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX ADDU_SPECIAL
#undef MY_NAME
#define MY_NAME "ADDU_SPECIAL"

  /* Extraction: ADDU
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x21 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 1631 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x21 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 602 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "addu r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 1655 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ADDU_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 616 "./mips.igen"
    do_addu (SD_, RS, RT, RD);
  }
#line 1683 "semantics.c"
  return nia;
  /* Extraction: ADDU
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x21 */

#undef RS
#undef RT
#undef RD
#line 1692 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SUB_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SUB_SPECIAL
#undef SUB_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SUB_SPECIAL
#undef MY_NAME
#define MY_NAME "SUB_SPECIAL"

  /* Extraction: SUB
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x22 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 1719 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x22 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3637 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sub r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 1743 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SUB_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3651 "./mips.igen"
    if (NotWordValue (GPR[RS]) || NotWordValue (GPR[RT]))
      Unpredictable ();
    TRACE_ALU_INPUT2 (GPR[RS], GPR[RT]);
    {
      ALU32_BEGIN (GPR[RS]);
      ALU32_SUB (GPR[RT]);
      ALU32_END (GPR[RD]);   /* This checks for overflow.  */
    }
    TRACE_ALU_RESULT (GPR[RD]);
  }
#line 1779 "semantics.c"
  return nia;
  /* Extraction: SUB
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x22 */

#undef RS
#undef RT
#undef RD
#line 1788 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SUBU_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SUBU_SPECIAL
#undef SUBU_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SUBU_SPECIAL
#undef MY_NAME
#define MY_NAME "SUBU_SPECIAL"

  /* Extraction: SUBU
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x23 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 1815 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x23 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3673 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "subu r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 1839 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SUBU_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3687 "./mips.igen"
    do_subu (SD_, RS, RT, RD);
  }
#line 1867 "semantics.c"
  return nia;
  /* Extraction: SUBU
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x23 */

#undef RS
#undef RT
#undef RD
#line 1876 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_AND_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_AND_SPECIAL
#undef AND_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX AND_SPECIAL
#undef MY_NAME
#define MY_NAME "AND_SPECIAL"

  /* Extraction: AND
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x24 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 1903 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x24 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 629 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "and r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 1927 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_AND_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 643 "./mips.igen"
    do_and (SD_, RS, RT, RD);
  }
#line 1955 "semantics.c"
  return nia;
  /* Extraction: AND
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x24 */

#undef RS
#undef RT
#undef RD
#line 1964 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_OR_SPECIAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_OR_SPECIAL
#undef OR_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX OR_SPECIAL
#undef MY_NAME
#define MY_NAME "OR_SPECIAL"

  /* Extraction: OR
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x25 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 1991 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x25 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2960 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "or r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 2015 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_OR_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2974 "./mips.igen"
    do_or (SD_, RS, RT, RD);
  }
#line 2043 "semantics.c"
  return nia;
  /* Extraction: OR
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x25 */

#undef RS
#undef RT
#undef RD
#line 2052 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_XOR_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_XOR_SPECIAL
#undef XOR_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX XOR_SPECIAL
#undef MY_NAME
#define MY_NAME "XOR_SPECIAL"

  /* Extraction: XOR
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x26 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 2079 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x26 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4029 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "xor r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 2103 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_XOR_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4043 "./mips.igen"
    do_xor (SD_, RS, RT, RD);
  }
#line 2131 "semantics.c"
  return nia;
  /* Extraction: XOR
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x26 */

#undef RS
#undef RT
#undef RD
#line 2140 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_NOR_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_NOR_SPECIAL
#undef NOR_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX NOR_SPECIAL
#undef MY_NAME
#define MY_NAME "NOR_SPECIAL"

  /* Extraction: NOR
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x27 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 2167 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x27 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2934 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "nor r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 2191 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_NOR_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2948 "./mips.igen"
    do_nor (SD_, RS, RT, RD);
  }
#line 2219 "semantics.c"
  return nia;
  /* Extraction: NOR
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x27 */

#undef RS
#undef RT
#undef RD
#line 2228 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SLT_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SLT_SPECIAL
#undef SLT_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SLT_SPECIAL
#undef MY_NAME
#define MY_NAME "SLT_SPECIAL"

  /* Extraction: SLT
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x2a */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 2255 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x2a */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3419 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "slt r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 2279 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SLT_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3433 "./mips.igen"
    do_slt (SD_, RS, RT, RD);
  }
#line 2307 "semantics.c"
  return nia;
  /* Extraction: SLT
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x2a */

#undef RS
#undef RT
#undef RD
#line 2316 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SLTU_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SLTU_SPECIAL
#undef SLTU_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SLTU_SPECIAL
#undef MY_NAME
#define MY_NAME "SLTU_SPECIAL"

  /* Extraction: SLTU
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x2b */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 2343 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x2b */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3498 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sltu r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 2367 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SLTU_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3512 "./mips.igen"
    do_sltu (SD_, RS, RT, RD);
  }
#line 2395 "semantics.c"
  return nia;
  /* Extraction: SLTU
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x2b */

#undef RS
#undef RT
#undef RD
#line 2404 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_DADD_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_DADD_SPECIAL
#undef DADD_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX DADD_SPECIAL
#undef MY_NAME
#define MY_NAME "DADD_SPECIAL"

  /* Extraction: DADD
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x2c */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 2431 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x2c */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1182 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "dadd r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 2455 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_DADD_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1191 "./mips.igen"
    check_u64 (SD_, instruction_0);
    TRACE_ALU_INPUT2 (GPR[RS], GPR[RT]);
    {
      ALU64_BEGIN (GPR[RS]);
      ALU64_ADD (GPR[RT]);
      ALU64_END (GPR[RD]);   /* This checks for overflow.  */
    }
    TRACE_ALU_RESULT (GPR[RD]);
  }
#line 2490 "semantics.c"
  return nia;
  /* Extraction: DADD
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x2c */

#undef RS
#undef RT
#undef RD
#line 2499 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_DADDU_SPECIAL (SIM_DESC sd,
                        instruction_word instruction_0,
                        instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_DADDU_SPECIAL
#undef DADDU_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX DADDU_SPECIAL
#undef MY_NAME
#define MY_NAME "DADDU_SPECIAL"

  /* Extraction: DADDU
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x2d */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 2526 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x2d */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1256 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "daddu r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 2550 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_DADDU_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1265 "./mips.igen"
    check_u64 (SD_, instruction_0);
    do_daddu (SD_, RS, RT, RD);
  }
#line 2579 "semantics.c"
  return nia;
  /* Extraction: DADDU
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x2d */

#undef RS
#undef RT
#undef RD
#line 2588 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_DSUB_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_DSUB_SPECIAL
#undef DSUB_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX DSUB_SPECIAL
#undef MY_NAME
#define MY_NAME "DSUB_SPECIAL"

  /* Extraction: DSUB
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x2e */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 2615 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x2e */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1842 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "dsub r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 2639 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_DSUB_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1851 "./mips.igen"
    check_u64 (SD_, instruction_0);
    TRACE_ALU_INPUT2 (GPR[RS], GPR[RT]);
    {
      ALU64_BEGIN (GPR[RS]);
      ALU64_SUB (GPR[RT]);
      ALU64_END (GPR[RD]);   /* This checks for overflow.  */
    }
    TRACE_ALU_RESULT (GPR[RD]);
  }
#line 2674 "semantics.c"
  return nia;
  /* Extraction: DSUB
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x2e */

#undef RS
#undef RT
#undef RD
#line 2683 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_DSUBU_SPECIAL (SIM_DESC sd,
                        instruction_word instruction_0,
                        instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_DSUBU_SPECIAL
#undef DSUBU_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX DSUBU_SPECIAL
#undef MY_NAME
#define MY_NAME "DSUBU_SPECIAL"

  /* Extraction: DSUBU
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x2f */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 2710 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x2f */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1870 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "dsubu r%ld, r%ld, r%ld", \
                    (long) RD, \
                    (long) RS, \
                    (long) RT);
#line 2734 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_DSUBU_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1879 "./mips.igen"
    check_u64 (SD_, instruction_0);
    do_dsubu (SD_, RS, RT, RD);
  }
#line 2763 "semantics.c"
  return nia;
  /* Extraction: DSUBU
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,5.RD,5.0x0,6.0x2f */

#undef RS
#undef RT
#undef RD
#line 2772 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MULT_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MULT_SPECIAL
#undef MULT_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX MULT_SPECIAL
#undef MY_NAME
#define MY_NAME "MULT_SPECIAL"

  /* Extraction: MULT
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.0x0,6.0x18 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#line 2797 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.0x0,6.0x18 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x0000ffc0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2814 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mult r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 2820 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MULT_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2824 "./mips.igen"
    do_mult (SD_, RS, RT, 0);
  }
#line 2848 "semantics.c"
  return nia;
  /* Extraction: MULT
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.0x0,6.0x18 */

#undef RS
#undef RT
#line 2856 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MULTU_SPECIAL (SIM_DESC sd,
                        instruction_word instruction_0,
                        instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MULTU_SPECIAL
#undef MULTU_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX MULTU_SPECIAL
#undef MY_NAME
#define MY_NAME "MULTU_SPECIAL"

  /* Extraction: MULTU
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.0x0,6.0x19 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#line 2881 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.0x0,6.0x19 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x0000ffc0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2880 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "multu r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 2904 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MULTU_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2890 "./mips.igen"
    do_multu (SD_, RS, RT, 0);
  }
#line 2932 "semantics.c"
  return nia;
  /* Extraction: MULTU
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.0x0,6.0x19 */

#undef RS
#undef RT
#line 2940 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_DIV_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_DIV_SPECIAL
#undef DIV_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX DIV_SPECIAL
#undef MY_NAME
#define MY_NAME "DIV_SPECIAL"

  /* Extraction: DIV
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.0x0,6.0x1a */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#line 2965 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.0x0,6.0x1a */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x0000ffc0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1433 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "div r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 2988 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_DIV_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1447 "./mips.igen"
    do_div (SD_, RS, RT);
  }
#line 3016 "semantics.c"
  return nia;
  /* Extraction: DIV
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.0x0,6.0x1a */

#undef RS
#undef RT
#line 3024 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_DIVU_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_DIVU_SPECIAL
#undef DIVU_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX DIVU_SPECIAL
#undef MY_NAME
#define MY_NAME "DIVU_SPECIAL"

  /* Extraction: DIVU
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.0x0,6.0x1b */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#line 3049 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.0x0,6.0x1b */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x0000ffc0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1474 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "divu r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 3072 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_DIVU_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1488 "./mips.igen"
    do_divu (SD_, RS, RT);
  }
#line 3100 "semantics.c"
  return nia;
  /* Extraction: DIVU
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.0x0,6.0x1b */

#undef RS
#undef RT
#line 3108 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_DMULT_SPECIAL (SIM_DESC sd,
                        instruction_word instruction_0,
                        instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_DMULT_SPECIAL
#undef DMULT_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX DMULT_SPECIAL
#undef MY_NAME
#define MY_NAME "DMULT_SPECIAL"

  /* Extraction: DMULT
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.0x0,6.0x1c */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#line 3133 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.0x0,6.0x1c */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x0000ffc0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1558 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "dmult r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 3156 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_DMULT_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1566 "./mips.igen"
    check_u64 (SD_, instruction_0);
    do_dmult (SD_, RS, RT, 0);
  }
#line 3185 "semantics.c"
  return nia;
  /* Extraction: DMULT
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.0x0,6.0x1c */

#undef RS
#undef RT
#line 3193 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_DMULTU_SPECIAL (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_DMULTU_SPECIAL
#undef DMULTU_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX DMULTU_SPECIAL
#undef MY_NAME
#define MY_NAME "DMULTU_SPECIAL"

  /* Extraction: DMULTU
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.0x0,6.0x1d */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#line 3218 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.0x0,6.0x1d */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x0000ffc0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1587 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "dmultu r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 3241 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_DMULTU_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1595 "./mips.igen"
    check_u64 (SD_, instruction_0);
    do_dmultu (SD_, RS, RT, 0);
  }
#line 3270 "semantics.c"
  return nia;
  /* Extraction: DMULTU
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.0x0,6.0x1d */

#undef RS
#undef RT
#line 3278 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_DDIV_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_DDIV_SPECIAL
#undef DDIV_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX DDIV_SPECIAL
#undef MY_NAME
#define MY_NAME "DDIV_SPECIAL"

  /* Extraction: DDIV
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.0x0,6.0x1e */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#line 3303 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.0x0,6.0x1e */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x0000ffc0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1352 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "ddiv r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 3326 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_DDIV_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1361 "./mips.igen"
    check_u64 (SD_, instruction_0);
    do_ddiv (SD_, RS, RT);
  }
#line 3355 "semantics.c"
  return nia;
  /* Extraction: DDIV
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.0x0,6.0x1e */

#undef RS
#undef RT
#line 3363 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_DDIVU_SPECIAL (SIM_DESC sd,
                        instruction_word instruction_0,
                        instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_DDIVU_SPECIAL
#undef DDIVU_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX DDIVU_SPECIAL
#undef MY_NAME
#define MY_NAME "DDIVU_SPECIAL"

  /* Extraction: DDIVU
       #define do-not-use-icache
       6.0x0,5.RS,5.RT,10.0x0,6.0x1f */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#line 3388 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.RT,10.0x0,6.0x1f */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x0000ffc0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1393 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "ddivu r%ld, r%ld", \
                    (long) RS, \
                    (long) RT);
#line 3411 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_DDIVU_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1402 "./mips.igen"
    check_u64 (SD_, instruction_0);
    do_ddivu (SD_, RS, RT);
  }
#line 3440 "semantics.c"
  return nia;
  /* Extraction: DDIVU
       #undef do-not-use-icache
       6.0x0,5.RS,5.RT,10.0x0,6.0x1f */

#undef RS
#undef RT
#line 3448 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MOVtf_SPECIAL (SIM_DESC sd,
                        instruction_word instruction_0,
                        instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MOVtf_SPECIAL
#undef MOVtf_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX MOVtf_SPECIAL
#undef MY_NAME
#define MY_NAME "MOVtf_SPECIAL"

  /* Extraction: MOVtf
       #define do-not-use-icache
       6.0x0,5.RS,3.CC,1.0x0,1.TF,5.RD,5.0x0,6.0x1 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef CC
#define CC ((unsigned) EXTRACTED32 (instruction_0, 20, 18)) /* cache - extraction */
#undef TF
#define TF ((unsigned) EXTRACTED32 (instruction_0, 16, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 3477 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,3.CC,1.0x0,1.TF,5.RD,5.0x0,6.0x1 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000207c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5045 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mov%s r%ld, r%ld, %ld", \
                    str_TF (SD_, TF), \
                    (long) RD, \
                    (long) RS, \
                    (long) CC);
#line 3516 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MOVtf_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5054 "./mips.igen"
    check_fpu (SD_);
    if (GETFCC(CC) == TF)
      GPR[RD] = GPR[RS];
  }
#line 3546 "semantics.c"
  return nia;
  /* Extraction: MOVtf
       #undef do-not-use-icache
       6.0x0,5.RS,3.CC,1.0x0,1.TF,5.RD,5.0x0,6.0x1 */

#undef RS
#undef CC
#undef TF
#undef RD
#line 3556 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_JALR_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_JALR_SPECIAL
#undef JALR_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX JALR_SPECIAL
#undef MY_NAME
#define MY_NAME "JALR_SPECIAL"

  /* Extraction: JALR
       #define do-not-use-icache
       6.0x0,5.RS,5.0x0,5.RD,5.0x0,6.0x9 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 3581 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,5.0x0,5.RD,5.0x0,6.0x9 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f07c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
      if (RD == 31)
#line 1929 "./mips.igen"
        trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                      itable[MY_INDEX].file, \
                      itable[MY_INDEX].line_nr, \
                      "jalr r%ld", \
                      (long) RS);
#line 3604 "semantics.c"
      else
#line 1930 "./mips.igen"
        trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                      itable[MY_INDEX].file, \
                      itable[MY_INDEX].line_nr, \
                      "jalr r%ld, r%ld", \
                      (long) RD, \
                      (long) RS);
#line 3613 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_JALR_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1944 "./mips.igen"
    address_word temp = GPR[RS];
    GPR[RD] = CIA + 8;
    DELAY_SLOT (temp);
  }
#line 3643 "semantics.c"
  return nia;
  /* Extraction: JALR
       #undef do-not-use-icache
       6.0x0,5.RS,5.0x0,5.RD,5.0x0,6.0x9 */

#undef RS
#undef RD
#line 3651 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_JR_SPECIAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_JR_SPECIAL
#undef JR_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX JR_SPECIAL
#undef MY_NAME
#define MY_NAME "JR_SPECIAL"

  /* Extraction: JR
       #define do-not-use-icache
       6.0x0,5.RS,10.0x0,5.0x0,6.0x8 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#line 3674 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,10.0x0,5.0x0,6.0x8 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001fffc0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1961 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "jr r%ld", \
                    (long) RS);
#line 3696 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_JR_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1975 "./mips.igen"
    DELAY_SLOT (GPR[RS]);
  }
#line 3724 "semantics.c"
  return nia;
  /* Extraction: JR
       #undef do-not-use-icache
       6.0x0,5.RS,10.0x0,5.0x0,6.0x8 */

#undef RS
#line 3731 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MTHI_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MTHI_SPECIAL
#undef MTHI_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX MTHI_SPECIAL
#undef MY_NAME
#define MY_NAME "MTHI_SPECIAL"

  /* Extraction: MTHI
       #define do-not-use-icache
       6.0x0,5.RS,15.0x0,6.0x11 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#line 3754 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,15.0x0,6.0x11 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001fffc0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2715 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mthi r%ld", \
                    (long) RS);
#line 3776 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MTHI_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2727 "./mips.igen"
    check_mt_hilo (SD_, HIHISTORY);
    HI = GPR[RS];
  }
#line 3805 "semantics.c"
  return nia;
  /* Extraction: MTHI
       #undef do-not-use-icache
       6.0x0,5.RS,15.0x0,6.0x11 */

#undef RS
#line 3812 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MTLO_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MTLO_SPECIAL
#undef MTLO_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX MTLO_SPECIAL
#undef MY_NAME
#define MY_NAME "MTLO_SPECIAL"

  /* Extraction: MTLO
       #define do-not-use-icache
       6.0x0,5.RS,15.0x0,6.0x13 */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#line 3835 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.RS,15.0x0,6.0x13 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001fffc0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2746 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mtlo r%ld", \
                    (long) RS);
#line 3857 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MTLO_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2758 "./mips.igen"
    check_mt_hilo (SD_, LOHISTORY);
    LO = GPR[RS];
  }
#line 3886 "semantics.c"
  return nia;
  /* Extraction: MTLO
       #undef do-not-use-icache
       6.0x0,5.RS,15.0x0,6.0x13 */

#undef RS
#line 3893 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SLLa_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SLLa_SPECIAL
#undef SLLa_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SLLa_SPECIAL
#undef MY_NAME
#define MY_NAME "SLLa_SPECIAL"

  /* Extraction: SLLa
       #define do-not-use-icache
       6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x0 */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef SHIFT
#define SHIFT ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#line 3920 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x0 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x03e00000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
      if (RD == 0 && RT == 0 && SHIFT == 0)
#line 3350 "./mips.igen"
        trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                      itable[MY_INDEX].file, \
                      itable[MY_INDEX].line_nr, \
                      "nop");
#line 3942 "semantics.c"
      else
#line 3351 "./mips.igen"
        trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                      itable[MY_INDEX].file, \
                      itable[MY_INDEX].line_nr, \
                      "sll r%ld, r%ld, %ld", \
                      (long) RD, \
                      (long) RT, \
                      (long) SHIFT);
#line 3952 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SLLa_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3361 "./mips.igen"
    /* Skip shift for NOP, so that there won't be lots of extraneous
       trace output.  */
    if (RD != 0 || RT != 0 || SHIFT != 0)
      do_sll (SD_, RT, RD, SHIFT);
  }
#line 3983 "semantics.c"
  return nia;
  /* Extraction: SLLa
       #undef do-not-use-icache
       6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x0 */

#undef RT
#undef RD
#undef SHIFT
#line 3992 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SRL_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SRL_SPECIAL
#undef SRL_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SRL_SPECIAL
#undef MY_NAME
#define MY_NAME "SRL_SPECIAL"

  /* Extraction: SRL
       #define do-not-use-icache
       6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x2 */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef SHIFT
#define SHIFT ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#line 4019 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x2 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x03e00000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3588 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "srl r%ld, r%ld, %ld", \
                    (long) RD, \
                    (long) RT, \
                    (long) SHIFT);
#line 4043 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SRL_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3602 "./mips.igen"
    do_srl (SD_, RT, RD, SHIFT);
  }
#line 4071 "semantics.c"
  return nia;
  /* Extraction: SRL
       #undef do-not-use-icache
       6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x2 */

#undef RT
#undef RD
#undef SHIFT
#line 4080 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SRA_SPECIAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SRA_SPECIAL
#undef SRA_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SRA_SPECIAL
#undef MY_NAME
#define MY_NAME "SRA_SPECIAL"

  /* Extraction: SRA
       #define do-not-use-icache
       6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x3 */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef SHIFT
#define SHIFT ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#line 4107 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x3 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x03e00000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3527 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sra r%ld, r%ld, %ld", \
                    (long) RD, \
                    (long) RT, \
                    (long) SHIFT);
#line 4131 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SRA_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3541 "./mips.igen"
    do_sra (SD_, RT, RD, SHIFT);
  }
#line 4159 "semantics.c"
  return nia;
  /* Extraction: SRA
       #undef do-not-use-icache
       6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x3 */

#undef RT
#undef RD
#undef SHIFT
#line 4168 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_DSLL_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_DSLL_SPECIAL
#undef DSLL_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX DSLL_SPECIAL
#undef MY_NAME
#define MY_NAME "DSLL_SPECIAL"

  /* Extraction: DSLL
       #define do-not-use-icache
       6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x38 */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef SHIFT
#define SHIFT ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#line 4195 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x38 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x03e00000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1659 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "dsll r%ld, r%ld, %ld", \
                    (long) RD, \
                    (long) RT, \
                    (long) SHIFT);
#line 4219 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_DSLL_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1668 "./mips.igen"
    check_u64 (SD_, instruction_0);
    do_dsll (SD_, RT, RD, SHIFT);
  }
#line 4248 "semantics.c"
  return nia;
  /* Extraction: DSLL
       #undef do-not-use-icache
       6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x38 */

#undef RT
#undef RD
#undef SHIFT
#line 4257 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_DSRL_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_DSRL_SPECIAL
#undef DSRL_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX DSRL_SPECIAL
#undef MY_NAME
#define MY_NAME "DSRL_SPECIAL"

  /* Extraction: DSRL
       #define do-not-use-icache
       6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x3a */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef SHIFT
#define SHIFT ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#line 4284 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x3a */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x03e00000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1784 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "dsrl r%ld, r%ld, %ld", \
                    (long) RD, \
                    (long) RT, \
                    (long) SHIFT);
#line 4308 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_DSRL_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1793 "./mips.igen"
    check_u64 (SD_, instruction_0);
    do_dsrl (SD_, RT, RD, SHIFT);
  }
#line 4337 "semantics.c"
  return nia;
  /* Extraction: DSRL
       #undef do-not-use-icache
       6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x3a */

#undef RT
#undef RD
#undef SHIFT
#line 4346 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_DSRA_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_DSRA_SPECIAL
#undef DSRA_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX DSRA_SPECIAL
#undef MY_NAME
#define MY_NAME "DSRA_SPECIAL"

  /* Extraction: DSRA
       #define do-not-use-icache
       6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x3b */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef SHIFT
#define SHIFT ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#line 4373 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x3b */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x03e00000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1721 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "dsra r%ld, r%ld, %ld", \
                    (long) RD, \
                    (long) RT, \
                    (long) SHIFT);
#line 4397 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_DSRA_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1730 "./mips.igen"
    check_u64 (SD_, instruction_0);
    do_dsra (SD_, RT, RD, SHIFT);
  }
#line 4426 "semantics.c"
  return nia;
  /* Extraction: DSRA
       #undef do-not-use-icache
       6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x3b */

#undef RT
#undef RD
#undef SHIFT
#line 4435 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_DSLL32_SPECIAL (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_DSLL32_SPECIAL
#undef DSLL32_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX DSLL32_SPECIAL
#undef MY_NAME
#define MY_NAME "DSLL32_SPECIAL"

  /* Extraction: DSLL32
       #define do-not-use-icache
       6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x3c */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef SHIFT
#define SHIFT ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#line 4462 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x3c */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x03e00000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1674 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "dsll32 r%ld, r%ld, %ld", \
                    (long) RD, \
                    (long) RT, \
                    (long) SHIFT);
#line 4486 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_DSLL32_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1683 "./mips.igen"
    int s = 32 + SHIFT;
    check_u64 (SD_, instruction_0);
    TRACE_ALU_INPUT2 (GPR[RT], s);
    GPR[RD] = GPR[RT] << s;
    TRACE_ALU_RESULT (GPR[RD]);
  }
#line 4518 "semantics.c"
  return nia;
  /* Extraction: DSLL32
       #undef do-not-use-icache
       6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x3c */

#undef RT
#undef RD
#undef SHIFT
#line 4527 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_DSRL32_SPECIAL (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_DSRL32_SPECIAL
#undef DSRL32_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX DSRL32_SPECIAL
#undef MY_NAME
#define MY_NAME "DSRL32_SPECIAL"

  /* Extraction: DSRL32
       #define do-not-use-icache
       6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x3e */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef SHIFT
#define SHIFT ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#line 4554 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x3e */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x03e00000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1799 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "dsrl32 r%ld, r%ld, %ld", \
                    (long) RD, \
                    (long) RT, \
                    (long) SHIFT);
#line 4578 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_DSRL32_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1808 "./mips.igen"
    int s = 32 + SHIFT;
    check_u64 (SD_, instruction_0);
    TRACE_ALU_INPUT2 (GPR[RT], s);
    GPR[RD] = (unsigned64) GPR[RT] >> s;
    TRACE_ALU_RESULT (GPR[RD]);
  }
#line 4610 "semantics.c"
  return nia;
  /* Extraction: DSRL32
       #undef do-not-use-icache
       6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x3e */

#undef RT
#undef RD
#undef SHIFT
#line 4619 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_DSRA32_SPECIAL (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_DSRA32_SPECIAL
#undef DSRA32_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX DSRA32_SPECIAL
#undef MY_NAME
#define MY_NAME "DSRA32_SPECIAL"

  /* Extraction: DSRA32
       #define do-not-use-icache
       6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x3f */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef SHIFT
#define SHIFT ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#line 4646 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x3f */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x03e00000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1736 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "dsra32 r%ld, r%ld, %ld", \
                    (long) RD, \
                    (long) RT, \
                    (long) SHIFT);
#line 4670 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_DSRA32_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1745 "./mips.igen"
    int s = 32 + SHIFT;
    check_u64 (SD_, instruction_0);
    TRACE_ALU_INPUT2 (GPR[RT], s);
    GPR[RD] = ((signed64) GPR[RT]) >> s;
    TRACE_ALU_RESULT (GPR[RD]);
  }
#line 4702 "semantics.c"
  return nia;
  /* Extraction: DSRA32
       #undef do-not-use-icache
       6.0x0,5.0x0,5.RT,5.RD,5.SHIFT,6.0x3f */

#undef RT
#undef RD
#undef SHIFT
#line 4711 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MFHI_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MFHI_SPECIAL
#undef MFHI_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX MFHI_SPECIAL
#undef MY_NAME
#define MY_NAME "MFHI_SPECIAL"

  /* Extraction: MFHI
       #define do-not-use-icache
       6.0x0,10.0x0,5.RD,5.0x0,6.0x10 */

#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 4734 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,10.0x0,5.RD,5.0x0,6.0x10 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x03ff07c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2525 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mfhi r%ld", \
                    (long) RD);
#line 4756 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MFHI_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2537 "./mips.igen"
    do_mfhi (SD_, RD);
  }
#line 4784 "semantics.c"
  return nia;
  /* Extraction: MFHI
       #undef do-not-use-icache
       6.0x0,10.0x0,5.RD,5.0x0,6.0x10 */

#undef RD
#line 4791 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MFLO_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MFLO_SPECIAL
#undef MFLO_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX MFLO_SPECIAL
#undef MY_NAME
#define MY_NAME "MFLO_SPECIAL"

  /* Extraction: MFLO
       #define do-not-use-icache
       6.0x0,10.0x0,5.RD,5.0x0,6.0x12 */

#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 4814 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,10.0x0,5.RD,5.0x0,6.0x12 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x03ff07c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2564 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mflo r%ld", \
                    (long) RD);
#line 4836 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MFLO_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2576 "./mips.igen"
    do_mflo (SD_, RD);
  }
#line 4864 "semantics.c"
  return nia;
  /* Extraction: MFLO
       #undef do-not-use-icache
       6.0x0,10.0x0,5.RD,5.0x0,6.0x12 */

#undef RD
#line 4871 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SYNC_SPECIAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SYNC_SPECIAL
#undef SYNC_SPECIAL
#undef MY_PREFIX
#define MY_PREFIX SYNC_SPECIAL
#undef MY_NAME
#define MY_NAME "SYNC_SPECIAL"

  /* Extraction: SYNC
       #define do-not-use-icache
       6.0x0,15.0x0,5.STYPE,6.0xf */

#undef STYPE
#define STYPE ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#line 4894 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x0,15.0x0,5.STYPE,6.0xf */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x03fff800) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
      if (STYPE == 0)
#line 3768 "./mips.igen"
        trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                      itable[MY_INDEX].file, \
                      itable[MY_INDEX].line_nr, \
                      "sync");
#line 4916 "semantics.c"
      else
#line 3769 "./mips.igen"
        trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                      itable[MY_INDEX].file, \
                      itable[MY_INDEX].line_nr, \
                      "sync %ld", \
                      (long) STYPE);
#line 4924 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SYNC_SPECIAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3782 "./mips.igen"
    SyncOperation (STYPE);
  }
#line 4952 "semantics.c"
  return nia;
  /* Extraction: SYNC
       #undef do-not-use-icache
       6.0x0,15.0x0,5.STYPE,6.0xf */

#undef STYPE
#line 4959 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BLTZ_REGIMM (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BLTZ_REGIMM
#undef BLTZ_REGIMM
#undef MY_PREFIX
#define MY_PREFIX BLTZ_REGIMM
#undef MY_NAME
#define MY_NAME "BLTZ_REGIMM"

  /* Extraction: BLTZ
       #define do-not-use-icache
       6.0x1,5.RS,5.0x0,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 4984 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0x0,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 928 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bltz r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 5002 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BLTZ_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 942 "./mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if ((signed_word) GPR[RS] < 0)
      {
        DELAY_SLOT (NIA + offset);
      }
  }
#line 5034 "semantics.c"
  return nia;
  /* Extraction: BLTZ
       #undef do-not-use-icache
       6.0x1,5.RS,5.0x0,16.OFFSET */

#undef RS
#undef OFFSET
#line 5042 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BGEZ_REGIMM (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BGEZ_REGIMM
#undef BGEZ_REGIMM
#undef MY_PREFIX
#define MY_PREFIX BGEZ_REGIMM
#undef MY_NAME
#define MY_NAME "BGEZ_REGIMM"

  /* Extraction: BGEZ
       #define do-not-use-icache
       6.0x1,5.RS,5.0x1,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 5067 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0x1,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 720 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bgez r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 5085 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BGEZ_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 734 "./mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if ((signed_word) GPR[RS] >= 0)
      {
        DELAY_SLOT (NIA + offset);
      }
  }
#line 5117 "semantics.c"
  return nia;
  /* Extraction: BGEZ
       #undef do-not-use-icache
       6.0x1,5.RS,5.0x1,16.OFFSET */

#undef RS
#undef OFFSET
#line 5125 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BLTZL_REGIMM (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BLTZL_REGIMM
#undef BLTZL_REGIMM
#undef MY_PREFIX
#define MY_PREFIX BLTZL_REGIMM
#undef MY_NAME
#define MY_NAME "BLTZL_REGIMM"

  /* Extraction: BLTZL
       #define do-not-use-icache
       6.0x1,5.RS,5.0x2,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 5150 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0x2,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1009 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bltzl r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 5168 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BLTZL_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1022 "./mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    /* NOTE: The branch occurs AFTER the next instruction has been
       executed */
    if ((signed_word) GPR[RS] < 0)
      {
        DELAY_SLOT (NIA + offset);
      }
    else
      NULLIFY_NEXT_INSTRUCTION ();
  }
#line 5204 "semantics.c"
  return nia;
  /* Extraction: BLTZL
       #undef do-not-use-icache
       6.0x1,5.RS,5.0x2,16.OFFSET */

#undef RS
#undef OFFSET
#line 5212 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BGEZL_REGIMM (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BGEZL_REGIMM
#undef BGEZL_REGIMM
#undef MY_PREFIX
#define MY_PREFIX BGEZL_REGIMM
#undef MY_NAME
#define MY_NAME "BGEZL_REGIMM"

  /* Extraction: BGEZL
       #define do-not-use-icache
       6.0x1,5.RS,5.0x3,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 5237 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0x3,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 801 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bgezl r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 5255 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BGEZL_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 814 "./mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if ((signed_word) GPR[RS] >= 0)
      {
        DELAY_SLOT (NIA + offset);
      }
    else
      NULLIFY_NEXT_INSTRUCTION ();
  }
#line 5289 "semantics.c"
  return nia;
  /* Extraction: BGEZL
       #undef do-not-use-icache
       6.0x1,5.RS,5.0x3,16.OFFSET */

#undef RS
#undef OFFSET
#line 5297 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TGEI_REGIMM (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TGEI_REGIMM
#undef TGEI_REGIMM
#undef MY_PREFIX
#define MY_PREFIX TGEI_REGIMM
#undef MY_NAME
#define MY_NAME "TGEI_REGIMM"

  /* Extraction: TGEI
       #define do-not-use-icache
       6.0x1,5.RS,5.0x8,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 5322 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0x8,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3860 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tgei r%ld, %ld", \
                    (long) RS, \
                    (long) IMMEDIATE);
#line 5340 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TGEI_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3872 "./mips.igen"
    if ((signed_word) GPR[RS] >= (signed_word) EXTEND16 (IMMEDIATE))
      SignalException (Trap, instruction_0);
  }
#line 5369 "semantics.c"
  return nia;
  /* Extraction: TGEI
       #undef do-not-use-icache
       6.0x1,5.RS,5.0x8,16.IMMEDIATE */

#undef RS
#undef IMMEDIATE
#line 5377 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TGEIU_REGIMM (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TGEIU_REGIMM
#undef TGEIU_REGIMM
#undef MY_PREFIX
#define MY_PREFIX TGEIU_REGIMM
#undef MY_NAME
#define MY_NAME "TGEIU_REGIMM"

  /* Extraction: TGEIU
       #define do-not-use-icache
       6.0x1,5.RS,5.0x9,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 5402 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0x9,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3878 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tgeiu r%ld, %ld", \
                    (long) RS, \
                    (long) IMMEDIATE);
#line 5420 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TGEIU_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3890 "./mips.igen"
    if ((unsigned_word) GPR[RS] >= (unsigned_word) EXTEND16 (IMMEDIATE))
      SignalException (Trap, instruction_0);
  }
#line 5449 "semantics.c"
  return nia;
  /* Extraction: TGEIU
       #undef do-not-use-icache
       6.0x1,5.RS,5.0x9,16.IMMEDIATE */

#undef RS
#undef IMMEDIATE
#line 5457 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TLTI_REGIMM (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TLTI_REGIMM
#undef TLTI_REGIMM
#undef MY_PREFIX
#define MY_PREFIX TLTI_REGIMM
#undef MY_NAME
#define MY_NAME "TLTI_REGIMM"

  /* Extraction: TLTI
       #define do-not-use-icache
       6.0x1,5.RS,5.0xa,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 5482 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0xa,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3932 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tlti r%ld, %ld", \
                    (long) RS, \
                    (long) IMMEDIATE);
#line 5500 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TLTI_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3944 "./mips.igen"
    if ((signed_word) GPR[RS] < (signed_word) EXTEND16 (IMMEDIATE))
      SignalException (Trap, instruction_0);
  }
#line 5529 "semantics.c"
  return nia;
  /* Extraction: TLTI
       #undef do-not-use-icache
       6.0x1,5.RS,5.0xa,16.IMMEDIATE */

#undef RS
#undef IMMEDIATE
#line 5537 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TLTIU_REGIMM (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TLTIU_REGIMM
#undef TLTIU_REGIMM
#undef MY_PREFIX
#define MY_PREFIX TLTIU_REGIMM
#undef MY_NAME
#define MY_NAME "TLTIU_REGIMM"

  /* Extraction: TLTIU
       #define do-not-use-icache
       6.0x1,5.RS,5.0xb,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 5562 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0xb,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3950 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tltiu r%ld, %ld", \
                    (long) RS, \
                    (long) IMMEDIATE);
#line 5580 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TLTIU_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3962 "./mips.igen"
    if ((unsigned_word) GPR[RS] < (unsigned_word) EXTEND16 (IMMEDIATE))
      SignalException (Trap, instruction_0);
  }
#line 5609 "semantics.c"
  return nia;
  /* Extraction: TLTIU
       #undef do-not-use-icache
       6.0x1,5.RS,5.0xb,16.IMMEDIATE */

#undef RS
#undef IMMEDIATE
#line 5617 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TEQI_REGIMM (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TEQI_REGIMM
#undef TEQI_REGIMM
#undef MY_PREFIX
#define MY_PREFIX TEQI_REGIMM
#undef MY_NAME
#define MY_NAME "TEQI_REGIMM"

  /* Extraction: TEQI
       #define do-not-use-icache
       6.0x1,5.RS,5.0xc,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 5642 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0xc,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3824 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "teqi r%ld, %ld", \
                    (long) RS, \
                    (long) IMMEDIATE);
#line 5660 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TEQI_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3836 "./mips.igen"
    if ((signed_word) GPR[RS] == (signed_word) EXTEND16 (IMMEDIATE))
      SignalException (Trap, instruction_0);
  }
#line 5689 "semantics.c"
  return nia;
  /* Extraction: TEQI
       #undef do-not-use-icache
       6.0x1,5.RS,5.0xc,16.IMMEDIATE */

#undef RS
#undef IMMEDIATE
#line 5697 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TNEI_REGIMM (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TNEI_REGIMM
#undef TNEI_REGIMM
#undef MY_PREFIX
#define MY_PREFIX TNEI_REGIMM
#undef MY_NAME
#define MY_NAME "TNEI_REGIMM"

  /* Extraction: TNEI
       #define do-not-use-icache
       6.0x1,5.RS,5.0xe,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 5722 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS,5.0xe,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4004 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tnei r%ld, %ld", \
                    (long) RS, \
                    (long) IMMEDIATE);
#line 5740 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TNEI_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4016 "./mips.igen"
    if ((signed_word) GPR[RS] != (signed_word) EXTEND16 (IMMEDIATE))
      SignalException (Trap, instruction_0);
  }
#line 5769 "semantics.c"
  return nia;
  /* Extraction: TNEI
       #undef do-not-use-icache
       6.0x1,5.RS,5.0xe,16.IMMEDIATE */

#undef RS
#undef IMMEDIATE
#line 5777 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BLTZAL_REGIMM (SIM_DESC sd,
                        instruction_word instruction_0,
                        instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BLTZAL_REGIMM
#undef BLTZAL_REGIMM
#undef MY_PREFIX
#define MY_PREFIX BLTZAL_REGIMM
#undef MY_NAME
#define MY_NAME "BLTZAL_REGIMM"

  /* Extraction: BLTZAL
       #define do-not-use-icache
       6.0x1,5.RS!31,5.0x10,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 5802 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS!31,5.0x10,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 952 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bltzal r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 5820 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BLTZAL_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 966 "./mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if (RS == 31)
      Unpredictable ();
    RA = (CIA + 8);
    /* NOTE: The branch occurs AFTER the next instruction has been
       executed */
    if ((signed_word) GPR[RS] < 0)
      {
        DELAY_SLOT (NIA + offset);
      }
  }
#line 5857 "semantics.c"
  return nia;
  /* Extraction: BLTZAL
       #undef do-not-use-icache
       6.0x1,5.RS!31,5.0x10,16.OFFSET */

#undef RS
#undef OFFSET
#line 5865 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BGEZAL_REGIMM (SIM_DESC sd,
                        instruction_word instruction_0,
                        instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BGEZAL_REGIMM
#undef BGEZAL_REGIMM
#undef MY_PREFIX
#define MY_PREFIX BGEZAL_REGIMM
#undef MY_NAME
#define MY_NAME "BGEZAL_REGIMM"

  /* Extraction: BGEZAL
       #define do-not-use-icache
       6.0x1,5.RS!31,5.0x11,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 5890 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS!31,5.0x11,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 744 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bgezal r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 5908 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BGEZAL_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 758 "./mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if (RS == 31)
      Unpredictable ();
    RA = (CIA + 8);
    if ((signed_word) GPR[RS] >= 0)
      {
        DELAY_SLOT (NIA + offset);
      }
  }
#line 5943 "semantics.c"
  return nia;
  /* Extraction: BGEZAL
       #undef do-not-use-icache
       6.0x1,5.RS!31,5.0x11,16.OFFSET */

#undef RS
#undef OFFSET
#line 5951 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BLTZALL_REGIMM (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BLTZALL_REGIMM
#undef BLTZALL_REGIMM
#undef MY_PREFIX
#define MY_PREFIX BLTZALL_REGIMM
#undef MY_NAME
#define MY_NAME "BLTZALL_REGIMM"

  /* Extraction: BLTZALL
       #define do-not-use-icache
       6.0x1,5.RS!31,5.0x12,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 5976 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS!31,5.0x12,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 981 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bltzall r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 5994 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BLTZALL_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 994 "./mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if (RS == 31)
      Unpredictable ();
    RA = (CIA + 8);
    if ((signed_word) GPR[RS] < 0)
      {
        DELAY_SLOT (NIA + offset);
      }
    else
      NULLIFY_NEXT_INSTRUCTION ();
  }
#line 6031 "semantics.c"
  return nia;
  /* Extraction: BLTZALL
       #undef do-not-use-icache
       6.0x1,5.RS!31,5.0x12,16.OFFSET */

#undef RS
#undef OFFSET
#line 6039 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BGEZALL_REGIMM (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BGEZALL_REGIMM
#undef BGEZALL_REGIMM
#undef MY_PREFIX
#define MY_PREFIX BGEZALL_REGIMM
#undef MY_NAME
#define MY_NAME "BGEZALL_REGIMM"

  /* Extraction: BGEZALL
       #define do-not-use-icache
       6.0x1,5.RS!31,5.0x13,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 6064 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1,5.RS!31,5.0x13,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 771 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bgezall r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 6082 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BGEZALL_REGIMM, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 784 "./mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if (RS == 31)
      Unpredictable ();
    RA = (CIA + 8);
    /* NOTE: The branch occurs AFTER the next instruction has been
       executed */
    if ((signed_word) GPR[RS] >= 0)
      {
        DELAY_SLOT (NIA + offset);
      }
    else
      NULLIFY_NEXT_INSTRUCTION ();
  }
#line 6121 "semantics.c"
  return nia;
  /* Extraction: BGEZALL
       #undef do-not-use-icache
       6.0x1,5.RS!31,5.0x13,16.OFFSET */

#undef RS
#undef OFFSET
#line 6129 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_J_NORMAL (SIM_DESC sd,
                   instruction_word instruction_0,
                   instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_J_NORMAL
#undef J_NORMAL
#undef MY_PREFIX
#define MY_PREFIX J_NORMAL
#undef MY_NAME
#define MY_NAME "J_NORMAL"

  /* Extraction: J
       #define do-not-use-icache
       6.0x2,26.INSTR_INDEX */

#undef INSTR_INDEX
#define INSTR_INDEX ((unsigned) MASKED32 (instruction_0, 25, 0)) /* cache - extraction */
#line 6152 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x2,26.INSTR_INDEX */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1885 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "j %ld", \
                    (long) INSTR_INDEX);
#line 6169 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_J_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1899 "./mips.igen"
    /* NOTE: The region used is that of the delay slot NIA and NOT the
       current instruction */
    address_word region = (NIA & MASK (63, 28));
    DELAY_SLOT (region | (INSTR_INDEX << 2));
  }
#line 6200 "semantics.c"
  return nia;
  /* Extraction: J
       #undef do-not-use-icache
       6.0x2,26.INSTR_INDEX */

#undef INSTR_INDEX
#line 6207 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_JAL_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_JAL_NORMAL
#undef JAL_NORMAL
#undef MY_PREFIX
#define MY_PREFIX JAL_NORMAL
#undef MY_NAME
#define MY_NAME "JAL_NORMAL"

  /* Extraction: JAL
       #define do-not-use-icache
       6.0x3,26.INSTR_INDEX */

#undef INSTR_INDEX
#define INSTR_INDEX ((unsigned) MASKED32 (instruction_0, 25, 0)) /* cache - extraction */
#line 6230 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x3,26.INSTR_INDEX */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1907 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "jal %ld", \
                    (long) INSTR_INDEX);
#line 6247 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_JAL_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1921 "./mips.igen"
    /* NOTE: The region used is that of the delay slot and NOT the
       current instruction */
    address_word region = (NIA & MASK (63, 28));
    GPR[31] = CIA + 8;
    DELAY_SLOT (region | (INSTR_INDEX << 2));
  }
#line 6279 "semantics.c"
  return nia;
  /* Extraction: JAL
       #undef do-not-use-icache
       6.0x3,26.INSTR_INDEX */

#undef INSTR_INDEX
#line 6286 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BEQ_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BEQ_NORMAL
#undef BEQ_NORMAL
#undef MY_PREFIX
#define MY_PREFIX BEQ_NORMAL
#undef MY_NAME
#define MY_NAME "BEQ_NORMAL"

  /* Extraction: BEQ
       #define do-not-use-icache
       6.0x4,5.RS,5.RT,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 6313 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x4,5.RS,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 671 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "beq r%ld, r%ld, %ld", \
                    (long) RS, \
                    (long) RT, \
                    (long) OFFSET);
#line 6332 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BEQ_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 685 "./mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if ((signed_word) GPR[RS] == (signed_word) GPR[RT])
      {
        DELAY_SLOT (NIA + offset);
      }
  }
#line 6364 "semantics.c"
  return nia;
  /* Extraction: BEQ
       #undef do-not-use-icache
       6.0x4,5.RS,5.RT,16.OFFSET */

#undef RS
#undef RT
#undef OFFSET
#line 6373 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BNE_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BNE_NORMAL
#undef BNE_NORMAL
#undef MY_PREFIX
#define MY_PREFIX BNE_NORMAL
#undef MY_NAME
#define MY_NAME "BNE_NORMAL"

  /* Extraction: BNE
       #define do-not-use-icache
       6.0x5,5.RS,5.RT,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 6400 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x5,5.RS,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1036 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bne r%ld, r%ld, %ld", \
                    (long) RS, \
                    (long) RT, \
                    (long) OFFSET);
#line 6419 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BNE_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1050 "./mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if ((signed_word) GPR[RS] != (signed_word) GPR[RT])
      {
        DELAY_SLOT (NIA + offset);
      }
  }
#line 6451 "semantics.c"
  return nia;
  /* Extraction: BNE
       #undef do-not-use-icache
       6.0x5,5.RS,5.RT,16.OFFSET */

#undef RS
#undef RT
#undef OFFSET
#line 6460 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BLEZ_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BLEZ_NORMAL
#undef BLEZ_NORMAL
#undef MY_PREFIX
#define MY_PREFIX BLEZ_NORMAL
#undef MY_NAME
#define MY_NAME "BLEZ_NORMAL"

  /* Extraction: BLEZ
       #define do-not-use-icache
       6.0x6,5.RS,5.0x0,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 6485 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x6,5.RS,5.0x0,16.OFFSET */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 877 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "blez r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 6508 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BLEZ_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 891 "./mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    /* NOTE: The branch occurs AFTER the next instruction has been
       executed */
    if ((signed_word) GPR[RS] <= 0)
      {
        DELAY_SLOT (NIA + offset);
      }
  }
#line 6542 "semantics.c"
  return nia;
  /* Extraction: BLEZ
       #undef do-not-use-icache
       6.0x6,5.RS,5.0x0,16.OFFSET */

#undef RS
#undef OFFSET
#line 6550 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BGTZ_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BGTZ_NORMAL
#undef BGTZ_NORMAL
#undef MY_PREFIX
#define MY_PREFIX BGTZ_NORMAL
#undef MY_NAME
#define MY_NAME "BGTZ_NORMAL"

  /* Extraction: BGTZ
       #define do-not-use-icache
       6.0x7,5.RS,5.0x0,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 6575 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x7,5.RS,5.0x0,16.OFFSET */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 826 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bgtz r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 6598 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BGTZ_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 840 "./mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if ((signed_word) GPR[RS] > 0)
      {
        DELAY_SLOT (NIA + offset);
      }
  }
#line 6630 "semantics.c"
  return nia;
  /* Extraction: BGTZ
       #undef do-not-use-icache
       6.0x7,5.RS,5.0x0,16.OFFSET */

#undef RS
#undef OFFSET
#line 6638 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ADDI_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ADDI_NORMAL
#undef ADDI_NORMAL
#undef MY_PREFIX
#define MY_PREFIX ADDI_NORMAL
#undef MY_NAME
#define MY_NAME "ADDI_NORMAL"

  /* Extraction: ADDI
       #define do-not-use-icache
       6.0x8,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 6665 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x8,5.RS,5.RT,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 536 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "addi r%ld, r%ld, %ld", \
                    (long) RT, \
                    (long) RS, \
                    (long) IMMEDIATE);
#line 6684 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ADDI_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 550 "./mips.igen"
    if (NotWordValue (GPR[RS]))
      Unpredictable ();
    TRACE_ALU_INPUT2 (GPR[RS], EXTEND16 (IMMEDIATE));
    {
      ALU32_BEGIN (GPR[RS]);
      ALU32_ADD (EXTEND16 (IMMEDIATE));
      ALU32_END (GPR[RT]);   /* This checks for overflow.  */
    }
    TRACE_ALU_RESULT (GPR[RT]);
  }
#line 6720 "semantics.c"
  return nia;
  /* Extraction: ADDI
       #undef do-not-use-icache
       6.0x8,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#undef RT
#undef IMMEDIATE
#line 6729 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ADDIU_NORMAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ADDIU_NORMAL
#undef ADDIU_NORMAL
#undef MY_PREFIX
#define MY_PREFIX ADDIU_NORMAL
#undef MY_NAME
#define MY_NAME "ADDIU_NORMAL"

  /* Extraction: ADDIU
       #define do-not-use-icache
       6.0x9,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 6756 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x9,5.RS,5.RT,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 573 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "addiu r%ld, r%ld, %ld", \
                    (long) RT, \
                    (long) RS, \
                    (long) IMMEDIATE);
#line 6775 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ADDIU_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 587 "./mips.igen"
    do_addiu (SD_, RS, RT, IMMEDIATE);
  }
#line 6803 "semantics.c"
  return nia;
  /* Extraction: ADDIU
       #undef do-not-use-icache
       6.0x9,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#undef RT
#undef IMMEDIATE
#line 6812 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SLTI_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SLTI_NORMAL
#undef SLTI_NORMAL
#undef MY_PREFIX
#define MY_PREFIX SLTI_NORMAL
#undef MY_NAME
#define MY_NAME "SLTI_NORMAL"

  /* Extraction: SLTI
       #define do-not-use-icache
       6.0xa,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 6839 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0xa,5.RS,5.RT,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3445 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "slti r%ld, r%ld, %ld", \
                    (long) RT, \
                    (long) RS, \
                    (long) IMMEDIATE);
#line 6858 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SLTI_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3459 "./mips.igen"
    do_slti (SD_, RS, RT, IMMEDIATE);
  }
#line 6886 "semantics.c"
  return nia;
  /* Extraction: SLTI
       #undef do-not-use-icache
       6.0xa,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#undef RT
#undef IMMEDIATE
#line 6895 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SLTIU_NORMAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SLTIU_NORMAL
#undef SLTIU_NORMAL
#undef MY_PREFIX
#define MY_PREFIX SLTIU_NORMAL
#undef MY_NAME
#define MY_NAME "SLTIU_NORMAL"

  /* Extraction: SLTIU
       #define do-not-use-icache
       6.0xb,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 6922 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0xb,5.RS,5.RT,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3471 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sltiu r%ld, r%ld, %ld", \
                    (long) RT, \
                    (long) RS, \
                    (long) IMMEDIATE);
#line 6941 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SLTIU_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3485 "./mips.igen"
    do_sltiu (SD_, RS, RT, IMMEDIATE);
  }
#line 6969 "semantics.c"
  return nia;
  /* Extraction: SLTIU
       #undef do-not-use-icache
       6.0xb,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#undef RT
#undef IMMEDIATE
#line 6978 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ANDI_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ANDI_NORMAL
#undef ANDI_NORMAL
#undef MY_PREFIX
#define MY_PREFIX ANDI_NORMAL
#undef MY_NAME
#define MY_NAME "ANDI_NORMAL"

  /* Extraction: ANDI
       #define do-not-use-icache
       6.0xc,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 7005 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0xc,5.RS,5.RT,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 649 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "andi r%ld, r%ld, %#lx", \
                    (long) RT, \
                    (long) RS, \
                    (unsigned long) IMMEDIATE);
#line 7024 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ANDI_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 663 "./mips.igen"
    TRACE_ALU_INPUT2 (GPR[RS], IMMEDIATE);
    GPR[RT] = GPR[RS] & IMMEDIATE;
    TRACE_ALU_RESULT (GPR[RT]);
  }
#line 7054 "semantics.c"
  return nia;
  /* Extraction: ANDI
       #undef do-not-use-icache
       6.0xc,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#undef RT
#undef IMMEDIATE
#line 7063 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ORI_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ORI_NORMAL
#undef ORI_NORMAL
#undef MY_PREFIX
#define MY_PREFIX ORI_NORMAL
#undef MY_NAME
#define MY_NAME "ORI_NORMAL"

  /* Extraction: ORI
       #define do-not-use-icache
       6.0xd,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 7090 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0xd,5.RS,5.RT,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2987 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "ori r%ld, r%ld, %#lx", \
                    (long) RT, \
                    (long) RS, \
                    (unsigned long) IMMEDIATE);
#line 7109 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ORI_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3001 "./mips.igen"
    do_ori (SD_, RS, RT, IMMEDIATE);
  }
#line 7137 "semantics.c"
  return nia;
  /* Extraction: ORI
       #undef do-not-use-icache
       6.0xd,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#undef RT
#undef IMMEDIATE
#line 7146 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_XORI_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_XORI_NORMAL
#undef XORI_NORMAL
#undef MY_PREFIX
#define MY_PREFIX XORI_NORMAL
#undef MY_NAME
#define MY_NAME "XORI_NORMAL"

  /* Extraction: XORI
       #define do-not-use-icache
       6.0xe,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 7173 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0xe,5.RS,5.RT,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4055 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "xori r%ld, r%ld, %#lx", \
                    (long) RT, \
                    (long) RS, \
                    (unsigned long) IMMEDIATE);
#line 7192 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_XORI_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4069 "./mips.igen"
    do_xori (SD_, RS, RT, IMMEDIATE);
  }
#line 7220 "semantics.c"
  return nia;
  /* Extraction: XORI
       #undef do-not-use-icache
       6.0xe,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#undef RT
#undef IMMEDIATE
#line 7229 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LUI_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LUI_NORMAL
#undef LUI_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LUI_NORMAL
#undef MY_NAME
#define MY_NAME "LUI_NORMAL"

  /* Extraction: LUI
       #define do-not-use-icache
       6.0xf,5.0x0,5.RT,16.IMMEDIATE */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 7254 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0xf,5.0x0,5.RT,16.IMMEDIATE */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x03e00000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2319 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lui r%ld, %#lx", \
                    (long) RT, \
                    (unsigned long) IMMEDIATE);
#line 7277 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LUI_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2333 "./mips.igen"
    TRACE_ALU_INPUT1 (IMMEDIATE);
    GPR[RT] = EXTEND32 (IMMEDIATE << 16);
    TRACE_ALU_RESULT (GPR[RT]);
  }
#line 7307 "semantics.c"
  return nia;
  /* Extraction: LUI
       #undef do-not-use-icache
       6.0xf,5.0x0,5.RT,16.IMMEDIATE */

#undef RT
#undef IMMEDIATE
#line 7315 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_COPz_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_COPz_NORMAL
#undef COPz_NORMAL
#undef MY_PREFIX
#define MY_PREFIX COPz_NORMAL
#undef MY_NAME
#define MY_NAME "COPz_NORMAL"

  /* Extraction: COPz
       #define do-not-use-icache
       4.0x4,2.ZZ!0!1!3,5.COP_FUN0!8,5.COP_FUN1,16.COP_FUN2 */

#undef ZZ
#define ZZ ((unsigned) EXTRACTED32 (instruction_0, 27, 26)) /* cache - extraction */
#undef COP_FUN0
#define COP_FUN0 ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef COP_FUN1
#define COP_FUN1 ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef COP_FUN2
#define COP_FUN2 ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 7344 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 4.0x4,2.ZZ!0!1!3,5.COP_FUN0!8,5.COP_FUN1,16.COP_FUN2 */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5879 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "cop%ld %ld%ld%ld", \
                    (long) ZZ, \
                    (long) COP_FUN0, \
                    (long) COP_FUN1, \
                    (long) COP_FUN2);
#line 7364 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_COPz_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5892 "./mips.igen"
    DecodeCoproc (instruction_0);
  }
#line 7392 "semantics.c"
  return nia;
  /* Extraction: COPz
       #undef do-not-use-icache
       4.0x4,2.ZZ!0!1!3,5.COP_FUN0!8,5.COP_FUN1,16.COP_FUN2 */

#undef ZZ
#undef COP_FUN0
#undef COP_FUN1
#undef COP_FUN2
#line 7402 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MFC0_COP0 (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MFC0_COP0
#undef MFC0_COP0
#undef MY_PREFIX
#define MY_PREFIX MFC0_COP0
#undef MY_NAME
#define MY_NAME "MFC0_COP0"

  /* Extraction: MFC0
       #define do-not-use-icache
       6.0x10,5.0x0,5.RT,5.RD,5.0x0,6.REGX */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef REGX
#define REGX ((unsigned) MASKED32 (instruction_0, 5, 0)) /* cache - extraction */
#line 7429 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,5.0x0,5.RT,5.RD,5.0x0,6.REGX */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x026007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5825 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mfc0 r%ld, r%ld # %ld", \
                    (long) RT, \
                    (long) RD, \
                    (long) REGX);
#line 7453 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MFC0_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5839 "./mips.igen"
    TRACE_ALU_INPUT0 ();
    DecodeCoproc (instruction_0);
    TRACE_ALU_RESULT (GPR[RT]);
  }
#line 7483 "semantics.c"
  return nia;
  /* Extraction: MFC0
       #undef do-not-use-icache
       6.0x10,5.0x0,5.RT,5.RD,5.0x0,6.REGX */

#undef RT
#undef RD
#undef REGX
#line 7492 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_DMFC0_COP0 (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_DMFC0_COP0
#undef DMFC0_COP0
#undef MY_PREFIX
#define MY_PREFIX DMFC0_COP0
#undef MY_NAME
#define MY_NAME "DMFC0_COP0"

  /* Extraction: DMFC0
       #define do-not-use-icache
       6.0x10,5.0x1,5.RT,5.RD,11.0x0 */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 7517 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,5.0x1,5.RT,5.RD,11.0x0 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x020007e0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5772 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "dmfc0 r%ld, r%ld", \
                    (long) RT, \
                    (long) RD);
#line 7540 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_DMFC0_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5779 "./mips.igen"
    check_u64 (SD_, instruction_0);
    DecodeCoproc (instruction_0);
  }
#line 7569 "semantics.c"
  return nia;
  /* Extraction: DMFC0
       #undef do-not-use-icache
       6.0x10,5.0x1,5.RT,5.RD,11.0x0 */

#undef RT
#undef RD
#line 7577 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MTC0_COP0 (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MTC0_COP0
#undef MTC0_COP0
#undef MY_PREFIX
#define MY_PREFIX MTC0_COP0
#undef MY_NAME
#define MY_NAME "MTC0_COP0"

  /* Extraction: MTC0
       #define do-not-use-icache
       6.0x10,5.0x4,5.RT,5.RD,5.0x0,6.REGX */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef REGX
#define REGX ((unsigned) MASKED32 (instruction_0, 5, 0)) /* cache - extraction */
#line 7604 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,5.0x4,5.RT,5.RD,5.0x0,6.REGX */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x026007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5845 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mtc0 r%ld, r%ld # %ld", \
                    (long) RT, \
                    (long) RD, \
                    (long) REGX);
#line 7628 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MTC0_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5859 "./mips.igen"
    DecodeCoproc (instruction_0);
  }
#line 7656 "semantics.c"
  return nia;
  /* Extraction: MTC0
       #undef do-not-use-icache
       6.0x10,5.0x4,5.RT,5.RD,5.0x0,6.REGX */

#undef RT
#undef RD
#undef REGX
#line 7665 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_DMTC0_COP0 (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_DMTC0_COP0
#undef DMTC0_COP0
#undef MY_PREFIX
#define MY_PREFIX DMTC0_COP0
#undef MY_NAME
#define MY_NAME "DMTC0_COP0"

  /* Extraction: DMTC0
       #define do-not-use-icache
       6.0x10,5.0x5,5.RT,5.RD,11.0x0 */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef RD
#define RD ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 7690 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,5.0x5,5.RT,5.RD,11.0x0 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x020007e0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5785 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "dmtc0 r%ld, r%ld", \
                    (long) RT, \
                    (long) RD);
#line 7713 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_DMTC0_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5792 "./mips.igen"
    check_u64 (SD_, instruction_0);
    DecodeCoproc (instruction_0);
  }
#line 7742 "semantics.c"
  return nia;
  /* Extraction: DMTC0
       #undef do-not-use-icache
       6.0x10,5.0x5,5.RT,5.RD,11.0x0 */

#undef RT
#undef RD
#line 7750 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BC0F_COP0 (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BC0F_COP0
#undef BC0F_COP0
#undef MY_PREFIX
#define MY_PREFIX BC0F_COP0
#undef MY_NAME
#define MY_NAME "BC0F_COP0"

  /* Extraction: BC0F
       #define do-not-use-icache
       6.0x10,5.0x8,5.0x0,16.OFFSET */

#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 7773 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,5.0x8,5.0x0,16.OFFSET */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x027c0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5680 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bc0f %ld", \
                    (long) OFFSET);
#line 7795 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BC0F_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
#line 5679 "./mips.igen"
  sim_engine_abort (SD, CPU, cia, \
                    "mips.igen:5679:0x%08lx:%s unimplemented\n", \
                    (long) CIA, \
                    itable[MY_INDEX].name);
#line 7824 "semantics.c"
  return nia;
  /* Extraction: BC0F
       #undef do-not-use-icache
       6.0x10,5.0x8,5.0x0,16.OFFSET */

#undef OFFSET
#line 7831 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BC0T_COP0 (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BC0T_COP0
#undef BC0T_COP0
#undef MY_PREFIX
#define MY_PREFIX BC0T_COP0
#undef MY_NAME
#define MY_NAME "BC0T_COP0"

  /* Extraction: BC0T
       #define do-not-use-icache
       6.0x10,5.0x8,5.0x1,16.OFFSET */

#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 7854 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,5.0x8,5.0x1,16.OFFSET */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x027c0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5718 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bc0t %ld", \
                    (long) OFFSET);
#line 7876 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BC0T_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
#line 5717 "./mips.igen"
  sim_engine_abort (SD, CPU, cia, \
                    "mips.igen:5717:0x%08lx:%s unimplemented\n", \
                    (long) CIA, \
                    itable[MY_INDEX].name);
#line 7905 "semantics.c"
  return nia;
  /* Extraction: BC0T
       #undef do-not-use-icache
       6.0x10,5.0x8,5.0x1,16.OFFSET */

#undef OFFSET
#line 7912 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BC0FL_COP0 (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BC0FL_COP0
#undef BC0FL_COP0
#undef MY_PREFIX
#define MY_PREFIX BC0FL_COP0
#undef MY_NAME
#define MY_NAME "BC0FL_COP0"

  /* Extraction: BC0FL
       #define do-not-use-icache
       6.0x10,5.0x8,5.0x2,16.OFFSET */

#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 7935 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,5.0x8,5.0x2,16.OFFSET */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x027c0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5703 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bc0fl %ld", \
                    (long) OFFSET);
#line 7957 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BC0FL_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
#line 5702 "./mips.igen"
  sim_engine_abort (SD, CPU, cia, \
                    "mips.igen:5702:0x%08lx:%s unimplemented\n", \
                    (long) CIA, \
                    itable[MY_INDEX].name);
#line 7986 "semantics.c"
  return nia;
  /* Extraction: BC0FL
       #undef do-not-use-icache
       6.0x10,5.0x8,5.0x2,16.OFFSET */

#undef OFFSET
#line 7993 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BC0TL_COP0 (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BC0TL_COP0
#undef BC0TL_COP0
#undef MY_PREFIX
#define MY_PREFIX BC0TL_COP0
#undef MY_NAME
#define MY_NAME "BC0TL_COP0"

  /* Extraction: BC0TL
       #define do-not-use-icache
       6.0x10,5.0x8,5.0x3,16.OFFSET */

#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 8016 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,5.0x8,5.0x3,16.OFFSET */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x027c0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5732 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bc0tl %ld", \
                    (long) OFFSET);
#line 8038 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BC0TL_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
#line 5731 "./mips.igen"
  sim_engine_abort (SD, CPU, cia, \
                    "mips.igen:5731:0x%08lx:%s unimplemented\n", \
                    (long) CIA, \
                    itable[MY_INDEX].name);
#line 8067 "semantics.c"
  return nia;
  /* Extraction: BC0TL
       #undef do-not-use-icache
       6.0x10,5.0x8,5.0x3,16.OFFSET */

#undef OFFSET
#line 8074 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TLBR_COP0 (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TLBR_COP0
#undef TLBR_COP0
#undef MY_PREFIX
#define MY_PREFIX TLBR_COP0
#undef MY_NAME
#define MY_NAME "TLBR_COP0"

  /* Extraction: TLBR
       #define do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x1 */

#line 8095 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,1.0x1,19.0x0,6.0x1 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x007cffe0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5913 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tlbr");
#line 8116 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TLBR_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
#line 5912 "./mips.igen"
  sim_engine_abort (SD, CPU, cia, \
                    "mips.igen:5912:0x%08lx:%s unimplemented\n", \
                    (long) CIA, \
                    itable[MY_INDEX].name);
#line 8145 "semantics.c"
  return nia;
  /* Extraction: TLBR
       #undef do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x1 */

#line 8151 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TLBWI_COP0 (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TLBWI_COP0
#undef TLBWI_COP0
#undef MY_PREFIX
#define MY_PREFIX TLBWI_COP0
#undef MY_NAME
#define MY_NAME "TLBWI_COP0"

  /* Extraction: TLBWI
       #define do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x2 */

#line 8172 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,1.0x1,19.0x0,6.0x2 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x007cffe0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5928 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tlbwi");
#line 8193 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TLBWI_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
#line 5927 "./mips.igen"
  sim_engine_abort (SD, CPU, cia, \
                    "mips.igen:5927:0x%08lx:%s unimplemented\n", \
                    (long) CIA, \
                    itable[MY_INDEX].name);
#line 8222 "semantics.c"
  return nia;
  /* Extraction: TLBWI
       #undef do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x2 */

#line 8228 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TLBWR_COP0 (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TLBWR_COP0
#undef TLBWR_COP0
#undef MY_PREFIX
#define MY_PREFIX TLBWR_COP0
#undef MY_NAME
#define MY_NAME "TLBWR_COP0"

  /* Extraction: TLBWR
       #define do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x6 */

#line 8249 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,1.0x1,19.0x0,6.0x6 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x007cffe0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5943 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tlbwr");
#line 8270 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TLBWR_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
#line 5942 "./mips.igen"
  sim_engine_abort (SD, CPU, cia, \
                    "mips.igen:5942:0x%08lx:%s unimplemented\n", \
                    (long) CIA, \
                    itable[MY_INDEX].name);
#line 8299 "semantics.c"
  return nia;
  /* Extraction: TLBWR
       #undef do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x6 */

#line 8305 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TLBP_COP0 (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TLBP_COP0
#undef TLBP_COP0
#undef MY_PREFIX
#define MY_PREFIX TLBP_COP0
#undef MY_NAME
#define MY_NAME "TLBP_COP0"

  /* Extraction: TLBP
       #define do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x8 */

#line 8326 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,1.0x1,19.0x0,6.0x8 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x007cffe0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5898 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "tlbp");
#line 8347 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TLBP_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
#line 5897 "./mips.igen"
  sim_engine_abort (SD, CPU, cia, \
                    "mips.igen:5897:0x%08lx:%s unimplemented\n", \
                    (long) CIA, \
                    itable[MY_INDEX].name);
#line 8376 "semantics.c"
  return nia;
  /* Extraction: TLBP
       #undef do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x8 */

#line 8382 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_RFE_COP0 (SIM_DESC sd,
                   instruction_word instruction_0,
                   instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_RFE_COP0
#undef RFE_COP0
#undef MY_PREFIX
#define MY_PREFIX RFE_COP0
#undef MY_NAME
#define MY_NAME "RFE_COP0"

  /* Extraction: RFE
       #define do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x10 */

#line 8403 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,1.0x1,19.0x0,6.0x10 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x007cffe0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5864 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "rfe");
#line 8424 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_RFE_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5874 "./mips.igen"
    DecodeCoproc (instruction_0);
  }
#line 8452 "semantics.c"
  return nia;
  /* Extraction: RFE
       #undef do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x10 */

#line 8458 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ERET_COP0 (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ERET_COP0
#undef ERET_COP0
#undef MY_PREFIX
#define MY_PREFIX ERET_COP0
#undef MY_NAME
#define MY_NAME "ERET_COP0"

  /* Extraction: ERET
       #define do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x18 */

#line 8479 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x10,1.0x1,19.0x0,6.0x18 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x007cffe0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5798 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "eret");
#line 8500 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ERET_COP0, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5809 "./mips.igen"
    if (SR & status_ERL)
      {
        /* Oops, not yet available */
        sim_io_printf (SD, "Warning: ERET when SR[ERL] set not supported");
        NIA = EPC;
        SR &= ~status_ERL;
      }
    else
      {
        NIA = EPC;
        SR &= ~status_EXL;
      }
  }
#line 8539 "semantics.c"
  return nia;
  /* Extraction: ERET
       #undef do-not-use-icache
       6.0x10,1.0x1,19.0x0,6.0x18 */

#line 8545 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MFC1b_COP1 (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MFC1b_COP1
#undef MFC1b_COP1
#undef MY_PREFIX
#define MY_PREFIX MFC1b_COP1
#undef MY_NAME
#define MY_NAME "MFC1b_COP1"

  /* Extraction: MFC1b
       #define do-not-use-icache
       6.0x11,5.0x0,5.RT,5.FS,11.0x0 */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 8572 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,5.0x0,5.RT,5.FS,11.0x0 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5003 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mfc1 r%ld, f%ld", \
                    (long) RT, \
                    (long) FS);
#line 8609 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MFC1b_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5014 "./mips.igen"
    check_fpu (SD_);
    GPR[RT] = EXTEND32 (FGR[FS]);
    TRACE_ALU_RESULT (GPR[RT]);
  }
#line 8639 "semantics.c"
  return nia;
  /* Extraction: MFC1b
       #undef do-not-use-icache
       6.0x11,5.0x0,5.RT,5.FS,11.0x0 */

#undef RT
#undef FS
#undef SFRAME
#line 8648 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_DMFC1b_COP1 (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_DMFC1b_COP1
#undef DMFC1b_COP1
#undef MY_PREFIX
#define MY_PREFIX DMFC1b_COP1
#undef MY_NAME
#define MY_NAME "DMFC1b_COP1"

  /* Extraction: DMFC1b
       #define do-not-use-icache
       6.0x11,5.0x1,5.RT,5.FS,11.0x0 */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 8675 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,5.0x1,5.RT,5.FS,11.0x0 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4747 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "dmfc1 r%ld, f%ld", \
                    (long) RT, \
                    (long) FS);
#line 8712 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_DMFC1b_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4756 "./mips.igen"
    check_fpu (SD_);
    check_u64 (SD_, instruction_0);
    if (SizeFGR () == 64)
      GPR[RT] = FGR[FS];
    else if ((FS & 0x1) == 0)
      GPR[RT] = SET64HI (FGR[FS+1]) | FGR[FS];
    else
      GPR[RT] = SET64HI (0xDEADC0DE) | 0xBAD0BAD0;
    TRACE_ALU_RESULT (GPR[RT]);
  }
#line 8748 "semantics.c"
  return nia;
  /* Extraction: DMFC1b
       #undef do-not-use-icache
       6.0x11,5.0x1,5.RT,5.FS,11.0x0 */

#undef RT
#undef FS
#undef SFRAME
#line 8757 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_CFC1b_COP1 (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_CFC1b_COP1
#undef CFC1b_COP1
#undef MY_PREFIX
#define MY_PREFIX CFC1b_COP1
#undef MY_NAME
#define MY_NAME "CFC1b_COP1"

  /* Extraction: CFC1b
       #define do-not-use-icache
       6.0x11,5.0x2,5.RT,5.FS,11.0x0 */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 8784 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,5.0x2,5.RT,5.FS,11.0x0 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4491 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "cfc1 r%ld, f%ld", \
                    (long) RT, \
                    (long) FS);
#line 8821 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_CFC1b_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4497 "./mips.igen"
    check_fpu (SD_);
    if (FS == 0 || FS == 31)
      {
        unsigned_word  fcr = ValueFCR (FS);
        TRACE_ALU_INPUT1 (fcr);
        GPR[RT] = fcr;
      }
    /* else NOP */
    TRACE_ALU_RESULT (GPR[RT]);
  }
#line 8857 "semantics.c"
  return nia;
  /* Extraction: CFC1b
       #undef do-not-use-icache
       6.0x11,5.0x2,5.RT,5.FS,11.0x0 */

#undef RT
#undef FS
#undef SFRAME
#line 8866 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MTC1b_COP1 (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MTC1b_COP1
#undef MTC1b_COP1
#undef MY_PREFIX
#define MY_PREFIX MTC1b_COP1
#undef MY_NAME
#define MY_NAME "MTC1b_COP1"

  /* Extraction: MTC1b
       #define do-not-use-icache
       6.0x11,5.0x4,5.RT,5.FS,11.0x0 */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 8893 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,5.0x4,5.RT,5.FS,11.0x0 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5169 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mtc1 r%ld, f%ld", \
                    (long) RT, \
                    (long) FS);
#line 8930 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MTC1b_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5180 "./mips.igen"
    check_fpu (SD_); 
    StoreFPR (FS, fmt_uninterpreted_32, VL4_8 (GPR[RT]));
  }
#line 8959 "semantics.c"
  return nia;
  /* Extraction: MTC1b
       #undef do-not-use-icache
       6.0x11,5.0x4,5.RT,5.FS,11.0x0 */

#undef RT
#undef FS
#undef SFRAME
#line 8968 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_DMTC1b_COP1 (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_DMTC1b_COP1
#undef DMTC1b_COP1
#undef MY_PREFIX
#define MY_PREFIX DMTC1b_COP1
#undef MY_NAME
#define MY_NAME "DMTC1b_COP1"

  /* Extraction: DMTC1b
       #define do-not-use-icache
       6.0x11,5.0x5,5.RT,5.FS,11.0x0 */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 8995 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,5.0x5,5.RT,5.FS,11.0x0 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4788 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "dmtc1 r%ld, f%ld", \
                    (long) RT, \
                    (long) FS);
#line 9032 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_DMTC1b_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4797 "./mips.igen"
    check_fpu (SD_);
    check_u64 (SD_, instruction_0);
    if (SizeFGR () == 64)
      StoreFPR (FS, fmt_uninterpreted_64, GPR[RT]);
    else if ((FS & 0x1) == 0)
      StoreFPR (FS, fmt_uninterpreted_64, GPR[RT]);
    else
      Unpredictable ();
  }
#line 9067 "semantics.c"
  return nia;
  /* Extraction: DMTC1b
       #undef do-not-use-icache
       6.0x11,5.0x5,5.RT,5.FS,11.0x0 */

#undef RT
#undef FS
#undef SFRAME
#line 9076 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_CTC1b_COP1 (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_CTC1b_COP1
#undef CTC1b_COP1
#undef MY_PREFIX
#define MY_PREFIX CTC1b_COP1
#undef MY_NAME
#define MY_NAME "CTC1b_COP1"

  /* Extraction: CTC1b
       #define do-not-use-icache
       6.0x11,5.0x6,5.RT,5.FS,11.0x0 */

#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 9103 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,5.0x6,5.RT,5.FS,11.0x0 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4540 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "ctc1 r%ld, f%ld", \
                    (long) RT, \
                    (long) FS);
#line 9140 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_CTC1b_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4546 "./mips.igen"
    check_fpu (SD_);
    TRACE_ALU_INPUT1 (GPR[RT]);
    if (FS == 31)
      StoreFCR (FS, GPR[RT]);
    /* else NOP */
  }
#line 9172 "semantics.c"
  return nia;
  /* Extraction: CTC1b
       #undef do-not-use-icache
       6.0x11,5.0x6,5.RT,5.FS,11.0x0 */

#undef RT
#undef FS
#undef SFRAME
#line 9181 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BC1b_COP1S (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BC1b_COP1S
#undef BC1b_COP1S
#undef MY_PREFIX
#define MY_PREFIX BC1b_COP1S
#undef MY_NAME
#define MY_NAME "BC1b_COP1S"

  /* Extraction: BC1b
       #define do-not-use-icache
       6.0x11,5.0x8,3.CC,1.ND,1.TF,16.OFFSET */

#undef CC
#define CC ((unsigned) EXTRACTED32 (instruction_0, 20, 18)) /* cache - extraction */
#undef ND
#define ND ((unsigned) EXTRACTED32 (instruction_0, 17, 17)) /* cache - extraction */
#undef TF
#define TF ((unsigned) EXTRACTED32 (instruction_0, 16, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 9210 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,5.0x8,3.CC,1.ND,1.TF,16.OFFSET */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x03e00000) != 0x01000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
      if (CC == 0)
#line 4378 "./mips.igen"
        trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                      itable[MY_INDEX].file, \
                      itable[MY_INDEX].line_nr, \
                      "bc1%s%s %ld", \
                      str_TF (SD_, TF), \
                      str_ND (SD_, ND), \
                      (long) OFFSET);
#line 9249 "semantics.c"
      else
#line 4379 "./mips.igen"
        trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                      itable[MY_INDEX].file, \
                      itable[MY_INDEX].line_nr, \
                      "bc1%s%s %ld, %ld", \
                      str_TF (SD_, TF), \
                      str_ND (SD_, ND), \
                      (long) CC, \
                      (long) OFFSET);
#line 9260 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BC1b_COP1S, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4390 "./mips.igen"
    check_fpu (SD_);
    if (GETFCC(CC) == TF)
      {
        address_word dest = NIA + (EXTEND16 (OFFSET) << 2);
        DELAY_SLOT (dest);
      }
    else if (ND)
      {
        NULLIFY_NEXT_INSTRUCTION ();
      }
  }
#line 9297 "semantics.c"
  return nia;
  /* Extraction: BC1b
       #undef do-not-use-icache
       6.0x11,5.0x8,3.CC,1.ND,1.TF,16.OFFSET */

#undef CC
#undef ND
#undef TF
#undef OFFSET
#line 9307 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ADD_fmt_COP1 (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ADD_fmt_COP1
#undef ADD_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX ADD_fmt_COP1
#undef MY_NAME
#define MY_NAME "ADD_fmt_COP1"

  /* Extraction: ADD.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.FT,5.FS,5.FD,6.0x0 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 9338 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.FT,5.FS,5.FD,6.0x0 */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4297 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "add.%s f%ld, f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS, \
                    (long) FT);
#line 9372 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ADD_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4311 "./mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    check_fmt_p (SD_, fmt, instruction_0);
    StoreFPR (FD, fmt, Add (ValueFPR (FS, fmt), ValueFPR (FT, fmt), fmt));
  }
#line 9403 "semantics.c"
  return nia;
  /* Extraction: ADD.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.FT,5.FS,5.FD,6.0x0 */

#undef FMT
#undef FT
#undef FS
#undef FD
#undef SFRAME
#line 9414 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SUB_fmt_COP1 (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SUB_fmt_COP1
#undef SUB_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX SUB_fmt_COP1
#undef MY_NAME
#define MY_NAME "SUB_fmt_COP1"

  /* Extraction: SUB.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.FT,5.FS,5.FD,6.0x1 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 9445 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.FT,5.FS,5.FD,6.0x1 */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5520 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sub.%s f%ld, f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS, \
                    (long) FT);
#line 9479 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SUB_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5534 "./mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    check_fmt_p (SD_, fmt, instruction_0);
    StoreFPR (FD, fmt, Sub (ValueFPR (FS, fmt), ValueFPR (FT, fmt), fmt));
  }
#line 9510 "semantics.c"
  return nia;
  /* Extraction: SUB.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.FT,5.FS,5.FD,6.0x1 */

#undef FMT
#undef FT
#undef FS
#undef FD
#undef SFRAME
#line 9521 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MUL_fmt_COP1 (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MUL_fmt_COP1
#undef MUL_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX MUL_fmt_COP1
#undef MY_NAME
#define MY_NAME "MUL_fmt_COP1"

  /* Extraction: MUL.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.FT,5.FS,5.FD,6.0x2 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 9552 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.FT,5.FS,5.FD,6.0x2 */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5186 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mul.%s f%ld, f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS, \
                    (long) FT);
#line 9586 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MUL_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5200 "./mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    check_fmt_p (SD_, fmt, instruction_0);
    StoreFPR (FD, fmt, Multiply (ValueFPR (FS, fmt), ValueFPR (FT, fmt), fmt));
  }
#line 9617 "semantics.c"
  return nia;
  /* Extraction: MUL.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.FT,5.FS,5.FD,6.0x2 */

#undef FMT
#undef FT
#undef FS
#undef FD
#undef SFRAME
#line 9628 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_DIV_fmt_COP1 (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_DIV_fmt_COP1
#undef DIV_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX DIV_fmt_COP1
#undef MY_NAME
#define MY_NAME "DIV_fmt_COP1"

  /* Extraction: DIV.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.FT,5.FS,5.FD,6.0x3 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 9659 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.FT,5.FS,5.FD,6.0x3 */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4709 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "div.%s f%ld, f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS, \
                    (long) FT);
#line 9693 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_DIV_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4723 "./mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    StoreFPR (FD, fmt, Divide (ValueFPR (FS, fmt), ValueFPR (FT, fmt), fmt));
  }
#line 9723 "semantics.c"
  return nia;
  /* Extraction: DIV.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.FT,5.FS,5.FD,6.0x3 */

#undef FMT
#undef FT
#undef FS
#undef FD
#undef SFRAME
#line 9734 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MOVZ_fmt_COP1 (SIM_DESC sd,
                        instruction_word instruction_0,
                        instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MOVZ_fmt_COP1
#undef MOVZ_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX MOVZ_fmt_COP1
#undef MY_NAME
#define MY_NAME "MOVZ_fmt_COP1"

  /* Extraction: MOVZ.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.RT,5.FS,5.FD,6.0x12 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 9765 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.RT,5.FS,5.FD,6.0x12 */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5119 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "movz.%s f%ld, f%ld, r%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS, \
                    (long) RT);
#line 9799 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MOVZ_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5128 "./mips.igen"
    check_fpu (SD_);
    if (GPR[RT] == 0)
      StoreFPR (FD, FMT, ValueFPR (FS, FMT));
    else
      StoreFPR (FD, FMT, ValueFPR (FD, FMT));
  }
#line 9831 "semantics.c"
  return nia;
  /* Extraction: MOVZ.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.RT,5.FS,5.FD,6.0x12 */

#undef FMT
#undef RT
#undef FS
#undef FD
#undef SFRAME
#line 9842 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MOVN_fmt_COP1 (SIM_DESC sd,
                        instruction_word instruction_0,
                        instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MOVN_fmt_COP1
#undef MOVN_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX MOVN_fmt_COP1
#undef MY_NAME
#define MY_NAME "MOVN_fmt_COP1"

  /* Extraction: MOVN.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.RT,5.FS,5.FD,6.0x13 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 9873 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.RT,5.FS,5.FD,6.0x13 */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5094 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "movn.%s f%ld, f%ld, r%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS, \
                    (long) RT);
#line 9907 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MOVN_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5103 "./mips.igen"
    check_fpu (SD_);
    if (GPR[RT] != 0)
      StoreFPR (FD, FMT, ValueFPR (FS, FMT));
    else
      StoreFPR (FD, FMT, ValueFPR (FD, FMT));
  }
#line 9939 "semantics.c"
  return nia;
  /* Extraction: MOVN.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.RT,5.FS,5.FD,6.0x13 */

#undef FMT
#undef RT
#undef FS
#undef FD
#undef SFRAME
#line 9950 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_C_cond_fmtb_COP1 (SIM_DESC sd,
                           instruction_word instruction_0,
                           instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_C_cond_fmtb_COP1
#undef C_cond_fmtb_COP1
#undef MY_PREFIX
#define MY_PREFIX C_cond_fmtb_COP1
#undef MY_NAME
#define MY_NAME "C_cond_fmtb_COP1"

  /* Extraction: C.cond.fmtb
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.FT,5.FS,3.CC,2.0x0,2.0x3,4.COND */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef CC
#define CC ((unsigned) EXTRACTED32 (instruction_0, 10, 8)) /* cache - extraction */
#undef COND
#define COND ((unsigned) MASKED32 (instruction_0, 3, 0)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 9983 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.FT,5.FS,3.CC,2.0x0,2.0x3,4.COND */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000000c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
      if (CC == 0)
#line 4416 "./mips.igen"
        trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                      itable[MY_INDEX].file, \
                      itable[MY_INDEX].line_nr, \
                      "c.%s.%s f%ld, f%ld", \
                      str_COND (SD_, COND), \
                      str_FMT (SD_, FMT), \
                      (long) FS, \
                      (long) FT);
#line 10023 "semantics.c"
      else
#line 4417 "./mips.igen"
        trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                      itable[MY_INDEX].file, \
                      itable[MY_INDEX].line_nr, \
                      "c.%s.%s %ld, f%ld, f%ld", \
                      str_COND (SD_, COND), \
                      str_FMT (SD_, FMT), \
                      (long) CC, \
                      (long) FS, \
                      (long) FT);
#line 10035 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_C_cond_fmtb_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4428 "./mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    check_fmt_p (SD_, fmt, instruction_0);
    Compare (ValueFPR (FS, fmt), ValueFPR (FT, fmt), fmt, COND, CC);
    TRACE_ALU_RESULT (ValueFCR (31));
  }
#line 10067 "semantics.c"
  return nia;
  /* Extraction: C.cond.fmtb
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.FT,5.FS,3.CC,2.0x0,2.0x3,4.COND */

#undef FMT
#undef FT
#undef FS
#undef CC
#undef COND
#undef SFRAME
#line 10079 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MOVtf_fmt_COP1 (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MOVtf_fmt_COP1
#undef MOVtf_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX MOVtf_fmt_COP1
#undef MY_NAME
#define MY_NAME "MOVtf_fmt_COP1"

  /* Extraction: MOVtf.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!7,3.CC,1.0x0,1.TF,5.FS,5.FD,6.0x11 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef CC
#define CC ((unsigned) EXTRACTED32 (instruction_0, 20, 18)) /* cache - extraction */
#undef TF
#define TF ((unsigned) EXTRACTED32 (instruction_0, 16, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 10112 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT!2!3!4!5!7,3.CC,1.0x0,1.TF,5.FS,5.FD,6.0x11 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x00020000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5063 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mov%s.%s f%ld, f%ld, %ld", \
                    str_TF (SD_, TF), \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS, \
                    (long) CC);
#line 10152 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MOVtf_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5072 "./mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    if (fmt != fmt_ps)
      {
        if (GETFCC(CC) == TF)
    	StoreFPR (FD, fmt, ValueFPR (FS, fmt));
        else
    	StoreFPR (FD, fmt, ValueFPR (FD, fmt));   /* set fmt */
      }
    else
      {
        unsigned64 fd;
        fd = PackPS (PSUpper (ValueFPR ((GETFCC (CC+1) == TF) ? FS : FD,
    				      fmt_ps)),
    		   PSLower (ValueFPR ((GETFCC (CC+0) == TF) ? FS : FD,
    				      fmt_ps)));
        StoreFPR (FD, fmt_ps, fd);
      }
  }
#line 10197 "semantics.c"
  return nia;
  /* Extraction: MOVtf.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!7,3.CC,1.0x0,1.TF,5.FS,5.FD,6.0x11 */

#undef FMT
#undef CC
#undef TF
#undef FS
#undef FD
#undef SFRAME
#line 10209 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SQRT_fmt_COP1 (SIM_DESC sd,
                        instruction_word instruction_0,
                        instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SQRT_fmt_COP1
#undef SQRT_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX SQRT_fmt_COP1
#undef MY_NAME
#define MY_NAME "SQRT_fmt_COP1"

  /* Extraction: SQRT.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0x4 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 10238 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0x4 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5500 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sqrt.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 10276 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SQRT_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5513 "./mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    StoreFPR (FD, fmt,  (SquareRoot (ValueFPR (FS, fmt), fmt)));
  }
#line 10306 "semantics.c"
  return nia;
  /* Extraction: SQRT.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0x4 */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 10316 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ABS_fmt_COP1 (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ABS_fmt_COP1
#undef ABS_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX ABS_fmt_COP1
#undef MY_NAME
#define MY_NAME "ABS_fmt_COP1"

  /* Extraction: ABS.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.0x0,5.FS,5.FD,6.0x5 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 10345 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.0x0,5.FS,5.FD,6.0x5 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4274 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "abs.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 10383 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ABS_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4288 "./mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    check_fmt_p (SD_, fmt, instruction_0);
    StoreFPR (FD, fmt, AbsoluteValue (ValueFPR (FS, fmt), fmt));
  }
#line 10414 "semantics.c"
  return nia;
  /* Extraction: ABS.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.0x0,5.FS,5.FD,6.0x5 */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 10424 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MOV_fmt_COP1 (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MOV_fmt_COP1
#undef MOV_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX MOV_fmt_COP1
#undef MY_NAME
#define MY_NAME "MOV_fmt_COP1"

  /* Extraction: MOV.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.0x0,5.FS,5.FD,6.0x6 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 10453 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.0x0,5.FS,5.FD,6.0x6 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5021 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "mov.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 10491 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MOV_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5035 "./mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    check_fmt_p (SD_, fmt, instruction_0);
    StoreFPR (FD, fmt, ValueFPR (FS, fmt));
  }
#line 10522 "semantics.c"
  return nia;
  /* Extraction: MOV.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.0x0,5.FS,5.FD,6.0x6 */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 10532 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_NEG_fmt_COP1 (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_NEG_fmt_COP1
#undef NEG_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX NEG_fmt_COP1
#undef MY_NAME
#define MY_NAME "NEG_fmt_COP1"

  /* Extraction: NEG.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.0x0,5.FS,5.FD,6.0x7 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 10561 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.0x0,5.FS,5.FD,6.0x7 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5208 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "neg.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 10599 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_NEG_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5222 "./mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    check_fmt_p (SD_, fmt, instruction_0);
    StoreFPR (FD, fmt, Negate (ValueFPR (FS, fmt), fmt));
  }
#line 10630 "semantics.c"
  return nia;
  /* Extraction: NEG.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!7,5.0x0,5.FS,5.FD,6.0x7 */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 10640 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ROUND_L_fmt_COP1 (SIM_DESC sd,
                           instruction_word instruction_0,
                           instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ROUND_L_fmt_COP1
#undef ROUND_L_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX ROUND_L_fmt_COP1
#undef MY_NAME
#define MY_NAME "ROUND_L_fmt_COP1"

  /* Extraction: ROUND.L.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0x8 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 10669 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0x8 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5358 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "round.l.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 10707 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ROUND_L_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5369 "./mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    StoreFPR (FD, fmt_long, Convert (FP_RM_NEAREST, ValueFPR (FS, fmt), fmt,
    	    fmt_long));
  }
#line 10738 "semantics.c"
  return nia;
  /* Extraction: ROUND.L.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0x8 */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 10748 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TRUNC_L_fmt_COP1 (SIM_DESC sd,
                           instruction_word instruction_0,
                           instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TRUNC_L_fmt_COP1
#undef TRUNC_L_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX TRUNC_L_fmt_COP1
#undef MY_NAME
#define MY_NAME "TRUNC_L_fmt_COP1"

  /* Extraction: TRUNC.L.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0x9 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 10777 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0x9 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5633 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "trunc.l.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 10815 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TRUNC_L_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5644 "./mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    StoreFPR (FD, fmt_long, Convert (FP_RM_TOZERO, ValueFPR (FS, fmt), fmt,
    	    fmt_long));
  }
#line 10846 "semantics.c"
  return nia;
  /* Extraction: TRUNC.L.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0x9 */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 10856 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_CEIL_L_fmt_COP1 (SIM_DESC sd,
                          instruction_word instruction_0,
                          instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_CEIL_L_fmt_COP1
#undef CEIL_L_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX CEIL_L_fmt_COP1
#undef MY_NAME
#define MY_NAME "CEIL_L_fmt_COP1"

  /* Extraction: CEIL.L.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0xa */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 10885 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0xa */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4437 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "ceil.l.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 10923 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_CEIL_L_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4448 "./mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    StoreFPR (FD, fmt_long, Convert (FP_RM_TOPINF, ValueFPR (FS, fmt), fmt,
    	    fmt_long));
  }
#line 10954 "semantics.c"
  return nia;
  /* Extraction: CEIL.L.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0xa */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 10964 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_FLOOR_L_fmt_COP1 (SIM_DESC sd,
                           instruction_word instruction_0,
                           instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_FLOOR_L_fmt_COP1
#undef FLOOR_L_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX FLOOR_L_fmt_COP1
#undef MY_NAME
#define MY_NAME "FLOOR_L_fmt_COP1"

  /* Extraction: FLOOR.L.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0xb */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 10993 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0xb */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4809 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "floor.l.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 11031 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_FLOOR_L_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4820 "./mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    StoreFPR (FD, fmt_long, Convert (FP_RM_TOMINF, ValueFPR (FS, fmt), fmt,
    	    fmt_long));
  }
#line 11062 "semantics.c"
  return nia;
  /* Extraction: FLOOR.L.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0xb */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 11072 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_ROUND_W_fmt_COP1 (SIM_DESC sd,
                           instruction_word instruction_0,
                           instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_ROUND_W_fmt_COP1
#undef ROUND_W_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX ROUND_W_fmt_COP1
#undef MY_NAME
#define MY_NAME "ROUND_W_fmt_COP1"

  /* Extraction: ROUND.W.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0xc */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 11101 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0xc */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5377 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "round.w.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 11139 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_ROUND_W_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5390 "./mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    StoreFPR (FD, fmt_word, Convert (FP_RM_NEAREST, ValueFPR (FS, fmt), fmt,
    	    fmt_word));
  }
#line 11170 "semantics.c"
  return nia;
  /* Extraction: ROUND.W.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0xc */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 11180 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_TRUNC_W_COP1 (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_TRUNC_W_COP1
#undef TRUNC_W_COP1
#undef MY_PREFIX
#define MY_PREFIX TRUNC_W_COP1
#undef MY_NAME
#define MY_NAME "TRUNC_W_COP1"

  /* Extraction: TRUNC.W
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0xd */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 11209 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0xd */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5652 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "trunc.w.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 11247 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_TRUNC_W_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5665 "./mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    StoreFPR (FD, fmt_word, Convert (FP_RM_TOZERO, ValueFPR (FS, fmt), fmt,
    	    fmt_word));
  }
#line 11278 "semantics.c"
  return nia;
  /* Extraction: TRUNC.W
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0xd */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 11288 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_CEIL_W_COP1 (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_CEIL_W_COP1
#undef CEIL_W_COP1
#undef MY_PREFIX
#define MY_PREFIX CEIL_W_COP1
#undef MY_NAME
#define MY_NAME "CEIL_W_COP1"

  /* Extraction: CEIL.W
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0xe */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 11317 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0xe */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4456 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "ceil.w.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 11355 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_CEIL_W_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4469 "./mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    StoreFPR (FD, fmt_word, Convert (FP_RM_TOPINF, ValueFPR (FS, fmt), fmt,
    	    fmt_word));
  }
#line 11386 "semantics.c"
  return nia;
  /* Extraction: CEIL.W
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0xe */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 11396 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_FLOOR_W_fmt_COP1 (SIM_DESC sd,
                           instruction_word instruction_0,
                           instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_FLOOR_W_fmt_COP1
#undef FLOOR_W_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX FLOOR_W_fmt_COP1
#undef MY_NAME
#define MY_NAME "FLOOR_W_fmt_COP1"

  /* Extraction: FLOOR.W.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0xf */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 11425 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0xf */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4828 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "floor.w.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 11463 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_FLOOR_W_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4841 "./mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    StoreFPR (FD, fmt_word, Convert (FP_RM_TOMINF, ValueFPR (FS, fmt), fmt,
    	    fmt_word));
  }
#line 11494 "semantics.c"
  return nia;
  /* Extraction: FLOOR.W.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0xf */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 11504 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_RECIP_fmt_COP1 (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_RECIP_fmt_COP1
#undef RECIP_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX RECIP_fmt_COP1
#undef MY_NAME
#define MY_NAME "RECIP_fmt_COP1"

  /* Extraction: RECIP.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0x15 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 11533 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0x15 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5343 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "recip.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 11571 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_RECIP_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5351 "./mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    StoreFPR (FD, fmt, Recip (ValueFPR (FS, fmt), fmt));
  }
#line 11601 "semantics.c"
  return nia;
  /* Extraction: RECIP.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0x15 */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 11611 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_RSQRT_fmt_COP1 (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_RSQRT_fmt_COP1
#undef RSQRT_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX RSQRT_fmt_COP1
#undef MY_NAME
#define MY_NAME "RSQRT_fmt_COP1"

  /* Extraction: RSQRT.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0x16 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 11640 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0x16 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5398 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "rsqrt.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 11678 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_RSQRT_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5406 "./mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    StoreFPR (FD, fmt, RSquareRoot (ValueFPR (FS, fmt), fmt));
  }
#line 11708 "semantics.c"
  return nia;
  /* Extraction: RSQRT.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0x16 */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 11718 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_CVT_S_fmt_COP1 (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_CVT_S_fmt_COP1
#undef CVT_S_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX CVT_S_fmt_COP1
#undef MY_NAME
#define MY_NAME "CVT_S_fmt_COP1"

  /* Extraction: CVT.S.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT!0!2!3!6!7,5.0x0,5.FS,5.FD,6.0x20 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 11747 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT!0!2!3!6!7,5.0x0,5.FS,5.FD,6.0x20 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4635 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "cvt.s.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 11785 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_CVT_S_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4649 "./mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    if ((fmt == fmt_single) | 0)
      SignalException (ReservedInstruction, instruction_0);
    StoreFPR (FD, fmt_single, Convert (GETRM (), ValueFPR (FS, fmt), fmt,
    	    fmt_single));
  }
#line 11818 "semantics.c"
  return nia;
  /* Extraction: CVT.S.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT!0!2!3!6!7,5.0x0,5.FS,5.FD,6.0x20 */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 11828 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_CVT_D_fmt_COP1 (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_CVT_D_fmt_COP1
#undef CVT_D_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX CVT_D_fmt_COP1
#undef MY_NAME
#define MY_NAME "CVT_D_fmt_COP1"

  /* Extraction: CVT.D.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT!1!2!3!6!7,5.0x0,5.FS,5.FD,6.0x21 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 11857 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT!1!2!3!6!7,5.0x0,5.FS,5.FD,6.0x21 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4573 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "cvt.d.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 11895 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_CVT_D_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4587 "./mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    if ((fmt == fmt_double) | 0)
      SignalException (ReservedInstruction, instruction_0);
    StoreFPR (FD, fmt_double, Convert (GETRM (), ValueFPR (FS, fmt), fmt,
    	    fmt_double));
  }
#line 11928 "semantics.c"
  return nia;
  /* Extraction: CVT.D.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT!1!2!3!6!7,5.0x0,5.FS,5.FD,6.0x21 */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 11938 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_CVT_W_fmt_COP1 (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_CVT_W_fmt_COP1
#undef CVT_W_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX CVT_W_fmt_COP1
#undef MY_NAME
#define MY_NAME "CVT_W_fmt_COP1"

  /* Extraction: CVT.W.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0x24 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 11967 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0x24 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4685 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "cvt.w.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 12005 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_CVT_W_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4699 "./mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    if ((fmt == fmt_word) | ((fmt == fmt_long) || (fmt == fmt_word)))
      SignalException (ReservedInstruction, instruction_0);
    StoreFPR (FD, fmt_word, Convert (GETRM (), ValueFPR (FS, fmt), fmt,
    	    fmt_word));
  }
#line 12038 "semantics.c"
  return nia;
  /* Extraction: CVT.W.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0x24 */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 12048 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_CVT_L_fmt_COP1 (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_CVT_L_fmt_COP1
#undef CVT_L_fmt_COP1
#undef MY_PREFIX
#define MY_PREFIX CVT_L_fmt_COP1
#undef MY_NAME
#define MY_NAME "CVT_L_fmt_COP1"

  /* Extraction: CVT.L.fmt
       #define do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0x25 */

#undef FMT
#define FMT ((unsigned) EXTRACTED32 (instruction_0, 23, 21)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 12077 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0x25 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4597 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "cvt.l.%s f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FS);
#line 12115 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_CVT_L_fmt_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4608 "./mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    if ((fmt == fmt_long) | ((fmt == fmt_long) || (fmt == fmt_word)))
      SignalException (ReservedInstruction, instruction_0);
    StoreFPR (FD, fmt_long, Convert (GETRM (), ValueFPR (FS, fmt), fmt,
    	    fmt_long));
  }
#line 12148 "semantics.c"
  return nia;
  /* Extraction: CVT.L.fmt
       #undef do-not-use-icache
       6.0x11,2.0x2,3.FMT!2!3!4!5!6!7,5.0x0,5.FS,5.FD,6.0x25 */

#undef FMT
#undef FS
#undef FD
#undef SFRAME
#line 12158 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MADD_fmt_COP1X (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MADD_fmt_COP1X
#undef MADD_fmt_COP1X
#undef MY_PREFIX
#define MY_PREFIX MADD_fmt_COP1X
#undef MY_NAME
#define MY_NAME "MADD_fmt_COP1X"

  /* Extraction: MADD.fmt
       #define do-not-use-icache
       6.0x13,5.FR,5.FT,5.FS,5.FD,3.0x4,3.FMT!2!3!4!5!7 */

#undef FR
#define FR ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef FMT
#define FMT ((unsigned) MASKED32 (instruction_0, 2, 0)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 12191 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x13,5.FR,5.FT,5.FS,5.FD,3.0x4,3.FMT!2!3!4!5!7 */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4972 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "madd.%s f%ld, f%ld, f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FR, \
                    (long) FS, \
                    (long) FT);
#line 12226 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MADD_fmt_COP1X, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4980 "./mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    check_u64 (SD_, instruction_0);
    check_fmt_p (SD_, fmt, instruction_0); 
    StoreFPR (FD, fmt, MultiplyAdd (ValueFPR (FS, fmt), ValueFPR (FT, fmt),
    				  ValueFPR (FR, fmt), fmt));
  }
#line 12259 "semantics.c"
  return nia;
  /* Extraction: MADD.fmt
       #undef do-not-use-icache
       6.0x13,5.FR,5.FT,5.FS,5.FD,3.0x4,3.FMT!2!3!4!5!7 */

#undef FR
#undef FT
#undef FS
#undef FD
#undef FMT
#undef SFRAME
#line 12271 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_MSUB_fmt_COP1X (SIM_DESC sd,
                         instruction_word instruction_0,
                         instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_MSUB_fmt_COP1X
#undef MSUB_fmt_COP1X
#undef MY_PREFIX
#define MY_PREFIX MSUB_fmt_COP1X
#undef MY_NAME
#define MY_NAME "MSUB_fmt_COP1X"

  /* Extraction: MSUB.fmt
       #define do-not-use-icache
       6.0x13,5.FR,5.FT,5.FS,5.FD,3.0x5,3.FMT!2!3!4!5!7 */

#undef FR
#define FR ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef FMT
#define FMT ((unsigned) MASKED32 (instruction_0, 2, 0)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 12304 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x13,5.FR,5.FT,5.FS,5.FD,3.0x5,3.FMT!2!3!4!5!7 */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5137 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "msub.%s f%ld, f%ld, f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FR, \
                    (long) FS, \
                    (long) FT);
#line 12339 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_MSUB_fmt_COP1X, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5145 "./mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    check_u64 (SD_, instruction_0);
    check_fmt_p (SD_, fmt, instruction_0);
    StoreFPR (FD, fmt, MultiplySub (ValueFPR (FS, fmt), ValueFPR (FT, fmt),
    				  ValueFPR (FR, fmt), fmt));
  }
#line 12372 "semantics.c"
  return nia;
  /* Extraction: MSUB.fmt
       #undef do-not-use-icache
       6.0x13,5.FR,5.FT,5.FS,5.FD,3.0x5,3.FMT!2!3!4!5!7 */

#undef FR
#undef FT
#undef FS
#undef FD
#undef FMT
#undef SFRAME
#line 12384 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_NMADD_fmt_COP1X (SIM_DESC sd,
                          instruction_word instruction_0,
                          instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_NMADD_fmt_COP1X
#undef NMADD_fmt_COP1X
#undef MY_PREFIX
#define MY_PREFIX NMADD_fmt_COP1X
#undef MY_NAME
#define MY_NAME "NMADD_fmt_COP1X"

  /* Extraction: NMADD.fmt
       #define do-not-use-icache
       6.0x13,5.FR,5.FT,5.FS,5.FD,3.0x6,3.FMT!2!3!4!5!7 */

#undef FR
#define FR ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef FMT
#define FMT ((unsigned) MASKED32 (instruction_0, 2, 0)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 12417 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x13,5.FR,5.FT,5.FS,5.FD,3.0x6,3.FMT!2!3!4!5!7 */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5230 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "nmadd.%s f%ld, f%ld, f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FR, \
                    (long) FS, \
                    (long) FT);
#line 12452 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_NMADD_fmt_COP1X, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5238 "./mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    check_u64 (SD_, instruction_0);
    check_fmt_p (SD_, fmt, instruction_0);
    StoreFPR (FD, fmt, NegMultiplyAdd (ValueFPR (FS, fmt), ValueFPR (FT, fmt),
    				     ValueFPR (FR, fmt), fmt));
  }
#line 12485 "semantics.c"
  return nia;
  /* Extraction: NMADD.fmt
       #undef do-not-use-icache
       6.0x13,5.FR,5.FT,5.FS,5.FD,3.0x6,3.FMT!2!3!4!5!7 */

#undef FR
#undef FT
#undef FS
#undef FD
#undef FMT
#undef SFRAME
#line 12497 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_NMSUB_fmt_COP1X (SIM_DESC sd,
                          instruction_word instruction_0,
                          instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_NMSUB_fmt_COP1X
#undef NMSUB_fmt_COP1X
#undef MY_PREFIX
#define MY_PREFIX NMSUB_fmt_COP1X
#undef MY_NAME
#define MY_NAME "NMSUB_fmt_COP1X"

  /* Extraction: NMSUB.fmt
       #define do-not-use-icache
       6.0x13,5.FR,5.FT,5.FS,5.FD,3.0x7,3.FMT!2!3!4!5!7 */

#undef FR
#define FR ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#undef FMT
#define FMT ((unsigned) MASKED32 (instruction_0, 2, 0)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 12530 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x13,5.FR,5.FT,5.FS,5.FD,3.0x7,3.FMT!2!3!4!5!7 */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5248 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "nmsub.%s f%ld, f%ld, f%ld, f%ld", \
                    str_FMT (SD_, FMT), \
                    (long) FD, \
                    (long) FR, \
                    (long) FS, \
                    (long) FT);
#line 12565 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_NMSUB_fmt_COP1X, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5256 "./mips.igen"
    int fmt = FMT;
    check_fpu (SD_);
    check_u64 (SD_, instruction_0);
    check_fmt_p (SD_, fmt, instruction_0);
    StoreFPR (FD, fmt, NegMultiplySub (ValueFPR (FS, fmt), ValueFPR (FT, fmt),
    				     ValueFPR (FR, fmt), fmt));
  }
#line 12598 "semantics.c"
  return nia;
  /* Extraction: NMSUB.fmt
       #undef do-not-use-icache
       6.0x13,5.FR,5.FT,5.FS,5.FD,3.0x7,3.FMT!2!3!4!5!7 */

#undef FR
#undef FT
#undef FS
#undef FD
#undef FMT
#undef SFRAME
#line 12610 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SWXC1_COP1X (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SWXC1_COP1X
#undef SWXC1_COP1X
#undef MY_PREFIX
#define MY_PREFIX SWXC1_COP1X
#undef MY_NAME
#define MY_NAME "SWXC1_COP1X"

  /* Extraction: SWXC1
       #define do-not-use-icache
       6.0x13,5.BASE,5.INDEX,5.FS,5.0x0,6.0x8 */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef INDEX
#define INDEX ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 12639 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x13,5.BASE,5.INDEX,5.FS,5.0x0,6.0x8 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5589 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "swxc1 f%ld, r%ld(r%ld)", \
                    (long) FS, \
                    (long) INDEX, \
                    (long) BASE);
#line 12677 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SWXC1_COP1X, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5597 "./mips.igen"

    address_word base = GPR[BASE];
    address_word index = GPR[INDEX];
    check_fpu (SD_);
    check_u64 (SD_, instruction_0);
    {
     address_word vaddr = loadstore_ea (SD_, base, index);
     address_word paddr;
     int uncached;
     if ((vaddr & 3) != 0)
       {
         SIM_CORE_SIGNAL (SD, CPU, cia, read_map, 4, vaddr, write_transfer, sim_core_unaligned_signal);
       }
     else
     {
      if (AddressTranslation(vaddr,isDATA,isSTORE,&paddr,&uncached,isTARGET,isREAL))
      {
       unsigned64 memval = 0;
       unsigned64 memval1 = 0;
       unsigned64 mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
       address_word reverseendian = (ReverseEndian ? (mask ^ AccessLength_WORD) : 0);
       address_word bigendiancpu = (BigEndianCPU ? (mask ^ AccessLength_WORD) : 0);
       unsigned int byte;
       paddr = ((paddr & ~mask) | ((paddr & mask) ^ reverseendian));
       byte = ((vaddr & mask) ^ bigendiancpu);
       memval = (((unsigned64)COP_SW(1,FS)) << (8 * byte));
        {
         StoreMemory(uncached,AccessLength_WORD,memval,memval1,paddr,vaddr,isREAL);
        }
      }
     }
    }
  }
#line 12736 "semantics.c"
  return nia;
  /* Extraction: SWXC1
       #undef do-not-use-icache
       6.0x13,5.BASE,5.INDEX,5.FS,5.0x0,6.0x8 */

#undef BASE
#undef INDEX
#undef FS
#undef SFRAME
#line 12746 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SDXC1_COP1X (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SDXC1_COP1X
#undef SDXC1_COP1X
#undef MY_PREFIX
#define MY_PREFIX SDXC1_COP1X
#undef MY_NAME
#define MY_NAME "SDXC1_COP1X"

  /* Extraction: SDXC1
       #define do-not-use-icache
       6.0x13,5.BASE,5.INDEX,5.FS,11.0x9 */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef INDEX
#define INDEX ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FS
#define FS ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#undef SFRAME
#define SFRAME ((int) ((FS == 0) ? 128 : (FS << 3))) /* scratch - extraction */
#line 12775 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x13,5.BASE,5.INDEX,5.FS,11.0x9 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5449 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sdxc1 f%ld, r%ld(r%ld)", \
                    (long) FS, \
                    (long) INDEX, \
                    (long) BASE);
#line 12813 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SDXC1_COP1X, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5456 "./mips.igen"
    check_fpu (SD_);
    check_u64 (SD_, instruction_0);
    do_store (SD_, AccessLength_DOUBLEWORD, GPR[BASE], GPR[INDEX], COP_SD (1, FS));
  }
#line 12843 "semantics.c"
  return nia;
  /* Extraction: SDXC1
       #undef do-not-use-icache
       6.0x13,5.BASE,5.INDEX,5.FS,11.0x9 */

#undef BASE
#undef INDEX
#undef FS
#undef SFRAME
#line 12853 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_PREFX_COP1X (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_PREFX_COP1X
#undef PREFX_COP1X
#undef MY_PREFIX
#define MY_PREFIX PREFX_COP1X
#undef MY_NAME
#define MY_NAME "PREFX_COP1X"

  /* Extraction: PREFX
       #define do-not-use-icache
       6.0x13,5.BASE,5.INDEX,5.HINT,5.0x0,6.0xf */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef INDEX
#define INDEX ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef HINT
#define HINT ((unsigned) EXTRACTED32 (instruction_0, 15, 11)) /* cache - extraction */
#line 12880 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x13,5.BASE,5.INDEX,5.HINT,5.0x0,6.0xf */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x000007c0) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5294 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "prefx %ld, r%ld(r%ld)", \
                    (long) HINT, \
                    (long) INDEX, \
                    (long) BASE);
#line 12904 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_PREFX_COP1X, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5302 "./mips.igen"
    address_word base = GPR[BASE];
    address_word index = GPR[INDEX];
    {
      address_word vaddr = loadstore_ea (SD_, base, index);
      address_word paddr;
      int uncached;
      if (AddressTranslation(vaddr,isDATA,isLOAD,&paddr,&uncached,isTARGET,isREAL))
        Prefetch(uncached,paddr,vaddr,isDATA,HINT);
    }
  }
#line 12940 "semantics.c"
  return nia;
  /* Extraction: PREFX
       #undef do-not-use-icache
       6.0x13,5.BASE,5.INDEX,5.HINT,5.0x0,6.0xf */

#undef BASE
#undef INDEX
#undef HINT
#line 12949 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LWXC1_COP1X (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LWXC1_COP1X
#undef LWXC1_COP1X
#undef MY_PREFIX
#define MY_PREFIX LWXC1_COP1X
#undef MY_NAME
#define MY_NAME "LWXC1_COP1X"

  /* Extraction: LWXC1
       #define do-not-use-icache
       6.0x13,5.BASE,5.INDEX,5.0x0,5.FD,6.0x0 */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef INDEX
#define INDEX ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#line 12976 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x13,5.BASE,5.INDEX,5.0x0,5.FD,6.0x0 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x0000f800) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4956 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lwxc1 f%ld, r%ld(r%ld)", \
                    (long) FD, \
                    (long) INDEX, \
                    (long) BASE);
#line 13014 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LWXC1_COP1X, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4964 "./mips.igen"
    check_fpu (SD_);
    check_u64 (SD_, instruction_0);
    COP_LW (1, FD, do_load (SD_, AccessLength_WORD, GPR[BASE], GPR[INDEX]));
  }
#line 13044 "semantics.c"
  return nia;
  /* Extraction: LWXC1
       #undef do-not-use-icache
       6.0x13,5.BASE,5.INDEX,5.0x0,5.FD,6.0x0 */

#undef BASE
#undef INDEX
#undef FD
#line 13053 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LDXC1_COP1X (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LDXC1_COP1X
#undef LDXC1_COP1X
#undef MY_PREFIX
#define MY_PREFIX LDXC1_COP1X
#undef MY_NAME
#define MY_NAME "LDXC1_COP1X"

  /* Extraction: LDXC1
       #define do-not-use-icache
       6.0x13,5.BASE,5.INDEX,5.0x0,5.FD,6.0x1 */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef INDEX
#define INDEX ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef FD
#define FD ((unsigned) EXTRACTED32 (instruction_0, 10, 6)) /* cache - extraction */
#line 13080 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x13,5.BASE,5.INDEX,5.0x0,5.FD,6.0x1 */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x0000f800) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4885 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "ldxc1 f%ld, r%ld(r%ld)", \
                    (long) FD, \
                    (long) INDEX, \
                    (long) BASE);
#line 13118 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LDXC1_COP1X, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4892 "./mips.igen"
    check_fpu (SD_);
    check_u64 (SD_, instruction_0);
    COP_LD (1, FD, do_load (SD_, AccessLength_DOUBLEWORD, GPR[BASE], GPR[INDEX]));
  }
#line 13148 "semantics.c"
  return nia;
  /* Extraction: LDXC1
       #undef do-not-use-icache
       6.0x13,5.BASE,5.INDEX,5.0x0,5.FD,6.0x1 */

#undef BASE
#undef INDEX
#undef FD
#line 13157 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BEQL_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BEQL_NORMAL
#undef BEQL_NORMAL
#undef MY_PREFIX
#define MY_PREFIX BEQL_NORMAL
#undef MY_NAME
#define MY_NAME "BEQL_NORMAL"

  /* Extraction: BEQL
       #define do-not-use-icache
       6.0x14,5.RS,5.RT,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 13184 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x14,5.RS,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 695 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "beql r%ld, r%ld, %ld", \
                    (long) RS, \
                    (long) RT, \
                    (long) OFFSET);
#line 13203 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BEQL_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 708 "./mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if ((signed_word) GPR[RS] == (signed_word) GPR[RT])
      {
        DELAY_SLOT (NIA + offset);
      }
    else
      NULLIFY_NEXT_INSTRUCTION ();
  }
#line 13237 "semantics.c"
  return nia;
  /* Extraction: BEQL
       #undef do-not-use-icache
       6.0x14,5.RS,5.RT,16.OFFSET */

#undef RS
#undef RT
#undef OFFSET
#line 13246 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BNEL_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BNEL_NORMAL
#undef BNEL_NORMAL
#undef MY_PREFIX
#define MY_PREFIX BNEL_NORMAL
#undef MY_NAME
#define MY_NAME "BNEL_NORMAL"

  /* Extraction: BNEL
       #define do-not-use-icache
       6.0x15,5.RS,5.RT,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 13273 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x15,5.RS,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1060 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bnel r%ld, r%ld, %ld", \
                    (long) RS, \
                    (long) RT, \
                    (long) OFFSET);
#line 13292 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BNEL_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1073 "./mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if ((signed_word) GPR[RS] != (signed_word) GPR[RT])
      {
        DELAY_SLOT (NIA + offset);
      }
    else
      NULLIFY_NEXT_INSTRUCTION ();
  }
#line 13326 "semantics.c"
  return nia;
  /* Extraction: BNEL
       #undef do-not-use-icache
       6.0x15,5.RS,5.RT,16.OFFSET */

#undef RS
#undef RT
#undef OFFSET
#line 13335 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BLEZL_NORMAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BLEZL_NORMAL
#undef BLEZL_NORMAL
#undef MY_PREFIX
#define MY_PREFIX BLEZL_NORMAL
#undef MY_NAME
#define MY_NAME "BLEZL_NORMAL"

  /* Extraction: BLEZL
       #define do-not-use-icache
       6.0x16,5.RS,5.0x0,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 13360 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x16,5.RS,5.0x0,16.OFFSET */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 903 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bgezl r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 13383 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BLEZL_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 916 "./mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    if ((signed_word) GPR[RS] <= 0)
      {
        DELAY_SLOT (NIA + offset);
      }
    else
      NULLIFY_NEXT_INSTRUCTION ();
  }
#line 13417 "semantics.c"
  return nia;
  /* Extraction: BLEZL
       #undef do-not-use-icache
       6.0x16,5.RS,5.0x0,16.OFFSET */

#undef RS
#undef OFFSET
#line 13425 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_BGTZL_NORMAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_BGTZL_NORMAL
#undef BGTZL_NORMAL
#undef MY_PREFIX
#define MY_PREFIX BGTZL_NORMAL
#undef MY_NAME
#define MY_NAME "BGTZL_NORMAL"

  /* Extraction: BGTZL
       #define do-not-use-icache
       6.0x17,5.RS,5.0x0,16.OFFSET */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 13450 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x17,5.RS,5.0x0,16.OFFSET */
  if (WITH_RESERVED_BITS)
    {
      if ((instruction_0 & 0x001f0000) != 0x00000000)
        return semantic_illegal (sd, cia);
    }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 850 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "bgtzl r%ld, %ld", \
                    (long) RS, \
                    (long) OFFSET);
#line 13473 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_BGTZL_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 863 "./mips.igen"
    address_word offset = EXTEND16 (OFFSET) << 2;
    /* NOTE: The branch occurs AFTER the next instruction has been
       executed */
    if ((signed_word) GPR[RS] > 0)
      {
        DELAY_SLOT (NIA + offset);
      }
    else
      NULLIFY_NEXT_INSTRUCTION ();
  }
#line 13509 "semantics.c"
  return nia;
  /* Extraction: BGTZL
       #undef do-not-use-icache
       6.0x17,5.RS,5.0x0,16.OFFSET */

#undef RS
#undef OFFSET
#line 13517 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_DADDI_NORMAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_DADDI_NORMAL
#undef DADDI_NORMAL
#undef MY_PREFIX
#define MY_PREFIX DADDI_NORMAL
#undef MY_NAME
#define MY_NAME "DADDI_NORMAL"

  /* Extraction: DADDI
       #define do-not-use-icache
       6.0x18,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 13544 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x18,5.RS,5.RT,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1204 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "daddi r%ld, r%ld, %ld", \
                    (long) RT, \
                    (long) RS, \
                    (long) IMMEDIATE);
#line 13563 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_DADDI_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1213 "./mips.igen"
    check_u64 (SD_, instruction_0);
    TRACE_ALU_INPUT2 (GPR[RS], EXTEND16 (IMMEDIATE));
    {
      ALU64_BEGIN (GPR[RS]);
      ALU64_ADD (EXTEND16 (IMMEDIATE));
      ALU64_END (GPR[RT]);   /* This checks for overflow.  */
    }
    TRACE_ALU_RESULT (GPR[RT]);
  }
#line 13598 "semantics.c"
  return nia;
  /* Extraction: DADDI
       #undef do-not-use-icache
       6.0x18,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#undef RT
#undef IMMEDIATE
#line 13607 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_DADDIU_NORMAL (SIM_DESC sd,
                        instruction_word instruction_0,
                        instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_DADDIU_NORMAL
#undef DADDIU_NORMAL
#undef MY_PREFIX
#define MY_PREFIX DADDIU_NORMAL
#undef MY_NAME
#define MY_NAME "DADDIU_NORMAL"

  /* Extraction: DADDIU
       #define do-not-use-icache
       6.0x19,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#define RS ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef IMMEDIATE
#define IMMEDIATE ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 13634 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x19,5.RS,5.RT,16.IMMEDIATE */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 1233 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "daddiu r%ld, r%ld, %ld", \
                    (long) RT, \
                    (long) RS, \
                    (long) IMMEDIATE);
#line 13653 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_DADDIU_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 1242 "./mips.igen"
    check_u64 (SD_, instruction_0);
    do_daddiu (SD_, RS, RT, IMMEDIATE);
  }
#line 13682 "semantics.c"
  return nia;
  /* Extraction: DADDIU
       #undef do-not-use-icache
       6.0x19,5.RS,5.RT,16.IMMEDIATE */

#undef RS
#undef RT
#undef IMMEDIATE
#line 13691 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LDL_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LDL_NORMAL
#undef LDL_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LDL_NORMAL
#undef MY_NAME
#define MY_NAME "LDL_NORMAL"

  /* Extraction: LDL
       #define do-not-use-icache
       6.0x1a,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 13718 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1a,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2170 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "ldl r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 13737 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LDL_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2179 "./mips.igen"
    check_u64 (SD_, instruction_0);
    GPR[RT] = do_load_left (SD_, AccessLength_DOUBLEWORD, GPR[BASE], EXTEND16 (OFFSET), GPR[RT]);
  }
#line 13766 "semantics.c"
  return nia;
  /* Extraction: LDL
       #undef do-not-use-icache
       6.0x1a,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 13775 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LDR_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LDR_NORMAL
#undef LDR_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LDR_NORMAL
#undef MY_NAME
#define MY_NAME "LDR_NORMAL"

  /* Extraction: LDR
       #define do-not-use-icache
       6.0x1b,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 13802 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x1b,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2185 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "ldr r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 13821 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LDR_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2194 "./mips.igen"
    check_u64 (SD_, instruction_0);
    GPR[RT] = do_load_right (SD_, AccessLength_DOUBLEWORD, GPR[BASE], EXTEND16 (OFFSET), GPR[RT]);
  }
#line 13850 "semantics.c"
  return nia;
  /* Extraction: LDR
       #undef do-not-use-icache
       6.0x1b,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 13859 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LB_NORMAL (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LB_NORMAL
#undef LB_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LB_NORMAL
#undef MY_NAME
#define MY_NAME "LB_NORMAL"

  /* Extraction: LB
       #define do-not-use-icache
       6.0x20,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 13886 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x20,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2097 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lb r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 13905 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LB_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2111 "./mips.igen"
    GPR[RT] = EXTEND8 (do_load (SD_, AccessLength_BYTE, GPR[BASE], EXTEND16 (OFFSET)));
  }
#line 13933 "semantics.c"
  return nia;
  /* Extraction: LB
       #undef do-not-use-icache
       6.0x20,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 13942 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LH_NORMAL (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LH_NORMAL
#undef LH_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LH_NORMAL
#undef MY_NAME
#define MY_NAME "LH_NORMAL"

  /* Extraction: LH
       #define do-not-use-icache
       6.0x21,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 13969 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x21,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2200 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lh r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 13988 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LH_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2214 "./mips.igen"
    GPR[RT] = EXTEND16 (do_load (SD_, AccessLength_HALFWORD, GPR[BASE], EXTEND16 (OFFSET)));
  }
#line 14016 "semantics.c"
  return nia;
  /* Extraction: LH
       #undef do-not-use-icache
       6.0x21,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 14025 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LWL_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LWL_NORMAL
#undef LWL_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LWL_NORMAL
#undef MY_NAME
#define MY_NAME "LWL_NORMAL"

  /* Extraction: LWL
       #define do-not-use-icache
       6.0x22,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 14052 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x22,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2378 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lwl r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 14071 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LWL_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2392 "./mips.igen"
    GPR[RT] = EXTEND32 (do_load_left (SD_, AccessLength_WORD, GPR[BASE], EXTEND16 (OFFSET), GPR[RT]));
  }
#line 14099 "semantics.c"
  return nia;
  /* Extraction: LWL
       #undef do-not-use-icache
       6.0x22,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 14108 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LW_NORMAL (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LW_NORMAL
#undef LW_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LW_NORMAL
#undef MY_NAME
#define MY_NAME "LW_NORMAL"

  /* Extraction: LW
       #define do-not-use-icache
       6.0x23,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 14135 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x23,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2340 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lw r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 14154 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LW_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2354 "./mips.igen"
    GPR[RT] = EXTEND32 (do_load (SD_, AccessLength_WORD, GPR[BASE], EXTEND16 (OFFSET)));
  }
#line 14182 "semantics.c"
  return nia;
  /* Extraction: LW
       #undef do-not-use-icache
       6.0x23,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 14191 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LBU_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LBU_NORMAL
#undef LBU_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LBU_NORMAL
#undef MY_NAME
#define MY_NAME "LBU_NORMAL"

  /* Extraction: LBU
       #define do-not-use-icache
       6.0x24,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 14218 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x24,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2116 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lbu r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 14237 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LBU_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2130 "./mips.igen"
    GPR[RT] = do_load (SD_, AccessLength_BYTE, GPR[BASE], EXTEND16 (OFFSET));
  }
#line 14265 "semantics.c"
  return nia;
  /* Extraction: LBU
       #undef do-not-use-icache
       6.0x24,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 14274 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LHU_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LHU_NORMAL
#undef LHU_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LHU_NORMAL
#undef MY_NAME
#define MY_NAME "LHU_NORMAL"

  /* Extraction: LHU
       #define do-not-use-icache
       6.0x25,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 14301 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x25,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2219 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lhu r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 14320 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LHU_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2233 "./mips.igen"
    GPR[RT] = do_load (SD_, AccessLength_HALFWORD, GPR[BASE], EXTEND16 (OFFSET));
  }
#line 14348 "semantics.c"
  return nia;
  /* Extraction: LHU
       #undef do-not-use-icache
       6.0x25,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 14357 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LWR_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LWR_NORMAL
#undef LWR_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LWR_NORMAL
#undef MY_NAME
#define MY_NAME "LWR_NORMAL"

  /* Extraction: LWR
       #define do-not-use-icache
       6.0x26,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 14384 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x26,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2397 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lwr r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 14403 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LWR_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2411 "./mips.igen"
    GPR[RT] = EXTEND32 (do_load_right (SD_, AccessLength_WORD, GPR[BASE], EXTEND16 (OFFSET), GPR[RT]));
  }
#line 14431 "semantics.c"
  return nia;
  /* Extraction: LWR
       #undef do-not-use-icache
       6.0x26,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 14440 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LWU_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LWU_NORMAL
#undef LWU_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LWU_NORMAL
#undef MY_NAME
#define MY_NAME "LWU_NORMAL"

  /* Extraction: LWU
       #define do-not-use-icache
       6.0x27,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 14467 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x27,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2416 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lwu r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 14486 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LWU_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2425 "./mips.igen"
    check_u64 (SD_, instruction_0);
    GPR[RT] = do_load (SD_, AccessLength_WORD, GPR[BASE], EXTEND16 (OFFSET));
  }
#line 14515 "semantics.c"
  return nia;
  /* Extraction: LWU
       #undef do-not-use-icache
       6.0x27,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 14524 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SB_NORMAL (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SB_NORMAL
#undef SB_NORMAL
#undef MY_PREFIX
#define MY_PREFIX SB_NORMAL
#undef MY_NAME
#define MY_NAME "SB_NORMAL"

  /* Extraction: SB
       #define do-not-use-icache
       6.0x28,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 14551 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x28,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3154 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sb r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 14570 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SB_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3168 "./mips.igen"
    do_store (SD_, AccessLength_BYTE, GPR[BASE], EXTEND16 (OFFSET), GPR[RT]);
  }
#line 14598 "semantics.c"
  return nia;
  /* Extraction: SB
       #undef do-not-use-icache
       6.0x28,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 14607 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SH_NORMAL (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SH_NORMAL
#undef SH_NORMAL
#undef MY_PREFIX
#define MY_PREFIX SH_NORMAL
#undef MY_NAME
#define MY_NAME "SH_NORMAL"

  /* Extraction: SH
       #define do-not-use-icache
       6.0x29,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 14634 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x29,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3323 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sh r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 14653 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SH_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3337 "./mips.igen"
    do_store (SD_, AccessLength_HALFWORD, GPR[BASE], EXTEND16 (OFFSET), GPR[RT]);
  }
#line 14681 "semantics.c"
  return nia;
  /* Extraction: SH
       #undef do-not-use-icache
       6.0x29,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 14690 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SWL_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SWL_NORMAL
#undef SWL_NORMAL
#undef MY_PREFIX
#define MY_PREFIX SWL_NORMAL
#undef MY_NAME
#define MY_NAME "SWL_NORMAL"

  /* Extraction: SWL
       #define do-not-use-icache
       6.0x2a,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 14717 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x2a,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3730 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "swl r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 14736 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SWL_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3744 "./mips.igen"
    do_store_left (SD_, AccessLength_WORD, GPR[BASE], EXTEND16 (OFFSET), GPR[RT]);
  }
#line 14764 "semantics.c"
  return nia;
  /* Extraction: SWL
       #undef do-not-use-icache
       6.0x2a,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 14773 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SW_NORMAL (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SW_NORMAL
#undef SW_NORMAL
#undef MY_PREFIX
#define MY_PREFIX SW_NORMAL
#undef MY_NAME
#define MY_NAME "SW_NORMAL"

  /* Extraction: SW
       #define do-not-use-icache
       6.0x2b,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 14800 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x2b,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3692 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sw r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 14819 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SW_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3706 "./mips.igen"
    do_store (SD_, AccessLength_WORD, GPR[BASE], EXTEND16 (OFFSET), GPR[RT]);
  }
#line 14847 "semantics.c"
  return nia;
  /* Extraction: SW
       #undef do-not-use-icache
       6.0x2b,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 14856 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SDL_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SDL_NORMAL
#undef SDL_NORMAL
#undef MY_PREFIX
#define MY_PREFIX SDL_NORMAL
#undef MY_NAME
#define MY_NAME "SDL_NORMAL"

  /* Extraction: SDL
       #define do-not-use-icache
       6.0x2c,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 14883 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x2c,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3292 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sdl r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 14902 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SDL_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3301 "./mips.igen"
    check_u64 (SD_, instruction_0);
    do_store_left (SD_, AccessLength_DOUBLEWORD, GPR[BASE], EXTEND16 (OFFSET), GPR[RT]);
  }
#line 14931 "semantics.c"
  return nia;
  /* Extraction: SDL
       #undef do-not-use-icache
       6.0x2c,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 14940 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SDR_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SDR_NORMAL
#undef SDR_NORMAL
#undef MY_PREFIX
#define MY_PREFIX SDR_NORMAL
#undef MY_NAME
#define MY_NAME "SDR_NORMAL"

  /* Extraction: SDR
       #define do-not-use-icache
       6.0x2d,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 14967 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x2d,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3307 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sdr r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 14986 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SDR_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3316 "./mips.igen"
    check_u64 (SD_, instruction_0);
    do_store_right (SD_, AccessLength_DOUBLEWORD, GPR[BASE], EXTEND16 (OFFSET), GPR[RT]);
  }
#line 15015 "semantics.c"
  return nia;
  /* Extraction: SDR
       #undef do-not-use-icache
       6.0x2d,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 15024 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SWR_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SWR_NORMAL
#undef SWR_NORMAL
#undef MY_PREFIX
#define MY_PREFIX SWR_NORMAL
#undef MY_NAME
#define MY_NAME "SWR_NORMAL"

  /* Extraction: SWR
       #define do-not-use-icache
       6.0x2e,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 15051 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x2e,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3749 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "swr r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 15070 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SWR_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3763 "./mips.igen"
    do_store_right (SD_, AccessLength_WORD, GPR[BASE], EXTEND16 (OFFSET), GPR[RT]);
  }
#line 15098 "semantics.c"
  return nia;
  /* Extraction: SWR
       #undef do-not-use-icache
       6.0x2e,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 15107 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_CACHE_NORMAL (SIM_DESC sd,
                       instruction_word instruction_0,
                       instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_CACHE_NORMAL
#undef CACHE_NORMAL
#undef MY_PREFIX
#define MY_PREFIX CACHE_NORMAL
#undef MY_NAME
#define MY_NAME "CACHE_NORMAL"

  /* Extraction: CACHE
       #define do-not-use-icache
       6.0x2f,5.BASE,5.OP,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef OP
#define OP ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 15134 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x2f,5.BASE,5.OP,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5747 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "cache %ld, %ld(r%ld)", \
                    (long) OP, \
                    (long) OFFSET, \
                    (long) BASE);
#line 15153 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_CACHE_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5759 "./mips.igen"
    address_word base = GPR[BASE];
    address_word offset = EXTEND16 (OFFSET);
    {
      address_word vaddr = loadstore_ea (SD_, base, offset);
      address_word paddr;
      int uncached;
      if (AddressTranslation(vaddr,isDATA,isLOAD,&paddr,&uncached,isTARGET,isREAL))
        CacheOp(OP,vaddr,paddr,instruction_0);
    }
  }
#line 15189 "semantics.c"
  return nia;
  /* Extraction: CACHE
       #undef do-not-use-icache
       6.0x2f,5.BASE,5.OP,16.OFFSET */

#undef BASE
#undef OP
#undef OFFSET
#line 15198 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LWCz_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LWCz_NORMAL
#undef LWCz_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LWCz_NORMAL
#undef MY_NAME
#define MY_NAME "LWCz_NORMAL"

  /* Extraction: LWCz
       #define do-not-use-icache
       4.0xc,2.ZZ!0!1!3,5.BASE,5.RT,16.OFFSET */

#undef ZZ
#define ZZ ((unsigned) EXTRACTED32 (instruction_0, 27, 26)) /* cache - extraction */
#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 15227 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 4.0xc,2.ZZ!0!1!3,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2359 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lwc%ld r%ld, %ld(r%ld)", \
                    (long) ZZ, \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 15247 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LWCz_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2373 "./mips.igen"
    COP_LW (ZZ, RT, do_load (SD_, AccessLength_WORD, GPR[BASE], EXTEND16 (OFFSET)));
  }
#line 15275 "semantics.c"
  return nia;
  /* Extraction: LWCz
       #undef do-not-use-icache
       4.0xc,2.ZZ!0!1!3,5.BASE,5.RT,16.OFFSET */

#undef ZZ
#undef BASE
#undef RT
#undef OFFSET
#line 15285 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LL_NORMAL (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LL_NORMAL
#undef LL_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LL_NORMAL
#undef MY_NAME
#define MY_NAME "LL_NORMAL"

  /* Extraction: LL
       #define do-not-use-icache
       6.0x30,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 15312 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x30,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2238 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "ll r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 15331 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LL_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2250 "./mips.igen"
    address_word base = GPR[BASE];
    address_word offset = EXTEND16 (OFFSET);
    {
      address_word vaddr = loadstore_ea (SD_, base, offset);
      address_word paddr;
      int uncached;
      if ((vaddr & 3) != 0)
        {
          SIM_CORE_SIGNAL (SD, CPU, cia, read_map, 4, vaddr, read_transfer, sim_core_unaligned_signal);
        }
      else
        {
    	if (AddressTranslation(vaddr,isDATA,isLOAD,&paddr,&uncached,isTARGET,isREAL))
    	  {
    	    unsigned64 memval = 0;
    	    unsigned64 memval1 = 0;
    	    unsigned64 mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
    	    unsigned int shift = 2;
    	    unsigned int reverse = (ReverseEndian ? (mask >> shift) : 0);
    	    unsigned int bigend = (BigEndianCPU ? (mask >> shift) : 0);
    	    unsigned int byte;
    	    paddr = ((paddr & ~mask) | ((paddr & mask) ^ (reverse << shift)));
    	    LoadMemory(&memval,&memval1,uncached,AccessLength_WORD,paddr,vaddr,isDATA,isREAL);
    	    byte = ((vaddr & mask) ^ (bigend << shift));
    	    GPR[RT] = EXTEND32 (memval >> (8 * byte));
    	    LLBIT = 1;
    	  }
        }
    }
  }
#line 15387 "semantics.c"
  return nia;
  /* Extraction: LL
       #undef do-not-use-icache
       6.0x30,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 15396 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LWC1_COP1 (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LWC1_COP1
#undef LWC1_COP1
#undef MY_PREFIX
#define MY_PREFIX LWC1_COP1
#undef MY_NAME
#define MY_NAME "LWC1_COP1"

  /* Extraction: LWC1
       #define do-not-use-icache
       6.0x31,5.BASE,5.FT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 15423 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x31,5.BASE,5.FT,16.OFFSET */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4936 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lwc1 f%ld, %ld(r%ld)", \
                    (long) FT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 15456 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LWC1_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4950 "./mips.igen"
    check_fpu (SD_);
    COP_LW (1, FT, do_load (SD_, AccessLength_WORD, GPR[BASE], EXTEND16 (OFFSET)));
  }
#line 15485 "semantics.c"
  return nia;
  /* Extraction: LWC1
       #undef do-not-use-icache
       6.0x31,5.BASE,5.FT,16.OFFSET */

#undef BASE
#undef FT
#undef OFFSET
#line 15494 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_PREF_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_PREF_NORMAL
#undef PREF_NORMAL
#undef MY_PREFIX
#define MY_PREFIX PREF_NORMAL
#undef MY_NAME
#define MY_NAME "PREF_NORMAL"

  /* Extraction: PREF
       #define do-not-use-icache
       6.0x33,5.BASE,5.HINT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef HINT
#define HINT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 15521 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x33,5.BASE,5.HINT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3006 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "pref %ld, %ld(r%ld)", \
                    (long) HINT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 15540 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_PREF_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3015 "./mips.igen"
    address_word base = GPR[BASE];
    address_word offset = EXTEND16 (OFFSET);
    {
      address_word vaddr = loadstore_ea (SD_, base, offset);
      address_word paddr;
      int uncached;
      {
        if (AddressTranslation(vaddr,isDATA,isLOAD,&paddr,&uncached,isTARGET,isREAL))
    	Prefetch(uncached,paddr,vaddr,isDATA,HINT);
      }
    }
  }
#line 15578 "semantics.c"
  return nia;
  /* Extraction: PREF
       #undef do-not-use-icache
       6.0x33,5.BASE,5.HINT,16.OFFSET */

#undef BASE
#undef HINT
#undef OFFSET
#line 15587 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LDCz_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LDCz_NORMAL
#undef LDCz_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LDCz_NORMAL
#undef MY_NAME
#define MY_NAME "LDCz_NORMAL"

  /* Extraction: LDCz
       #define do-not-use-icache
       4.0xd,2.ZZ!0!1!3,5.BASE,5.RT,16.OFFSET */

#undef ZZ
#define ZZ ((unsigned) EXTRACTED32 (instruction_0, 27, 26)) /* cache - extraction */
#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 15616 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 4.0xd,2.ZZ!0!1!3,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2150 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "ldc%ld r%ld, %ld(r%ld)", \
                    (long) ZZ, \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 15636 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LDCz_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2163 "./mips.igen"
    COP_LD (ZZ, RT, do_load (SD_, AccessLength_DOUBLEWORD, GPR[BASE], EXTEND16 (OFFSET)));
  }
#line 15664 "semantics.c"
  return nia;
  /* Extraction: LDCz
       #undef do-not-use-icache
       4.0xd,2.ZZ!0!1!3,5.BASE,5.RT,16.OFFSET */

#undef ZZ
#undef BASE
#undef RT
#undef OFFSET
#line 15674 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LLD_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LLD_NORMAL
#undef LLD_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LLD_NORMAL
#undef MY_NAME
#define MY_NAME "LLD_NORMAL"

  /* Extraction: LLD
       #define do-not-use-icache
       6.0x34,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 15701 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x34,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2283 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "lld r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 15720 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LLD_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2292 "./mips.igen"
    address_word base = GPR[BASE];
    address_word offset = EXTEND16 (OFFSET);
    check_u64 (SD_, instruction_0);
    {
      address_word vaddr = loadstore_ea (SD_, base, offset);
      address_word paddr;
      int uncached;
      if ((vaddr & 7) != 0)
        {
    	SIM_CORE_SIGNAL (SD, CPU, cia, read_map, 8, vaddr, read_transfer, sim_core_unaligned_signal);
        }
      else
        {
    	if (AddressTranslation(vaddr,isDATA,isLOAD,&paddr,&uncached,isTARGET,isREAL))
    	  {
    	    unsigned64 memval = 0;
    	    unsigned64 memval1 = 0;
    	    LoadMemory(&memval,&memval1,uncached,AccessLength_DOUBLEWORD,paddr,vaddr,isDATA,isREAL);
    	    GPR[RT] = memval;
    	    LLBIT = 1;
    	  }
        }
    }
  }
#line 15770 "semantics.c"
  return nia;
  /* Extraction: LLD
       #undef do-not-use-icache
       6.0x34,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 15779 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LDC1b_COP1 (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LDC1b_COP1
#undef LDC1b_COP1
#undef MY_PREFIX
#define MY_PREFIX LDC1b_COP1
#undef MY_NAME
#define MY_NAME "LDC1b_COP1"

  /* Extraction: LDC1b
       #define do-not-use-icache
       6.0x35,5.BASE,5.FT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 15806 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x35,5.BASE,5.FT,16.OFFSET */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 4860 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "ldc1 f%ld, %ld(r%ld)", \
                    (long) FT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 15839 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LDC1b_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 4870 "./mips.igen"
    check_fpu (SD_);
    COP_LD (1, FT, do_load (SD_, AccessLength_DOUBLEWORD, GPR[BASE], EXTEND16 (OFFSET)));
  }
#line 15868 "semantics.c"
  return nia;
  /* Extraction: LDC1b
       #undef do-not-use-icache
       6.0x35,5.BASE,5.FT,16.OFFSET */

#undef BASE
#undef FT
#undef OFFSET
#line 15877 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_LD_NORMAL (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_LD_NORMAL
#undef LD_NORMAL
#undef MY_PREFIX
#define MY_PREFIX LD_NORMAL
#undef MY_NAME
#define MY_NAME "LD_NORMAL"

  /* Extraction: LD
       #define do-not-use-icache
       6.0x37,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 15904 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x37,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 2135 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "ld r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 15923 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_LD_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 2144 "./mips.igen"
    check_u64 (SD_, instruction_0);
    GPR[RT] = EXTEND64 (do_load (SD_, AccessLength_DOUBLEWORD, GPR[BASE], EXTEND16 (OFFSET)));
  }
#line 15952 "semantics.c"
  return nia;
  /* Extraction: LD
       #undef do-not-use-icache
       6.0x37,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 15961 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SWCz_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SWCz_NORMAL
#undef SWCz_NORMAL
#undef MY_PREFIX
#define MY_PREFIX SWCz_NORMAL
#undef MY_NAME
#define MY_NAME "SWCz_NORMAL"

  /* Extraction: SWCz
       #define do-not-use-icache
       4.0xe,2.ZZ!0!1!3,5.BASE,5.RT,16.OFFSET */

#undef ZZ
#define ZZ ((unsigned) EXTRACTED32 (instruction_0, 27, 26)) /* cache - extraction */
#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 15990 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 4.0xe,2.ZZ!0!1!3,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3711 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "swc%ld r%ld, %ld(r%ld)", \
                    (long) ZZ, \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 16010 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SWCz_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3725 "./mips.igen"
    do_store (SD_, AccessLength_WORD, GPR[BASE], EXTEND16 (OFFSET), COP_SW (ZZ, RT));
  }
#line 16038 "semantics.c"
  return nia;
  /* Extraction: SWCz
       #undef do-not-use-icache
       4.0xe,2.ZZ!0!1!3,5.BASE,5.RT,16.OFFSET */

#undef ZZ
#undef BASE
#undef RT
#undef OFFSET
#line 16048 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SC_NORMAL (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SC_NORMAL
#undef SC_NORMAL
#undef MY_PREFIX
#define MY_PREFIX SC_NORMAL
#undef MY_NAME
#define MY_NAME "SC_NORMAL"

  /* Extraction: SC
       #define do-not-use-icache
       6.0x38,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 16075 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x38,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3173 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sc r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 16094 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SC_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3185 "./mips.igen"
    unsigned32 instruction = instruction_0;
    address_word base = GPR[BASE];
    address_word offset = EXTEND16 (OFFSET);
    {
      address_word vaddr = loadstore_ea (SD_, base, offset);
      address_word paddr;
      int uncached;
      if ((vaddr & 3) != 0)
        {
    	SIM_CORE_SIGNAL (SD, CPU, cia, read_map, 4, vaddr, write_transfer, sim_core_unaligned_signal);
        }
      else
        {
    	if (AddressTranslation(vaddr,isDATA,isSTORE,&paddr,&uncached,isTARGET,isREAL))
    	  {
    	    unsigned64 memval = 0;
    	    unsigned64 memval1 = 0;
    	    unsigned64 mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
    	    address_word reverseendian = (ReverseEndian ? (mask ^ AccessLength_WORD) : 0);
    	    address_word bigendiancpu = (BigEndianCPU ? (mask ^ AccessLength_WORD) : 0);
    	    unsigned int byte;
    	    paddr = ((paddr & ~mask) | ((paddr & mask) ^ reverseendian));
    	    byte = ((vaddr & mask) ^ bigendiancpu);
    	    memval = ((unsigned64) GPR[RT] << (8 * byte));
    	    if (LLBIT)
    	      {
    		StoreMemory(uncached,AccessLength_WORD,memval,memval1,paddr,vaddr,isREAL);
    	      }
    	    GPR[RT] = LLBIT;
    	  }
        }
    }
  }
#line 16153 "semantics.c"
  return nia;
  /* Extraction: SC
       #undef do-not-use-icache
       6.0x38,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 16162 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SWC1_COP1 (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SWC1_COP1
#undef SWC1_COP1
#undef MY_PREFIX
#define MY_PREFIX SWC1_COP1
#undef MY_NAME
#define MY_NAME "SWC1_COP1"

  /* Extraction: SWC1
       #define do-not-use-icache
       6.0x39,5.BASE,5.FT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 16189 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x39,5.BASE,5.FT,16.OFFSET */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5543 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "swc1 f%ld, %ld(r%ld)", \
                    (long) FT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 16222 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SWC1_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5557 "./mips.igen"
    address_word base = GPR[BASE];
    address_word offset = EXTEND16 (OFFSET);
    check_fpu (SD_);
    {
      address_word vaddr = loadstore_ea (SD_, base, offset);
      address_word paddr;
      int uncached;
      if ((vaddr & 3) != 0)
        {
    	SIM_CORE_SIGNAL (SD, CPU, cia, read_map, AccessLength_WORD+1, vaddr, write_transfer, sim_core_unaligned_signal);
        }
      else
        {
    	if (AddressTranslation(vaddr,isDATA,isSTORE,&paddr,&uncached,isTARGET,isREAL))
    	  {
    	    uword64 memval = 0;
    	    uword64 memval1 = 0;
    	    uword64 mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
    	    address_word reverseendian = (ReverseEndian ?(mask ^ AccessLength_WORD): 0);
    	    address_word bigendiancpu = (BigEndianCPU ?(mask ^ AccessLength_WORD): 0);
    	    unsigned int byte;
    	    paddr = ((paddr & ~mask) | ((paddr & mask) ^ reverseendian));
    	    byte = ((vaddr & mask) ^ bigendiancpu);
    	    memval = (((uword64)COP_SW(((instruction_0 >> 26) & 0x3),FT)) << (8 * byte));
    	    StoreMemory(uncached,AccessLength_WORD,memval,memval1,paddr,vaddr,isREAL);
    	  }
        }
    }
  }
#line 16277 "semantics.c"
  return nia;
  /* Extraction: SWC1
       #undef do-not-use-icache
       6.0x39,5.BASE,5.FT,16.OFFSET */

#undef BASE
#undef FT
#undef OFFSET
#line 16286 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SDCz_NORMAL (SIM_DESC sd,
                      instruction_word instruction_0,
                      instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SDCz_NORMAL
#undef SDCz_NORMAL
#undef MY_PREFIX
#define MY_PREFIX SDCz_NORMAL
#undef MY_NAME
#define MY_NAME "SDCz_NORMAL"

  /* Extraction: SDCz
       #define do-not-use-icache
       4.0xf,2.ZZ!0!1!3,5.BASE,5.RT,16.OFFSET */

#undef ZZ
#define ZZ ((unsigned) EXTRACTED32 (instruction_0, 27, 26)) /* cache - extraction */
#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 16315 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 4.0xf,2.ZZ!0!1!3,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3275 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sdc%ld r%ld, %ld(r%ld)", \
                    (long) ZZ, \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 16335 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SDCz_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3287 "./mips.igen"
    do_store (SD_, AccessLength_DOUBLEWORD, GPR[BASE], EXTEND16 (OFFSET), COP_SD (ZZ, RT));
  }
#line 16363 "semantics.c"
  return nia;
  /* Extraction: SDCz
       #undef do-not-use-icache
       4.0xf,2.ZZ!0!1!3,5.BASE,5.RT,16.OFFSET */

#undef ZZ
#undef BASE
#undef RT
#undef OFFSET
#line 16373 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SCD_NORMAL (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SCD_NORMAL
#undef SCD_NORMAL
#undef MY_PREFIX
#define MY_PREFIX SCD_NORMAL
#undef MY_NAME
#define MY_NAME "SCD_NORMAL"

  /* Extraction: SCD
       #define do-not-use-icache
       6.0x3c,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 16400 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x3c,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3221 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "scd r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 16419 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SCD_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3230 "./mips.igen"
    address_word base = GPR[BASE];
    address_word offset = EXTEND16 (OFFSET);
    check_u64 (SD_, instruction_0);
    {
      address_word vaddr = loadstore_ea (SD_, base, offset);
      address_word paddr;
      int uncached;
      if ((vaddr & 7) != 0)
        {
    	SIM_CORE_SIGNAL (SD, CPU, cia, read_map, 8, vaddr, write_transfer, sim_core_unaligned_signal);
        }
      else
        {
    	if (AddressTranslation(vaddr,isDATA,isSTORE,&paddr,&uncached,isTARGET,isREAL))
    	  {
    	    unsigned64 memval = 0;
    	    unsigned64 memval1 = 0;
    	    memval = GPR[RT];
    	    if (LLBIT)
    	      {
    		StoreMemory(uncached,AccessLength_DOUBLEWORD,memval,memval1,paddr,vaddr,isREAL);
    	      }
    	    GPR[RT] = LLBIT;
    	  }
        }
    }
  }
#line 16472 "semantics.c"
  return nia;
  /* Extraction: SCD
       #undef do-not-use-icache
       6.0x3c,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 16481 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SDC1b_COP1 (SIM_DESC sd,
                     instruction_word instruction_0,
                     instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SDC1b_COP1
#undef SDC1b_COP1
#undef MY_PREFIX
#define MY_PREFIX SDC1b_COP1
#undef MY_NAME
#define MY_NAME "SDC1b_COP1"

  /* Extraction: SDC1b
       #define do-not-use-icache
       6.0x3d,5.BASE,5.FT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef FT
#define FT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 16508 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x3d,5.BASE,5.FT,16.OFFSET */
#endif

#if defined(CURRENT_FLOATING_POINT)
  /* Validate: FP hardware exists */
  if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {
    return semantic_illegal (sd, cia);
  }
#endif

#if defined(IS_FP_AVAILABLE)
  /* Validate: FP available according to cpu */
  if (!IS_FP_AVAILABLE) {
    return semantic_fp_unavailable (sd, cia);
  }
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 5424 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sdc1 f%ld, %ld(r%ld)", \
                    (long) FT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 16541 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SDC1b_COP1, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 5434 "./mips.igen"
    check_fpu (SD_);
    do_store (SD_, AccessLength_DOUBLEWORD, GPR[BASE], EXTEND16 (OFFSET), COP_SD (1, FT));
  }
#line 16570 "semantics.c"
  return nia;
  /* Extraction: SDC1b
       #undef do-not-use-icache
       6.0x3d,5.BASE,5.FT,16.OFFSET */

#undef BASE
#undef FT
#undef OFFSET
#line 16579 "semantics.c"
}

EXTERN_SEMANTICS\
(instruction_address)
semantic_SD_NORMAL (SIM_DESC sd,
                    instruction_word instruction_0,
                    instruction_address cia)
{
#undef MY_INDEX
#define MY_INDEX itable_SD_NORMAL
#undef SD_NORMAL
#undef MY_PREFIX
#define MY_PREFIX SD_NORMAL
#undef MY_NAME
#define MY_NAME "SD_NORMAL"

  /* Extraction: SD
       #define do-not-use-icache
       6.0x3f,5.BASE,5.RT,16.OFFSET */

#undef BASE
#define BASE ((unsigned) EXTRACTED32 (instruction_0, 25, 21)) /* cache - extraction */
#undef RT
#define RT ((unsigned) EXTRACTED32 (instruction_0, 20, 16)) /* cache - extraction */
#undef OFFSET
#define OFFSET ((unsigned) MASKED32 (instruction_0, 15, 0)) /* cache - extraction */
#line 16606 "semantics.c"
  instruction_address nia;

#if defined (WITH_RESERVED_BITS)
  /* validate: 6.0x3f,5.BASE,5.RT,16.OFFSET */
#endif

#if defined (WITH_TRACE)
  /* generate a trace prefix if any tracing enabled */
  if (TRACE_ANY_P (CPU))
    {
#line 3260 "./mips.igen"
      trace_prefix (SD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \
                    itable[MY_INDEX].file, \
                    itable[MY_INDEX].line_nr, \
                    "sd r%ld, %ld(r%ld)", \
                    (long) RT, \
                    (long) OFFSET, \
                    (long) BASE);
#line 16625 "semantics.c"
      /* trace the instruction execution if enabled */
      if (TRACE_INSN_P (CPU))
        trace_generic (SD, CPU, TRACE_INSN_IDX, " %s", itable[MY_INDEX].name);
    }
#endif

#if defined (PROFILE_COUNT_INSN)
  PROFILE_COUNT_INSN (CPU, CIA, MY_INDEX);
#endif

#if defined (WITH_MON)
  /* monitoring: */
  if (WITH_MON & MONITOR_INSTRUCTION_ISSUE)
    mon_issue (itable_SD_NORMAL, cpu, cia);
#endif

  /* keep the next instruction address handy */
  nia = cia + 4;

  /* Architecture expects REG to be zero */
  GPR_CLEAR(0);

  /* semantics: */
  {
#line 3269 "./mips.igen"
    check_u64 (SD_, instruction_0);
    do_store (SD_, AccessLength_DOUBLEWORD, GPR[BASE], EXTEND16 (OFFSET), GPR[RT]);
  }
#line 16654 "semantics.c"
  return nia;
  /* Extraction: SD
       #undef do-not-use-icache
       6.0x3f,5.BASE,5.RT,16.OFFSET */

#undef BASE
#undef RT
#undef OFFSET
#line 16663 "semantics.c"
}

#endif /* _SEMANTICS_C_*/
