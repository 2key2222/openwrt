The system is: Linux - 4.4.0-148-generic - x86_64
Compiling the C compiler identification source file "CMakeCCompilerId.c" succeeded.
Compiler: /usr/bin/gcc 
Build flags: 
Id flags: 

The output was:
0


Compilation of the C compiler identification source "CMakeCCompilerId.c" produced "a.out"

The C compiler identification is GNU, found in "/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/2.8.12.2/CompilerIdC/a.out"

Compiling the CXX compiler identification source file "CMakeCXXCompilerId.cpp" succeeded.
Compiler: /usr/bin/g++ 
Build flags: 
Id flags: 

The output was:
0


Compilation of the CXX compiler identification source "CMakeCXXCompilerId.cpp" produced "a.out"

The CXX compiler identification is GNU, found in "/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/2.8.12.2/CompilerIdCXX/a.out"

Determining if the C compiler works passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4015378772/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec4015378772.dir/build.make CMakeFiles/cmTryCompileExec4015378772.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4015378772.dir/testCCompiler.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec4015378772.dir/testCCompiler.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/testCCompiler.c
Linking C executable cmTryCompileExec4015378772
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4015378772.dir/link.txt --verbose=1
/usr/bin/gcc       CMakeFiles/cmTryCompileExec4015378772.dir/testCCompiler.c.o  -o cmTryCompileExec4015378772 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Detecting C compiler ABI info compiled with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3347554162/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3347554162.dir/build.make CMakeFiles/cmTryCompileExec3347554162.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3347554162.dir/CMakeCCompilerABI.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3347554162.dir/CMakeCCompilerABI.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CMakeCCompilerABI.c
Linking C executable cmTryCompileExec3347554162
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3347554162.dir/link.txt --verbose=1
/usr/bin/gcc     -v CMakeFiles/cmTryCompileExec3347554162.dir/CMakeCCompilerABI.c.o  -o cmTryCompileExec3347554162 -rdynamic  
Using built-in specs.
COLLECT_GCC=/usr/bin/gcc
COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/4.8/lto-wrapper
Target: x86_64-linux-gnu
Configured with: ../src/configure -v --with-pkgversion='Ubuntu 4.8.4-2ubuntu1~14.04.4' --with-bugurl=file:///usr/share/doc/gcc-4.8/README.Bugs --enable-languages=c,c++,java,go,d,fortran,objc,obj-c++ --prefix=/usr --program-suffix=-4.8 --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --with-gxx-include-dir=/usr/include/c++/4.8 --libdir=/usr/lib --enable-nls --with-sysroot=/ --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --enable-gnu-unique-object --disable-libmudflap --enable-plugin --with-system-zlib --disable-browser-plugin --enable-java-awt=gtk --enable-gtk-cairo --with-java-home=/usr/lib/jvm/java-1.5.0-gcj-4.8-amd64/jre --enable-java-home --with-jvm-root-dir=/usr/lib/jvm/java-1.5.0-gcj-4.8-amd64 --with-jvm-jar-dir=/usr/lib/jvm-exports/java-1.5.0-gcj-4.8-amd64 --with-arch-directory=amd64 --with-ecj-jar=/usr/share/java/eclipse-ecj.jar --enable-objc-gc --enable-multiarch --disable-werror --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --with-tune=generic --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu
Thread model: posix
gcc version 4.8.4 (Ubuntu 4.8.4-2ubuntu1~14.04.4) 
COMPILER_PATH=/usr/lib/gcc/x86_64-linux-gnu/4.8/:/usr/lib/gcc/x86_64-linux-gnu/4.8/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/4.8/:/usr/lib/gcc/x86_64-linux-gnu/
LIBRARY_PATH=/usr/lib/gcc/x86_64-linux-gnu/4.8/:/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../lib/:/lib/x86_64-linux-gnu/:/lib/../lib/:/usr/lib/x86_64-linux-gnu/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../:/lib/:/usr/lib/
COLLECT_GCC_OPTIONS='-v' '-o' 'cmTryCompileExec3347554162' '-rdynamic' '-mtune=generic' '-march=x86-64'
 /usr/lib/gcc/x86_64-linux-gnu/4.8/collect2 --sysroot=/ --build-id --eh-frame-hdr -m elf_x86_64 --hash-style=gnu --as-needed -export-dynamic -dynamic-linker /lib64/ld-linux-x86-64.so.2 -z relro -o cmTryCompileExec3347554162 /usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/crt1.o /usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/4.8/crtbegin.o -L/usr/lib/gcc/x86_64-linux-gnu/4.8 -L/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../lib -L/lib/x86_64-linux-gnu -L/lib/../lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/4.8/../../.. CMakeFiles/cmTryCompileExec3347554162.dir/CMakeCCompilerABI.c.o -lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed -lgcc_s --no-as-needed /usr/lib/gcc/x86_64-linux-gnu/4.8/crtend.o /usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/crtn.o
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Parsed C implicit link information from above output:
  link line regex: [^( *|.*[/\])(ld|([^/\]+-)?ld|collect2)[^/\]*( |$)]
  ignore line: [Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp]
  ignore line: []
  ignore line: [Run Build Command:/usr/bin/make "cmTryCompileExec3347554162/fast"]
  ignore line: [make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp']
  ignore line: [make -f CMakeFiles/cmTryCompileExec3347554162.dir/build.make CMakeFiles/cmTryCompileExec3347554162.dir/build]
  ignore line: [make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp']
  ignore line: [/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1]
  ignore line: [Building C object CMakeFiles/cmTryCompileExec3347554162.dir/CMakeCCompilerABI.c.o]
  ignore line: [/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3347554162.dir/CMakeCCompilerABI.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CMakeCCompilerABI.c]
  ignore line: [Linking C executable cmTryCompileExec3347554162]
  ignore line: [/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3347554162.dir/link.txt --verbose=1]
  ignore line: [/usr/bin/gcc     -v CMakeFiles/cmTryCompileExec3347554162.dir/CMakeCCompilerABI.c.o  -o cmTryCompileExec3347554162 -rdynamic  ]
  ignore line: [Using built-in specs.]
  ignore line: [COLLECT_GCC=/usr/bin/gcc]
  ignore line: [COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/4.8/lto-wrapper]
  ignore line: [Target: x86_64-linux-gnu]
  ignore line: [Configured with: ../src/configure -v --with-pkgversion='Ubuntu 4.8.4-2ubuntu1~14.04.4' --with-bugurl=file:///usr/share/doc/gcc-4.8/README.Bugs --enable-languages=c,c++,java,go,d,fortran,objc,obj-c++ --prefix=/usr --program-suffix=-4.8 --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --with-gxx-include-dir=/usr/include/c++/4.8 --libdir=/usr/lib --enable-nls --with-sysroot=/ --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --enable-gnu-unique-object --disable-libmudflap --enable-plugin --with-system-zlib --disable-browser-plugin --enable-java-awt=gtk --enable-gtk-cairo --with-java-home=/usr/lib/jvm/java-1.5.0-gcj-4.8-amd64/jre --enable-java-home --with-jvm-root-dir=/usr/lib/jvm/java-1.5.0-gcj-4.8-amd64 --with-jvm-jar-dir=/usr/lib/jvm-exports/java-1.5.0-gcj-4.8-amd64 --with-arch-directory=amd64 --with-ecj-jar=/usr/share/java/eclipse-ecj.jar --enable-objc-gc --enable-multiarch --disable-werror --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --with-tune=generic --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu]
  ignore line: [Thread model: posix]
  ignore line: [gcc version 4.8.4 (Ubuntu 4.8.4-2ubuntu1~14.04.4) ]
  ignore line: [COMPILER_PATH=/usr/lib/gcc/x86_64-linux-gnu/4.8/:/usr/lib/gcc/x86_64-linux-gnu/4.8/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/4.8/:/usr/lib/gcc/x86_64-linux-gnu/]
  ignore line: [LIBRARY_PATH=/usr/lib/gcc/x86_64-linux-gnu/4.8/:/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../lib/:/lib/x86_64-linux-gnu/:/lib/../lib/:/usr/lib/x86_64-linux-gnu/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../:/lib/:/usr/lib/]
  ignore line: [COLLECT_GCC_OPTIONS='-v' '-o' 'cmTryCompileExec3347554162' '-rdynamic' '-mtune=generic' '-march=x86-64']
  link line: [ /usr/lib/gcc/x86_64-linux-gnu/4.8/collect2 --sysroot=/ --build-id --eh-frame-hdr -m elf_x86_64 --hash-style=gnu --as-needed -export-dynamic -dynamic-linker /lib64/ld-linux-x86-64.so.2 -z relro -o cmTryCompileExec3347554162 /usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/crt1.o /usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/4.8/crtbegin.o -L/usr/lib/gcc/x86_64-linux-gnu/4.8 -L/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../lib -L/lib/x86_64-linux-gnu -L/lib/../lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/4.8/../../.. CMakeFiles/cmTryCompileExec3347554162.dir/CMakeCCompilerABI.c.o -lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed -lgcc_s --no-as-needed /usr/lib/gcc/x86_64-linux-gnu/4.8/crtend.o /usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/crtn.o]
    arg [/usr/lib/gcc/x86_64-linux-gnu/4.8/collect2] ==> ignore
    arg [--sysroot=/] ==> ignore
    arg [--build-id] ==> ignore
    arg [--eh-frame-hdr] ==> ignore
    arg [-m] ==> ignore
    arg [elf_x86_64] ==> ignore
    arg [--hash-style=gnu] ==> ignore
    arg [--as-needed] ==> ignore
    arg [-export-dynamic] ==> ignore
    arg [-dynamic-linker] ==> ignore
    arg [/lib64/ld-linux-x86-64.so.2] ==> ignore
    arg [-zrelro] ==> ignore
    arg [-o] ==> ignore
    arg [cmTryCompileExec3347554162] ==> ignore
    arg [/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/crt1.o] ==> ignore
    arg [/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/crti.o] ==> ignore
    arg [/usr/lib/gcc/x86_64-linux-gnu/4.8/crtbegin.o] ==> ignore
    arg [-L/usr/lib/gcc/x86_64-linux-gnu/4.8] ==> dir [/usr/lib/gcc/x86_64-linux-gnu/4.8]
    arg [-L/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu] ==> dir [/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu]
    arg [-L/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../lib] ==> dir [/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../lib]
    arg [-L/lib/x86_64-linux-gnu] ==> dir [/lib/x86_64-linux-gnu]
    arg [-L/lib/../lib] ==> dir [/lib/../lib]
    arg [-L/usr/lib/x86_64-linux-gnu] ==> dir [/usr/lib/x86_64-linux-gnu]
    arg [-L/usr/lib/../lib] ==> dir [/usr/lib/../lib]
    arg [-L/usr/lib/gcc/x86_64-linux-gnu/4.8/../../..] ==> dir [/usr/lib/gcc/x86_64-linux-gnu/4.8/../../..]
    arg [CMakeFiles/cmTryCompileExec3347554162.dir/CMakeCCompilerABI.c.o] ==> ignore
    arg [-lgcc] ==> lib [gcc]
    arg [--as-needed] ==> ignore
    arg [-lgcc_s] ==> lib [gcc_s]
    arg [--no-as-needed] ==> ignore
    arg [-lc] ==> lib [c]
    arg [-lgcc] ==> lib [gcc]
    arg [--as-needed] ==> ignore
    arg [-lgcc_s] ==> lib [gcc_s]
    arg [--no-as-needed] ==> ignore
    arg [/usr/lib/gcc/x86_64-linux-gnu/4.8/crtend.o] ==> ignore
    arg [/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/crtn.o] ==> ignore
  remove lib [gcc]
  remove lib [gcc_s]
  remove lib [gcc]
  remove lib [gcc_s]
  collapse library dir [/usr/lib/gcc/x86_64-linux-gnu/4.8] ==> [/usr/lib/gcc/x86_64-linux-gnu/4.8]
  collapse library dir [/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu] ==> [/usr/lib/x86_64-linux-gnu]
  collapse library dir [/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../lib] ==> [/usr/lib]
  collapse library dir [/lib/x86_64-linux-gnu] ==> [/lib/x86_64-linux-gnu]
  collapse library dir [/lib/../lib] ==> [/lib]
  collapse library dir [/usr/lib/x86_64-linux-gnu] ==> [/usr/lib/x86_64-linux-gnu]
  collapse library dir [/usr/lib/../lib] ==> [/usr/lib]
  collapse library dir [/usr/lib/gcc/x86_64-linux-gnu/4.8/../../..] ==> [/usr/lib]
  implicit libs: [c]
  implicit dirs: [/usr/lib/gcc/x86_64-linux-gnu/4.8;/usr/lib/x86_64-linux-gnu;/usr/lib;/lib/x86_64-linux-gnu;/lib]
  implicit fwks: []


Determining if the CXX compiler works passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec65755702/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec65755702.dir/build.make CMakeFiles/cmTryCompileExec65755702.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec65755702.dir/testCXXCompiler.cxx.o
/usr/bin/g++     -o CMakeFiles/cmTryCompileExec65755702.dir/testCXXCompiler.cxx.o -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/testCXXCompiler.cxx
Linking CXX executable cmTryCompileExec65755702
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec65755702.dir/link.txt --verbose=1
/usr/bin/g++        CMakeFiles/cmTryCompileExec65755702.dir/testCXXCompiler.cxx.o  -o cmTryCompileExec65755702 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Detecting CXX compiler ABI info compiled with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2273648959/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2273648959.dir/build.make CMakeFiles/cmTryCompileExec2273648959.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2273648959.dir/CMakeCXXCompilerABI.cpp.o
/usr/bin/g++     -o CMakeFiles/cmTryCompileExec2273648959.dir/CMakeCXXCompilerABI.cpp.o -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CMakeCXXCompilerABI.cpp
Linking CXX executable cmTryCompileExec2273648959
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2273648959.dir/link.txt --verbose=1
/usr/bin/g++      -v CMakeFiles/cmTryCompileExec2273648959.dir/CMakeCXXCompilerABI.cpp.o  -o cmTryCompileExec2273648959 -rdynamic  
Using built-in specs.
COLLECT_GCC=/usr/bin/g++
COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/4.8/lto-wrapper
Target: x86_64-linux-gnu
Configured with: ../src/configure -v --with-pkgversion='Ubuntu 4.8.4-2ubuntu1~14.04.4' --with-bugurl=file:///usr/share/doc/gcc-4.8/README.Bugs --enable-languages=c,c++,java,go,d,fortran,objc,obj-c++ --prefix=/usr --program-suffix=-4.8 --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --with-gxx-include-dir=/usr/include/c++/4.8 --libdir=/usr/lib --enable-nls --with-sysroot=/ --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --enable-gnu-unique-object --disable-libmudflap --enable-plugin --with-system-zlib --disable-browser-plugin --enable-java-awt=gtk --enable-gtk-cairo --with-java-home=/usr/lib/jvm/java-1.5.0-gcj-4.8-amd64/jre --enable-java-home --with-jvm-root-dir=/usr/lib/jvm/java-1.5.0-gcj-4.8-amd64 --with-jvm-jar-dir=/usr/lib/jvm-exports/java-1.5.0-gcj-4.8-amd64 --with-arch-directory=amd64 --with-ecj-jar=/usr/share/java/eclipse-ecj.jar --enable-objc-gc --enable-multiarch --disable-werror --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --with-tune=generic --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu
Thread model: posix
gcc version 4.8.4 (Ubuntu 4.8.4-2ubuntu1~14.04.4) 
COMPILER_PATH=/usr/lib/gcc/x86_64-linux-gnu/4.8/:/usr/lib/gcc/x86_64-linux-gnu/4.8/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/4.8/:/usr/lib/gcc/x86_64-linux-gnu/
LIBRARY_PATH=/usr/lib/gcc/x86_64-linux-gnu/4.8/:/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../lib/:/lib/x86_64-linux-gnu/:/lib/../lib/:/usr/lib/x86_64-linux-gnu/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../:/lib/:/usr/lib/
COLLECT_GCC_OPTIONS='-v' '-o' 'cmTryCompileExec2273648959' '-rdynamic' '-shared-libgcc' '-mtune=generic' '-march=x86-64'
 /usr/lib/gcc/x86_64-linux-gnu/4.8/collect2 --sysroot=/ --build-id --eh-frame-hdr -m elf_x86_64 --hash-style=gnu --as-needed -export-dynamic -dynamic-linker /lib64/ld-linux-x86-64.so.2 -z relro -o cmTryCompileExec2273648959 /usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/crt1.o /usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/4.8/crtbegin.o -L/usr/lib/gcc/x86_64-linux-gnu/4.8 -L/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../lib -L/lib/x86_64-linux-gnu -L/lib/../lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/4.8/../../.. CMakeFiles/cmTryCompileExec2273648959.dir/CMakeCXXCompilerABI.cpp.o -lstdc++ -lm -lgcc_s -lgcc -lc -lgcc_s -lgcc /usr/lib/gcc/x86_64-linux-gnu/4.8/crtend.o /usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/crtn.o
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Parsed CXX implicit link information from above output:
  link line regex: [^( *|.*[/\])(ld|([^/\]+-)?ld|collect2)[^/\]*( |$)]
  ignore line: [Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp]
  ignore line: []
  ignore line: [Run Build Command:/usr/bin/make "cmTryCompileExec2273648959/fast"]
  ignore line: [make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp']
  ignore line: [make -f CMakeFiles/cmTryCompileExec2273648959.dir/build.make CMakeFiles/cmTryCompileExec2273648959.dir/build]
  ignore line: [make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp']
  ignore line: [/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1]
  ignore line: [Building CXX object CMakeFiles/cmTryCompileExec2273648959.dir/CMakeCXXCompilerABI.cpp.o]
  ignore line: [/usr/bin/g++     -o CMakeFiles/cmTryCompileExec2273648959.dir/CMakeCXXCompilerABI.cpp.o -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CMakeCXXCompilerABI.cpp]
  ignore line: [Linking CXX executable cmTryCompileExec2273648959]
  ignore line: [/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2273648959.dir/link.txt --verbose=1]
  ignore line: [/usr/bin/g++      -v CMakeFiles/cmTryCompileExec2273648959.dir/CMakeCXXCompilerABI.cpp.o  -o cmTryCompileExec2273648959 -rdynamic  ]
  ignore line: [Using built-in specs.]
  ignore line: [COLLECT_GCC=/usr/bin/g++]
  ignore line: [COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/4.8/lto-wrapper]
  ignore line: [Target: x86_64-linux-gnu]
  ignore line: [Configured with: ../src/configure -v --with-pkgversion='Ubuntu 4.8.4-2ubuntu1~14.04.4' --with-bugurl=file:///usr/share/doc/gcc-4.8/README.Bugs --enable-languages=c,c++,java,go,d,fortran,objc,obj-c++ --prefix=/usr --program-suffix=-4.8 --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --with-gxx-include-dir=/usr/include/c++/4.8 --libdir=/usr/lib --enable-nls --with-sysroot=/ --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --enable-gnu-unique-object --disable-libmudflap --enable-plugin --with-system-zlib --disable-browser-plugin --enable-java-awt=gtk --enable-gtk-cairo --with-java-home=/usr/lib/jvm/java-1.5.0-gcj-4.8-amd64/jre --enable-java-home --with-jvm-root-dir=/usr/lib/jvm/java-1.5.0-gcj-4.8-amd64 --with-jvm-jar-dir=/usr/lib/jvm-exports/java-1.5.0-gcj-4.8-amd64 --with-arch-directory=amd64 --with-ecj-jar=/usr/share/java/eclipse-ecj.jar --enable-objc-gc --enable-multiarch --disable-werror --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --with-tune=generic --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu]
  ignore line: [Thread model: posix]
  ignore line: [gcc version 4.8.4 (Ubuntu 4.8.4-2ubuntu1~14.04.4) ]
  ignore line: [COMPILER_PATH=/usr/lib/gcc/x86_64-linux-gnu/4.8/:/usr/lib/gcc/x86_64-linux-gnu/4.8/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/4.8/:/usr/lib/gcc/x86_64-linux-gnu/]
  ignore line: [LIBRARY_PATH=/usr/lib/gcc/x86_64-linux-gnu/4.8/:/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../lib/:/lib/x86_64-linux-gnu/:/lib/../lib/:/usr/lib/x86_64-linux-gnu/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../:/lib/:/usr/lib/]
  ignore line: [COLLECT_GCC_OPTIONS='-v' '-o' 'cmTryCompileExec2273648959' '-rdynamic' '-shared-libgcc' '-mtune=generic' '-march=x86-64']
  link line: [ /usr/lib/gcc/x86_64-linux-gnu/4.8/collect2 --sysroot=/ --build-id --eh-frame-hdr -m elf_x86_64 --hash-style=gnu --as-needed -export-dynamic -dynamic-linker /lib64/ld-linux-x86-64.so.2 -z relro -o cmTryCompileExec2273648959 /usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/crt1.o /usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/4.8/crtbegin.o -L/usr/lib/gcc/x86_64-linux-gnu/4.8 -L/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../lib -L/lib/x86_64-linux-gnu -L/lib/../lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/4.8/../../.. CMakeFiles/cmTryCompileExec2273648959.dir/CMakeCXXCompilerABI.cpp.o -lstdc++ -lm -lgcc_s -lgcc -lc -lgcc_s -lgcc /usr/lib/gcc/x86_64-linux-gnu/4.8/crtend.o /usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/crtn.o]
    arg [/usr/lib/gcc/x86_64-linux-gnu/4.8/collect2] ==> ignore
    arg [--sysroot=/] ==> ignore
    arg [--build-id] ==> ignore
    arg [--eh-frame-hdr] ==> ignore
    arg [-m] ==> ignore
    arg [elf_x86_64] ==> ignore
    arg [--hash-style=gnu] ==> ignore
    arg [--as-needed] ==> ignore
    arg [-export-dynamic] ==> ignore
    arg [-dynamic-linker] ==> ignore
    arg [/lib64/ld-linux-x86-64.so.2] ==> ignore
    arg [-zrelro] ==> ignore
    arg [-o] ==> ignore
    arg [cmTryCompileExec2273648959] ==> ignore
    arg [/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/crt1.o] ==> ignore
    arg [/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/crti.o] ==> ignore
    arg [/usr/lib/gcc/x86_64-linux-gnu/4.8/crtbegin.o] ==> ignore
    arg [-L/usr/lib/gcc/x86_64-linux-gnu/4.8] ==> dir [/usr/lib/gcc/x86_64-linux-gnu/4.8]
    arg [-L/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu] ==> dir [/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu]
    arg [-L/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../lib] ==> dir [/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../lib]
    arg [-L/lib/x86_64-linux-gnu] ==> dir [/lib/x86_64-linux-gnu]
    arg [-L/lib/../lib] ==> dir [/lib/../lib]
    arg [-L/usr/lib/x86_64-linux-gnu] ==> dir [/usr/lib/x86_64-linux-gnu]
    arg [-L/usr/lib/../lib] ==> dir [/usr/lib/../lib]
    arg [-L/usr/lib/gcc/x86_64-linux-gnu/4.8/../../..] ==> dir [/usr/lib/gcc/x86_64-linux-gnu/4.8/../../..]
    arg [CMakeFiles/cmTryCompileExec2273648959.dir/CMakeCXXCompilerABI.cpp.o] ==> ignore
    arg [-lstdc++] ==> lib [stdc++]
    arg [-lm] ==> lib [m]
    arg [-lgcc_s] ==> lib [gcc_s]
    arg [-lgcc] ==> lib [gcc]
    arg [-lc] ==> lib [c]
    arg [-lgcc_s] ==> lib [gcc_s]
    arg [-lgcc] ==> lib [gcc]
    arg [/usr/lib/gcc/x86_64-linux-gnu/4.8/crtend.o] ==> ignore
    arg [/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/crtn.o] ==> ignore
  remove lib [gcc_s]
  remove lib [gcc]
  remove lib [gcc_s]
  remove lib [gcc]
  collapse library dir [/usr/lib/gcc/x86_64-linux-gnu/4.8] ==> [/usr/lib/gcc/x86_64-linux-gnu/4.8]
  collapse library dir [/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu] ==> [/usr/lib/x86_64-linux-gnu]
  collapse library dir [/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../lib] ==> [/usr/lib]
  collapse library dir [/lib/x86_64-linux-gnu] ==> [/lib/x86_64-linux-gnu]
  collapse library dir [/lib/../lib] ==> [/lib]
  collapse library dir [/usr/lib/x86_64-linux-gnu] ==> [/usr/lib/x86_64-linux-gnu]
  collapse library dir [/usr/lib/../lib] ==> [/usr/lib]
  collapse library dir [/usr/lib/gcc/x86_64-linux-gnu/4.8/../../..] ==> [/usr/lib]
  implicit libs: [stdc++;m;c]
  implicit dirs: [/usr/lib/gcc/x86_64-linux-gnu/4.8;/usr/lib/x86_64-linux-gnu;/usr/lib;/lib/x86_64-linux-gnu;/lib]
  implicit fwks: []


Determining if the include file iostream exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4032566142/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec4032566142.dir/build.make CMakeFiles/cmTryCompileExec4032566142.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec4032566142.dir/CheckIncludeFile.cxx.o
/usr/bin/g++     -o CMakeFiles/cmTryCompileExec4032566142.dir/CheckIncludeFile.cxx.o -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFile.cxx
Linking CXX executable cmTryCompileExec4032566142
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4032566142.dir/link.txt --verbose=1
/usr/bin/g++         CMakeFiles/cmTryCompileExec4032566142.dir/CheckIncludeFile.cxx.o  -o cmTryCompileExec4032566142 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the CXX compiler has std namespace passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2229439743/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2229439743.dir/build.make CMakeFiles/cmTryCompileExec2229439743.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2229439743.dir/TestForSTDNamespace.cxx.o
/usr/bin/g++     -o CMakeFiles/cmTryCompileExec2229439743.dir/TestForSTDNamespace.cxx.o -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/TestForSTDNamespace.cxx
Linking CXX executable cmTryCompileExec2229439743
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2229439743.dir/link.txt --verbose=1
/usr/bin/g++         CMakeFiles/cmTryCompileExec2229439743.dir/TestForSTDNamespace.cxx.o  -o cmTryCompileExec2229439743 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the CXX compiler understands ansi for scopes passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec328759456/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec328759456.dir/build.make CMakeFiles/cmTryCompileExec328759456.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec328759456.dir/TestForAnsiForScope.cxx.o
/usr/bin/g++     -o CMakeFiles/cmTryCompileExec328759456.dir/TestForAnsiForScope.cxx.o -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/TestForAnsiForScope.cxx
Linking CXX executable cmTryCompileExec328759456
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec328759456.dir/link.txt --verbose=1
/usr/bin/g++         CMakeFiles/cmTryCompileExec328759456.dir/TestForAnsiForScope.cxx.o  -o cmTryCompileExec328759456 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the CXX compiler has sstream passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2685640350/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2685640350.dir/build.make CMakeFiles/cmTryCompileExec2685640350.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2685640350.dir/TestForSSTREAM.cxx.o
/usr/bin/g++     -o CMakeFiles/cmTryCompileExec2685640350.dir/TestForSSTREAM.cxx.o -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/TestForSSTREAM.cxx
Linking CXX executable cmTryCompileExec2685640350
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2685640350.dir/link.txt --verbose=1
/usr/bin/g++         CMakeFiles/cmTryCompileExec2685640350.dir/TestForSSTREAM.cxx.o  -o cmTryCompileExec2685640350 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the unsetenv exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2390599667/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2390599667.dir/build.make CMakeFiles/cmTryCompileExec2390599667.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2390599667.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2390599667.dir/CheckSymbolExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2390599667
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2390599667.dir/link.txt --verbose=1
/usr/bin/gcc       CMakeFiles/cmTryCompileExec2390599667.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2390599667 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

File /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdlib.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef unsetenv
  return ((int*)(&unsetenv))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Checking whether header cstdio is available compiled with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2515494063/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2515494063.dir/build.make CMakeFiles/cmTryCompileExec2515494063.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2515494063.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_CXX_HAS_CSTDIO  -o CMakeFiles/cmTryCompileExec2515494063.dir/kwsysPlatformTestsCXX.cxx.o -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec2515494063
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2515494063.dir/link.txt --verbose=1
/usr/bin/g++        CMakeFiles/cmTryCompileExec2515494063.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec2515494063 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking for Large File Support compiled and ran with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4270921669/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec4270921669.dir/build.make CMakeFiles/cmTryCompileExec4270921669.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec4270921669.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DKWSYS_CXX_HAS_CSTDIO=1 -DTEST_KWSYS_LFS_WORKS  -o CMakeFiles/cmTryCompileExec4270921669.dir/kwsysPlatformTestsCXX.cxx.o -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec4270921669
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4270921669.dir/link.txt --verbose=1
/usr/bin/g++        CMakeFiles/cmTryCompileExec4270921669.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec4270921669 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether STL classes are in std namespace compiled with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3063643480/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3063643480.dir/build.make CMakeFiles/cmTryCompileExec3063643480.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec3063643480.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_STL_HAVE_STD  -o CMakeFiles/cmTryCompileExec3063643480.dir/kwsysPlatformTestsCXX.cxx.o -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec3063643480
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3063643480.dir/link.txt --verbose=1
/usr/bin/g++        CMakeFiles/cmTryCompileExec3063643480.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec3063643480 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether ANSI stream headers are available compiled with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec464307185/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec464307185.dir/build.make CMakeFiles/cmTryCompileExec464307185.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec464307185.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_IOS_USE_ANSI  -o CMakeFiles/cmTryCompileExec464307185.dir/kwsysPlatformTestsCXX.cxx.o -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec464307185
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec464307185.dir/link.txt --verbose=1
/usr/bin/g++        CMakeFiles/cmTryCompileExec464307185.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec464307185 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether ANSI streams are in std namespace compiled with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec324285663/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec324285663.dir/build.make CMakeFiles/cmTryCompileExec324285663.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec324285663.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_IOS_HAVE_STD  -o CMakeFiles/cmTryCompileExec324285663.dir/kwsysPlatformTestsCXX.cxx.o -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec324285663
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec324285663.dir/link.txt --verbose=1
/usr/bin/g++        CMakeFiles/cmTryCompileExec324285663.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec324285663 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether ANSI string stream is available compiled with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1136531270/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1136531270.dir/build.make CMakeFiles/cmTryCompileExec1136531270.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec1136531270.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_IOS_USE_SSTREAM  -o CMakeFiles/cmTryCompileExec1136531270.dir/kwsysPlatformTestsCXX.cxx.o -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec1136531270
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1136531270.dir/link.txt --verbose=1
/usr/bin/g++        CMakeFiles/cmTryCompileExec1136531270.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec1136531270 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether header cstddef is available compiled with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1257322963/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1257322963.dir/build.make CMakeFiles/cmTryCompileExec1257322963.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec1257322963.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_CXX_HAS_CSTDDEF  -o CMakeFiles/cmTryCompileExec1257322963.dir/kwsysPlatformTestsCXX.cxx.o -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec1257322963
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1257322963.dir/link.txt --verbose=1
/usr/bin/g++        CMakeFiles/cmTryCompileExec1257322963.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec1257322963 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether stl string has operator!= for char* compiled with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4002853096/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec4002853096.dir/build.make CMakeFiles/cmTryCompileExec4002853096.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec4002853096.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DKWSYS_STL_HAVE_STD=1 -DTEST_KWSYS_STL_STRING_HAVE_NEQ_CHAR  -o CMakeFiles/cmTryCompileExec4002853096.dir/kwsysPlatformTestsCXX.cxx.o -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec4002853096
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4002853096.dir/link.txt --verbose=1
/usr/bin/g++        CMakeFiles/cmTryCompileExec4002853096.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec4002853096 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether stl has iterator_traits compiled with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3743044444/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3743044444.dir/build.make CMakeFiles/cmTryCompileExec3743044444.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec3743044444.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DKWSYS_STL_HAVE_STD=1 -DTEST_KWSYS_STL_HAS_ITERATOR_TRAITS  -o CMakeFiles/cmTryCompileExec3743044444.dir/kwsysPlatformTestsCXX.cxx.o -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec3743044444
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3743044444.dir/link.txt --verbose=1
/usr/bin/g++        CMakeFiles/cmTryCompileExec3743044444.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec3743044444 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether stl has standard template allocator compiled with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2476787/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2476787.dir/build.make CMakeFiles/cmTryCompileExec2476787.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2476787.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DKWSYS_STL_HAVE_STD=1 -DTEST_KWSYS_STL_HAS_ALLOCATOR_TEMPLATE  -o CMakeFiles/cmTryCompileExec2476787.dir/kwsysPlatformTestsCXX.cxx.o -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec2476787
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2476787.dir/link.txt --verbose=1
/usr/bin/g++        CMakeFiles/cmTryCompileExec2476787.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec2476787 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking for rebind member of stl allocator compiled with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1525106074/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1525106074.dir/build.make CMakeFiles/cmTryCompileExec1525106074.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec1525106074.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DKWSYS_STL_HAVE_STD=1 -DTEST_KWSYS_STL_HAS_ALLOCATOR_REBIND  -o CMakeFiles/cmTryCompileExec1525106074.dir/kwsysPlatformTestsCXX.cxx.o -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec1525106074
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1525106074.dir/link.txt --verbose=1
/usr/bin/g++        CMakeFiles/cmTryCompileExec1525106074.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec1525106074 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether stl containers support allocator objects. compiled with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3153632991/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3153632991.dir/build.make CMakeFiles/cmTryCompileExec3153632991.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec3153632991.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DKWSYS_STL_HAVE_STD=1 -DTEST_KWSYS_STL_HAS_ALLOCATOR_OBJECTS  -o CMakeFiles/cmTryCompileExec3153632991.dir/kwsysPlatformTestsCXX.cxx.o -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec3153632991
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3153632991.dir/link.txt --verbose=1
/usr/bin/g++        CMakeFiles/cmTryCompileExec3153632991.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec3153632991 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether ios has binary openmode compiled with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1581723222/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1581723222.dir/build.make CMakeFiles/cmTryCompileExec1581723222.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec1581723222.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DKWSYS_IOS_HAVE_STD=1 -DKWSYS_IOS_USE_ANSI=1 -DTEST_KWSYS_IOS_HAVE_BINARY  -o CMakeFiles/cmTryCompileExec1581723222.dir/kwsysPlatformTestsCXX.cxx.o -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec1581723222
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1581723222.dir/link.txt --verbose=1
/usr/bin/g++        CMakeFiles/cmTryCompileExec1581723222.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec1581723222 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking for member template support compiled with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2909873879/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2909873879.dir/build.make CMakeFiles/cmTryCompileExec2909873879.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2909873879.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_CXX_HAS_MEMBER_TEMPLATES  -o CMakeFiles/cmTryCompileExec2909873879.dir/kwsysPlatformTestsCXX.cxx.o -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec2909873879
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2909873879.dir/link.txt --verbose=1
/usr/bin/g++        CMakeFiles/cmTryCompileExec2909873879.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec2909873879 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking for standard template specialization syntax compiled with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2397922495/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2397922495.dir/build.make CMakeFiles/cmTryCompileExec2397922495.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2397922495.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_CXX_HAS_FULL_SPECIALIZATION  -o CMakeFiles/cmTryCompileExec2397922495.dir/kwsysPlatformTestsCXX.cxx.o -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec2397922495
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2397922495.dir/link.txt --verbose=1
/usr/bin/g++        CMakeFiles/cmTryCompileExec2397922495.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec2397922495 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether argument dependent lookup is supported compiled with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3694959734/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3694959734.dir/build.make CMakeFiles/cmTryCompileExec3694959734.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec3694959734.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_CXX_HAS_ARGUMENT_DEPENDENT_LOOKUP  -o CMakeFiles/cmTryCompileExec3694959734.dir/kwsysPlatformTestsCXX.cxx.o -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec3694959734
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3694959734.dir/link.txt --verbose=1
/usr/bin/g++        CMakeFiles/cmTryCompileExec3694959734.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec3694959734 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether struct stat has st_mtim member compiled with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3294232083/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3294232083.dir/build.make CMakeFiles/cmTryCompileExec3294232083.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec3294232083.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_STAT_HAS_ST_MTIM  -o CMakeFiles/cmTryCompileExec3294232083.dir/kwsysPlatformTestsCXX.cxx.o -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec3294232083
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3294232083.dir/link.txt --verbose=1
/usr/bin/g++        CMakeFiles/cmTryCompileExec3294232083.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec3294232083 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether C++ compiler has 'long long' compiled with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec108078241/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec108078241.dir/build.make CMakeFiles/cmTryCompileExec108078241.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec108078241.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_CXX_HAS_LONG_LONG  -o CMakeFiles/cmTryCompileExec108078241.dir/kwsysPlatformTestsCXX.cxx.o -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec108078241
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec108078241.dir/link.txt --verbose=1
/usr/bin/g++        CMakeFiles/cmTryCompileExec108078241.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec108078241 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking for C type size macros compiled with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec816859037/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec816859037.dir/build.make CMakeFiles/cmTryCompileExec816859037.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec816859037.dir/kwsysPlatformTestsC.c.o
/usr/bin/gcc  -DTEST_KWSYS_C_TYPE_MACROS  -o CMakeFiles/cmTryCompileExec816859037.dir/kwsysPlatformTestsC.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/kwsysPlatformTestsC.c
Linking C executable cmTryCompileExec816859037
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec816859037.dir/link.txt --verbose=1
/usr/bin/gcc       CMakeFiles/cmTryCompileExec816859037.dir/kwsysPlatformTestsC.c.o  -o cmTryCompileExec816859037 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'


Determining if the include file sys/types.h exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1266463498/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1266463498.dir/build.make CMakeFiles/cmTryCompileExec1266463498.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1266463498.dir/CheckIncludeFile.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1266463498.dir/CheckIncludeFile.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFile.c
Linking C executable cmTryCompileExec1266463498
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1266463498.dir/link.txt --verbose=1
/usr/bin/gcc       CMakeFiles/cmTryCompileExec1266463498.dir/CheckIncludeFile.c.o  -o cmTryCompileExec1266463498 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the include file stdint.h exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2533013745/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2533013745.dir/build.make CMakeFiles/cmTryCompileExec2533013745.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2533013745.dir/CheckIncludeFile.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2533013745.dir/CheckIncludeFile.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFile.c
Linking C executable cmTryCompileExec2533013745
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2533013745.dir/link.txt --verbose=1
/usr/bin/gcc       CMakeFiles/cmTryCompileExec2533013745.dir/CheckIncludeFile.c.o  -o cmTryCompileExec2533013745 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the include file stddef.h exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec961498368/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec961498368.dir/build.make CMakeFiles/cmTryCompileExec961498368.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec961498368.dir/CheckIncludeFile.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec961498368.dir/CheckIncludeFile.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFile.c
Linking C executable cmTryCompileExec961498368
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec961498368.dir/link.txt --verbose=1
/usr/bin/gcc       CMakeFiles/cmTryCompileExec961498368.dir/CheckIncludeFile.c.o  -o cmTryCompileExec961498368 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining size of char passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2090797315/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2090797315.dir/build.make CMakeFiles/cmTryCompileExec2090797315.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2090797315.dir/KWSYS_SIZEOF_CHAR.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2090797315.dir/KWSYS_SIZEOF_CHAR.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CheckTypeSize/KWSYS_SIZEOF_CHAR.c
Linking C executable cmTryCompileExec2090797315
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2090797315.dir/link.txt --verbose=1
/usr/bin/gcc       CMakeFiles/cmTryCompileExec2090797315.dir/KWSYS_SIZEOF_CHAR.c.o  -o cmTryCompileExec2090797315 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Checking whether char is signed compiled and ran with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1438987490/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1438987490.dir/build.make CMakeFiles/cmTryCompileExec1438987490.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec1438987490.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_CHAR_IS_SIGNED  -o CMakeFiles/cmTryCompileExec1438987490.dir/kwsysPlatformTestsCXX.cxx.o -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec1438987490
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1438987490.dir/link.txt --verbose=1
/usr/bin/g++        CMakeFiles/cmTryCompileExec1438987490.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec1438987490 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking if istream supports long long compiled with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1362433173/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1362433173.dir/build.make CMakeFiles/cmTryCompileExec1362433173.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec1362433173.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DKWSYS_IOS_HAVE_STD=1 -DKWSYS_IOS_USE_ANSI=1 -DTEST_KWSYS_IOS_HAS_ISTREAM_LONG_LONG  -o CMakeFiles/cmTryCompileExec1362433173.dir/kwsysPlatformTestsCXX.cxx.o -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec1362433173
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1362433173.dir/link.txt --verbose=1
/usr/bin/g++        CMakeFiles/cmTryCompileExec1362433173.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec1362433173 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking if ostream supports long long compiled with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec615438813/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec615438813.dir/build.make CMakeFiles/cmTryCompileExec615438813.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec615438813.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DKWSYS_IOS_HAVE_STD=1 -DKWSYS_IOS_USE_ANSI=1 -DTEST_KWSYS_IOS_HAS_OSTREAM_LONG_LONG  -o CMakeFiles/cmTryCompileExec615438813.dir/kwsysPlatformTestsCXX.cxx.o -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec615438813
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec615438813.dir/link.txt --verbose=1
/usr/bin/g++        CMakeFiles/cmTryCompileExec615438813.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec615438813 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether C compiler has ptrdiff_t in stddef.h compiled with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4134607305/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec4134607305.dir/build.make CMakeFiles/cmTryCompileExec4134607305.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4134607305.dir/kwsysPlatformTestsC.c.o
/usr/bin/gcc  -DTEST_KWSYS_C_HAS_PTRDIFF_T  -o CMakeFiles/cmTryCompileExec4134607305.dir/kwsysPlatformTestsC.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/kwsysPlatformTestsC.c
Linking C executable cmTryCompileExec4134607305
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4134607305.dir/link.txt --verbose=1
/usr/bin/gcc       CMakeFiles/cmTryCompileExec4134607305.dir/kwsysPlatformTestsC.c.o  -o cmTryCompileExec4134607305 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether C compiler has ssize_t in unistd.h compiled with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3151519524/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3151519524.dir/build.make CMakeFiles/cmTryCompileExec3151519524.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3151519524.dir/kwsysPlatformTestsC.c.o
/usr/bin/gcc  -DTEST_KWSYS_C_HAS_SSIZE_T  -o CMakeFiles/cmTryCompileExec3151519524.dir/kwsysPlatformTestsC.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/kwsysPlatformTestsC.c
Linking C executable cmTryCompileExec3151519524
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3151519524.dir/link.txt --verbose=1
/usr/bin/gcc       CMakeFiles/cmTryCompileExec3151519524.dir/kwsysPlatformTestsC.c.o  -o cmTryCompileExec3151519524 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether CXX compiler has setenv compiled with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2865736041/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2865736041.dir/build.make CMakeFiles/cmTryCompileExec2865736041.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2865736041.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_CXX_HAS_SETENV  -o CMakeFiles/cmTryCompileExec2865736041.dir/kwsysPlatformTestsCXX.cxx.o -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec2865736041
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2865736041.dir/link.txt --verbose=1
/usr/bin/g++        CMakeFiles/cmTryCompileExec2865736041.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec2865736041 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether CXX compiler has unsetenv compiled with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec42146288/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec42146288.dir/build.make CMakeFiles/cmTryCompileExec42146288.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec42146288.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_CXX_HAS_UNSETENV  -o CMakeFiles/cmTryCompileExec42146288.dir/kwsysPlatformTestsCXX.cxx.o -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec42146288
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec42146288.dir/link.txt --verbose=1
/usr/bin/g++        CMakeFiles/cmTryCompileExec42146288.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec42146288 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether CXX compiler has utimes compiled with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3635803327/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3635803327.dir/build.make CMakeFiles/cmTryCompileExec3635803327.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec3635803327.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_CXX_HAS_UTIMES  -o CMakeFiles/cmTryCompileExec3635803327.dir/kwsysPlatformTestsCXX.cxx.o -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec3635803327
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3635803327.dir/link.txt --verbose=1
/usr/bin/g++        CMakeFiles/cmTryCompileExec3635803327.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec3635803327 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether CXX compiler has utimensat compiled with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1079814315/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1079814315.dir/build.make CMakeFiles/cmTryCompileExec1079814315.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec1079814315.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_CXX_HAS_UTIMENSAT  -o CMakeFiles/cmTryCompileExec1079814315.dir/kwsysPlatformTestsCXX.cxx.o -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec1079814315
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1079814315.dir/link.txt --verbose=1
/usr/bin/g++        CMakeFiles/cmTryCompileExec1079814315.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec1079814315 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ifaddrs.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2401152014/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2401152014.dir/build.make CMakeFiles/cmTryCompileExec2401152014.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2401152014.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2401152014.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2401152014
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2401152014.dir/link.txt --verbose=1
/usr/bin/gcc       CMakeFiles/cmTryCompileExec2401152014.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2401152014 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Checking whether CXX compiler has rlimit64 compiled with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3149549259/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3149549259.dir/build.make CMakeFiles/cmTryCompileExec3149549259.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec3149549259.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DKWSYS_HAS_LFS=1 -DTEST_KWSYS_CXX_HAS_RLIMIT64  -o CMakeFiles/cmTryCompileExec3149549259.dir/kwsysPlatformTestsCXX.cxx.o -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec3149549259
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3149549259.dir/link.txt --verbose=1
/usr/bin/g++        CMakeFiles/cmTryCompileExec3149549259.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec3149549259 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether CXX compiler has atol compiled with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec871248540/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec871248540.dir/build.make CMakeFiles/cmTryCompileExec871248540.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec871248540.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_CXX_HAS_ATOL  -o CMakeFiles/cmTryCompileExec871248540.dir/kwsysPlatformTestsCXX.cxx.o -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec871248540
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec871248540.dir/link.txt --verbose=1
/usr/bin/g++        CMakeFiles/cmTryCompileExec871248540.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec871248540 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether CXX compiler has atoll compiled with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4093874872/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec4093874872.dir/build.make CMakeFiles/cmTryCompileExec4093874872.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec4093874872.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_CXX_HAS_ATOLL  -o CMakeFiles/cmTryCompileExec4093874872.dir/kwsysPlatformTestsCXX.cxx.o -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec4093874872
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4093874872.dir/link.txt --verbose=1
/usr/bin/g++        CMakeFiles/cmTryCompileExec4093874872.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec4093874872 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'


Determining if the include file execinfo.h exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1501280683/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1501280683.dir/build.make CMakeFiles/cmTryCompileExec1501280683.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec1501280683.dir/CheckIncludeFile.cxx.o
/usr/bin/g++     -o CMakeFiles/cmTryCompileExec1501280683.dir/CheckIncludeFile.cxx.o -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFile.cxx
Linking CXX executable cmTryCompileExec1501280683
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1501280683.dir/link.txt --verbose=1
/usr/bin/g++        CMakeFiles/cmTryCompileExec1501280683.dir/CheckIncludeFile.cxx.o  -o cmTryCompileExec1501280683 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Checking whether backtrace works with this C++ compiler compiled with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4182094240/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec4182094240.dir/build.make CMakeFiles/cmTryCompileExec4182094240.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec4182094240.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_CXX_HAS_BACKTRACE  -o CMakeFiles/cmTryCompileExec4182094240.dir/kwsysPlatformTestsCXX.cxx.o -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec4182094240
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4182094240.dir/link.txt --verbose=1
/usr/bin/g++        CMakeFiles/cmTryCompileExec4182094240.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec4182094240 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'


Determining if the include file dlfcn.h exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4115202290/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec4115202290.dir/build.make CMakeFiles/cmTryCompileExec4115202290.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec4115202290.dir/CheckIncludeFile.cxx.o
/usr/bin/g++     -o CMakeFiles/cmTryCompileExec4115202290.dir/CheckIncludeFile.cxx.o -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFile.cxx
Linking CXX executable cmTryCompileExec4115202290
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4115202290.dir/link.txt --verbose=1
/usr/bin/g++        CMakeFiles/cmTryCompileExec4115202290.dir/CheckIncludeFile.cxx.o  -o cmTryCompileExec4115202290 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Checking whether dladdr works with this C++ compiler compiled with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2009653602/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2009653602.dir/build.make CMakeFiles/cmTryCompileExec2009653602.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2009653602.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_CXX_HAS_DLADDR  -o CMakeFiles/cmTryCompileExec2009653602.dir/kwsysPlatformTestsCXX.cxx.o -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec2009653602
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2009653602.dir/link.txt --verbose=1
/usr/bin/g++        CMakeFiles/cmTryCompileExec2009653602.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec2009653602 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'


Determining if the include file cxxabi.h exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3594504378/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3594504378.dir/build.make CMakeFiles/cmTryCompileExec3594504378.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec3594504378.dir/CheckIncludeFile.cxx.o
/usr/bin/g++     -o CMakeFiles/cmTryCompileExec3594504378.dir/CheckIncludeFile.cxx.o -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFile.cxx
Linking CXX executable cmTryCompileExec3594504378
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3594504378.dir/link.txt --verbose=1
/usr/bin/g++        CMakeFiles/cmTryCompileExec3594504378.dir/CheckIncludeFile.cxx.o  -o cmTryCompileExec3594504378 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Checking whether cxxabi works with this C++ compiler compiled with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1355725079/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1355725079.dir/build.make CMakeFiles/cmTryCompileExec1355725079.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec1355725079.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/g++   -DTEST_KWSYS_CXX_HAS_CXXABI  -o CMakeFiles/cmTryCompileExec1355725079.dir/kwsysPlatformTestsCXX.cxx.o -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec1355725079
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1355725079.dir/link.txt --verbose=1
/usr/bin/g++        CMakeFiles/cmTryCompileExec1355725079.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec1355725079 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Source/kwsys/CMakeFiles/CMakeTmp'


Determining if the function gethostbyname exists in the c passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2504406925/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2504406925.dir/build.make CMakeFiles/cmTryCompileExec2504406925.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2504406925.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -DCHECK_FUNCTION_EXISTS=gethostbyname   -o CMakeFiles/cmTryCompileExec2504406925.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2504406925
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2504406925.dir/link.txt --verbose=1
/usr/bin/gcc    -DCHECK_FUNCTION_EXISTS=gethostbyname    CMakeFiles/cmTryCompileExec2504406925.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2504406925 -rdynamic -lc 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function dlopen exists in the dl passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec809770353/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec809770353.dir/build.make CMakeFiles/cmTryCompileExec809770353.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec809770353.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -DCHECK_FUNCTION_EXISTS=dlopen   -o CMakeFiles/cmTryCompileExec809770353.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec809770353
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec809770353.dir/link.txt --verbose=1
/usr/bin/gcc    -DCHECK_FUNCTION_EXISTS=dlopen    CMakeFiles/cmTryCompileExec809770353.dir/CheckFunctionExists.c.o  -o cmTryCompileExec809770353 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the include file features.h exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2964934414/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2964934414.dir/build.make CMakeFiles/cmTryCompileExec2964934414.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2964934414.dir/CheckIncludeFile.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2964934414.dir/CheckIncludeFile.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFile.c
Linking C executable cmTryCompileExec2964934414
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2964934414.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec2964934414.dir/CheckIncludeFile.c.o  -o cmTryCompileExec2964934414 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files ;stdio.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec714172326/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec714172326.dir/build.make CMakeFiles/cmTryCompileExec714172326.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec714172326.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec714172326.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec714172326
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec714172326.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec714172326.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec714172326 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2137291816/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2137291816.dir/build.make CMakeFiles/cmTryCompileExec2137291816.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2137291816.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2137291816.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2137291816
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2137291816.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec2137291816.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2137291816 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2618884945/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2618884945.dir/build.make CMakeFiles/cmTryCompileExec2618884945.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2618884945.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2618884945.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2618884945
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2618884945.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec2618884945.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2618884945 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec264204408/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec264204408.dir/build.make CMakeFiles/cmTryCompileExec264204408.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec264204408.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec264204408.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec264204408
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec264204408.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec264204408.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec264204408 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4270670377/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec4270670377.dir/build.make CMakeFiles/cmTryCompileExec4270670377.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4270670377.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec4270670377.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec4270670377
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4270670377.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec4270670377.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec4270670377 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec202025198/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec202025198.dir/build.make CMakeFiles/cmTryCompileExec202025198.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec202025198.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec202025198.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec202025198
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec202025198.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec202025198.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec202025198 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec269141587/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec269141587.dir/build.make CMakeFiles/cmTryCompileExec269141587.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec269141587.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec269141587.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec269141587
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec269141587.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec269141587.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec269141587 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3003845417/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3003845417.dir/build.make CMakeFiles/cmTryCompileExec3003845417.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3003845417.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3003845417.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3003845417
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3003845417.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec3003845417.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3003845417 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4029902856/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec4029902856.dir/build.make CMakeFiles/cmTryCompileExec4029902856.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4029902856.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec4029902856.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec4029902856
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4029902856.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec4029902856.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec4029902856 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1385666873/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1385666873.dir/build.make CMakeFiles/cmTryCompileExec1385666873.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1385666873.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1385666873.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1385666873
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1385666873.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec1385666873.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1385666873 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3127092684/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3127092684.dir/build.make CMakeFiles/cmTryCompileExec3127092684.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3127092684.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3127092684.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3127092684
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3127092684.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec3127092684.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3127092684 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2817885563/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2817885563.dir/build.make CMakeFiles/cmTryCompileExec2817885563.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2817885563.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2817885563.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2817885563
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2817885563.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec2817885563.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2817885563 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec684780857/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec684780857.dir/build.make CMakeFiles/cmTryCompileExec684780857.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec684780857.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec684780857.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec684780857
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec684780857.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec684780857.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec684780857 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1908536001/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1908536001.dir/build.make CMakeFiles/cmTryCompileExec1908536001.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1908536001.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1908536001.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1908536001
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1908536001.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec1908536001.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1908536001 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3930786966/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3930786966.dir/build.make CMakeFiles/cmTryCompileExec3930786966.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3930786966.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3930786966.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3930786966
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3930786966.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec3930786966.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3930786966 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2319890611/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2319890611.dir/build.make CMakeFiles/cmTryCompileExec2319890611.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2319890611.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2319890611.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2319890611
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2319890611.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec2319890611.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2319890611 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2080354038/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2080354038.dir/build.make CMakeFiles/cmTryCompileExec2080354038.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2080354038.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2080354038.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2080354038
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2080354038.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec2080354038.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2080354038 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec681824600/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec681824600.dir/build.make CMakeFiles/cmTryCompileExec681824600.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec681824600.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec681824600.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec681824600
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec681824600.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec681824600.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec681824600 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3741194620/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3741194620.dir/build.make CMakeFiles/cmTryCompileExec3741194620.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3741194620.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3741194620.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3741194620
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3741194620.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec3741194620.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3741194620 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec797022823/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec797022823.dir/build.make CMakeFiles/cmTryCompileExec797022823.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec797022823.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec797022823.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec797022823
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec797022823.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec797022823.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec797022823 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2522697261/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2522697261.dir/build.make CMakeFiles/cmTryCompileExec2522697261.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2522697261.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2522697261.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2522697261
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2522697261.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec2522697261.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2522697261 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2021122229/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2021122229.dir/build.make CMakeFiles/cmTryCompileExec2021122229.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2021122229.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2021122229.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2021122229
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2021122229.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec2021122229.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2021122229 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec348291006/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec348291006.dir/build.make CMakeFiles/cmTryCompileExec348291006.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec348291006.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec348291006.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec348291006
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec348291006.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec348291006.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec348291006 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec326370042/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec326370042.dir/build.make CMakeFiles/cmTryCompileExec326370042.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec326370042.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec326370042.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec326370042
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec326370042.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec326370042.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec326370042 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1573129275/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1573129275.dir/build.make CMakeFiles/cmTryCompileExec1573129275.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1573129275.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1573129275.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1573129275
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1573129275.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec1573129275.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1573129275 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec520490036/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec520490036.dir/build.make CMakeFiles/cmTryCompileExec520490036.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec520490036.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec520490036.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec520490036
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec520490036.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec520490036.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec520490036 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3627744406/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3627744406.dir/build.make CMakeFiles/cmTryCompileExec3627744406.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3627744406.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3627744406.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3627744406
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3627744406.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec3627744406.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3627744406 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec839782276/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec839782276.dir/build.make CMakeFiles/cmTryCompileExec839782276.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec839782276.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec839782276.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec839782276
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec839782276.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec839782276.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec839782276 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2757124273/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2757124273.dir/build.make CMakeFiles/cmTryCompileExec2757124273.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2757124273.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2757124273.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2757124273
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2757124273.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec2757124273.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2757124273 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec338647144/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec338647144.dir/build.make CMakeFiles/cmTryCompileExec338647144.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec338647144.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec338647144.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec338647144
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec338647144.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec338647144.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec338647144 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3810490277/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3810490277.dir/build.make CMakeFiles/cmTryCompileExec3810490277.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3810490277.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3810490277.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3810490277
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3810490277.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec3810490277.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3810490277 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2912524838/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2912524838.dir/build.make CMakeFiles/cmTryCompileExec2912524838.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2912524838.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2912524838.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2912524838
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2912524838.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec2912524838.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2912524838 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2207074595/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2207074595.dir/build.make CMakeFiles/cmTryCompileExec2207074595.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2207074595.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2207074595.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2207074595
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2207074595.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec2207074595.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2207074595 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h;setjmp.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1833739747/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1833739747.dir/build.make CMakeFiles/cmTryCompileExec1833739747.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1833739747.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1833739747.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1833739747
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1833739747.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec1833739747.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1833739747 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h;setjmp.h;signal.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec597978995/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec597978995.dir/build.make CMakeFiles/cmTryCompileExec597978995.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec597978995.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec597978995.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec597978995
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec597978995.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec597978995.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec597978995 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h;setjmp.h;signal.h;sys/ioctl.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec676650906/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec676650906.dir/build.make CMakeFiles/cmTryCompileExec676650906.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec676650906.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec676650906.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec676650906
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec676650906.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec676650906.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec676650906 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h;setjmp.h;signal.h;sys/ioctl.h;sys/utsname.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3923973594/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3923973594.dir/build.make CMakeFiles/cmTryCompileExec3923973594.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3923973594.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3923973594.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3923973594
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3923973594.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec3923973594.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3923973594 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h;setjmp.h;signal.h;sys/ioctl.h;sys/utsname.h;arpa/tftp.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1186300710/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1186300710.dir/build.make CMakeFiles/cmTryCompileExec1186300710.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1186300710.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1186300710.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1186300710
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1186300710.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec1186300710.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1186300710 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h;setjmp.h;signal.h;sys/ioctl.h;sys/utsname.h;arpa/tftp.h;errno.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3532797741/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3532797741.dir/build.make CMakeFiles/cmTryCompileExec3532797741.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3532797741.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3532797741.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3532797741
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3532797741.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec3532797741.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3532797741 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h;setjmp.h;signal.h;sys/ioctl.h;sys/utsname.h;arpa/tftp.h;errno.h;libgen.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1975231664/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1975231664.dir/build.make CMakeFiles/cmTryCompileExec1975231664.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1975231664.dir/CheckIncludeFiles.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1975231664.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1975231664
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1975231664.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec1975231664.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1975231664 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining size of size_t passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3038379168/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3038379168.dir/build.make CMakeFiles/cmTryCompileExec3038379168.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3038379168.dir/SIZEOF_SIZE_T.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3038379168.dir/SIZEOF_SIZE_T.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CheckTypeSize/SIZEOF_SIZE_T.c
Linking C executable cmTryCompileExec3038379168
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3038379168.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec3038379168.dir/SIZEOF_SIZE_T.c.o  -o cmTryCompileExec3038379168 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining size of ssize_t passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2604956096/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2604956096.dir/build.make CMakeFiles/cmTryCompileExec2604956096.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2604956096.dir/SIZEOF_SSIZE_T.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2604956096.dir/SIZEOF_SSIZE_T.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CheckTypeSize/SIZEOF_SSIZE_T.c
Linking C executable cmTryCompileExec2604956096
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2604956096.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec2604956096.dir/SIZEOF_SSIZE_T.c.o  -o cmTryCompileExec2604956096 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining size of long long passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2623439184/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2623439184.dir/build.make CMakeFiles/cmTryCompileExec2623439184.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2623439184.dir/SIZEOF_LONG_LONG.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2623439184.dir/SIZEOF_LONG_LONG.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CheckTypeSize/SIZEOF_LONG_LONG.c
Linking C executable cmTryCompileExec2623439184
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2623439184.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec2623439184.dir/SIZEOF_LONG_LONG.c.o  -o cmTryCompileExec2623439184 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining size of long passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1683812042/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1683812042.dir/build.make CMakeFiles/cmTryCompileExec1683812042.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1683812042.dir/SIZEOF_LONG.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1683812042.dir/SIZEOF_LONG.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CheckTypeSize/SIZEOF_LONG.c
Linking C executable cmTryCompileExec1683812042
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1683812042.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec1683812042.dir/SIZEOF_LONG.c.o  -o cmTryCompileExec1683812042 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining size of time_t passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1949467105/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1949467105.dir/build.make CMakeFiles/cmTryCompileExec1949467105.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1949467105.dir/SIZEOF_TIME_T.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1949467105.dir/SIZEOF_TIME_T.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CheckTypeSize/SIZEOF_TIME_T.c
Linking C executable cmTryCompileExec1949467105
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1949467105.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec1949467105.dir/SIZEOF_TIME_T.c.o  -o cmTryCompileExec1949467105 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the basename exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec652931537/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec652931537.dir/build.make CMakeFiles/cmTryCompileExec652931537.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec652931537.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec652931537.dir/CheckSymbolExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec652931537
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec652931537.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec652931537.dir/CheckSymbolExists.c.o  -o cmTryCompileExec652931537 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

File /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef basename
  return ((int*)(&basename))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the socket exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2570710586/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2570710586.dir/build.make CMakeFiles/cmTryCompileExec2570710586.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2570710586.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2570710586.dir/CheckSymbolExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2570710586
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2570710586.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec2570710586.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2570710586 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

File /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef socket
  return ((int*)(&socket))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the poll exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2347943716/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2347943716.dir/build.make CMakeFiles/cmTryCompileExec2347943716.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2347943716.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2347943716.dir/CheckSymbolExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2347943716
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2347943716.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec2347943716.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2347943716 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

File /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef poll
  return ((int*)(&poll))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the select exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1932276383/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1932276383.dir/build.make CMakeFiles/cmTryCompileExec1932276383.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1932276383.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1932276383.dir/CheckSymbolExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1932276383
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1932276383.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec1932276383.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1932276383 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

File /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef select
  return ((int*)(&select))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the strdup exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2622073880/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2622073880.dir/build.make CMakeFiles/cmTryCompileExec2622073880.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2622073880.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2622073880.dir/CheckSymbolExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2622073880
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2622073880.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec2622073880.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2622073880 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

File /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef strdup
  return ((int*)(&strdup))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the strstr exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1308232207/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1308232207.dir/build.make CMakeFiles/cmTryCompileExec1308232207.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1308232207.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1308232207.dir/CheckSymbolExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1308232207
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1308232207.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec1308232207.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1308232207 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

File /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef strstr
  return ((int*)(&strstr))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the strtok_r exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1228658625/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1228658625.dir/build.make CMakeFiles/cmTryCompileExec1228658625.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1228658625.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1228658625.dir/CheckSymbolExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1228658625
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1228658625.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec1228658625.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1228658625 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

File /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef strtok_r
  return ((int*)(&strtok_r))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the strftime exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3620271260/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3620271260.dir/build.make CMakeFiles/cmTryCompileExec3620271260.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3620271260.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3620271260.dir/CheckSymbolExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3620271260
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3620271260.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec3620271260.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3620271260 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

File /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef strftime
  return ((int*)(&strftime))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the uname exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2216855928/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2216855928.dir/build.make CMakeFiles/cmTryCompileExec2216855928.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2216855928.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2216855928.dir/CheckSymbolExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2216855928
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2216855928.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec2216855928.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2216855928 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

File /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef uname
  return ((int*)(&uname))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the strcasecmp exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1610977888/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1610977888.dir/build.make CMakeFiles/cmTryCompileExec1610977888.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1610977888.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1610977888.dir/CheckSymbolExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1610977888
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1610977888.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec1610977888.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1610977888 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

File /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef strcasecmp
  return ((int*)(&strcasecmp))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the gethostbyaddr exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec801955354/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec801955354.dir/build.make CMakeFiles/cmTryCompileExec801955354.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec801955354.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec801955354.dir/CheckSymbolExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec801955354
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec801955354.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec801955354.dir/CheckSymbolExists.c.o  -o cmTryCompileExec801955354 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

File /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef gethostbyaddr
  return ((int*)(&gethostbyaddr))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the gettimeofday exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2992239884/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2992239884.dir/build.make CMakeFiles/cmTryCompileExec2992239884.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2992239884.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2992239884.dir/CheckSymbolExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2992239884
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2992239884.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec2992239884.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2992239884 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

File /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef gettimeofday
  return ((int*)(&gettimeofday))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the inet_addr exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec980096600/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec980096600.dir/build.make CMakeFiles/cmTryCompileExec980096600.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec980096600.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec980096600.dir/CheckSymbolExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec980096600
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec980096600.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec980096600.dir/CheckSymbolExists.c.o  -o cmTryCompileExec980096600 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

File /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef inet_addr
  return ((int*)(&inet_addr))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the inet_pton exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3406642430/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3406642430.dir/build.make CMakeFiles/cmTryCompileExec3406642430.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3406642430.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3406642430.dir/CheckSymbolExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3406642430
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3406642430.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec3406642430.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3406642430 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

File /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef inet_pton
  return ((int*)(&inet_pton))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the inet_ntoa exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4137104325/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec4137104325.dir/build.make CMakeFiles/cmTryCompileExec4137104325.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4137104325.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec4137104325.dir/CheckSymbolExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec4137104325
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4137104325.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec4137104325.dir/CheckSymbolExists.c.o  -o cmTryCompileExec4137104325 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

File /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef inet_ntoa
  return ((int*)(&inet_ntoa))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the tcsetattr exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2215130128/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2215130128.dir/build.make CMakeFiles/cmTryCompileExec2215130128.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2215130128.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2215130128.dir/CheckSymbolExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2215130128
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2215130128.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec2215130128.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2215130128 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

File /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef tcsetattr
  return ((int*)(&tcsetattr))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the tcgetattr exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4006151109/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec4006151109.dir/build.make CMakeFiles/cmTryCompileExec4006151109.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4006151109.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec4006151109.dir/CheckSymbolExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec4006151109
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4006151109.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec4006151109.dir/CheckSymbolExists.c.o  -o cmTryCompileExec4006151109 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

File /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef tcgetattr
  return ((int*)(&tcgetattr))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the perror exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3507999708/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3507999708.dir/build.make CMakeFiles/cmTryCompileExec3507999708.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3507999708.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3507999708.dir/CheckSymbolExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3507999708
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3507999708.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec3507999708.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3507999708 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

File /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef perror
  return ((int*)(&perror))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the setvbuf exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2646693729/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2646693729.dir/build.make CMakeFiles/cmTryCompileExec2646693729.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2646693729.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2646693729.dir/CheckSymbolExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2646693729
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2646693729.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec2646693729.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2646693729 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

File /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef setvbuf
  return ((int*)(&setvbuf))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the sigsetjmp exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec670974707/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec670974707.dir/build.make CMakeFiles/cmTryCompileExec670974707.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec670974707.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec670974707.dir/CheckSymbolExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec670974707
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec670974707.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec670974707.dir/CheckSymbolExists.c.o  -o cmTryCompileExec670974707 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

File /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef sigsetjmp
  return ((int*)(&sigsetjmp))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the getpwuid exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec51113099/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec51113099.dir/build.make CMakeFiles/cmTryCompileExec51113099.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec51113099.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec51113099.dir/CheckSymbolExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec51113099
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec51113099.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec51113099.dir/CheckSymbolExists.c.o  -o cmTryCompileExec51113099 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

File /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef getpwuid
  return ((int*)(&getpwuid))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the geteuid exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1633289495/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1633289495.dir/build.make CMakeFiles/cmTryCompileExec1633289495.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1633289495.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1633289495.dir/CheckSymbolExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1633289495
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1633289495.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec1633289495.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1633289495 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

File /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef geteuid
  return ((int*)(&geteuid))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the utime exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1275788316/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1275788316.dir/build.make CMakeFiles/cmTryCompileExec1275788316.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1275788316.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1275788316.dir/CheckSymbolExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1275788316
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1275788316.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec1275788316.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1275788316 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

File /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef utime
  return ((int*)(&utime))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the gmtime_r exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1616079795/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1616079795.dir/build.make CMakeFiles/cmTryCompileExec1616079795.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1616079795.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1616079795.dir/CheckSymbolExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1616079795
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1616079795.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec1616079795.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1616079795 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

File /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef gmtime_r
  return ((int*)(&gmtime_r))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the localtime_r exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1828389445/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1828389445.dir/build.make CMakeFiles/cmTryCompileExec1828389445.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1828389445.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1828389445.dir/CheckSymbolExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1828389445
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1828389445.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec1828389445.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1828389445 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

File /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef localtime_r
  return ((int*)(&localtime_r))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the gethostbyname exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2506066083/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2506066083.dir/build.make CMakeFiles/cmTryCompileExec2506066083.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2506066083.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2506066083.dir/CheckSymbolExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2506066083
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2506066083.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec2506066083.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2506066083 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

File /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef gethostbyname
  return ((int*)(&gethostbyname))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the gethostbyname_r exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4155160019/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec4155160019.dir/build.make CMakeFiles/cmTryCompileExec4155160019.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4155160019.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec4155160019.dir/CheckSymbolExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec4155160019
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4155160019.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec4155160019.dir/CheckSymbolExists.c.o  -o cmTryCompileExec4155160019 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

File /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef gethostbyname_r
  return ((int*)(&gethostbyname_r))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the gethostbyaddr_r exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2121082863/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2121082863.dir/build.make CMakeFiles/cmTryCompileExec2121082863.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2121082863.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2121082863.dir/CheckSymbolExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2121082863
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2121082863.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec2121082863.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2121082863 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

File /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef gethostbyaddr_r
  return ((int*)(&gethostbyaddr_r))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the signal exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec39283474/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec39283474.dir/build.make CMakeFiles/cmTryCompileExec39283474.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec39283474.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec39283474.dir/CheckSymbolExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec39283474
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec39283474.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec39283474.dir/CheckSymbolExists.c.o  -o cmTryCompileExec39283474 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

File /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef signal
  return ((int*)(&signal))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the SIGALRM exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec36136628/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec36136628.dir/build.make CMakeFiles/cmTryCompileExec36136628.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec36136628.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec36136628.dir/CheckSymbolExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec36136628
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec36136628.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec36136628.dir/CheckSymbolExists.c.o  -o cmTryCompileExec36136628 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

File /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef SIGALRM
  return ((int*)(&SIGALRM))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the strtoll exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2657639128/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2657639128.dir/build.make CMakeFiles/cmTryCompileExec2657639128.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2657639128.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2657639128.dir/CheckSymbolExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2657639128
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2657639128.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec2657639128.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2657639128 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

File /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef strtoll
  return ((int*)(&strtoll))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the strerror_r exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec792877455/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec792877455.dir/build.make CMakeFiles/cmTryCompileExec792877455.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec792877455.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec792877455.dir/CheckSymbolExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec792877455
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec792877455.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec792877455.dir/CheckSymbolExists.c.o  -o cmTryCompileExec792877455 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

File /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef strerror_r
  return ((int*)(&strerror_r))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the siginterrupt exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec351316011/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec351316011.dir/build.make CMakeFiles/cmTryCompileExec351316011.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec351316011.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec351316011.dir/CheckSymbolExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec351316011
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec351316011.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec351316011.dir/CheckSymbolExists.c.o  -o cmTryCompileExec351316011 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

File /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef siginterrupt
  return ((int*)(&siginterrupt))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the fork exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec211522335/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec211522335.dir/build.make CMakeFiles/cmTryCompileExec211522335.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec211522335.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec211522335.dir/CheckSymbolExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec211522335
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec211522335.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec211522335.dir/CheckSymbolExists.c.o  -o cmTryCompileExec211522335 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

File /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef fork
  return ((int*)(&fork))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the pipe exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec936023323/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec936023323.dir/build.make CMakeFiles/cmTryCompileExec936023323.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec936023323.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec936023323.dir/CheckSymbolExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec936023323
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec936023323.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec936023323.dir/CheckSymbolExists.c.o  -o cmTryCompileExec936023323 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

File /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef pipe
  return ((int*)(&pipe))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the ftruncate exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3890919145/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3890919145.dir/build.make CMakeFiles/cmTryCompileExec3890919145.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3890919145.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3890919145.dir/CheckSymbolExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3890919145
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3890919145.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec3890919145.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3890919145 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

File /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef ftruncate
  return ((int*)(&ftruncate))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the getprotobyname exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec898405691/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec898405691.dir/build.make CMakeFiles/cmTryCompileExec898405691.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec898405691.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec898405691.dir/CheckSymbolExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec898405691
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec898405691.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec898405691.dir/CheckSymbolExists.c.o  -o cmTryCompileExec898405691 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

File /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef getprotobyname
  return ((int*)(&getprotobyname))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the getrlimit exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3400452623/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3400452623.dir/build.make CMakeFiles/cmTryCompileExec3400452623.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3400452623.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec3400452623.dir/CheckSymbolExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3400452623
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3400452623.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec3400452623.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3400452623 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

File /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef getrlimit
  return ((int*)(&getrlimit))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the setlocale exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1834115887/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1834115887.dir/build.make CMakeFiles/cmTryCompileExec1834115887.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1834115887.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1834115887.dir/CheckSymbolExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1834115887
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1834115887.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec1834115887.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1834115887 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

File /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef setlocale
  return ((int*)(&setlocale))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the setrlimit exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec813431937/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec813431937.dir/build.make CMakeFiles/cmTryCompileExec813431937.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec813431937.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec813431937.dir/CheckSymbolExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec813431937
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec813431937.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec813431937.dir/CheckSymbolExists.c.o  -o cmTryCompileExec813431937 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

File /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef setrlimit
  return ((int*)(&setrlimit))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the sigaction exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec668700147/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec668700147.dir/build.make CMakeFiles/cmTryCompileExec668700147.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec668700147.dir/CheckSymbolExists.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec668700147.dir/CheckSymbolExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec668700147
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec668700147.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec668700147.dir/CheckSymbolExists.c.o  -o cmTryCompileExec668700147 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

File /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <signal.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef sigaction
  return ((int*)(&sigaction))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Performing Curl Test HAVE_O_NONBLOCK passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1947207809/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1947207809.dir/build.make CMakeFiles/cmTryCompileExec1947207809.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1947207809.dir/CurlTests.c.o
/usr/bin/gcc   -DHAVE_O_NONBLOCK   -o CMakeFiles/cmTryCompileExec1947207809.dir/CurlTests.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec1947207809
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1947207809.dir/link.txt --verbose=1
/usr/bin/gcc    -DHAVE_O_NONBLOCK    CMakeFiles/cmTryCompileExec1947207809.dir/CurlTests.c.o  -o cmTryCompileExec1947207809 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

Performing Curl Test TIME_WITH_SYS_TIME passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1217892295/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1217892295.dir/build.make CMakeFiles/cmTryCompileExec1217892295.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1217892295.dir/CurlTests.c.o
/usr/bin/gcc   -DTIME_WITH_SYS_TIME   -o CMakeFiles/cmTryCompileExec1217892295.dir/CurlTests.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec1217892295
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1217892295.dir/link.txt --verbose=1
/usr/bin/gcc    -DTIME_WITH_SYS_TIME    CMakeFiles/cmTryCompileExec1217892295.dir/CurlTests.c.o  -o cmTryCompileExec1217892295 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_GETHOSTBYADDR_R_8 passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3490843400/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3490843400.dir/build.make CMakeFiles/cmTryCompileExec3490843400.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3490843400.dir/CurlTests.c.o
/usr/bin/gcc   -DHAVE_GETHOSTBYADDR_R_8   -o CMakeFiles/cmTryCompileExec3490843400.dir/CurlTests.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec3490843400
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3490843400.dir/link.txt --verbose=1
/usr/bin/gcc    -DHAVE_GETHOSTBYADDR_R_8    CMakeFiles/cmTryCompileExec3490843400.dir/CurlTests.c.o  -o cmTryCompileExec3490843400 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_GETHOSTBYADDR_R_8_REENTRANT passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3911814990/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3911814990.dir/build.make CMakeFiles/cmTryCompileExec3911814990.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3911814990.dir/CurlTests.c.o
/usr/bin/gcc   -DHAVE_GETHOSTBYADDR_R_8_REENTRANT   -o CMakeFiles/cmTryCompileExec3911814990.dir/CurlTests.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec3911814990
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3911814990.dir/link.txt --verbose=1
/usr/bin/gcc    -DHAVE_GETHOSTBYADDR_R_8_REENTRANT    CMakeFiles/cmTryCompileExec3911814990.dir/CurlTests.c.o  -o cmTryCompileExec3911814990 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_GETHOSTBYNAME_R_6 passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec708204379/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec708204379.dir/build.make CMakeFiles/cmTryCompileExec708204379.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec708204379.dir/CurlTests.c.o
/usr/bin/gcc   -DHAVE_GETHOSTBYNAME_R_6   -o CMakeFiles/cmTryCompileExec708204379.dir/CurlTests.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec708204379
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec708204379.dir/link.txt --verbose=1
/usr/bin/gcc    -DHAVE_GETHOSTBYNAME_R_6    CMakeFiles/cmTryCompileExec708204379.dir/CurlTests.c.o  -o cmTryCompileExec708204379 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_GETHOSTBYNAME_R_6_REENTRANT passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec382096454/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec382096454.dir/build.make CMakeFiles/cmTryCompileExec382096454.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec382096454.dir/CurlTests.c.o
/usr/bin/gcc   -DHAVE_GETHOSTBYNAME_R_6_REENTRANT   -o CMakeFiles/cmTryCompileExec382096454.dir/CurlTests.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec382096454
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec382096454.dir/link.txt --verbose=1
/usr/bin/gcc    -DHAVE_GETHOSTBYNAME_R_6_REENTRANT    CMakeFiles/cmTryCompileExec382096454.dir/CurlTests.c.o  -o cmTryCompileExec382096454 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_SOCKLEN_T passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1702188471/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1702188471.dir/build.make CMakeFiles/cmTryCompileExec1702188471.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1702188471.dir/CurlTests.c.o
/usr/bin/gcc   -DHAVE_SOCKLEN_T   -o CMakeFiles/cmTryCompileExec1702188471.dir/CurlTests.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec1702188471
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1702188471.dir/link.txt --verbose=1
/usr/bin/gcc    -DHAVE_SOCKLEN_T    CMakeFiles/cmTryCompileExec1702188471.dir/CurlTests.c.o  -o cmTryCompileExec1702188471 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_IN_ADDR_T passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3356593415/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3356593415.dir/build.make CMakeFiles/cmTryCompileExec3356593415.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3356593415.dir/CurlTests.c.o
/usr/bin/gcc   -DHAVE_IN_ADDR_T   -o CMakeFiles/cmTryCompileExec3356593415.dir/CurlTests.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec3356593415
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3356593415.dir/link.txt --verbose=1
/usr/bin/gcc    -DHAVE_IN_ADDR_T    CMakeFiles/cmTryCompileExec3356593415.dir/CurlTests.c.o  -o cmTryCompileExec3356593415 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

Performing Curl Test STDC_HEADERS passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec788346362/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec788346362.dir/build.make CMakeFiles/cmTryCompileExec788346362.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec788346362.dir/CurlTests.c.o
/usr/bin/gcc   -DSTDC_HEADERS   -o CMakeFiles/cmTryCompileExec788346362.dir/CurlTests.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec788346362
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec788346362.dir/link.txt --verbose=1
/usr/bin/gcc    -DSTDC_HEADERS    CMakeFiles/cmTryCompileExec788346362.dir/CurlTests.c.o  -o cmTryCompileExec788346362 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

Performing Curl Test RETSIGTYPE_TEST passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3269772374/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3269772374.dir/build.make CMakeFiles/cmTryCompileExec3269772374.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3269772374.dir/CurlTests.c.o
/usr/bin/gcc   -DRETSIGTYPE_TEST   -o CMakeFiles/cmTryCompileExec3269772374.dir/CurlTests.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec3269772374
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3269772374.dir/link.txt --verbose=1
/usr/bin/gcc    -DRETSIGTYPE_TEST    CMakeFiles/cmTryCompileExec3269772374.dir/CurlTests.c.o  -o cmTryCompileExec3269772374 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_GETADDRINFO passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2834209495/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2834209495.dir/build.make CMakeFiles/cmTryCompileExec2834209495.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2834209495.dir/CurlTests.c.o
/usr/bin/gcc   -DHAVE_GETADDRINFO   -o CMakeFiles/cmTryCompileExec2834209495.dir/CurlTests.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmcurl/CMake/CurlTests.c
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmcurl/CMake/CurlTests.c: In function 'main':
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmcurl/CMake/CurlTests.c:405:5: warning: incompatible implicit declaration of built-in function 'memset' [enabled by default]
     memset(&hints, 0, sizeof(hints));
     ^
Linking C executable cmTryCompileExec2834209495
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2834209495.dir/link.txt --verbose=1
/usr/bin/gcc    -DHAVE_GETADDRINFO    CMakeFiles/cmTryCompileExec2834209495.dir/CurlTests.c.o  -o cmTryCompileExec2834209495 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_FILE_OFFSET_BITS passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2169408706/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2169408706.dir/build.make CMakeFiles/cmTryCompileExec2169408706.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2169408706.dir/CurlTests.c.o
/usr/bin/gcc   -DHAVE_FILE_OFFSET_BITS   -o CMakeFiles/cmTryCompileExec2169408706.dir/CurlTests.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec2169408706
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2169408706.dir/link.txt --verbose=1
/usr/bin/gcc    -DHAVE_FILE_OFFSET_BITS    CMakeFiles/cmTryCompileExec2169408706.dir/CurlTests.c.o  -o cmTryCompileExec2169408706 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

Determining size of curl_off_t passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3580297331/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3580297331.dir/build.make CMakeFiles/cmTryCompileExec3580297331.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3580297331.dir/SIZEOF_CURL_OFF_T.c.o
/usr/bin/gcc   -D_FILE_OFFSET_BITS=64   -o CMakeFiles/cmTryCompileExec3580297331.dir/SIZEOF_CURL_OFF_T.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CheckTypeSize/SIZEOF_CURL_OFF_T.c
Linking C executable cmTryCompileExec3580297331
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3580297331.dir/link.txt --verbose=1
/usr/bin/gcc    -D_FILE_OFFSET_BITS=64    CMakeFiles/cmTryCompileExec3580297331.dir/SIZEOF_CURL_OFF_T.c.o  -o cmTryCompileExec3580297331 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Performing C SOURCE FILE Test curl_cv_recv succeded with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1418527508/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1418527508.dir/build.make CMakeFiles/cmTryCompileExec1418527508.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1418527508.dir/src.c.o
/usr/bin/gcc   -Dcurl_cv_recv   -o CMakeFiles/cmTryCompileExec1418527508.dir/src.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec1418527508
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1418527508.dir/link.txt --verbose=1
/usr/bin/gcc    -Dcurl_cv_recv    CMakeFiles/cmTryCompileExec1418527508.dir/src.c.o  -o cmTryCompileExec1418527508 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

Source file was:
#define __unused1
#undef inline
#define __unused2

#include <sys/types.h>
#include <sys/socket.h>

#define __unused5 1

int main() { recv(0, 0, 0, 0) ; return 0; }
Performing C SOURCE FILE Test ssize_t recv(int, void *, size_t, int) (curl_cv_func_recv_test) succeded with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec111263668/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec111263668.dir/build.make CMakeFiles/cmTryCompileExec111263668.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec111263668.dir/src.c.o
/usr/bin/gcc   -Dcurl_cv_func_recv_test   -o CMakeFiles/cmTryCompileExec111263668.dir/src.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec111263668
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec111263668.dir/link.txt --verbose=1
/usr/bin/gcc    -Dcurl_cv_func_recv_test    CMakeFiles/cmTryCompileExec111263668.dir/src.c.o  -o cmTryCompileExec111263668 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

Source file was:
#define __unused1
#undef inline
#define __unused2

#include <sys/types.h>
#include <sys/socket.h>
extern ssize_t  recv(int, void *, size_t, int);
#define __unused5 1

int main() { 
                    int s=0;
                    void * buf=0;
                    size_t len=0;
                    int flags=0;
                    ssize_t res = recv(s, buf, len, flags) ; return 0; }
Performing C SOURCE FILE Test curl_cv_send succeded with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4190040489/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec4190040489.dir/build.make CMakeFiles/cmTryCompileExec4190040489.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4190040489.dir/src.c.o
/usr/bin/gcc   -Dcurl_cv_send   -o CMakeFiles/cmTryCompileExec4190040489.dir/src.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec4190040489
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4190040489.dir/link.txt --verbose=1
/usr/bin/gcc    -Dcurl_cv_send    CMakeFiles/cmTryCompileExec4190040489.dir/src.c.o  -o cmTryCompileExec4190040489 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

Source file was:
#define __unused1
#undef inline
#define __unused2

#include <sys/types.h>
#include <sys/socket.h>
extern ssize_t  recv(int, void *, size_t, int);
#define __unused5 1

int main() { send(0, 0, 0, 0) ; return 0; }
Performing C SOURCE FILE Test ssize_t send(int, const void *, size_t, int) (curl_cv_func_send_test) succeded with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3369752323/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3369752323.dir/build.make CMakeFiles/cmTryCompileExec3369752323.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3369752323.dir/src.c.o
/usr/bin/gcc   -Dcurl_cv_func_send_test   -o CMakeFiles/cmTryCompileExec3369752323.dir/src.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec3369752323
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3369752323.dir/link.txt --verbose=1
/usr/bin/gcc    -Dcurl_cv_func_send_test    CMakeFiles/cmTryCompileExec3369752323.dir/src.c.o  -o cmTryCompileExec3369752323 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

Source file was:
#define __unused1
#undef inline
#define __unused2

#include <sys/types.h>
#include <sys/socket.h>
extern ssize_t  send(int, const void *, size_t, int);
#define __unused5 1

int main() { 
                    int s=0;
                    const void * buf=0;
                    size_t len=0;
                    int flags=0;
                    ssize_t res = send(s, buf, len, flags) ; return 0; }
Performing C SOURCE FILE Test HAVE_MSG_NOSIGNAL succeded with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec226852895/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec226852895.dir/build.make CMakeFiles/cmTryCompileExec226852895.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec226852895.dir/src.c.o
/usr/bin/gcc   -DHAVE_MSG_NOSIGNAL   -o CMakeFiles/cmTryCompileExec226852895.dir/src.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/src.c
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/src.c:12:0: warning: "__unused5" redefined [enabled by default]
 #define __unused5 1
 ^
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/src.c:8:0: note: this is the location of the previous definition
 #define __unused5
 ^
Linking C executable cmTryCompileExec226852895
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec226852895.dir/link.txt --verbose=1
/usr/bin/gcc    -DHAVE_MSG_NOSIGNAL    CMakeFiles/cmTryCompileExec226852895.dir/src.c.o  -o cmTryCompileExec226852895 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

Source file was:
#define __unused1
#undef inline
#define __unused2

#include <sys/types.h>
#include <sys/socket.h>
extern ssize_t  send(int, const void *, size_t, int);
#define __unused5

#include <sys/types.h>
#include <sys/socket.h>
#define __unused5 1

int main() { int flag = MSG_NOSIGNAL ; return 0; }
Performing C SOURCE FILE Test HAVE_STRUCT_TIMEVAL succeded with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1871653744/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1871653744.dir/build.make CMakeFiles/cmTryCompileExec1871653744.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1871653744.dir/src.c.o
/usr/bin/gcc   -DHAVE_STRUCT_TIMEVAL   -o CMakeFiles/cmTryCompileExec1871653744.dir/src.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec1871653744
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1871653744.dir/link.txt --verbose=1
/usr/bin/gcc    -DHAVE_STRUCT_TIMEVAL    CMakeFiles/cmTryCompileExec1871653744.dir/src.c.o  -o cmTryCompileExec1871653744 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

Source file was:
#define __unused1
#undef inline
#define __unused2

#include <sys/types.h>
#include <sys/time.h>
#include <time.h>
#include <time.h>
#define __unused5 1

int main() { struct timeval ts;
ts.tv_sec  = 0;
ts.tv_usec = 0 ; return 0; }
Determining size of sig_atomic_t passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2583676775/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2583676775.dir/build.make CMakeFiles/cmTryCompileExec2583676775.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2583676775.dir/SIZEOF_SIG_ATOMIC_T.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec2583676775.dir/SIZEOF_SIG_ATOMIC_T.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CheckTypeSize/SIZEOF_SIG_ATOMIC_T.c
Linking C executable cmTryCompileExec2583676775
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2583676775.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec2583676775.dir/SIZEOF_SIG_ATOMIC_T.c.o  -o cmTryCompileExec2583676775 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Performing C SOURCE FILE Test HAVE_SIG_ATOMIC_T_NOT_VOLATILE succeded with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec951466597/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec951466597.dir/build.make CMakeFiles/cmTryCompileExec951466597.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec951466597.dir/src.c.o
/usr/bin/gcc   -DHAVE_SIG_ATOMIC_T_NOT_VOLATILE   -o CMakeFiles/cmTryCompileExec951466597.dir/src.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec951466597
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec951466597.dir/link.txt --verbose=1
/usr/bin/gcc    -DHAVE_SIG_ATOMIC_T_NOT_VOLATILE    CMakeFiles/cmTryCompileExec951466597.dir/src.c.o  -o cmTryCompileExec951466597 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

Source file was:
#include <signal.h>

int main() { static volatile sig_atomic_t dummy = 0 ; return 0; }
Determining size of struct sockaddr_storage passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec771386691/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec771386691.dir/build.make CMakeFiles/cmTryCompileExec771386691.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec771386691.dir/SIZEOF_STRUCT_SOCKADDR_STORAGE.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec771386691.dir/SIZEOF_STRUCT_SOCKADDR_STORAGE.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CheckTypeSize/SIZEOF_STRUCT_SOCKADDR_STORAGE.c
Linking C executable cmTryCompileExec771386691
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec771386691.dir/link.txt --verbose=1
/usr/bin/gcc        CMakeFiles/cmTryCompileExec771386691.dir/SIZEOF_STRUCT_SOCKADDR_STORAGE.c.o  -o cmTryCompileExec771386691 -rdynamic -ldl 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Performing C SOURCE FILE Test HAVE_DIRENT_H succeded with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec769015771/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec769015771.dir/build.make CMakeFiles/cmTryCompileExec769015771.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec769015771.dir/src.c.o
/usr/bin/gcc   -w -DHAVE_DIRENT_H   -o CMakeFiles/cmTryCompileExec769015771.dir/src.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec769015771
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec769015771.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DHAVE_DIRENT_H    CMakeFiles/cmTryCompileExec769015771.dir/src.c.o  -o cmTryCompileExec769015771 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

Source file was:

#include <dirent.h>

int main()
{
   static DIR * tmp;
   if (sizeof(tmp))
      return 0;
  return 0;
}

Determining if files sys/types.h;ctype.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3460325638/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3460325638.dir/build.make CMakeFiles/cmTryCompileExec3460325638.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3460325638.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec3460325638.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3460325638
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3460325638.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec3460325638.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3460325638 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec48465817/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec48465817.dir/build.make CMakeFiles/cmTryCompileExec48465817.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec48465817.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec48465817.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec48465817
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec48465817.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec48465817.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec48465817 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2119002122/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2119002122.dir/build.make CMakeFiles/cmTryCompileExec2119002122.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2119002122.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec2119002122.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2119002122
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2119002122.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec2119002122.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2119002122 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3205158849/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3205158849.dir/build.make CMakeFiles/cmTryCompileExec3205158849.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3205158849.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec3205158849.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3205158849
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3205158849.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec3205158849.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3205158849 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec672905660/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec672905660.dir/build.make CMakeFiles/cmTryCompileExec672905660.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec672905660.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec672905660.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec672905660
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec672905660.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec672905660.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec672905660 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3626334832/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3626334832.dir/build.make CMakeFiles/cmTryCompileExec3626334832.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3626334832.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec3626334832.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3626334832
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3626334832.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec3626334832.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3626334832 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1017212578/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1017212578.dir/build.make CMakeFiles/cmTryCompileExec1017212578.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1017212578.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec1017212578.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1017212578
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1017212578.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec1017212578.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1017212578 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1261347823/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1261347823.dir/build.make CMakeFiles/cmTryCompileExec1261347823.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1261347823.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec1261347823.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1261347823
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1261347823.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec1261347823.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1261347823 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1764952671/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1764952671.dir/build.make CMakeFiles/cmTryCompileExec1764952671.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1764952671.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec1764952671.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1764952671
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1764952671.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec1764952671.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1764952671 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec253044400/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec253044400.dir/build.make CMakeFiles/cmTryCompileExec253044400.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec253044400.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec253044400.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec253044400
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec253044400.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec253044400.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec253044400 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;spawn.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2656802765/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2656802765.dir/build.make CMakeFiles/cmTryCompileExec2656802765.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2656802765.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec2656802765.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2656802765
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2656802765.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec2656802765.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2656802765 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;spawn.h;stdarg.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec109513648/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec109513648.dir/build.make CMakeFiles/cmTryCompileExec109513648.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec109513648.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec109513648.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec109513648
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec109513648.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec109513648.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec109513648 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;spawn.h;stdarg.h;stdint.h;stdlib.h;string.h;strings.h;sys/cdefs.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec413058269/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec413058269.dir/build.make CMakeFiles/cmTryCompileExec413058269.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec413058269.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec413058269.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec413058269
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec413058269.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec413058269.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec413058269 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;spawn.h;stdarg.h;stdint.h;stdlib.h;string.h;strings.h;sys/cdefs.h;sys/ioctl.h;sys/param.h;sys/poll.h;sys/select.h;sys/stat.h;sys/statfs.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1100605055/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1100605055.dir/build.make CMakeFiles/cmTryCompileExec1100605055.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1100605055.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec1100605055.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1100605055
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1100605055.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec1100605055.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1100605055 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;spawn.h;stdarg.h;stdint.h;stdlib.h;string.h;strings.h;sys/cdefs.h;sys/ioctl.h;sys/param.h;sys/poll.h;sys/select.h;sys/stat.h;sys/statfs.h;sys/statvfs.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2940935814/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2940935814.dir/build.make CMakeFiles/cmTryCompileExec2940935814.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2940935814.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec2940935814.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2940935814
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2940935814.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec2940935814.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2940935814 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;spawn.h;stdarg.h;stdint.h;stdlib.h;string.h;strings.h;sys/cdefs.h;sys/ioctl.h;sys/param.h;sys/poll.h;sys/select.h;sys/stat.h;sys/statfs.h;sys/statvfs.h;sys/time.h;sys/utsname.h;sys/vfs.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2424158065/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2424158065.dir/build.make CMakeFiles/cmTryCompileExec2424158065.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2424158065.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec2424158065.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2424158065
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2424158065.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec2424158065.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2424158065 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;spawn.h;stdarg.h;stdint.h;stdlib.h;string.h;strings.h;sys/cdefs.h;sys/ioctl.h;sys/param.h;sys/poll.h;sys/select.h;sys/stat.h;sys/statfs.h;sys/statvfs.h;sys/time.h;sys/utsname.h;sys/vfs.h;sys/wait.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4242243026/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec4242243026.dir/build.make CMakeFiles/cmTryCompileExec4242243026.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4242243026.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec4242243026.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec4242243026
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4242243026.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec4242243026.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec4242243026 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;spawn.h;stdarg.h;stdint.h;stdlib.h;string.h;strings.h;sys/cdefs.h;sys/ioctl.h;sys/param.h;sys/poll.h;sys/select.h;sys/stat.h;sys/statfs.h;sys/statvfs.h;sys/time.h;sys/utsname.h;sys/vfs.h;sys/wait.h;time.h;unistd.h;utime.h;wchar.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2084416281/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2084416281.dir/build.make CMakeFiles/cmTryCompileExec2084416281.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2084416281.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec2084416281.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2084416281
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2084416281.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec2084416281.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2084416281 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;spawn.h;stdarg.h;stdint.h;stdlib.h;string.h;strings.h;sys/cdefs.h;sys/ioctl.h;sys/param.h;sys/poll.h;sys/select.h;sys/stat.h;sys/statfs.h;sys/statvfs.h;sys/time.h;sys/utsname.h;sys/vfs.h;sys/wait.h;time.h;unistd.h;utime.h;wchar.h;wctype.h exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1763517429/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1763517429.dir/build.make CMakeFiles/cmTryCompileExec1763517429.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1763517429.dir/CheckIncludeFiles.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec1763517429.dir/CheckIncludeFiles.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1763517429
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1763517429.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec1763517429.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1763517429 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Performing C SOURCE FILE Test SAFE_TO_DEFINE_EXTENSIONS succeded with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2566280316/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2566280316.dir/build.make CMakeFiles/cmTryCompileExec2566280316.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2566280316.dir/src.c.o
/usr/bin/gcc   -w -DSAFE_TO_DEFINE_EXTENSIONS   -o CMakeFiles/cmTryCompileExec2566280316.dir/src.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec2566280316
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2566280316.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DSAFE_TO_DEFINE_EXTENSIONS    CMakeFiles/cmTryCompileExec2566280316.dir/src.c.o  -o cmTryCompileExec2566280316 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

Source file was:
#define __EXTENSIONS__ 1
   
   int main() { return 0;}
Determining if the function chown exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3014512153/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3014512153.dir/build.make CMakeFiles/cmTryCompileExec3014512153.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3014512153.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=chown  -fno-builtin   -o CMakeFiles/cmTryCompileExec3014512153.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3014512153
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3014512153.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=chown  -fno-builtin    CMakeFiles/cmTryCompileExec3014512153.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3014512153 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function chroot exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2460294093/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2460294093.dir/build.make CMakeFiles/cmTryCompileExec2460294093.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2460294093.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=chroot  -fno-builtin   -o CMakeFiles/cmTryCompileExec2460294093.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2460294093
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2460294093.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=chroot  -fno-builtin    CMakeFiles/cmTryCompileExec2460294093.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2460294093 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function ctime_r exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3417654478/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3417654478.dir/build.make CMakeFiles/cmTryCompileExec3417654478.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3417654478.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=ctime_r  -fno-builtin   -o CMakeFiles/cmTryCompileExec3417654478.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3417654478
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3417654478.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=ctime_r  -fno-builtin    CMakeFiles/cmTryCompileExec3417654478.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3417654478 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function dirfd exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec32505874/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec32505874.dir/build.make CMakeFiles/cmTryCompileExec32505874.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec32505874.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=dirfd  -fno-builtin   -o CMakeFiles/cmTryCompileExec32505874.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec32505874
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec32505874.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=dirfd  -fno-builtin    CMakeFiles/cmTryCompileExec32505874.dir/CheckFunctionExists.c.o  -o cmTryCompileExec32505874 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function fchdir exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1887143127/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1887143127.dir/build.make CMakeFiles/cmTryCompileExec1887143127.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1887143127.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=fchdir  -fno-builtin   -o CMakeFiles/cmTryCompileExec1887143127.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1887143127
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1887143127.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=fchdir  -fno-builtin    CMakeFiles/cmTryCompileExec1887143127.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1887143127 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function fchmod exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec894585253/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec894585253.dir/build.make CMakeFiles/cmTryCompileExec894585253.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec894585253.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=fchmod  -fno-builtin   -o CMakeFiles/cmTryCompileExec894585253.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec894585253
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec894585253.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=fchmod  -fno-builtin    CMakeFiles/cmTryCompileExec894585253.dir/CheckFunctionExists.c.o  -o cmTryCompileExec894585253 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function fchown exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec570020877/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec570020877.dir/build.make CMakeFiles/cmTryCompileExec570020877.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec570020877.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=fchown  -fno-builtin   -o CMakeFiles/cmTryCompileExec570020877.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec570020877
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec570020877.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=fchown  -fno-builtin    CMakeFiles/cmTryCompileExec570020877.dir/CheckFunctionExists.c.o  -o cmTryCompileExec570020877 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function fcntl exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3803913224/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3803913224.dir/build.make CMakeFiles/cmTryCompileExec3803913224.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3803913224.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=fcntl  -fno-builtin   -o CMakeFiles/cmTryCompileExec3803913224.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3803913224
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3803913224.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=fcntl  -fno-builtin    CMakeFiles/cmTryCompileExec3803913224.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3803913224 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function fdopendir exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1101841730/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1101841730.dir/build.make CMakeFiles/cmTryCompileExec1101841730.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1101841730.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=fdopendir  -fno-builtin   -o CMakeFiles/cmTryCompileExec1101841730.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1101841730
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1101841730.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=fdopendir  -fno-builtin    CMakeFiles/cmTryCompileExec1101841730.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1101841730 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function fstat exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1382943149/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1382943149.dir/build.make CMakeFiles/cmTryCompileExec1382943149.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1382943149.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=fstat  -fno-builtin   -o CMakeFiles/cmTryCompileExec1382943149.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1382943149
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1382943149.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=fstat  -fno-builtin    CMakeFiles/cmTryCompileExec1382943149.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1382943149 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function fstatat exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1207795201/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1207795201.dir/build.make CMakeFiles/cmTryCompileExec1207795201.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1207795201.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=fstatat  -fno-builtin   -o CMakeFiles/cmTryCompileExec1207795201.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1207795201
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1207795201.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=fstatat  -fno-builtin    CMakeFiles/cmTryCompileExec1207795201.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1207795201 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function fstatfs exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec640291319/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec640291319.dir/build.make CMakeFiles/cmTryCompileExec640291319.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec640291319.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=fstatfs  -fno-builtin   -o CMakeFiles/cmTryCompileExec640291319.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec640291319
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec640291319.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=fstatfs  -fno-builtin    CMakeFiles/cmTryCompileExec640291319.dir/CheckFunctionExists.c.o  -o cmTryCompileExec640291319 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function fstatvfs exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2358182410/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2358182410.dir/build.make CMakeFiles/cmTryCompileExec2358182410.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2358182410.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=fstatvfs  -fno-builtin   -o CMakeFiles/cmTryCompileExec2358182410.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2358182410
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2358182410.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=fstatvfs  -fno-builtin    CMakeFiles/cmTryCompileExec2358182410.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2358182410 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function futimens exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2104507954/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2104507954.dir/build.make CMakeFiles/cmTryCompileExec2104507954.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2104507954.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=futimens  -fno-builtin   -o CMakeFiles/cmTryCompileExec2104507954.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2104507954
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2104507954.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=futimens  -fno-builtin    CMakeFiles/cmTryCompileExec2104507954.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2104507954 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function futimes exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2571570272/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2571570272.dir/build.make CMakeFiles/cmTryCompileExec2571570272.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2571570272.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=futimes  -fno-builtin   -o CMakeFiles/cmTryCompileExec2571570272.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2571570272
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2571570272.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=futimes  -fno-builtin    CMakeFiles/cmTryCompileExec2571570272.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2571570272 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function futimesat exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3168616413/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3168616413.dir/build.make CMakeFiles/cmTryCompileExec3168616413.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3168616413.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=futimesat  -fno-builtin   -o CMakeFiles/cmTryCompileExec3168616413.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3168616413
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3168616413.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=futimesat  -fno-builtin    CMakeFiles/cmTryCompileExec3168616413.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3168616413 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function getgrgid_r exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2187387671/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2187387671.dir/build.make CMakeFiles/cmTryCompileExec2187387671.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2187387671.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=getgrgid_r  -fno-builtin   -o CMakeFiles/cmTryCompileExec2187387671.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2187387671
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2187387671.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=getgrgid_r  -fno-builtin    CMakeFiles/cmTryCompileExec2187387671.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2187387671 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function getgrnam_r exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3208957325/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3208957325.dir/build.make CMakeFiles/cmTryCompileExec3208957325.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3208957325.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=getgrnam_r  -fno-builtin   -o CMakeFiles/cmTryCompileExec3208957325.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3208957325
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3208957325.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=getgrnam_r  -fno-builtin    CMakeFiles/cmTryCompileExec3208957325.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3208957325 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function getpwnam_r exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3425987237/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3425987237.dir/build.make CMakeFiles/cmTryCompileExec3425987237.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3425987237.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=getpwnam_r  -fno-builtin   -o CMakeFiles/cmTryCompileExec3425987237.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3425987237
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3425987237.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=getpwnam_r  -fno-builtin    CMakeFiles/cmTryCompileExec3425987237.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3425987237 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function getpwuid_r exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec447886957/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec447886957.dir/build.make CMakeFiles/cmTryCompileExec447886957.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec447886957.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=getpwuid_r  -fno-builtin   -o CMakeFiles/cmTryCompileExec447886957.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec447886957
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec447886957.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=getpwuid_r  -fno-builtin    CMakeFiles/cmTryCompileExec447886957.dir/CheckFunctionExists.c.o  -o cmTryCompileExec447886957 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function getpid exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3804562976/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3804562976.dir/build.make CMakeFiles/cmTryCompileExec3804562976.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3804562976.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=getpid  -fno-builtin   -o CMakeFiles/cmTryCompileExec3804562976.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3804562976
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3804562976.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=getpid  -fno-builtin    CMakeFiles/cmTryCompileExec3804562976.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3804562976 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function lchown exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec600049329/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec600049329.dir/build.make CMakeFiles/cmTryCompileExec600049329.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec600049329.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=lchown  -fno-builtin   -o CMakeFiles/cmTryCompileExec600049329.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec600049329
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec600049329.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=lchown  -fno-builtin    CMakeFiles/cmTryCompileExec600049329.dir/CheckFunctionExists.c.o  -o cmTryCompileExec600049329 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function link exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2810044823/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2810044823.dir/build.make CMakeFiles/cmTryCompileExec2810044823.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2810044823.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=link  -fno-builtin   -o CMakeFiles/cmTryCompileExec2810044823.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2810044823
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2810044823.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=link  -fno-builtin    CMakeFiles/cmTryCompileExec2810044823.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2810044823 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function lstat exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2787221006/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2787221006.dir/build.make CMakeFiles/cmTryCompileExec2787221006.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2787221006.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=lstat  -fno-builtin   -o CMakeFiles/cmTryCompileExec2787221006.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2787221006
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2787221006.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=lstat  -fno-builtin    CMakeFiles/cmTryCompileExec2787221006.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2787221006 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function lutimes exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2722595343/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2722595343.dir/build.make CMakeFiles/cmTryCompileExec2722595343.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2722595343.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=lutimes  -fno-builtin   -o CMakeFiles/cmTryCompileExec2722595343.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2722595343
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2722595343.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=lutimes  -fno-builtin    CMakeFiles/cmTryCompileExec2722595343.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2722595343 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function mbrtowc exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3367490537/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3367490537.dir/build.make CMakeFiles/cmTryCompileExec3367490537.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3367490537.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=mbrtowc  -fno-builtin   -o CMakeFiles/cmTryCompileExec3367490537.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3367490537
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3367490537.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=mbrtowc  -fno-builtin    CMakeFiles/cmTryCompileExec3367490537.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3367490537 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function memmove exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3107599147/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3107599147.dir/build.make CMakeFiles/cmTryCompileExec3107599147.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3107599147.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=memmove  -fno-builtin   -o CMakeFiles/cmTryCompileExec3107599147.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3107599147
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3107599147.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=memmove  -fno-builtin    CMakeFiles/cmTryCompileExec3107599147.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3107599147 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function mkdir exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3989066478/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3989066478.dir/build.make CMakeFiles/cmTryCompileExec3989066478.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3989066478.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=mkdir  -fno-builtin   -o CMakeFiles/cmTryCompileExec3989066478.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3989066478
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3989066478.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=mkdir  -fno-builtin    CMakeFiles/cmTryCompileExec3989066478.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3989066478 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function mkfifo exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec671309472/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec671309472.dir/build.make CMakeFiles/cmTryCompileExec671309472.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec671309472.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=mkfifo  -fno-builtin   -o CMakeFiles/cmTryCompileExec671309472.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec671309472
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec671309472.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=mkfifo  -fno-builtin    CMakeFiles/cmTryCompileExec671309472.dir/CheckFunctionExists.c.o  -o cmTryCompileExec671309472 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function mknod exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2736090709/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2736090709.dir/build.make CMakeFiles/cmTryCompileExec2736090709.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2736090709.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=mknod  -fno-builtin   -o CMakeFiles/cmTryCompileExec2736090709.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2736090709
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2736090709.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=mknod  -fno-builtin    CMakeFiles/cmTryCompileExec2736090709.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2736090709 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function mkstemp exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2530592290/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2530592290.dir/build.make CMakeFiles/cmTryCompileExec2530592290.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2530592290.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=mkstemp  -fno-builtin   -o CMakeFiles/cmTryCompileExec2530592290.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2530592290
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2530592290.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=mkstemp  -fno-builtin    CMakeFiles/cmTryCompileExec2530592290.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2530592290 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function nl_langinfo exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1497632490/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1497632490.dir/build.make CMakeFiles/cmTryCompileExec1497632490.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1497632490.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=nl_langinfo  -fno-builtin   -o CMakeFiles/cmTryCompileExec1497632490.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1497632490
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1497632490.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=nl_langinfo  -fno-builtin    CMakeFiles/cmTryCompileExec1497632490.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1497632490 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function openat exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4156265666/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec4156265666.dir/build.make CMakeFiles/cmTryCompileExec4156265666.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4156265666.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=openat  -fno-builtin   -o CMakeFiles/cmTryCompileExec4156265666.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec4156265666
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4156265666.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=openat  -fno-builtin    CMakeFiles/cmTryCompileExec4156265666.dir/CheckFunctionExists.c.o  -o cmTryCompileExec4156265666 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function posix_spawnp exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1544355368/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1544355368.dir/build.make CMakeFiles/cmTryCompileExec1544355368.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1544355368.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=posix_spawnp  -fno-builtin   -o CMakeFiles/cmTryCompileExec1544355368.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1544355368
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1544355368.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=posix_spawnp  -fno-builtin    CMakeFiles/cmTryCompileExec1544355368.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1544355368 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function readlink exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4232711398/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec4232711398.dir/build.make CMakeFiles/cmTryCompileExec4232711398.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4232711398.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=readlink  -fno-builtin   -o CMakeFiles/cmTryCompileExec4232711398.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec4232711398
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4232711398.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=readlink  -fno-builtin    CMakeFiles/cmTryCompileExec4232711398.dir/CheckFunctionExists.c.o  -o cmTryCompileExec4232711398 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function setenv exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1533229261/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1533229261.dir/build.make CMakeFiles/cmTryCompileExec1533229261.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1533229261.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=setenv  -fno-builtin   -o CMakeFiles/cmTryCompileExec1533229261.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1533229261
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1533229261.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=setenv  -fno-builtin    CMakeFiles/cmTryCompileExec1533229261.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1533229261 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function statfs exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1545185189/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1545185189.dir/build.make CMakeFiles/cmTryCompileExec1545185189.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1545185189.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=statfs  -fno-builtin   -o CMakeFiles/cmTryCompileExec1545185189.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1545185189
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1545185189.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=statfs  -fno-builtin    CMakeFiles/cmTryCompileExec1545185189.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1545185189 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function statvfs exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2216136402/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2216136402.dir/build.make CMakeFiles/cmTryCompileExec2216136402.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2216136402.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=statvfs  -fno-builtin   -o CMakeFiles/cmTryCompileExec2216136402.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2216136402
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2216136402.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=statvfs  -fno-builtin    CMakeFiles/cmTryCompileExec2216136402.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2216136402 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function strchr exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1875723014/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1875723014.dir/build.make CMakeFiles/cmTryCompileExec1875723014.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1875723014.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=strchr  -fno-builtin   -o CMakeFiles/cmTryCompileExec1875723014.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1875723014
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1875723014.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=strchr  -fno-builtin    CMakeFiles/cmTryCompileExec1875723014.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1875723014 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function strerror exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1383432967/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1383432967.dir/build.make CMakeFiles/cmTryCompileExec1383432967.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1383432967.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=strerror  -fno-builtin   -o CMakeFiles/cmTryCompileExec1383432967.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1383432967
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1383432967.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=strerror  -fno-builtin    CMakeFiles/cmTryCompileExec1383432967.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1383432967 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function strrchr exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3542060486/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3542060486.dir/build.make CMakeFiles/cmTryCompileExec3542060486.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3542060486.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=strrchr  -fno-builtin   -o CMakeFiles/cmTryCompileExec3542060486.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3542060486
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3542060486.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=strrchr  -fno-builtin    CMakeFiles/cmTryCompileExec3542060486.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3542060486 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function symlink exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1690462071/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1690462071.dir/build.make CMakeFiles/cmTryCompileExec1690462071.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1690462071.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=symlink  -fno-builtin   -o CMakeFiles/cmTryCompileExec1690462071.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1690462071
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1690462071.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=symlink  -fno-builtin    CMakeFiles/cmTryCompileExec1690462071.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1690462071 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function timegm exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2690370943/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2690370943.dir/build.make CMakeFiles/cmTryCompileExec2690370943.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2690370943.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=timegm  -fno-builtin   -o CMakeFiles/cmTryCompileExec2690370943.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2690370943
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2690370943.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=timegm  -fno-builtin    CMakeFiles/cmTryCompileExec2690370943.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2690370943 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function tzset exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2379086764/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2379086764.dir/build.make CMakeFiles/cmTryCompileExec2379086764.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2379086764.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=tzset  -fno-builtin   -o CMakeFiles/cmTryCompileExec2379086764.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2379086764
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2379086764.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=tzset  -fno-builtin    CMakeFiles/cmTryCompileExec2379086764.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2379086764 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function utimes exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3943941463/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3943941463.dir/build.make CMakeFiles/cmTryCompileExec3943941463.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3943941463.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=utimes  -fno-builtin   -o CMakeFiles/cmTryCompileExec3943941463.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3943941463
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3943941463.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=utimes  -fno-builtin    CMakeFiles/cmTryCompileExec3943941463.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3943941463 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function utimensat exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2931111750/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2931111750.dir/build.make CMakeFiles/cmTryCompileExec2931111750.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2931111750.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=utimensat  -fno-builtin   -o CMakeFiles/cmTryCompileExec2931111750.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2931111750
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2931111750.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=utimensat  -fno-builtin    CMakeFiles/cmTryCompileExec2931111750.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2931111750 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function vfork exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2480522098/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2480522098.dir/build.make CMakeFiles/cmTryCompileExec2480522098.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2480522098.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=vfork  -fno-builtin   -o CMakeFiles/cmTryCompileExec2480522098.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2480522098
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2480522098.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=vfork  -fno-builtin    CMakeFiles/cmTryCompileExec2480522098.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2480522098 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function wcrtomb exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1988815467/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1988815467.dir/build.make CMakeFiles/cmTryCompileExec1988815467.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1988815467.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=wcrtomb  -fno-builtin   -o CMakeFiles/cmTryCompileExec1988815467.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1988815467
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1988815467.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=wcrtomb  -fno-builtin    CMakeFiles/cmTryCompileExec1988815467.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1988815467 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function wcscmp exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2480502357/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2480502357.dir/build.make CMakeFiles/cmTryCompileExec2480502357.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2480502357.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=wcscmp  -fno-builtin   -o CMakeFiles/cmTryCompileExec2480502357.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2480502357
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2480502357.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=wcscmp  -fno-builtin    CMakeFiles/cmTryCompileExec2480502357.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2480502357 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function wcscpy exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2423488672/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2423488672.dir/build.make CMakeFiles/cmTryCompileExec2423488672.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2423488672.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=wcscpy  -fno-builtin   -o CMakeFiles/cmTryCompileExec2423488672.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2423488672
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2423488672.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=wcscpy  -fno-builtin    CMakeFiles/cmTryCompileExec2423488672.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2423488672 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function wcslen exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec215831106/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec215831106.dir/build.make CMakeFiles/cmTryCompileExec215831106.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec215831106.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=wcslen  -fno-builtin   -o CMakeFiles/cmTryCompileExec215831106.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec215831106
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec215831106.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=wcslen  -fno-builtin    CMakeFiles/cmTryCompileExec215831106.dir/CheckFunctionExists.c.o  -o cmTryCompileExec215831106 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function wctomb exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2511670013/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2511670013.dir/build.make CMakeFiles/cmTryCompileExec2511670013.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2511670013.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=wctomb  -fno-builtin   -o CMakeFiles/cmTryCompileExec2511670013.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2511670013
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2511670013.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=wctomb  -fno-builtin    CMakeFiles/cmTryCompileExec2511670013.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2511670013 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function fseeko exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3032753205/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3032753205.dir/build.make CMakeFiles/cmTryCompileExec3032753205.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3032753205.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=fseeko  -fno-builtin   -o CMakeFiles/cmTryCompileExec3032753205.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3032753205
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3032753205.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=fseeko  -fno-builtin    CMakeFiles/cmTryCompileExec3032753205.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3032753205 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function vprintf exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2511079666/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2511079666.dir/build.make CMakeFiles/cmTryCompileExec2511079666.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2511079666.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=vprintf  -fno-builtin   -o CMakeFiles/cmTryCompileExec2511079666.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2511079666
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2511079666.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=vprintf  -fno-builtin    CMakeFiles/cmTryCompileExec2511079666.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2511079666 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function wmemcmp exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2772224846/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2772224846.dir/build.make CMakeFiles/cmTryCompileExec2772224846.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2772224846.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=wmemcmp  -fno-builtin   -o CMakeFiles/cmTryCompileExec2772224846.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2772224846
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2772224846.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=wmemcmp  -fno-builtin    CMakeFiles/cmTryCompileExec2772224846.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2772224846 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function wmemcpy exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2037087057/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2037087057.dir/build.make CMakeFiles/cmTryCompileExec2037087057.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2037087057.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=wmemcpy  -fno-builtin   -o CMakeFiles/cmTryCompileExec2037087057.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2037087057
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2037087057.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DCHECK_FUNCTION_EXISTS=wmemcpy  -fno-builtin    CMakeFiles/cmTryCompileExec2037087057.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2037087057 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Performing C SOURCE FILE Test HAVE_READDIR_R succeded with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1580161203/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1580161203.dir/build.make CMakeFiles/cmTryCompileExec1580161203.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1580161203.dir/src.c.o
/usr/bin/gcc   -w -DHAVE_READDIR_R   -o CMakeFiles/cmTryCompileExec1580161203.dir/src.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec1580161203
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1580161203.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DHAVE_READDIR_R    CMakeFiles/cmTryCompileExec1580161203.dir/src.c.o  -o cmTryCompileExec1580161203 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

Source file was:
#include <dirent.h>
int main() {DIR *d = opendir("."); struct dirent e,*r; return readdir_r(d,&e,&r);}
Performing C SOURCE FILE Test HAVE_READLINKAT succeded with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec5461976/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec5461976.dir/build.make CMakeFiles/cmTryCompileExec5461976.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec5461976.dir/src.c.o
/usr/bin/gcc   -w -DHAVE_READLINKAT   -o CMakeFiles/cmTryCompileExec5461976.dir/src.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec5461976
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec5461976.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DHAVE_READLINKAT    CMakeFiles/cmTryCompileExec5461976.dir/src.c.o  -o cmTryCompileExec5461976 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

Source file was:
#include <fcntl.h>
#include <unistd.h>
int main() {char buf[10]; return readlinkat(AT_FDCWD, "", buf, 0);}
Performing C SOURCE FILE Test MAJOR_IN_SYSMACROS succeded with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3830277960/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3830277960.dir/build.make CMakeFiles/cmTryCompileExec3830277960.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3830277960.dir/src.c.o
/usr/bin/gcc   -w -DMAJOR_IN_SYSMACROS   -o CMakeFiles/cmTryCompileExec3830277960.dir/src.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec3830277960
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3830277960.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DMAJOR_IN_SYSMACROS    CMakeFiles/cmTryCompileExec3830277960.dir/src.c.o  -o cmTryCompileExec3830277960 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

Source file was:
#include <sys/sysmacros.h>
int main() { return major(256); }
Determining if the EILSEQ exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec306542025/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec306542025.dir/build.make CMakeFiles/cmTryCompileExec306542025.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec306542025.dir/CheckSymbolExists.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec306542025.dir/CheckSymbolExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec306542025
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec306542025.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec306542025.dir/CheckSymbolExists.c.o  -o cmTryCompileExec306542025 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

File /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <errno.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef EILSEQ
  return ((int*)(&EILSEQ))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the INT64_MAX exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3795045128/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3795045128.dir/build.make CMakeFiles/cmTryCompileExec3795045128.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3795045128.dir/CheckSymbolExists.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec3795045128.dir/CheckSymbolExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3795045128
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3795045128.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec3795045128.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3795045128 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

File /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <limits.h>
#include <stdint.h>
#include <inttypes.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef INT64_MAX
  return ((int*)(&INT64_MAX))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the INT64_MIN exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4282296492/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec4282296492.dir/build.make CMakeFiles/cmTryCompileExec4282296492.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4282296492.dir/CheckSymbolExists.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec4282296492.dir/CheckSymbolExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec4282296492
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4282296492.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec4282296492.dir/CheckSymbolExists.c.o  -o cmTryCompileExec4282296492 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

File /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <limits.h>
#include <stdint.h>
#include <inttypes.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef INT64_MIN
  return ((int*)(&INT64_MIN))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the UINT32_MAX exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec445346667/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec445346667.dir/build.make CMakeFiles/cmTryCompileExec445346667.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec445346667.dir/CheckSymbolExists.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec445346667.dir/CheckSymbolExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec445346667
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec445346667.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec445346667.dir/CheckSymbolExists.c.o  -o cmTryCompileExec445346667 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

File /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <limits.h>
#include <stdint.h>
#include <inttypes.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef UINT32_MAX
  return ((int*)(&UINT32_MAX))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the UINT64_MAX exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3631120224/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3631120224.dir/build.make CMakeFiles/cmTryCompileExec3631120224.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3631120224.dir/CheckSymbolExists.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec3631120224.dir/CheckSymbolExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3631120224
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3631120224.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec3631120224.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3631120224 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

File /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <limits.h>
#include <stdint.h>
#include <inttypes.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef UINT64_MAX
  return ((int*)(&UINT64_MAX))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the SIZE_MAX exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1801995215/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1801995215.dir/build.make CMakeFiles/cmTryCompileExec1801995215.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1801995215.dir/CheckSymbolExists.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec1801995215.dir/CheckSymbolExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1801995215
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1801995215.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec1801995215.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1801995215 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

File /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <limits.h>
#include <stdint.h>
#include <inttypes.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef SIZE_MAX
  return ((int*)(&SIZE_MAX))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the SSIZE_MAX exist passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2785475031/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2785475031.dir/build.make CMakeFiles/cmTryCompileExec2785475031.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2785475031.dir/CheckSymbolExists.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec2785475031.dir/CheckSymbolExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2785475031
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2785475031.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec2785475031.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2785475031 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

File /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <limits.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef SSIZE_MAX
  return ((int*)(&SSIZE_MAX))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Performing C SOURCE FILE Test HAVE_STRUCT_TM_TM_GMTOFF succeded with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2401282256/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2401282256.dir/build.make CMakeFiles/cmTryCompileExec2401282256.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2401282256.dir/src.c.o
/usr/bin/gcc   -w -DHAVE_STRUCT_TM_TM_GMTOFF   -o CMakeFiles/cmTryCompileExec2401282256.dir/src.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec2401282256
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2401282256.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DHAVE_STRUCT_TM_TM_GMTOFF    CMakeFiles/cmTryCompileExec2401282256.dir/src.c.o  -o cmTryCompileExec2401282256 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

Source file was:

#include <time.h>

int main()
{
   static struct tm tmp;
   if (sizeof(tmp.tm_gmtoff))
      return 0;
  return 0;
}

Performing C SOURCE FILE Test HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC succeded with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec535758231/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec535758231.dir/build.make CMakeFiles/cmTryCompileExec535758231.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec535758231.dir/src.c.o
/usr/bin/gcc   -w -DHAVE_STRUCT_STAT_ST_MTIM_TV_NSEC   -o CMakeFiles/cmTryCompileExec535758231.dir/src.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec535758231
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec535758231.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DHAVE_STRUCT_STAT_ST_MTIM_TV_NSEC    CMakeFiles/cmTryCompileExec535758231.dir/src.c.o  -o cmTryCompileExec535758231 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

Source file was:

#include <sys/types.h>
#include <sys/stat.h>

int main()
{
   static struct stat tmp;
   if (sizeof(tmp.st_mtim.tv_nsec))
      return 0;
  return 0;
}

Performing C SOURCE FILE Test HAVE_STRUCT_STAT_ST_BLKSIZE succeded with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec853041876/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec853041876.dir/build.make CMakeFiles/cmTryCompileExec853041876.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec853041876.dir/src.c.o
/usr/bin/gcc   -w -DHAVE_STRUCT_STAT_ST_BLKSIZE   -o CMakeFiles/cmTryCompileExec853041876.dir/src.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec853041876
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec853041876.dir/link.txt --verbose=1
/usr/bin/gcc   -w -DHAVE_STRUCT_STAT_ST_BLKSIZE    CMakeFiles/cmTryCompileExec853041876.dir/src.c.o  -o cmTryCompileExec853041876 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

Source file was:

#include <sys/types.h>
#include <sys/stat.h>

int main()
{
   static struct stat tmp;
   if (sizeof(tmp.st_blksize))
      return 0;
  return 0;
}

Determining size of short passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec234858909/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec234858909.dir/build.make CMakeFiles/cmTryCompileExec234858909.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec234858909.dir/SIZE_OF_SHORT.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec234858909.dir/SIZE_OF_SHORT.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CheckTypeSize/SIZE_OF_SHORT.c
Linking C executable cmTryCompileExec234858909
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec234858909.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec234858909.dir/SIZE_OF_SHORT.c.o  -o cmTryCompileExec234858909 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining size of int passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec178918631/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec178918631.dir/build.make CMakeFiles/cmTryCompileExec178918631.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec178918631.dir/SIZE_OF_INT.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec178918631.dir/SIZE_OF_INT.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CheckTypeSize/SIZE_OF_INT.c
Linking C executable cmTryCompileExec178918631
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec178918631.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec178918631.dir/SIZE_OF_INT.c.o  -o cmTryCompileExec178918631 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining size of long passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1236835757/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1236835757.dir/build.make CMakeFiles/cmTryCompileExec1236835757.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1236835757.dir/SIZE_OF_LONG.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec1236835757.dir/SIZE_OF_LONG.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CheckTypeSize/SIZE_OF_LONG.c
Linking C executable cmTryCompileExec1236835757
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1236835757.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec1236835757.dir/SIZE_OF_LONG.c.o  -o cmTryCompileExec1236835757 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining size of long long passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2690816580/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2690816580.dir/build.make CMakeFiles/cmTryCompileExec2690816580.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2690816580.dir/SIZE_OF_LONG_LONG.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec2690816580.dir/SIZE_OF_LONG_LONG.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CheckTypeSize/SIZE_OF_LONG_LONG.c
Linking C executable cmTryCompileExec2690816580
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2690816580.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec2690816580.dir/SIZE_OF_LONG_LONG.c.o  -o cmTryCompileExec2690816580 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining size of unsigned short passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2705687317/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2705687317.dir/build.make CMakeFiles/cmTryCompileExec2705687317.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2705687317.dir/SIZE_OF_UNSIGNED_SHORT.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec2705687317.dir/SIZE_OF_UNSIGNED_SHORT.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CheckTypeSize/SIZE_OF_UNSIGNED_SHORT.c
Linking C executable cmTryCompileExec2705687317
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2705687317.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec2705687317.dir/SIZE_OF_UNSIGNED_SHORT.c.o  -o cmTryCompileExec2705687317 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining size of unsigned passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec142411751/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec142411751.dir/build.make CMakeFiles/cmTryCompileExec142411751.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec142411751.dir/SIZE_OF_UNSIGNED.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec142411751.dir/SIZE_OF_UNSIGNED.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CheckTypeSize/SIZE_OF_UNSIGNED.c
Linking C executable cmTryCompileExec142411751
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec142411751.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec142411751.dir/SIZE_OF_UNSIGNED.c.o  -o cmTryCompileExec142411751 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining size of unsigned long passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4153759825/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec4153759825.dir/build.make CMakeFiles/cmTryCompileExec4153759825.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4153759825.dir/SIZE_OF_UNSIGNED_LONG.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec4153759825.dir/SIZE_OF_UNSIGNED_LONG.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CheckTypeSize/SIZE_OF_UNSIGNED_LONG.c
Linking C executable cmTryCompileExec4153759825
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4153759825.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec4153759825.dir/SIZE_OF_UNSIGNED_LONG.c.o  -o cmTryCompileExec4153759825 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining size of unsigned long long passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2428125645/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2428125645.dir/build.make CMakeFiles/cmTryCompileExec2428125645.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2428125645.dir/SIZE_OF_UNSIGNED_LONG_LONG.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec2428125645.dir/SIZE_OF_UNSIGNED_LONG_LONG.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CheckTypeSize/SIZE_OF_UNSIGNED_LONG_LONG.c
Linking C executable cmTryCompileExec2428125645
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2428125645.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec2428125645.dir/SIZE_OF_UNSIGNED_LONG_LONG.c.o  -o cmTryCompileExec2428125645 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining size of int16_t passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1401964314/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1401964314.dir/build.make CMakeFiles/cmTryCompileExec1401964314.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1401964314.dir/INT16_T.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec1401964314.dir/INT16_T.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CheckTypeSize/INT16_T.c
Linking C executable cmTryCompileExec1401964314
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1401964314.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec1401964314.dir/INT16_T.c.o  -o cmTryCompileExec1401964314 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining size of int32_t passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec369529014/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec369529014.dir/build.make CMakeFiles/cmTryCompileExec369529014.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec369529014.dir/INT32_T.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec369529014.dir/INT32_T.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CheckTypeSize/INT32_T.c
Linking C executable cmTryCompileExec369529014
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec369529014.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec369529014.dir/INT32_T.c.o  -o cmTryCompileExec369529014 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining size of int64_t passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2082514144/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2082514144.dir/build.make CMakeFiles/cmTryCompileExec2082514144.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2082514144.dir/INT64_T.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec2082514144.dir/INT64_T.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CheckTypeSize/INT64_T.c
Linking C executable cmTryCompileExec2082514144
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2082514144.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec2082514144.dir/INT64_T.c.o  -o cmTryCompileExec2082514144 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining size of intmax_t passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3600659891/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3600659891.dir/build.make CMakeFiles/cmTryCompileExec3600659891.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3600659891.dir/INTMAX_T.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec3600659891.dir/INTMAX_T.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CheckTypeSize/INTMAX_T.c
Linking C executable cmTryCompileExec3600659891
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3600659891.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec3600659891.dir/INTMAX_T.c.o  -o cmTryCompileExec3600659891 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining size of uint8_t passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1273242432/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1273242432.dir/build.make CMakeFiles/cmTryCompileExec1273242432.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1273242432.dir/UINT8_T.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec1273242432.dir/UINT8_T.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CheckTypeSize/UINT8_T.c
Linking C executable cmTryCompileExec1273242432
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1273242432.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec1273242432.dir/UINT8_T.c.o  -o cmTryCompileExec1273242432 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining size of uint16_t passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1645657807/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1645657807.dir/build.make CMakeFiles/cmTryCompileExec1645657807.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1645657807.dir/UINT16_T.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec1645657807.dir/UINT16_T.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CheckTypeSize/UINT16_T.c
Linking C executable cmTryCompileExec1645657807
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1645657807.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec1645657807.dir/UINT16_T.c.o  -o cmTryCompileExec1645657807 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining size of uint32_t passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3121898399/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3121898399.dir/build.make CMakeFiles/cmTryCompileExec3121898399.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3121898399.dir/UINT32_T.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec3121898399.dir/UINT32_T.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CheckTypeSize/UINT32_T.c
Linking C executable cmTryCompileExec3121898399
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3121898399.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec3121898399.dir/UINT32_T.c.o  -o cmTryCompileExec3121898399 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining size of uint64_t passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1028382483/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1028382483.dir/build.make CMakeFiles/cmTryCompileExec1028382483.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1028382483.dir/UINT64_T.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec1028382483.dir/UINT64_T.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CheckTypeSize/UINT64_T.c
Linking C executable cmTryCompileExec1028382483
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1028382483.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec1028382483.dir/UINT64_T.c.o  -o cmTryCompileExec1028382483 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining size of uintmax_t passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1020869753/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1020869753.dir/build.make CMakeFiles/cmTryCompileExec1020869753.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1020869753.dir/UINTMAX_T.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec1020869753.dir/UINTMAX_T.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CheckTypeSize/UINTMAX_T.c
Linking C executable cmTryCompileExec1020869753
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1020869753.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec1020869753.dir/UINTMAX_T.c.o  -o cmTryCompileExec1020869753 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining size of dev_t passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3381804064/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3381804064.dir/build.make CMakeFiles/cmTryCompileExec3381804064.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3381804064.dir/DEV_T.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec3381804064.dir/DEV_T.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CheckTypeSize/DEV_T.c
Linking C executable cmTryCompileExec3381804064
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3381804064.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec3381804064.dir/DEV_T.c.o  -o cmTryCompileExec3381804064 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining size of gid_t passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec703816300/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec703816300.dir/build.make CMakeFiles/cmTryCompileExec703816300.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec703816300.dir/GID_T.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec703816300.dir/GID_T.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CheckTypeSize/GID_T.c
Linking C executable cmTryCompileExec703816300
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec703816300.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec703816300.dir/GID_T.c.o  -o cmTryCompileExec703816300 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining size of id_t passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1145352288/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1145352288.dir/build.make CMakeFiles/cmTryCompileExec1145352288.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1145352288.dir/ID_T.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec1145352288.dir/ID_T.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CheckTypeSize/ID_T.c
Linking C executable cmTryCompileExec1145352288
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1145352288.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec1145352288.dir/ID_T.c.o  -o cmTryCompileExec1145352288 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining size of mode_t passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2445340043/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2445340043.dir/build.make CMakeFiles/cmTryCompileExec2445340043.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2445340043.dir/MODE_T.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec2445340043.dir/MODE_T.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CheckTypeSize/MODE_T.c
Linking C executable cmTryCompileExec2445340043
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2445340043.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec2445340043.dir/MODE_T.c.o  -o cmTryCompileExec2445340043 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining size of off_t passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec472380775/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec472380775.dir/build.make CMakeFiles/cmTryCompileExec472380775.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec472380775.dir/OFF_T.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec472380775.dir/OFF_T.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CheckTypeSize/OFF_T.c
Linking C executable cmTryCompileExec472380775
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec472380775.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec472380775.dir/OFF_T.c.o  -o cmTryCompileExec472380775 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining size of size_t passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2267822973/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2267822973.dir/build.make CMakeFiles/cmTryCompileExec2267822973.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2267822973.dir/SIZE_T.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec2267822973.dir/SIZE_T.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CheckTypeSize/SIZE_T.c
Linking C executable cmTryCompileExec2267822973
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2267822973.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec2267822973.dir/SIZE_T.c.o  -o cmTryCompileExec2267822973 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining size of ssize_t passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1250170663/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1250170663.dir/build.make CMakeFiles/cmTryCompileExec1250170663.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1250170663.dir/SSIZE_T.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec1250170663.dir/SSIZE_T.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CheckTypeSize/SSIZE_T.c
Linking C executable cmTryCompileExec1250170663
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1250170663.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec1250170663.dir/SSIZE_T.c.o  -o cmTryCompileExec1250170663 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining size of uid_t passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3464917161/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3464917161.dir/build.make CMakeFiles/cmTryCompileExec3464917161.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3464917161.dir/UID_T.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec3464917161.dir/UID_T.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CheckTypeSize/UID_T.c
Linking C executable cmTryCompileExec3464917161
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3464917161.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec3464917161.dir/UID_T.c.o  -o cmTryCompileExec3464917161 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining size of pid_t passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3046264831/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3046264831.dir/build.make CMakeFiles/cmTryCompileExec3046264831.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3046264831.dir/PID_T.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec3046264831.dir/PID_T.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CheckTypeSize/PID_T.c
Linking C executable cmTryCompileExec3046264831
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3046264831.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec3046264831.dir/PID_T.c.o  -o cmTryCompileExec3046264831 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining size of intptr_t passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1860993866/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1860993866.dir/build.make CMakeFiles/cmTryCompileExec1860993866.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1860993866.dir/INTPTR_T.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec1860993866.dir/INTPTR_T.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CheckTypeSize/INTPTR_T.c
Linking C executable cmTryCompileExec1860993866
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1860993866.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec1860993866.dir/INTPTR_T.c.o  -o cmTryCompileExec1860993866 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining size of uintptr_t passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2576560247/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2576560247.dir/build.make CMakeFiles/cmTryCompileExec2576560247.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2576560247.dir/UINTPTR_T.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec2576560247.dir/UINTPTR_T.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CheckTypeSize/UINTPTR_T.c
Linking C executable cmTryCompileExec2576560247
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2576560247.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec2576560247.dir/UINTPTR_T.c.o  -o cmTryCompileExec2576560247 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining size of wchar_t passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec42888838/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec42888838.dir/build.make CMakeFiles/cmTryCompileExec42888838.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec42888838.dir/SIZEOF_WCHAR_T.c.o
/usr/bin/gcc   -w    -o CMakeFiles/cmTryCompileExec42888838.dir/SIZEOF_WCHAR_T.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CheckTypeSize/SIZEOF_WCHAR_T.c
Linking C executable cmTryCompileExec42888838
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec42888838.dir/link.txt --verbose=1
/usr/bin/gcc   -w     CMakeFiles/cmTryCompileExec42888838.dir/SIZEOF_WCHAR_T.c.o  -o cmTryCompileExec42888838 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Checking support for ARCHIVE_CRYPTO_MD5_LIBC failed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2546668088/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2546668088.dir/build.make CMakeFiles/cmTryCompileExec2546668088.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2546668088.dir/check_crypto_md.c.o
/usr/bin/gcc   -w  -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2 -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmlibarchive/libarchive -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec2546668088.dir/check_crypto_md.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1186:0:
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:61:17: fatal error: md5.h: No such file or directory
 #include <md5.h>
                 ^
compilation terminated.
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec2546668088.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec2546668088/fast] Error 2

Source file was:
/* config.h.  Generated from build/cmake/config.h.in by cmake configure */
#if defined(__osf__)
# define _OSF_SOURCE
#endif

/*
 * Ensure we have C99-style int64_t, etc, all defined.
 */

/* First, we need to know if the system has already defined them. */
#define HAVE_INT16_T
#define HAVE_INT32_T
#define HAVE_INT64_T
#define HAVE_INTMAX_T

#define HAVE_UINT8_T
#define HAVE_UINT16_T
#define HAVE_UINT32_T
#define HAVE_UINT64_T
#define HAVE_UINTMAX_T

/* We might have the types we want under other spellings. */
/* #undef HAVE___INT64 */
/* #undef HAVE_U_INT64_T */
/* #undef HAVE_UNSIGNED___INT64 */

/* The sizes of various standard integer types. */
#define SIZE_OF_SHORT 2
#define SIZE_OF_INT 4
#define SIZE_OF_LONG 8
#define SIZE_OF_LONG_LONG 8
#define SIZE_OF_UNSIGNED_SHORT 2
#define SIZE_OF_UNSIGNED 4
#define SIZE_OF_UNSIGNED_LONG 8
#define SIZE_OF_UNSIGNED_LONG_LONG 8

/*
 * If we lack int64_t, define it to the first of __int64, int, long, and long long
 * that exists and is the right size.
 */
#if !defined(HAVE_INT64_T) && defined(HAVE___INT64)
typedef __int64 int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_INT == 8
typedef int int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_LONG == 8
typedef long int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_LONG_LONG == 8
typedef long long int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T)
#error No 64-bit integer type was found.
#endif

/*
 * Similarly for int32_t
 */
#if !defined(HAVE_INT32_T) && SIZE_OF_INT == 4
typedef long int32_t;
#define HAVE_INT32_T
#endif

#if !defined(HAVE_INT32_T) && SIZE_OF_LONG == 4
typedef long int32_t;
#define HAVE_INT32_T
#endif

#if !defined(HAVE_INT32_T)
#error No 32-bit integer type was found.
#endif

/*
 * Similarly for int16_t
 */
#if !defined(HAVE_INT16_T) && SIZE_OF_INT == 2
typedef int int16_t;
#define HAVE_INT16_T
#endif

#if !defined(HAVE_INT16_T) && SIZE_OF_SHORT == 2
typedef short int16_t;
#define HAVE_INT16_T
#endif

#if !defined(HAVE_INT16_T)
#error No 16-bit integer type was found.
#endif

/*
 * Similarly for uint64_t
 */
#if !defined(HAVE_UINT64_T) && defined(HAVE_UNSIGNED___INT64)
typedef unsigned __int64 uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED == 8
typedef unsigned uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED_LONG == 8
typedef unsigned long uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED_LONG_LONG == 8
typedef unsigned long long uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T)
#error No 64-bit unsigned integer type was found.
#endif


/*
 * Similarly for uint32_t
 */
#if !defined(HAVE_UINT32_T) && SIZE_OF_UNSIGNED == 4
typedef unsigned uint32_t;
#define HAVE_UINT32_T
#endif

#if !defined(HAVE_UINT32_T) && SIZE_OF_UNSIGNED_LONG == 4
typedef unsigned long uint32_t;
#define HAVE_UINT32_T
#endif

#if !defined(HAVE_UINT32_T)
#error No 32-bit unsigned integer type was found.
#endif

/*
 * Similarly for uint16_t
 */
#if !defined(HAVE_UINT16_T) && SIZE_OF_UNSIGNED == 2
typedef unsigned uint16_t;
#define HAVE_UINT16_T
#endif

#if !defined(HAVE_UINT16_T) && SIZE_OF_UNSIGNED_SHORT == 2
typedef unsigned short uint16_t;
#define HAVE_UINT16_T
#endif

#if !defined(HAVE_UINT16_T)
#error No 16-bit unsigned integer type was found.
#endif

/*
 * Similarly for uint8_t
 */
#if !defined(HAVE_UINT8_T)
typedef unsigned char uint8_t;
#define HAVE_UINT8_T
#endif

#if !defined(HAVE_UINT16_T)
#error No 8-bit unsigned integer type was found.
#endif

/* Define intmax_t and uintmax_t if they are not already defined. */
#if !defined(HAVE_INTMAX_T)
typedef int64_t intmax_t;
#define INTMAX_MIN INT64_MIN
#define INTMAX_MAX INT64_MAX
#endif

#if !defined(HAVE_UINTMAX_T)
typedef uint64_t uintmax_t;
#endif

/* Define ZLIB_WINAPI if zlib was built on Visual Studio. */
/* #undef ZLIB_WINAPI */

/* MD5 via ARCHIVE_CRYPTO_MD5_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_MD5_LIBC */

/* MD5 via ARCHIVE_CRYPTO_MD5_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_MD5_LIBSYSTEM */

/* MD5 via ARCHIVE_CRYPTO_MD5_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_MD5_NETTLE */

/* MD5 via ARCHIVE_CRYPTO_MD5_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_MD5_OPENSSL */

/* MD5 via ARCHIVE_CRYPTO_MD5_WIN supported. */
/* #undef ARCHIVE_CRYPTO_MD5_WIN */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_LIBC */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_NETTLE */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_OPENSSL */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_LIBC */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_LIBSYSTEM */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_NETTLE */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_OPENSSL */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_WIN */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC2 */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC3 */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBSYSTEM */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_NETTLE */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_OPENSSL */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_WIN */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC2 */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC3 */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBSYSTEM */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_NETTLE */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_OPENSSL */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_WIN */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC2 */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC3 */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBSYSTEM */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_NETTLE */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_OPENSSL */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_WIN */

/* Version number of bsdcpio */
#define BSDCPIO_VERSION_STRING "3.1.2"

/* Version number of bsdtar */
#define BSDTAR_VERSION_STRING "3.1.2"

/* Define to 1 if you have the `acl_create_entry' function. */
/* #undef HAVE_ACL_CREATE_ENTRY */

/* Define to 1 if you have the `acl_get_link' function. */
/* #undef HAVE_ACL_GET_LINK */

/* Define to 1 if you have the `acl_get_link_np' function. */
/* #undef HAVE_ACL_GET_LINK_NP */

/* Define to 1 if you have the `acl_get_perm' function. */
/* #undef HAVE_ACL_GET_PERM */

/* Define to 1 if you have the `acl_get_perm_np' function. */
/* #undef HAVE_ACL_GET_PERM_NP */

/* Define to 1 if you have the `acl_init' function. */
/* #undef HAVE_ACL_INIT */

/* Define to 1 if you have the <acl/libacl.h> header file. */
/* #undef HAVE_ACL_LIBACL_H */

/* Define to 1 if the system has the type `acl_permset_t'. */
/* #undef HAVE_ACL_PERMSET_T */

/* Define to 1 if you have the `acl_set_fd' function. */
/* #undef HAVE_ACL_SET_FD */

/* Define to 1 if you have the `acl_set_fd_np' function. */
/* #undef HAVE_ACL_SET_FD_NP */

/* Define to 1 if you have the `acl_set_file' function. */
/* #undef HAVE_ACL_SET_FILE */

/* True for systems with POSIX ACL support */
/* #undef HAVE_ACL_USER */

/* Define to 1 if you have the <attr/xattr.h> header file. */
/* #undef HAVE_ATTR_XATTR_H */

/* Define to 1 if you have the <bsdxml.h> header file. */
/* #undef HAVE_BSDXML_H */

/* Define to 1 if you have the <bzlib.h> header file. */
#define HAVE_BZLIB_H 1

/* Define to 1 if you have the `chflags' function. */
/* #undef HAVE_CHFLAGS */

/* Define to 1 if you have the `chown' function. */
#define HAVE_CHOWN 1

/* Define to 1 if you have the `chroot' function. */
#define HAVE_CHROOT 1

/* Define to 1 if you have the <copyfile.h> header file. */
/* #undef HAVE_COPYFILE_H */

/* Define to 1 if you have the `ctime_r' function. */
#define HAVE_CTIME_R 1

/* Define to 1 if you have the <ctype.h> header file. */
#define HAVE_CTYPE_H 1

/* Define to 1 if you have the `cygwin_conv_path' function. */
/* #undef HAVE_CYGWIN_CONV_PATH */

/* Define to 1 if you have the declaration of `INT64_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_INT64_MAX 1

/* Define to 1 if you have the declaration of `INT64_MIN', and to 0 if you
   don't. */
#define HAVE_DECL_INT64_MIN 1

/* Define to 1 if you have the declaration of `SIZE_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_SIZE_MAX 1

/* Define to 1 if you have the declaration of `SSIZE_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_SSIZE_MAX 1

/* Define to 1 if you have the declaration of `strerror_r', and to 0 if you
   don't. */
#define HAVE_DECL_STRERROR_R 1

/* Define to 1 if you have the declaration of `UINT32_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_UINT32_MAX 1

/* Define to 1 if you have the declaration of `UINT64_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_UINT64_MAX 1

/* Define to 1 if you have the <direct.h> header file. */
/* #undef HAVE_DIRECT_H */

/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.
   */
#define HAVE_DIRENT_H 1

/* Define to 1 if you have the `dirfd' function. */
#define HAVE_DIRFD 1

/* Define to 1 if you have the <dlfcn.h> header file. */
#define HAVE_DLFCN_H 1

/* Define to 1 if you don't have `vprintf' but do have `_doprnt.' */
/* #undef HAVE_DOPRNT */

/* Define to 1 if nl_langinfo supports D_MD_ORDER */
/* #undef HAVE_D_MD_ORDER */

/* A possible errno value for invalid file format errors */
/* #undef HAVE_EFTYPE */

/* A possible errno value for invalid file format errors */
#define HAVE_EILSEQ 1

/* Define to 1 if you have the <errno.h> header file. */
#define HAVE_ERRNO_H 1

/* Define to 1 if you have the <expat.h> header file. */
/* #undef HAVE_EXPAT_H */

/* Define to 1 if you have the <ext2fs/ext2_fs.h> header file. */
/* #undef HAVE_EXT2FS_EXT2_FS_H */

/* Define to 1 if you have the `extattr_get_file' function. */
/* #undef HAVE_EXTATTR_GET_FILE */

/* Define to 1 if you have the `extattr_list_file' function. */
/* #undef HAVE_EXTATTR_LIST_FILE */

/* Define to 1 if you have the `extattr_set_fd' function. */
/* #undef HAVE_EXTATTR_SET_FD */

/* Define to 1 if you have the `extattr_set_file' function. */
/* #undef HAVE_EXTATTR_SET_FILE */

/* Define to 1 if EXTATTR_NAMESPACE_USER is defined in sys/extattr.h. */
/* #undef HAVE_DECL_EXTATTR_NAMESPACE_USER */

/* Define to 1 if you have the `fchdir' function. */
#define HAVE_FCHDIR 1

/* Define to 1 if you have the `fchflags' function. */
/* #undef HAVE_FCHFLAGS */

/* Define to 1 if you have the `fchmod' function. */
#define HAVE_FCHMOD 1

/* Define to 1 if you have the `fchown' function. */
#define HAVE_FCHOWN 1

/* Define to 1 if you have the `fcntl' function. */
#define HAVE_FCNTL 1

/* Define to 1 if you have the <fcntl.h> header file. */
#define HAVE_FCNTL_H 1

/* Define to 1 if you have the `fdopendir' function. */
#define HAVE_FDOPENDIR 1

/* Define to 1 if you have the `fgetea' function. */
/* #undef HAVE_FGETEA */

/* Define to 1 if you have the `fgetxattr' function. */
/* #undef HAVE_FGETXATTR */

/* Define to 1 if you have the `flistea' function. */
/* #undef HAVE_FLISTEA */

/* Define to 1 if you have the `flistxattr' function. */
/* #undef HAVE_FLISTXATTR */

/* Define to 1 if you have the `fork' function. */
#define HAVE_FORK 1

/* Define to 1 if fseeko (and presumably ftello) exists and is declared. */
#define HAVE_FSEEKO 1

/* Define to 1 if you have the `fsetea' function. */
/* #undef HAVE_FSETEA */

/* Define to 1 if you have the `fsetxattr' function. */
/* #undef HAVE_FSETXATTR */

/* Define to 1 if you have the `fstat' function. */
#define HAVE_FSTAT 1

/* Define to 1 if you have the `fstatat' function. */
#define HAVE_FSTATAT 1

/* Define to 1 if you have the `fstatfs' function. */
#define HAVE_FSTATFS 1

/* Define to 1 if you have the `fstatvfs' function. */
#define HAVE_FSTATVFS 1

/* Define to 1 if you have the `ftruncate' function. */
#define HAVE_FTRUNCATE 1

/* Define to 1 if you have the `futimens' function. */
#define HAVE_FUTIMENS 1

/* Define to 1 if you have the `futimes' function. */
#define HAVE_FUTIMES 1

/* Define to 1 if you have the `futimesat' function. */
#define HAVE_FUTIMESAT 1

/* Define to 1 if you have the `getea' function. */
/* #undef HAVE_GETEA */

/* Define to 1 if you have the `geteuid' function. */
#define HAVE_GETEUID 1

/* Define to 1 if you have the `getgrgid_r' function. */
#define HAVE_GETGRGID_R 1

/* Define to 1 if you have the `getgrnam_r' function. */
#define HAVE_GETGRNAM_R 1

/* Define to 1 if you have the `getpid' function. */
#define HAVE_GETPID 1

/* Define to 1 if you have the `getpwnam_r' function. */
#define HAVE_GETPWNAM_R 1

/* Define to 1 if you have the `getpwuid_r' function. */
#define HAVE_GETPWUID_R 1

/* Define to 1 if you have the `getvfsbyname' function. */
/* #undef HAVE_GETVFSBYNAME */

/* Define to 1 if you have the `getxattr' function. */
/* #undef HAVE_GETXATTR */

/* Define to 1 if you have the `gmtime_r' function. */
#define HAVE_GMTIME_R 1

/* Define to 1 if you have the <grp.h> header file. */
#define HAVE_GRP_H 1

/* Define to 1 if you have the `iconv' function. */
/* #undef HAVE_ICONV */

/* Define to 1 if you have the <iconv.h> header file. */
/* #undef HAVE_ICONV_H */

/* Define to 1 if you have the <inttypes.h> header file. */
#define HAVE_INTTYPES_H 1

/* Define to 1 if you have the <io.h> header file. */
/* #undef HAVE_IO_H */

/* Define to 1 if you have the <langinfo.h> header file. */
#define HAVE_LANGINFO_H 1

/* Define to 1 if you have the `lchflags' function. */
/* #undef HAVE_LCHFLAGS */

/* Define to 1 if you have the `lchmod' function. */
/* #undef HAVE_LCHMOD */

/* Define to 1 if you have the `lchown' function. */
#define HAVE_LCHOWN 1

/* Define to 1 if you have the `lgetea' function. */
/* #undef HAVE_LGETEA */

/* Define to 1 if you have the `lgetxattr' function. */
/* #undef HAVE_LGETXATTR */

/* Define to 1 if you have the `acl' library (-lacl). */
/* #undef HAVE_LIBACL */

/* Define to 1 if you have the `attr' library (-lattr). */
/* #undef HAVE_LIBATTR */

/* Define to 1 if you have the `bsdxml' library (-lbsdxml). */
/* #undef HAVE_LIBBSDXML */

/* Define to 1 if you have the `bz2' library (-lbz2). */
#define HAVE_LIBBZ2 1

/* Define to 1 if you have the `expat' library (-lexpat). */
/* #undef HAVE_LIBEXPAT */

/* Define to 1 if you have the `gcc' library (-lgcc). */
/* #undef HAVE_LIBGCC */

/* Define to 1 if you have the `lzma' library (-llzma). */
/* #undef HAVE_LIBLZMA */

/* Define to 1 if you have the `lzmadec' library (-llzmadec). */
/* #undef HAVE_LIBLZMADEC */

/* Define to 1 if you have the `lzo2' library (-llzo2). */
/* #undef HAVE_LIBLZO2 */

/* Define to 1 if you have the `nettle' library (-lnettle). */
/* #undef HAVE_LIBNETTLE */

/* Define to 1 if you have the `pcre' library (-lpcre). */
/* #undef HAVE_LIBPCRE */

/* Define to 1 if you have the `pcreposix' library (-lpcreposix). */
/* #undef HAVE_LIBPCREPOSIX */

/* Define to 1 if you have the `xml2' library (-lxml2). */
/* #undef HAVE_LIBXML2 */

/* Define to 1 if you have the <libxml/xmlreader.h> header file. */
/* #undef HAVE_LIBXML_XMLREADER_H */

/* Define to 1 if you have the <libxml/xmlwriter.h> header file. */
/* #undef HAVE_LIBXML_XMLWRITER_H */

/* Define to 1 if you have the `z' library (-lz). */
#define HAVE_LIBZ 1

/* Define to 1 if you have the <limits.h> header file. */
#define HAVE_LIMITS_H 1

/* Define to 1 if you have the `link' function. */
#define HAVE_LINK 1

/* Define to 1 if you have the <linux/types.h> header file. */
#define HAVE_LINUX_TYPES_H 1

/* Define to 1 if you have the <linux/fiemap.h> header file. */
#define HAVE_LINUX_FIEMAP_H 1

/* Define to 1 if you have the <linux/fs.h> header file. */
#define HAVE_LINUX_FS_H 1

/* Define to 1 if you have the <linux/magic.h> header file. */
#define HAVE_LINUX_MAGIC_H 1

/* Define to 1 if you have the <linux/types.h> header file. */
#define HAVE_LINUX_TYPES_H 1

/* Define to 1 if you have the `listea' function. */
/* #undef HAVE_LISTEA */

/* Define to 1 if you have the `listxattr' function. */
/* #undef HAVE_LISTXATTR */

/* Define to 1 if you have the `llistea' function. */
/* #undef HAVE_LLISTEA */

/* Define to 1 if you have the `llistxattr' function. */
/* #undef HAVE_LLISTXATTR */

/* Define to 1 if you have the <localcharset.h> header file. */
/* #undef HAVE_LOCALCHARSET_H */

/* Define to 1 if you have the `locale_charset' function. */
/* #undef HAVE_LOCALE_CHARSET */

/* Define to 1 if you have the <locale.h> header file. */
#define HAVE_LOCALE_H 1

/* Define to 1 if you have the `localtime_r' function. */
#define HAVE_LOCALTIME_R 1

/* Define to 1 if the system has the type `long long int'. */
/* #undef HAVE_LONG_LONG_INT */

/* Define to 1 if you have the `lsetea' function. */
/* #undef HAVE_LSETEA */

/* Define to 1 if you have the `lsetxattr' function. */
/* #undef HAVE_LSETXATTR */

/* Define to 1 if you have the `lstat' function. */
#define HAVE_LSTAT 1

/* Define to 1 if `lstat' has the bug that it succeeds when given the
   zero-length file name argument. */
/* #undef HAVE_LSTAT_EMPTY_STRING_BUG */

/* Define to 1 if you have the `lutimes' function. */
#define HAVE_LUTIMES 1

/* Define to 1 if you have the <lzmadec.h> header file. */
/* #undef HAVE_LZMADEC_H */

/* Define to 1 if you have the <lzma.h> header file. */
/* #undef HAVE_LZMA_H */

/* Define to 1 if you have the <lzo/lzo1x.h> header file. */
/* #undef HAVE_LZO_LZO1X_H */

/* Define to 1 if you have the <lzo/lzoconf.h> header file. */
/* #undef HAVE_LZO_LZOCONF_H */

/* Define to 1 if you have the `mbrtowc' function. */
#define HAVE_MBRTOWC 1

/* Define to 1 if you have the `memmove' function. */
#define HAVE_MEMMOVE 1

/* Define to 1 if you have the <memory.h> header file. */
#define HAVE_MEMORY_H 1

/* Define to 1 if you have the `mkdir' function. */
#define HAVE_MKDIR 1

/* Define to 1 if you have the `mkfifo' function. */
#define HAVE_MKFIFO 1

/* Define to 1 if you have the `mknod' function. */
#define HAVE_MKNOD 1

/* Define to 1 if you have the `mkstemp' function. */
#define HAVE_MKSTEMP 1

/* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */
/* #undef HAVE_NDIR_H */

/* Define to 1 if you have the <nettle/md5.h> header file. */
/* #undef HAVE_NETTLE_MD5_H */

/* Define to 1 if you have the <nettle/ripemd160.h> header file. */
/* #undef HAVE_NETTLE_RIPEMD160_H */

/* Define to 1 if you have the <nettle/sha.h> header file. */
/* #undef HAVE_NETTLE_SHA_H */

/* Define to 1 if you have the `nl_langinfo' function. */
#define HAVE_NL_LANGINFO 1

/* Define to 1 if you have the `openat' function. */
#define HAVE_OPENAT 1

/* Define to 1 if you have the <paths.h> header file. */
#define HAVE_PATHS_H 1

/* Define to 1 if you have the <pcreposix.h> header file. */
/* #undef HAVE_PCREPOSIX_H */

/* Define to 1 if you have the `pipe' function. */
#define HAVE_PIPE 1

/* Define to 1 if you have the `poll' function. */
#define HAVE_POLL 1

/* Define to 1 if you have the <poll.h> header file. */
#define HAVE_POLL_H 1

/* Define to 1 if you have the `posix_spawnp' function. */
#define HAVE_POSIX_SPAWNP 1

/* Define to 1 if you have the <process.h> header file. */
/* #undef HAVE_PROCESS_H */

/* Define to 1 if you have the <pwd.h> header file. */
#define HAVE_PWD_H 1

/* Define to 1 if you have the `readdir_r' function. */
#define HAVE_READDIR_R 1

/* Define to 1 if you have the `readlink' function. */
#define HAVE_READLINK 1

/* Define to 1 if you have the `readlinkat' function. */
#define HAVE_READLINKAT 1

/* Define to 1 if you have the <regex.h> header file. */
#define HAVE_REGEX_H 1

/* Define to 1 if you have the `select' function. */
#define HAVE_SELECT 1

/* Define to 1 if you have the `setenv' function. */
#define HAVE_SETENV 1

/* Define to 1 if you have the `setlocale' function. */
#define HAVE_SETLOCALE 1

/* Define to 1 if you have the `sigaction' function. */
#define HAVE_SIGACTION 1

/* Define to 1 if you have the <signal.h> header file. */
#define HAVE_SIGNAL_H 1

/* Define to 1 if you have the <spawn.h> header file. */
#define HAVE_SPAWN_H 1

/* Define to 1 if you have the `statfs' function. */
#define HAVE_STATFS 1

/* Define to 1 if you have the `statvfs' function. */
#define HAVE_STATVFS 1

/* Define to 1 if `stat' has the bug that it succeeds when given the
   zero-length file name argument. */
/* #undef HAVE_STAT_EMPTY_STRING_BUG */

/* Define to 1 if you have the <stdarg.h> header file. */
#define HAVE_STDARG_H 1

/* Define to 1 if you have the <stdint.h> header file. */
#define HAVE_STDINT_H 1

/* Define to 1 if you have the <stdlib.h> header file. */
#define HAVE_STDLIB_H 1

/* Define to 1 if you have the `strchr' function. */
#define HAVE_STRCHR 1

/* Define to 1 if you have the `strdup' function. */
#define HAVE_STRDUP 1

/* Define to 1 if you have the `strerror' function. */
#define HAVE_STRERROR 1

/* Define to 1 if you have the `strerror_r' function. */
#define HAVE_STRERROR_R 1

/* Define to 1 if you have the `strftime' function. */
#define HAVE_STRFTIME 1

/* Define to 1 if you have the <strings.h> header file. */
#define HAVE_STRINGS_H 1

/* Define to 1 if you have the <string.h> header file. */
#define HAVE_STRING_H 1

/* Define to 1 if you have the `strrchr' function. */
#define HAVE_STRRCHR 1

/* Define to 1 if `f_namemax' is a member of `struct statfs'. */
/* #undef HAVE_STRUCT_STATFS_F_NAMEMAX */

/* Define to 1 if `f_iosize' is a member of `struct statvfs'. */
/* #undef HAVE_STRUCT_STATVFS_F_IOSIZE */

/* Define to 1 if `st_birthtime' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIME */

/* Define to 1 if `st_birthtimespec.tv_nsec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC_TV_NSEC */

/* Define to 1 if `st_blksize' is a member of `struct stat'. */
#define HAVE_STRUCT_STAT_ST_BLKSIZE 1

/* Define to 1 if `st_flags' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_FLAGS */

/* Define to 1 if `st_mtimespec.tv_nsec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC */

/* Define to 1 if `st_mtime_n' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIME_N */

/* Define to 1 if `st_mtime_usec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIME_USEC */

/* Define to 1 if `st_mtim.tv_nsec' is a member of `struct stat'. */
#define HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC 1

/* Define to 1 if `st_umtime' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_UMTIME */

/* Define to 1 if `tm_gmtoff' is a member of `struct tm'. */
#define HAVE_STRUCT_TM_TM_GMTOFF 1

/* Define to 1 if `__tm_gmtoff' is a member of `struct tm'. */
/* #undef HAVE_STRUCT_TM___TM_GMTOFF */

/* Define to 1 if you have the `symlink' function. */
#define HAVE_SYMLINK 1

/* Define to 1 if you have the <sys/acl.h> header file. */
/* #undef HAVE_SYS_ACL_H */

/* Define to 1 if you have the <sys/cdefs.h> header file. */
#define HAVE_SYS_CDEFS_H 1

/* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.
   */
/* #undef HAVE_SYS_DIR_H */

/* Define to 1 if you have the <sys/ea.h> header file. */
/* #undef HAVE_SYS_EA_H */

/* Define to 1 if you have the <sys/extattr.h> header file. */
/* #undef HAVE_SYS_EXTATTR_H */

/* Define to 1 if you have the <sys/ioctl.h> header file. */
#define HAVE_SYS_IOCTL_H 1

/* Define to 1 if you have the <sys/mkdev.h> header file. */
/* #undef HAVE_SYS_MKDEV_H */

/* Define to 1 if you have the <sys/mount.h> header file. */
/* #undef HAVE_SYS_MOUNT_H */

/* Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.
   */
/* #undef HAVE_SYS_NDIR_H */

/* Define to 1 if you have the <sys/param.h> header file. */
#define HAVE_SYS_PARAM_H 1

/* Define to 1 if you have the <sys/poll.h> header file. */
#define HAVE_SYS_POLL_H 1

/* Define to 1 if you have the <sys/select.h> header file. */
#define HAVE_SYS_SELECT_H 1

/* Define to 1 if you have the <sys/statfs.h> header file. */
#define HAVE_SYS_STATFS_H 1

/* Define to 1 if you have the <sys/statvfs.h> header file. */
#define HAVE_SYS_STATVFS_H 1

/* Define to 1 if you have the <sys/stat.h> header file. */
#define HAVE_SYS_STAT_H 1

/* Define to 1 if you have the <sys/time.h> header file. */
#define HAVE_SYS_TIME_H 1

/* Define to 1 if you have the <sys/types.h> header file. */
#define HAVE_SYS_TYPES_H 1

/* Define to 1 if you have the <sys/utime.h> header file. */
/* #undef HAVE_SYS_UTIME_H */

/* Define to 1 if you have the <sys/utsname.h> header file. */
#define HAVE_SYS_UTSNAME_H 1

/* Define to 1 if you have the <sys/vfs.h> header file. */
#define HAVE_SYS_VFS_H 1

/* Define to 1 if you have <sys/wait.h> that is POSIX.1 compatible. */
#define HAVE_SYS_WAIT_H 1

/* Define to 1 if you have the <sys/xattr.h> header file. */
/* #undef HAVE_SYS_XATTR_H */

/* Define to 1 if you have the `timegm' function. */
#define HAVE_TIMEGM 1

/* Define to 1 if you have the <time.h> header file. */
#define HAVE_TIME_H 1

/* Define to 1 if you have the `tzset' function. */
#define HAVE_TZSET 1

/* Define to 1 if you have the <unistd.h> header file. */
#define HAVE_UNISTD_H 1

/* Define to 1 if you have the `unsetenv' function. */
#define HAVE_UNSETENV 1

/* Define to 1 if the system has the type `unsigned long long'. */
/* #undef HAVE_UNSIGNED_LONG_LONG */

/* Define to 1 if the system has the type `unsigned long long int'. */
/* #undef HAVE_UNSIGNED_LONG_LONG_INT */

/* Define to 1 if you have the `utime' function. */
#define HAVE_UTIME 1

/* Define to 1 if you have the `utimensat' function. */
#define HAVE_UTIMENSAT 1

/* Define to 1 if you have the `utimes' function. */
#define HAVE_UTIMES 1

/* Define to 1 if you have the <utime.h> header file. */
#define HAVE_UTIME_H 1

/* Define to 1 if you have the `vfork' function. */
#define HAVE_VFORK 1

/* Define to 1 if you have the `vprintf' function. */
#define HAVE_VPRINTF 1

/* Define to 1 if you have the <wchar.h> header file. */
#define HAVE_WCHAR_H 1

/* Define to 1 if the system has the type `wchar_t'. */
#define HAVE_WCHAR_T 1

/* Define to 1 if you have the `wcrtomb' function. */
#define HAVE_WCRTOMB 1

/* Define to 1 if you have the `wcscmp' function. */
#define HAVE_WCSCMP 1

/* Define to 1 if you have the `wcscpy' function. */
#define HAVE_WCSCPY 1

/* Define to 1 if you have the `wcslen' function. */
#define HAVE_WCSLEN 1

/* Define to 1 if you have the `wctomb' function. */
#define HAVE_WCTOMB 1

/* Define to 1 if you have the <wctype.h> header file. */
#define HAVE_WCTYPE_H 1

/* Define to 1 if you have the <wincrypt.h> header file. */
/* #undef HAVE_WINCRYPT_H */

/* Define to 1 if you have the <windows.h> header file. */
/* #undef HAVE_WINDOWS_H */

/* Define to 1 if you have the <winioctl.h> header file. */
/* #undef HAVE_WINIOCTL_H */

/* Define to 1 if you have _CrtSetReportMode in <crtdbg.h>  */
/* #undef HAVE__CrtSetReportMode */

/* Define to 1 if you have the `wmemcmp' function. */
#define HAVE_WMEMCMP 1

/* Define to 1 if you have the `wmemcpy' function. */
#define HAVE_WMEMCPY 1

/* Define to 1 if you have a working EXT2_IOC_GETFLAGS */
/* #undef HAVE_WORKING_EXT2_IOC_GETFLAGS */

/* Define to 1 if you have the <zlib.h> header file. */
#define HAVE_ZLIB_H 1

/* Define to 1 if you have the `_ctime64_s' function. */
/* #undef HAVE__CTIME64_S */

/* Define to 1 if you have the `_fseeki64' function. */
/* #undef HAVE__FSEEKI64 */

/* Define to 1 if you have the `_get_timezone' function. */
/* #undef HAVE__GET_TIMEZONE */

/* Define to 1 if you have the `_localtime64_s' function. */
/* #undef HAVE__LOCALTIME64_S */

/* Define to 1 if you have the `_mkgmtime64' function. */
/* #undef HAVE__MKGMTIME64 */

/* Define as const if the declaration of iconv() needs const. */
#define ICONV_CONST 

/* Version number of libarchive as a single integer */
#define LIBARCHIVE_VERSION_NUMBER "3001002"

/* Version number of libarchive */
#define LIBARCHIVE_VERSION_STRING "3.1.2"

/* Define to 1 if `lstat' dereferences a symlink specified with a trailing
   slash. */
/* #undef LSTAT_FOLLOWS_SLASHED_SYMLINK */

/* Define to 1 if `major', `minor', and `makedev' are declared in <mkdev.h>.
   */
/* #undef MAJOR_IN_MKDEV */

/* Define to 1 if `major', `minor', and `makedev' are declared in
   <sysmacros.h>. */
#define MAJOR_IN_SYSMACROS 1

/* Define to 1 if your C compiler doesn't accept -c and -o together. */
/* #undef NO_MINUS_C_MINUS_O */

/* The size of `wchar_t', as computed by sizeof. */
#define SIZEOF_WCHAR_T 4

/* Define to 1 if strerror_r returns char *. */
/* #undef STRERROR_R_CHAR_P */

/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
#define TIME_WITH_SYS_TIME 1

/*
 * Some platform requires a macro to use extension functions.
 */
#define SAFE_TO_DEFINE_EXTENSIONS 1
#ifdef SAFE_TO_DEFINE_EXTENSIONS
/* Enable extensions on AIX 3, Interix.  */
#ifndef _ALL_SOURCE
# define _ALL_SOURCE 1
#endif
/* Enable GNU extensions on systems that have them.  */
#ifndef _GNU_SOURCE
# define _GNU_SOURCE 1
#endif
/* Enable threading extensions on Solaris.  */
#ifndef _POSIX_PTHREAD_SEMANTICS
# define _POSIX_PTHREAD_SEMANTICS 1
#endif
/* Enable extensions on HP NonStop.  */
#ifndef _TANDEM_SOURCE
# define _TANDEM_SOURCE 1
#endif
/* Enable general extensions on Solaris.  */
#ifndef __EXTENSIONS__
# define __EXTENSIONS__ 1
#endif
#endif /* SAFE_TO_DEFINE_EXTENSIONS */

/* Version number of package */
#define VERSION "3.1.2"

/* Number of bits in a file offset, on hosts where this is settable. */
/* #undef _FILE_OFFSET_BITS */

/* Define to 1 to make fseeko visible on some hosts (e.g. glibc 2.2). */
/* #undef _LARGEFILE_SOURCE */

/* Define for large files, on AIX-style hosts. */
/* #undef _LARGE_FILES */

/* Define for Windows to use Windows 2000+ APIs. */
/* #undef _WIN32_WINNT */
/* #undef WINVER */

/* Define to empty if `const' does not conform to ANSI C. */
/* #undef const */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef gid_t */

/* Define to `unsigned long' if <sys/types.h> does not define. */
/* #undef id_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef mode_t */

/* Define to `long long' if <sys/types.h> does not define. */
/* #undef off_t */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef pid_t */

/* Define to `unsigned int' if <sys/types.h> does not define. */
/* #undef size_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef ssize_t */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef uid_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef intptr_t */

/* Define to `unsigned int' if <sys/types.h> does not define. */
/* #undef uintptr_t */


#define ARCHIVE_MD5_COMPILE_TEST
#define ARCHIVE_CRYPTO_MD5_LIBC
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = (DWORD)bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. Nettle
 * 6. OpenSSL
 * 7. libmd
 * 8. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive_md5_ctx ctx;
  archive_md5_init(&ctx);
  archive_md5_update(&ctx, *argv, argc);
  archive_md5_final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_RMD160_LIBC failed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec266596207/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec266596207.dir/build.make CMakeFiles/cmTryCompileExec266596207.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec266596207.dir/check_crypto_md.c.o
/usr/bin/gcc   -w  -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2 -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmlibarchive/libarchive -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec266596207.dir/check_crypto_md.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1186:0:
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:64:20: fatal error: rmd160.h: No such file or directory
 #include <rmd160.h>
                    ^
compilation terminated.
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec266596207.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec266596207/fast] Error 2

Source file was:
/* config.h.  Generated from build/cmake/config.h.in by cmake configure */
#if defined(__osf__)
# define _OSF_SOURCE
#endif

/*
 * Ensure we have C99-style int64_t, etc, all defined.
 */

/* First, we need to know if the system has already defined them. */
#define HAVE_INT16_T
#define HAVE_INT32_T
#define HAVE_INT64_T
#define HAVE_INTMAX_T

#define HAVE_UINT8_T
#define HAVE_UINT16_T
#define HAVE_UINT32_T
#define HAVE_UINT64_T
#define HAVE_UINTMAX_T

/* We might have the types we want under other spellings. */
/* #undef HAVE___INT64 */
/* #undef HAVE_U_INT64_T */
/* #undef HAVE_UNSIGNED___INT64 */

/* The sizes of various standard integer types. */
#define SIZE_OF_SHORT 2
#define SIZE_OF_INT 4
#define SIZE_OF_LONG 8
#define SIZE_OF_LONG_LONG 8
#define SIZE_OF_UNSIGNED_SHORT 2
#define SIZE_OF_UNSIGNED 4
#define SIZE_OF_UNSIGNED_LONG 8
#define SIZE_OF_UNSIGNED_LONG_LONG 8

/*
 * If we lack int64_t, define it to the first of __int64, int, long, and long long
 * that exists and is the right size.
 */
#if !defined(HAVE_INT64_T) && defined(HAVE___INT64)
typedef __int64 int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_INT == 8
typedef int int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_LONG == 8
typedef long int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_LONG_LONG == 8
typedef long long int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T)
#error No 64-bit integer type was found.
#endif

/*
 * Similarly for int32_t
 */
#if !defined(HAVE_INT32_T) && SIZE_OF_INT == 4
typedef long int32_t;
#define HAVE_INT32_T
#endif

#if !defined(HAVE_INT32_T) && SIZE_OF_LONG == 4
typedef long int32_t;
#define HAVE_INT32_T
#endif

#if !defined(HAVE_INT32_T)
#error No 32-bit integer type was found.
#endif

/*
 * Similarly for int16_t
 */
#if !defined(HAVE_INT16_T) && SIZE_OF_INT == 2
typedef int int16_t;
#define HAVE_INT16_T
#endif

#if !defined(HAVE_INT16_T) && SIZE_OF_SHORT == 2
typedef short int16_t;
#define HAVE_INT16_T
#endif

#if !defined(HAVE_INT16_T)
#error No 16-bit integer type was found.
#endif

/*
 * Similarly for uint64_t
 */
#if !defined(HAVE_UINT64_T) && defined(HAVE_UNSIGNED___INT64)
typedef unsigned __int64 uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED == 8
typedef unsigned uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED_LONG == 8
typedef unsigned long uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED_LONG_LONG == 8
typedef unsigned long long uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T)
#error No 64-bit unsigned integer type was found.
#endif


/*
 * Similarly for uint32_t
 */
#if !defined(HAVE_UINT32_T) && SIZE_OF_UNSIGNED == 4
typedef unsigned uint32_t;
#define HAVE_UINT32_T
#endif

#if !defined(HAVE_UINT32_T) && SIZE_OF_UNSIGNED_LONG == 4
typedef unsigned long uint32_t;
#define HAVE_UINT32_T
#endif

#if !defined(HAVE_UINT32_T)
#error No 32-bit unsigned integer type was found.
#endif

/*
 * Similarly for uint16_t
 */
#if !defined(HAVE_UINT16_T) && SIZE_OF_UNSIGNED == 2
typedef unsigned uint16_t;
#define HAVE_UINT16_T
#endif

#if !defined(HAVE_UINT16_T) && SIZE_OF_UNSIGNED_SHORT == 2
typedef unsigned short uint16_t;
#define HAVE_UINT16_T
#endif

#if !defined(HAVE_UINT16_T)
#error No 16-bit unsigned integer type was found.
#endif

/*
 * Similarly for uint8_t
 */
#if !defined(HAVE_UINT8_T)
typedef unsigned char uint8_t;
#define HAVE_UINT8_T
#endif

#if !defined(HAVE_UINT16_T)
#error No 8-bit unsigned integer type was found.
#endif

/* Define intmax_t and uintmax_t if they are not already defined. */
#if !defined(HAVE_INTMAX_T)
typedef int64_t intmax_t;
#define INTMAX_MIN INT64_MIN
#define INTMAX_MAX INT64_MAX
#endif

#if !defined(HAVE_UINTMAX_T)
typedef uint64_t uintmax_t;
#endif

/* Define ZLIB_WINAPI if zlib was built on Visual Studio. */
/* #undef ZLIB_WINAPI */

/* MD5 via ARCHIVE_CRYPTO_MD5_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_MD5_LIBC */

/* MD5 via ARCHIVE_CRYPTO_MD5_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_MD5_LIBSYSTEM */

/* MD5 via ARCHIVE_CRYPTO_MD5_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_MD5_NETTLE */

/* MD5 via ARCHIVE_CRYPTO_MD5_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_MD5_OPENSSL */

/* MD5 via ARCHIVE_CRYPTO_MD5_WIN supported. */
/* #undef ARCHIVE_CRYPTO_MD5_WIN */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_LIBC */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_NETTLE */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_OPENSSL */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_LIBC */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_LIBSYSTEM */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_NETTLE */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_OPENSSL */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_WIN */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC2 */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC3 */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBSYSTEM */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_NETTLE */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_OPENSSL */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_WIN */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC2 */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC3 */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBSYSTEM */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_NETTLE */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_OPENSSL */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_WIN */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC2 */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC3 */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBSYSTEM */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_NETTLE */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_OPENSSL */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_WIN */

/* Version number of bsdcpio */
#define BSDCPIO_VERSION_STRING "3.1.2"

/* Version number of bsdtar */
#define BSDTAR_VERSION_STRING "3.1.2"

/* Define to 1 if you have the `acl_create_entry' function. */
/* #undef HAVE_ACL_CREATE_ENTRY */

/* Define to 1 if you have the `acl_get_link' function. */
/* #undef HAVE_ACL_GET_LINK */

/* Define to 1 if you have the `acl_get_link_np' function. */
/* #undef HAVE_ACL_GET_LINK_NP */

/* Define to 1 if you have the `acl_get_perm' function. */
/* #undef HAVE_ACL_GET_PERM */

/* Define to 1 if you have the `acl_get_perm_np' function. */
/* #undef HAVE_ACL_GET_PERM_NP */

/* Define to 1 if you have the `acl_init' function. */
/* #undef HAVE_ACL_INIT */

/* Define to 1 if you have the <acl/libacl.h> header file. */
/* #undef HAVE_ACL_LIBACL_H */

/* Define to 1 if the system has the type `acl_permset_t'. */
/* #undef HAVE_ACL_PERMSET_T */

/* Define to 1 if you have the `acl_set_fd' function. */
/* #undef HAVE_ACL_SET_FD */

/* Define to 1 if you have the `acl_set_fd_np' function. */
/* #undef HAVE_ACL_SET_FD_NP */

/* Define to 1 if you have the `acl_set_file' function. */
/* #undef HAVE_ACL_SET_FILE */

/* True for systems with POSIX ACL support */
/* #undef HAVE_ACL_USER */

/* Define to 1 if you have the <attr/xattr.h> header file. */
/* #undef HAVE_ATTR_XATTR_H */

/* Define to 1 if you have the <bsdxml.h> header file. */
/* #undef HAVE_BSDXML_H */

/* Define to 1 if you have the <bzlib.h> header file. */
#define HAVE_BZLIB_H 1

/* Define to 1 if you have the `chflags' function. */
/* #undef HAVE_CHFLAGS */

/* Define to 1 if you have the `chown' function. */
#define HAVE_CHOWN 1

/* Define to 1 if you have the `chroot' function. */
#define HAVE_CHROOT 1

/* Define to 1 if you have the <copyfile.h> header file. */
/* #undef HAVE_COPYFILE_H */

/* Define to 1 if you have the `ctime_r' function. */
#define HAVE_CTIME_R 1

/* Define to 1 if you have the <ctype.h> header file. */
#define HAVE_CTYPE_H 1

/* Define to 1 if you have the `cygwin_conv_path' function. */
/* #undef HAVE_CYGWIN_CONV_PATH */

/* Define to 1 if you have the declaration of `INT64_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_INT64_MAX 1

/* Define to 1 if you have the declaration of `INT64_MIN', and to 0 if you
   don't. */
#define HAVE_DECL_INT64_MIN 1

/* Define to 1 if you have the declaration of `SIZE_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_SIZE_MAX 1

/* Define to 1 if you have the declaration of `SSIZE_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_SSIZE_MAX 1

/* Define to 1 if you have the declaration of `strerror_r', and to 0 if you
   don't. */
#define HAVE_DECL_STRERROR_R 1

/* Define to 1 if you have the declaration of `UINT32_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_UINT32_MAX 1

/* Define to 1 if you have the declaration of `UINT64_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_UINT64_MAX 1

/* Define to 1 if you have the <direct.h> header file. */
/* #undef HAVE_DIRECT_H */

/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.
   */
#define HAVE_DIRENT_H 1

/* Define to 1 if you have the `dirfd' function. */
#define HAVE_DIRFD 1

/* Define to 1 if you have the <dlfcn.h> header file. */
#define HAVE_DLFCN_H 1

/* Define to 1 if you don't have `vprintf' but do have `_doprnt.' */
/* #undef HAVE_DOPRNT */

/* Define to 1 if nl_langinfo supports D_MD_ORDER */
/* #undef HAVE_D_MD_ORDER */

/* A possible errno value for invalid file format errors */
/* #undef HAVE_EFTYPE */

/* A possible errno value for invalid file format errors */
#define HAVE_EILSEQ 1

/* Define to 1 if you have the <errno.h> header file. */
#define HAVE_ERRNO_H 1

/* Define to 1 if you have the <expat.h> header file. */
/* #undef HAVE_EXPAT_H */

/* Define to 1 if you have the <ext2fs/ext2_fs.h> header file. */
/* #undef HAVE_EXT2FS_EXT2_FS_H */

/* Define to 1 if you have the `extattr_get_file' function. */
/* #undef HAVE_EXTATTR_GET_FILE */

/* Define to 1 if you have the `extattr_list_file' function. */
/* #undef HAVE_EXTATTR_LIST_FILE */

/* Define to 1 if you have the `extattr_set_fd' function. */
/* #undef HAVE_EXTATTR_SET_FD */

/* Define to 1 if you have the `extattr_set_file' function. */
/* #undef HAVE_EXTATTR_SET_FILE */

/* Define to 1 if EXTATTR_NAMESPACE_USER is defined in sys/extattr.h. */
/* #undef HAVE_DECL_EXTATTR_NAMESPACE_USER */

/* Define to 1 if you have the `fchdir' function. */
#define HAVE_FCHDIR 1

/* Define to 1 if you have the `fchflags' function. */
/* #undef HAVE_FCHFLAGS */

/* Define to 1 if you have the `fchmod' function. */
#define HAVE_FCHMOD 1

/* Define to 1 if you have the `fchown' function. */
#define HAVE_FCHOWN 1

/* Define to 1 if you have the `fcntl' function. */
#define HAVE_FCNTL 1

/* Define to 1 if you have the <fcntl.h> header file. */
#define HAVE_FCNTL_H 1

/* Define to 1 if you have the `fdopendir' function. */
#define HAVE_FDOPENDIR 1

/* Define to 1 if you have the `fgetea' function. */
/* #undef HAVE_FGETEA */

/* Define to 1 if you have the `fgetxattr' function. */
/* #undef HAVE_FGETXATTR */

/* Define to 1 if you have the `flistea' function. */
/* #undef HAVE_FLISTEA */

/* Define to 1 if you have the `flistxattr' function. */
/* #undef HAVE_FLISTXATTR */

/* Define to 1 if you have the `fork' function. */
#define HAVE_FORK 1

/* Define to 1 if fseeko (and presumably ftello) exists and is declared. */
#define HAVE_FSEEKO 1

/* Define to 1 if you have the `fsetea' function. */
/* #undef HAVE_FSETEA */

/* Define to 1 if you have the `fsetxattr' function. */
/* #undef HAVE_FSETXATTR */

/* Define to 1 if you have the `fstat' function. */
#define HAVE_FSTAT 1

/* Define to 1 if you have the `fstatat' function. */
#define HAVE_FSTATAT 1

/* Define to 1 if you have the `fstatfs' function. */
#define HAVE_FSTATFS 1

/* Define to 1 if you have the `fstatvfs' function. */
#define HAVE_FSTATVFS 1

/* Define to 1 if you have the `ftruncate' function. */
#define HAVE_FTRUNCATE 1

/* Define to 1 if you have the `futimens' function. */
#define HAVE_FUTIMENS 1

/* Define to 1 if you have the `futimes' function. */
#define HAVE_FUTIMES 1

/* Define to 1 if you have the `futimesat' function. */
#define HAVE_FUTIMESAT 1

/* Define to 1 if you have the `getea' function. */
/* #undef HAVE_GETEA */

/* Define to 1 if you have the `geteuid' function. */
#define HAVE_GETEUID 1

/* Define to 1 if you have the `getgrgid_r' function. */
#define HAVE_GETGRGID_R 1

/* Define to 1 if you have the `getgrnam_r' function. */
#define HAVE_GETGRNAM_R 1

/* Define to 1 if you have the `getpid' function. */
#define HAVE_GETPID 1

/* Define to 1 if you have the `getpwnam_r' function. */
#define HAVE_GETPWNAM_R 1

/* Define to 1 if you have the `getpwuid_r' function. */
#define HAVE_GETPWUID_R 1

/* Define to 1 if you have the `getvfsbyname' function. */
/* #undef HAVE_GETVFSBYNAME */

/* Define to 1 if you have the `getxattr' function. */
/* #undef HAVE_GETXATTR */

/* Define to 1 if you have the `gmtime_r' function. */
#define HAVE_GMTIME_R 1

/* Define to 1 if you have the <grp.h> header file. */
#define HAVE_GRP_H 1

/* Define to 1 if you have the `iconv' function. */
/* #undef HAVE_ICONV */

/* Define to 1 if you have the <iconv.h> header file. */
/* #undef HAVE_ICONV_H */

/* Define to 1 if you have the <inttypes.h> header file. */
#define HAVE_INTTYPES_H 1

/* Define to 1 if you have the <io.h> header file. */
/* #undef HAVE_IO_H */

/* Define to 1 if you have the <langinfo.h> header file. */
#define HAVE_LANGINFO_H 1

/* Define to 1 if you have the `lchflags' function. */
/* #undef HAVE_LCHFLAGS */

/* Define to 1 if you have the `lchmod' function. */
/* #undef HAVE_LCHMOD */

/* Define to 1 if you have the `lchown' function. */
#define HAVE_LCHOWN 1

/* Define to 1 if you have the `lgetea' function. */
/* #undef HAVE_LGETEA */

/* Define to 1 if you have the `lgetxattr' function. */
/* #undef HAVE_LGETXATTR */

/* Define to 1 if you have the `acl' library (-lacl). */
/* #undef HAVE_LIBACL */

/* Define to 1 if you have the `attr' library (-lattr). */
/* #undef HAVE_LIBATTR */

/* Define to 1 if you have the `bsdxml' library (-lbsdxml). */
/* #undef HAVE_LIBBSDXML */

/* Define to 1 if you have the `bz2' library (-lbz2). */
#define HAVE_LIBBZ2 1

/* Define to 1 if you have the `expat' library (-lexpat). */
/* #undef HAVE_LIBEXPAT */

/* Define to 1 if you have the `gcc' library (-lgcc). */
/* #undef HAVE_LIBGCC */

/* Define to 1 if you have the `lzma' library (-llzma). */
/* #undef HAVE_LIBLZMA */

/* Define to 1 if you have the `lzmadec' library (-llzmadec). */
/* #undef HAVE_LIBLZMADEC */

/* Define to 1 if you have the `lzo2' library (-llzo2). */
/* #undef HAVE_LIBLZO2 */

/* Define to 1 if you have the `nettle' library (-lnettle). */
/* #undef HAVE_LIBNETTLE */

/* Define to 1 if you have the `pcre' library (-lpcre). */
/* #undef HAVE_LIBPCRE */

/* Define to 1 if you have the `pcreposix' library (-lpcreposix). */
/* #undef HAVE_LIBPCREPOSIX */

/* Define to 1 if you have the `xml2' library (-lxml2). */
/* #undef HAVE_LIBXML2 */

/* Define to 1 if you have the <libxml/xmlreader.h> header file. */
/* #undef HAVE_LIBXML_XMLREADER_H */

/* Define to 1 if you have the <libxml/xmlwriter.h> header file. */
/* #undef HAVE_LIBXML_XMLWRITER_H */

/* Define to 1 if you have the `z' library (-lz). */
#define HAVE_LIBZ 1

/* Define to 1 if you have the <limits.h> header file. */
#define HAVE_LIMITS_H 1

/* Define to 1 if you have the `link' function. */
#define HAVE_LINK 1

/* Define to 1 if you have the <linux/types.h> header file. */
#define HAVE_LINUX_TYPES_H 1

/* Define to 1 if you have the <linux/fiemap.h> header file. */
#define HAVE_LINUX_FIEMAP_H 1

/* Define to 1 if you have the <linux/fs.h> header file. */
#define HAVE_LINUX_FS_H 1

/* Define to 1 if you have the <linux/magic.h> header file. */
#define HAVE_LINUX_MAGIC_H 1

/* Define to 1 if you have the <linux/types.h> header file. */
#define HAVE_LINUX_TYPES_H 1

/* Define to 1 if you have the `listea' function. */
/* #undef HAVE_LISTEA */

/* Define to 1 if you have the `listxattr' function. */
/* #undef HAVE_LISTXATTR */

/* Define to 1 if you have the `llistea' function. */
/* #undef HAVE_LLISTEA */

/* Define to 1 if you have the `llistxattr' function. */
/* #undef HAVE_LLISTXATTR */

/* Define to 1 if you have the <localcharset.h> header file. */
/* #undef HAVE_LOCALCHARSET_H */

/* Define to 1 if you have the `locale_charset' function. */
/* #undef HAVE_LOCALE_CHARSET */

/* Define to 1 if you have the <locale.h> header file. */
#define HAVE_LOCALE_H 1

/* Define to 1 if you have the `localtime_r' function. */
#define HAVE_LOCALTIME_R 1

/* Define to 1 if the system has the type `long long int'. */
/* #undef HAVE_LONG_LONG_INT */

/* Define to 1 if you have the `lsetea' function. */
/* #undef HAVE_LSETEA */

/* Define to 1 if you have the `lsetxattr' function. */
/* #undef HAVE_LSETXATTR */

/* Define to 1 if you have the `lstat' function. */
#define HAVE_LSTAT 1

/* Define to 1 if `lstat' has the bug that it succeeds when given the
   zero-length file name argument. */
/* #undef HAVE_LSTAT_EMPTY_STRING_BUG */

/* Define to 1 if you have the `lutimes' function. */
#define HAVE_LUTIMES 1

/* Define to 1 if you have the <lzmadec.h> header file. */
/* #undef HAVE_LZMADEC_H */

/* Define to 1 if you have the <lzma.h> header file. */
/* #undef HAVE_LZMA_H */

/* Define to 1 if you have the <lzo/lzo1x.h> header file. */
/* #undef HAVE_LZO_LZO1X_H */

/* Define to 1 if you have the <lzo/lzoconf.h> header file. */
/* #undef HAVE_LZO_LZOCONF_H */

/* Define to 1 if you have the `mbrtowc' function. */
#define HAVE_MBRTOWC 1

/* Define to 1 if you have the `memmove' function. */
#define HAVE_MEMMOVE 1

/* Define to 1 if you have the <memory.h> header file. */
#define HAVE_MEMORY_H 1

/* Define to 1 if you have the `mkdir' function. */
#define HAVE_MKDIR 1

/* Define to 1 if you have the `mkfifo' function. */
#define HAVE_MKFIFO 1

/* Define to 1 if you have the `mknod' function. */
#define HAVE_MKNOD 1

/* Define to 1 if you have the `mkstemp' function. */
#define HAVE_MKSTEMP 1

/* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */
/* #undef HAVE_NDIR_H */

/* Define to 1 if you have the <nettle/md5.h> header file. */
/* #undef HAVE_NETTLE_MD5_H */

/* Define to 1 if you have the <nettle/ripemd160.h> header file. */
/* #undef HAVE_NETTLE_RIPEMD160_H */

/* Define to 1 if you have the <nettle/sha.h> header file. */
/* #undef HAVE_NETTLE_SHA_H */

/* Define to 1 if you have the `nl_langinfo' function. */
#define HAVE_NL_LANGINFO 1

/* Define to 1 if you have the `openat' function. */
#define HAVE_OPENAT 1

/* Define to 1 if you have the <paths.h> header file. */
#define HAVE_PATHS_H 1

/* Define to 1 if you have the <pcreposix.h> header file. */
/* #undef HAVE_PCREPOSIX_H */

/* Define to 1 if you have the `pipe' function. */
#define HAVE_PIPE 1

/* Define to 1 if you have the `poll' function. */
#define HAVE_POLL 1

/* Define to 1 if you have the <poll.h> header file. */
#define HAVE_POLL_H 1

/* Define to 1 if you have the `posix_spawnp' function. */
#define HAVE_POSIX_SPAWNP 1

/* Define to 1 if you have the <process.h> header file. */
/* #undef HAVE_PROCESS_H */

/* Define to 1 if you have the <pwd.h> header file. */
#define HAVE_PWD_H 1

/* Define to 1 if you have the `readdir_r' function. */
#define HAVE_READDIR_R 1

/* Define to 1 if you have the `readlink' function. */
#define HAVE_READLINK 1

/* Define to 1 if you have the `readlinkat' function. */
#define HAVE_READLINKAT 1

/* Define to 1 if you have the <regex.h> header file. */
#define HAVE_REGEX_H 1

/* Define to 1 if you have the `select' function. */
#define HAVE_SELECT 1

/* Define to 1 if you have the `setenv' function. */
#define HAVE_SETENV 1

/* Define to 1 if you have the `setlocale' function. */
#define HAVE_SETLOCALE 1

/* Define to 1 if you have the `sigaction' function. */
#define HAVE_SIGACTION 1

/* Define to 1 if you have the <signal.h> header file. */
#define HAVE_SIGNAL_H 1

/* Define to 1 if you have the <spawn.h> header file. */
#define HAVE_SPAWN_H 1

/* Define to 1 if you have the `statfs' function. */
#define HAVE_STATFS 1

/* Define to 1 if you have the `statvfs' function. */
#define HAVE_STATVFS 1

/* Define to 1 if `stat' has the bug that it succeeds when given the
   zero-length file name argument. */
/* #undef HAVE_STAT_EMPTY_STRING_BUG */

/* Define to 1 if you have the <stdarg.h> header file. */
#define HAVE_STDARG_H 1

/* Define to 1 if you have the <stdint.h> header file. */
#define HAVE_STDINT_H 1

/* Define to 1 if you have the <stdlib.h> header file. */
#define HAVE_STDLIB_H 1

/* Define to 1 if you have the `strchr' function. */
#define HAVE_STRCHR 1

/* Define to 1 if you have the `strdup' function. */
#define HAVE_STRDUP 1

/* Define to 1 if you have the `strerror' function. */
#define HAVE_STRERROR 1

/* Define to 1 if you have the `strerror_r' function. */
#define HAVE_STRERROR_R 1

/* Define to 1 if you have the `strftime' function. */
#define HAVE_STRFTIME 1

/* Define to 1 if you have the <strings.h> header file. */
#define HAVE_STRINGS_H 1

/* Define to 1 if you have the <string.h> header file. */
#define HAVE_STRING_H 1

/* Define to 1 if you have the `strrchr' function. */
#define HAVE_STRRCHR 1

/* Define to 1 if `f_namemax' is a member of `struct statfs'. */
/* #undef HAVE_STRUCT_STATFS_F_NAMEMAX */

/* Define to 1 if `f_iosize' is a member of `struct statvfs'. */
/* #undef HAVE_STRUCT_STATVFS_F_IOSIZE */

/* Define to 1 if `st_birthtime' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIME */

/* Define to 1 if `st_birthtimespec.tv_nsec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC_TV_NSEC */

/* Define to 1 if `st_blksize' is a member of `struct stat'. */
#define HAVE_STRUCT_STAT_ST_BLKSIZE 1

/* Define to 1 if `st_flags' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_FLAGS */

/* Define to 1 if `st_mtimespec.tv_nsec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC */

/* Define to 1 if `st_mtime_n' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIME_N */

/* Define to 1 if `st_mtime_usec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIME_USEC */

/* Define to 1 if `st_mtim.tv_nsec' is a member of `struct stat'. */
#define HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC 1

/* Define to 1 if `st_umtime' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_UMTIME */

/* Define to 1 if `tm_gmtoff' is a member of `struct tm'. */
#define HAVE_STRUCT_TM_TM_GMTOFF 1

/* Define to 1 if `__tm_gmtoff' is a member of `struct tm'. */
/* #undef HAVE_STRUCT_TM___TM_GMTOFF */

/* Define to 1 if you have the `symlink' function. */
#define HAVE_SYMLINK 1

/* Define to 1 if you have the <sys/acl.h> header file. */
/* #undef HAVE_SYS_ACL_H */

/* Define to 1 if you have the <sys/cdefs.h> header file. */
#define HAVE_SYS_CDEFS_H 1

/* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.
   */
/* #undef HAVE_SYS_DIR_H */

/* Define to 1 if you have the <sys/ea.h> header file. */
/* #undef HAVE_SYS_EA_H */

/* Define to 1 if you have the <sys/extattr.h> header file. */
/* #undef HAVE_SYS_EXTATTR_H */

/* Define to 1 if you have the <sys/ioctl.h> header file. */
#define HAVE_SYS_IOCTL_H 1

/* Define to 1 if you have the <sys/mkdev.h> header file. */
/* #undef HAVE_SYS_MKDEV_H */

/* Define to 1 if you have the <sys/mount.h> header file. */
/* #undef HAVE_SYS_MOUNT_H */

/* Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.
   */
/* #undef HAVE_SYS_NDIR_H */

/* Define to 1 if you have the <sys/param.h> header file. */
#define HAVE_SYS_PARAM_H 1

/* Define to 1 if you have the <sys/poll.h> header file. */
#define HAVE_SYS_POLL_H 1

/* Define to 1 if you have the <sys/select.h> header file. */
#define HAVE_SYS_SELECT_H 1

/* Define to 1 if you have the <sys/statfs.h> header file. */
#define HAVE_SYS_STATFS_H 1

/* Define to 1 if you have the <sys/statvfs.h> header file. */
#define HAVE_SYS_STATVFS_H 1

/* Define to 1 if you have the <sys/stat.h> header file. */
#define HAVE_SYS_STAT_H 1

/* Define to 1 if you have the <sys/time.h> header file. */
#define HAVE_SYS_TIME_H 1

/* Define to 1 if you have the <sys/types.h> header file. */
#define HAVE_SYS_TYPES_H 1

/* Define to 1 if you have the <sys/utime.h> header file. */
/* #undef HAVE_SYS_UTIME_H */

/* Define to 1 if you have the <sys/utsname.h> header file. */
#define HAVE_SYS_UTSNAME_H 1

/* Define to 1 if you have the <sys/vfs.h> header file. */
#define HAVE_SYS_VFS_H 1

/* Define to 1 if you have <sys/wait.h> that is POSIX.1 compatible. */
#define HAVE_SYS_WAIT_H 1

/* Define to 1 if you have the <sys/xattr.h> header file. */
/* #undef HAVE_SYS_XATTR_H */

/* Define to 1 if you have the `timegm' function. */
#define HAVE_TIMEGM 1

/* Define to 1 if you have the <time.h> header file. */
#define HAVE_TIME_H 1

/* Define to 1 if you have the `tzset' function. */
#define HAVE_TZSET 1

/* Define to 1 if you have the <unistd.h> header file. */
#define HAVE_UNISTD_H 1

/* Define to 1 if you have the `unsetenv' function. */
#define HAVE_UNSETENV 1

/* Define to 1 if the system has the type `unsigned long long'. */
/* #undef HAVE_UNSIGNED_LONG_LONG */

/* Define to 1 if the system has the type `unsigned long long int'. */
/* #undef HAVE_UNSIGNED_LONG_LONG_INT */

/* Define to 1 if you have the `utime' function. */
#define HAVE_UTIME 1

/* Define to 1 if you have the `utimensat' function. */
#define HAVE_UTIMENSAT 1

/* Define to 1 if you have the `utimes' function. */
#define HAVE_UTIMES 1

/* Define to 1 if you have the <utime.h> header file. */
#define HAVE_UTIME_H 1

/* Define to 1 if you have the `vfork' function. */
#define HAVE_VFORK 1

/* Define to 1 if you have the `vprintf' function. */
#define HAVE_VPRINTF 1

/* Define to 1 if you have the <wchar.h> header file. */
#define HAVE_WCHAR_H 1

/* Define to 1 if the system has the type `wchar_t'. */
#define HAVE_WCHAR_T 1

/* Define to 1 if you have the `wcrtomb' function. */
#define HAVE_WCRTOMB 1

/* Define to 1 if you have the `wcscmp' function. */
#define HAVE_WCSCMP 1

/* Define to 1 if you have the `wcscpy' function. */
#define HAVE_WCSCPY 1

/* Define to 1 if you have the `wcslen' function. */
#define HAVE_WCSLEN 1

/* Define to 1 if you have the `wctomb' function. */
#define HAVE_WCTOMB 1

/* Define to 1 if you have the <wctype.h> header file. */
#define HAVE_WCTYPE_H 1

/* Define to 1 if you have the <wincrypt.h> header file. */
/* #undef HAVE_WINCRYPT_H */

/* Define to 1 if you have the <windows.h> header file. */
/* #undef HAVE_WINDOWS_H */

/* Define to 1 if you have the <winioctl.h> header file. */
/* #undef HAVE_WINIOCTL_H */

/* Define to 1 if you have _CrtSetReportMode in <crtdbg.h>  */
/* #undef HAVE__CrtSetReportMode */

/* Define to 1 if you have the `wmemcmp' function. */
#define HAVE_WMEMCMP 1

/* Define to 1 if you have the `wmemcpy' function. */
#define HAVE_WMEMCPY 1

/* Define to 1 if you have a working EXT2_IOC_GETFLAGS */
/* #undef HAVE_WORKING_EXT2_IOC_GETFLAGS */

/* Define to 1 if you have the <zlib.h> header file. */
#define HAVE_ZLIB_H 1

/* Define to 1 if you have the `_ctime64_s' function. */
/* #undef HAVE__CTIME64_S */

/* Define to 1 if you have the `_fseeki64' function. */
/* #undef HAVE__FSEEKI64 */

/* Define to 1 if you have the `_get_timezone' function. */
/* #undef HAVE__GET_TIMEZONE */

/* Define to 1 if you have the `_localtime64_s' function. */
/* #undef HAVE__LOCALTIME64_S */

/* Define to 1 if you have the `_mkgmtime64' function. */
/* #undef HAVE__MKGMTIME64 */

/* Define as const if the declaration of iconv() needs const. */
#define ICONV_CONST 

/* Version number of libarchive as a single integer */
#define LIBARCHIVE_VERSION_NUMBER "3001002"

/* Version number of libarchive */
#define LIBARCHIVE_VERSION_STRING "3.1.2"

/* Define to 1 if `lstat' dereferences a symlink specified with a trailing
   slash. */
/* #undef LSTAT_FOLLOWS_SLASHED_SYMLINK */

/* Define to 1 if `major', `minor', and `makedev' are declared in <mkdev.h>.
   */
/* #undef MAJOR_IN_MKDEV */

/* Define to 1 if `major', `minor', and `makedev' are declared in
   <sysmacros.h>. */
#define MAJOR_IN_SYSMACROS 1

/* Define to 1 if your C compiler doesn't accept -c and -o together. */
/* #undef NO_MINUS_C_MINUS_O */

/* The size of `wchar_t', as computed by sizeof. */
#define SIZEOF_WCHAR_T 4

/* Define to 1 if strerror_r returns char *. */
/* #undef STRERROR_R_CHAR_P */

/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
#define TIME_WITH_SYS_TIME 1

/*
 * Some platform requires a macro to use extension functions.
 */
#define SAFE_TO_DEFINE_EXTENSIONS 1
#ifdef SAFE_TO_DEFINE_EXTENSIONS
/* Enable extensions on AIX 3, Interix.  */
#ifndef _ALL_SOURCE
# define _ALL_SOURCE 1
#endif
/* Enable GNU extensions on systems that have them.  */
#ifndef _GNU_SOURCE
# define _GNU_SOURCE 1
#endif
/* Enable threading extensions on Solaris.  */
#ifndef _POSIX_PTHREAD_SEMANTICS
# define _POSIX_PTHREAD_SEMANTICS 1
#endif
/* Enable extensions on HP NonStop.  */
#ifndef _TANDEM_SOURCE
# define _TANDEM_SOURCE 1
#endif
/* Enable general extensions on Solaris.  */
#ifndef __EXTENSIONS__
# define __EXTENSIONS__ 1
#endif
#endif /* SAFE_TO_DEFINE_EXTENSIONS */

/* Version number of package */
#define VERSION "3.1.2"

/* Number of bits in a file offset, on hosts where this is settable. */
/* #undef _FILE_OFFSET_BITS */

/* Define to 1 to make fseeko visible on some hosts (e.g. glibc 2.2). */
/* #undef _LARGEFILE_SOURCE */

/* Define for large files, on AIX-style hosts. */
/* #undef _LARGE_FILES */

/* Define for Windows to use Windows 2000+ APIs. */
/* #undef _WIN32_WINNT */
/* #undef WINVER */

/* Define to empty if `const' does not conform to ANSI C. */
/* #undef const */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef gid_t */

/* Define to `unsigned long' if <sys/types.h> does not define. */
/* #undef id_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef mode_t */

/* Define to `long long' if <sys/types.h> does not define. */
/* #undef off_t */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef pid_t */

/* Define to `unsigned int' if <sys/types.h> does not define. */
/* #undef size_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef ssize_t */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef uid_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef intptr_t */

/* Define to `unsigned int' if <sys/types.h> does not define. */
/* #undef uintptr_t */


#define ARCHIVE_RMD160_COMPILE_TEST
#define ARCHIVE_CRYPTO_RMD160_LIBC
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = (DWORD)bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. Nettle
 * 6. OpenSSL
 * 7. libmd
 * 8. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive_rmd160_ctx ctx;
  archive_rmd160_init(&ctx);
  archive_rmd160_update(&ctx, *argv, argc);
  archive_rmd160_final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA1_LIBC failed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec911899447/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec911899447.dir/build.make CMakeFiles/cmTryCompileExec911899447.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec911899447.dir/check_crypto_md.c.o
/usr/bin/gcc   -w  -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2 -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmlibarchive/libarchive -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec911899447.dir/check_crypto_md.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1186:0:
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:67:18: fatal error: sha1.h: No such file or directory
 #include <sha1.h>
                  ^
compilation terminated.
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec911899447.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec911899447/fast] Error 2

Source file was:
/* config.h.  Generated from build/cmake/config.h.in by cmake configure */
#if defined(__osf__)
# define _OSF_SOURCE
#endif

/*
 * Ensure we have C99-style int64_t, etc, all defined.
 */

/* First, we need to know if the system has already defined them. */
#define HAVE_INT16_T
#define HAVE_INT32_T
#define HAVE_INT64_T
#define HAVE_INTMAX_T

#define HAVE_UINT8_T
#define HAVE_UINT16_T
#define HAVE_UINT32_T
#define HAVE_UINT64_T
#define HAVE_UINTMAX_T

/* We might have the types we want under other spellings. */
/* #undef HAVE___INT64 */
/* #undef HAVE_U_INT64_T */
/* #undef HAVE_UNSIGNED___INT64 */

/* The sizes of various standard integer types. */
#define SIZE_OF_SHORT 2
#define SIZE_OF_INT 4
#define SIZE_OF_LONG 8
#define SIZE_OF_LONG_LONG 8
#define SIZE_OF_UNSIGNED_SHORT 2
#define SIZE_OF_UNSIGNED 4
#define SIZE_OF_UNSIGNED_LONG 8
#define SIZE_OF_UNSIGNED_LONG_LONG 8

/*
 * If we lack int64_t, define it to the first of __int64, int, long, and long long
 * that exists and is the right size.
 */
#if !defined(HAVE_INT64_T) && defined(HAVE___INT64)
typedef __int64 int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_INT == 8
typedef int int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_LONG == 8
typedef long int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_LONG_LONG == 8
typedef long long int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T)
#error No 64-bit integer type was found.
#endif

/*
 * Similarly for int32_t
 */
#if !defined(HAVE_INT32_T) && SIZE_OF_INT == 4
typedef long int32_t;
#define HAVE_INT32_T
#endif

#if !defined(HAVE_INT32_T) && SIZE_OF_LONG == 4
typedef long int32_t;
#define HAVE_INT32_T
#endif

#if !defined(HAVE_INT32_T)
#error No 32-bit integer type was found.
#endif

/*
 * Similarly for int16_t
 */
#if !defined(HAVE_INT16_T) && SIZE_OF_INT == 2
typedef int int16_t;
#define HAVE_INT16_T
#endif

#if !defined(HAVE_INT16_T) && SIZE_OF_SHORT == 2
typedef short int16_t;
#define HAVE_INT16_T
#endif

#if !defined(HAVE_INT16_T)
#error No 16-bit integer type was found.
#endif

/*
 * Similarly for uint64_t
 */
#if !defined(HAVE_UINT64_T) && defined(HAVE_UNSIGNED___INT64)
typedef unsigned __int64 uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED == 8
typedef unsigned uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED_LONG == 8
typedef unsigned long uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED_LONG_LONG == 8
typedef unsigned long long uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T)
#error No 64-bit unsigned integer type was found.
#endif


/*
 * Similarly for uint32_t
 */
#if !defined(HAVE_UINT32_T) && SIZE_OF_UNSIGNED == 4
typedef unsigned uint32_t;
#define HAVE_UINT32_T
#endif

#if !defined(HAVE_UINT32_T) && SIZE_OF_UNSIGNED_LONG == 4
typedef unsigned long uint32_t;
#define HAVE_UINT32_T
#endif

#if !defined(HAVE_UINT32_T)
#error No 32-bit unsigned integer type was found.
#endif

/*
 * Similarly for uint16_t
 */
#if !defined(HAVE_UINT16_T) && SIZE_OF_UNSIGNED == 2
typedef unsigned uint16_t;
#define HAVE_UINT16_T
#endif

#if !defined(HAVE_UINT16_T) && SIZE_OF_UNSIGNED_SHORT == 2
typedef unsigned short uint16_t;
#define HAVE_UINT16_T
#endif

#if !defined(HAVE_UINT16_T)
#error No 16-bit unsigned integer type was found.
#endif

/*
 * Similarly for uint8_t
 */
#if !defined(HAVE_UINT8_T)
typedef unsigned char uint8_t;
#define HAVE_UINT8_T
#endif

#if !defined(HAVE_UINT16_T)
#error No 8-bit unsigned integer type was found.
#endif

/* Define intmax_t and uintmax_t if they are not already defined. */
#if !defined(HAVE_INTMAX_T)
typedef int64_t intmax_t;
#define INTMAX_MIN INT64_MIN
#define INTMAX_MAX INT64_MAX
#endif

#if !defined(HAVE_UINTMAX_T)
typedef uint64_t uintmax_t;
#endif

/* Define ZLIB_WINAPI if zlib was built on Visual Studio. */
/* #undef ZLIB_WINAPI */

/* MD5 via ARCHIVE_CRYPTO_MD5_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_MD5_LIBC */

/* MD5 via ARCHIVE_CRYPTO_MD5_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_MD5_LIBSYSTEM */

/* MD5 via ARCHIVE_CRYPTO_MD5_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_MD5_NETTLE */

/* MD5 via ARCHIVE_CRYPTO_MD5_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_MD5_OPENSSL */

/* MD5 via ARCHIVE_CRYPTO_MD5_WIN supported. */
/* #undef ARCHIVE_CRYPTO_MD5_WIN */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_LIBC */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_NETTLE */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_OPENSSL */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_LIBC */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_LIBSYSTEM */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_NETTLE */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_OPENSSL */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_WIN */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC2 */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC3 */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBSYSTEM */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_NETTLE */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_OPENSSL */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_WIN */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC2 */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC3 */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBSYSTEM */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_NETTLE */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_OPENSSL */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_WIN */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC2 */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC3 */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBSYSTEM */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_NETTLE */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_OPENSSL */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_WIN */

/* Version number of bsdcpio */
#define BSDCPIO_VERSION_STRING "3.1.2"

/* Version number of bsdtar */
#define BSDTAR_VERSION_STRING "3.1.2"

/* Define to 1 if you have the `acl_create_entry' function. */
/* #undef HAVE_ACL_CREATE_ENTRY */

/* Define to 1 if you have the `acl_get_link' function. */
/* #undef HAVE_ACL_GET_LINK */

/* Define to 1 if you have the `acl_get_link_np' function. */
/* #undef HAVE_ACL_GET_LINK_NP */

/* Define to 1 if you have the `acl_get_perm' function. */
/* #undef HAVE_ACL_GET_PERM */

/* Define to 1 if you have the `acl_get_perm_np' function. */
/* #undef HAVE_ACL_GET_PERM_NP */

/* Define to 1 if you have the `acl_init' function. */
/* #undef HAVE_ACL_INIT */

/* Define to 1 if you have the <acl/libacl.h> header file. */
/* #undef HAVE_ACL_LIBACL_H */

/* Define to 1 if the system has the type `acl_permset_t'. */
/* #undef HAVE_ACL_PERMSET_T */

/* Define to 1 if you have the `acl_set_fd' function. */
/* #undef HAVE_ACL_SET_FD */

/* Define to 1 if you have the `acl_set_fd_np' function. */
/* #undef HAVE_ACL_SET_FD_NP */

/* Define to 1 if you have the `acl_set_file' function. */
/* #undef HAVE_ACL_SET_FILE */

/* True for systems with POSIX ACL support */
/* #undef HAVE_ACL_USER */

/* Define to 1 if you have the <attr/xattr.h> header file. */
/* #undef HAVE_ATTR_XATTR_H */

/* Define to 1 if you have the <bsdxml.h> header file. */
/* #undef HAVE_BSDXML_H */

/* Define to 1 if you have the <bzlib.h> header file. */
#define HAVE_BZLIB_H 1

/* Define to 1 if you have the `chflags' function. */
/* #undef HAVE_CHFLAGS */

/* Define to 1 if you have the `chown' function. */
#define HAVE_CHOWN 1

/* Define to 1 if you have the `chroot' function. */
#define HAVE_CHROOT 1

/* Define to 1 if you have the <copyfile.h> header file. */
/* #undef HAVE_COPYFILE_H */

/* Define to 1 if you have the `ctime_r' function. */
#define HAVE_CTIME_R 1

/* Define to 1 if you have the <ctype.h> header file. */
#define HAVE_CTYPE_H 1

/* Define to 1 if you have the `cygwin_conv_path' function. */
/* #undef HAVE_CYGWIN_CONV_PATH */

/* Define to 1 if you have the declaration of `INT64_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_INT64_MAX 1

/* Define to 1 if you have the declaration of `INT64_MIN', and to 0 if you
   don't. */
#define HAVE_DECL_INT64_MIN 1

/* Define to 1 if you have the declaration of `SIZE_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_SIZE_MAX 1

/* Define to 1 if you have the declaration of `SSIZE_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_SSIZE_MAX 1

/* Define to 1 if you have the declaration of `strerror_r', and to 0 if you
   don't. */
#define HAVE_DECL_STRERROR_R 1

/* Define to 1 if you have the declaration of `UINT32_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_UINT32_MAX 1

/* Define to 1 if you have the declaration of `UINT64_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_UINT64_MAX 1

/* Define to 1 if you have the <direct.h> header file. */
/* #undef HAVE_DIRECT_H */

/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.
   */
#define HAVE_DIRENT_H 1

/* Define to 1 if you have the `dirfd' function. */
#define HAVE_DIRFD 1

/* Define to 1 if you have the <dlfcn.h> header file. */
#define HAVE_DLFCN_H 1

/* Define to 1 if you don't have `vprintf' but do have `_doprnt.' */
/* #undef HAVE_DOPRNT */

/* Define to 1 if nl_langinfo supports D_MD_ORDER */
/* #undef HAVE_D_MD_ORDER */

/* A possible errno value for invalid file format errors */
/* #undef HAVE_EFTYPE */

/* A possible errno value for invalid file format errors */
#define HAVE_EILSEQ 1

/* Define to 1 if you have the <errno.h> header file. */
#define HAVE_ERRNO_H 1

/* Define to 1 if you have the <expat.h> header file. */
/* #undef HAVE_EXPAT_H */

/* Define to 1 if you have the <ext2fs/ext2_fs.h> header file. */
/* #undef HAVE_EXT2FS_EXT2_FS_H */

/* Define to 1 if you have the `extattr_get_file' function. */
/* #undef HAVE_EXTATTR_GET_FILE */

/* Define to 1 if you have the `extattr_list_file' function. */
/* #undef HAVE_EXTATTR_LIST_FILE */

/* Define to 1 if you have the `extattr_set_fd' function. */
/* #undef HAVE_EXTATTR_SET_FD */

/* Define to 1 if you have the `extattr_set_file' function. */
/* #undef HAVE_EXTATTR_SET_FILE */

/* Define to 1 if EXTATTR_NAMESPACE_USER is defined in sys/extattr.h. */
/* #undef HAVE_DECL_EXTATTR_NAMESPACE_USER */

/* Define to 1 if you have the `fchdir' function. */
#define HAVE_FCHDIR 1

/* Define to 1 if you have the `fchflags' function. */
/* #undef HAVE_FCHFLAGS */

/* Define to 1 if you have the `fchmod' function. */
#define HAVE_FCHMOD 1

/* Define to 1 if you have the `fchown' function. */
#define HAVE_FCHOWN 1

/* Define to 1 if you have the `fcntl' function. */
#define HAVE_FCNTL 1

/* Define to 1 if you have the <fcntl.h> header file. */
#define HAVE_FCNTL_H 1

/* Define to 1 if you have the `fdopendir' function. */
#define HAVE_FDOPENDIR 1

/* Define to 1 if you have the `fgetea' function. */
/* #undef HAVE_FGETEA */

/* Define to 1 if you have the `fgetxattr' function. */
/* #undef HAVE_FGETXATTR */

/* Define to 1 if you have the `flistea' function. */
/* #undef HAVE_FLISTEA */

/* Define to 1 if you have the `flistxattr' function. */
/* #undef HAVE_FLISTXATTR */

/* Define to 1 if you have the `fork' function. */
#define HAVE_FORK 1

/* Define to 1 if fseeko (and presumably ftello) exists and is declared. */
#define HAVE_FSEEKO 1

/* Define to 1 if you have the `fsetea' function. */
/* #undef HAVE_FSETEA */

/* Define to 1 if you have the `fsetxattr' function. */
/* #undef HAVE_FSETXATTR */

/* Define to 1 if you have the `fstat' function. */
#define HAVE_FSTAT 1

/* Define to 1 if you have the `fstatat' function. */
#define HAVE_FSTATAT 1

/* Define to 1 if you have the `fstatfs' function. */
#define HAVE_FSTATFS 1

/* Define to 1 if you have the `fstatvfs' function. */
#define HAVE_FSTATVFS 1

/* Define to 1 if you have the `ftruncate' function. */
#define HAVE_FTRUNCATE 1

/* Define to 1 if you have the `futimens' function. */
#define HAVE_FUTIMENS 1

/* Define to 1 if you have the `futimes' function. */
#define HAVE_FUTIMES 1

/* Define to 1 if you have the `futimesat' function. */
#define HAVE_FUTIMESAT 1

/* Define to 1 if you have the `getea' function. */
/* #undef HAVE_GETEA */

/* Define to 1 if you have the `geteuid' function. */
#define HAVE_GETEUID 1

/* Define to 1 if you have the `getgrgid_r' function. */
#define HAVE_GETGRGID_R 1

/* Define to 1 if you have the `getgrnam_r' function. */
#define HAVE_GETGRNAM_R 1

/* Define to 1 if you have the `getpid' function. */
#define HAVE_GETPID 1

/* Define to 1 if you have the `getpwnam_r' function. */
#define HAVE_GETPWNAM_R 1

/* Define to 1 if you have the `getpwuid_r' function. */
#define HAVE_GETPWUID_R 1

/* Define to 1 if you have the `getvfsbyname' function. */
/* #undef HAVE_GETVFSBYNAME */

/* Define to 1 if you have the `getxattr' function. */
/* #undef HAVE_GETXATTR */

/* Define to 1 if you have the `gmtime_r' function. */
#define HAVE_GMTIME_R 1

/* Define to 1 if you have the <grp.h> header file. */
#define HAVE_GRP_H 1

/* Define to 1 if you have the `iconv' function. */
/* #undef HAVE_ICONV */

/* Define to 1 if you have the <iconv.h> header file. */
/* #undef HAVE_ICONV_H */

/* Define to 1 if you have the <inttypes.h> header file. */
#define HAVE_INTTYPES_H 1

/* Define to 1 if you have the <io.h> header file. */
/* #undef HAVE_IO_H */

/* Define to 1 if you have the <langinfo.h> header file. */
#define HAVE_LANGINFO_H 1

/* Define to 1 if you have the `lchflags' function. */
/* #undef HAVE_LCHFLAGS */

/* Define to 1 if you have the `lchmod' function. */
/* #undef HAVE_LCHMOD */

/* Define to 1 if you have the `lchown' function. */
#define HAVE_LCHOWN 1

/* Define to 1 if you have the `lgetea' function. */
/* #undef HAVE_LGETEA */

/* Define to 1 if you have the `lgetxattr' function. */
/* #undef HAVE_LGETXATTR */

/* Define to 1 if you have the `acl' library (-lacl). */
/* #undef HAVE_LIBACL */

/* Define to 1 if you have the `attr' library (-lattr). */
/* #undef HAVE_LIBATTR */

/* Define to 1 if you have the `bsdxml' library (-lbsdxml). */
/* #undef HAVE_LIBBSDXML */

/* Define to 1 if you have the `bz2' library (-lbz2). */
#define HAVE_LIBBZ2 1

/* Define to 1 if you have the `expat' library (-lexpat). */
/* #undef HAVE_LIBEXPAT */

/* Define to 1 if you have the `gcc' library (-lgcc). */
/* #undef HAVE_LIBGCC */

/* Define to 1 if you have the `lzma' library (-llzma). */
/* #undef HAVE_LIBLZMA */

/* Define to 1 if you have the `lzmadec' library (-llzmadec). */
/* #undef HAVE_LIBLZMADEC */

/* Define to 1 if you have the `lzo2' library (-llzo2). */
/* #undef HAVE_LIBLZO2 */

/* Define to 1 if you have the `nettle' library (-lnettle). */
/* #undef HAVE_LIBNETTLE */

/* Define to 1 if you have the `pcre' library (-lpcre). */
/* #undef HAVE_LIBPCRE */

/* Define to 1 if you have the `pcreposix' library (-lpcreposix). */
/* #undef HAVE_LIBPCREPOSIX */

/* Define to 1 if you have the `xml2' library (-lxml2). */
/* #undef HAVE_LIBXML2 */

/* Define to 1 if you have the <libxml/xmlreader.h> header file. */
/* #undef HAVE_LIBXML_XMLREADER_H */

/* Define to 1 if you have the <libxml/xmlwriter.h> header file. */
/* #undef HAVE_LIBXML_XMLWRITER_H */

/* Define to 1 if you have the `z' library (-lz). */
#define HAVE_LIBZ 1

/* Define to 1 if you have the <limits.h> header file. */
#define HAVE_LIMITS_H 1

/* Define to 1 if you have the `link' function. */
#define HAVE_LINK 1

/* Define to 1 if you have the <linux/types.h> header file. */
#define HAVE_LINUX_TYPES_H 1

/* Define to 1 if you have the <linux/fiemap.h> header file. */
#define HAVE_LINUX_FIEMAP_H 1

/* Define to 1 if you have the <linux/fs.h> header file. */
#define HAVE_LINUX_FS_H 1

/* Define to 1 if you have the <linux/magic.h> header file. */
#define HAVE_LINUX_MAGIC_H 1

/* Define to 1 if you have the <linux/types.h> header file. */
#define HAVE_LINUX_TYPES_H 1

/* Define to 1 if you have the `listea' function. */
/* #undef HAVE_LISTEA */

/* Define to 1 if you have the `listxattr' function. */
/* #undef HAVE_LISTXATTR */

/* Define to 1 if you have the `llistea' function. */
/* #undef HAVE_LLISTEA */

/* Define to 1 if you have the `llistxattr' function. */
/* #undef HAVE_LLISTXATTR */

/* Define to 1 if you have the <localcharset.h> header file. */
/* #undef HAVE_LOCALCHARSET_H */

/* Define to 1 if you have the `locale_charset' function. */
/* #undef HAVE_LOCALE_CHARSET */

/* Define to 1 if you have the <locale.h> header file. */
#define HAVE_LOCALE_H 1

/* Define to 1 if you have the `localtime_r' function. */
#define HAVE_LOCALTIME_R 1

/* Define to 1 if the system has the type `long long int'. */
/* #undef HAVE_LONG_LONG_INT */

/* Define to 1 if you have the `lsetea' function. */
/* #undef HAVE_LSETEA */

/* Define to 1 if you have the `lsetxattr' function. */
/* #undef HAVE_LSETXATTR */

/* Define to 1 if you have the `lstat' function. */
#define HAVE_LSTAT 1

/* Define to 1 if `lstat' has the bug that it succeeds when given the
   zero-length file name argument. */
/* #undef HAVE_LSTAT_EMPTY_STRING_BUG */

/* Define to 1 if you have the `lutimes' function. */
#define HAVE_LUTIMES 1

/* Define to 1 if you have the <lzmadec.h> header file. */
/* #undef HAVE_LZMADEC_H */

/* Define to 1 if you have the <lzma.h> header file. */
/* #undef HAVE_LZMA_H */

/* Define to 1 if you have the <lzo/lzo1x.h> header file. */
/* #undef HAVE_LZO_LZO1X_H */

/* Define to 1 if you have the <lzo/lzoconf.h> header file. */
/* #undef HAVE_LZO_LZOCONF_H */

/* Define to 1 if you have the `mbrtowc' function. */
#define HAVE_MBRTOWC 1

/* Define to 1 if you have the `memmove' function. */
#define HAVE_MEMMOVE 1

/* Define to 1 if you have the <memory.h> header file. */
#define HAVE_MEMORY_H 1

/* Define to 1 if you have the `mkdir' function. */
#define HAVE_MKDIR 1

/* Define to 1 if you have the `mkfifo' function. */
#define HAVE_MKFIFO 1

/* Define to 1 if you have the `mknod' function. */
#define HAVE_MKNOD 1

/* Define to 1 if you have the `mkstemp' function. */
#define HAVE_MKSTEMP 1

/* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */
/* #undef HAVE_NDIR_H */

/* Define to 1 if you have the <nettle/md5.h> header file. */
/* #undef HAVE_NETTLE_MD5_H */

/* Define to 1 if you have the <nettle/ripemd160.h> header file. */
/* #undef HAVE_NETTLE_RIPEMD160_H */

/* Define to 1 if you have the <nettle/sha.h> header file. */
/* #undef HAVE_NETTLE_SHA_H */

/* Define to 1 if you have the `nl_langinfo' function. */
#define HAVE_NL_LANGINFO 1

/* Define to 1 if you have the `openat' function. */
#define HAVE_OPENAT 1

/* Define to 1 if you have the <paths.h> header file. */
#define HAVE_PATHS_H 1

/* Define to 1 if you have the <pcreposix.h> header file. */
/* #undef HAVE_PCREPOSIX_H */

/* Define to 1 if you have the `pipe' function. */
#define HAVE_PIPE 1

/* Define to 1 if you have the `poll' function. */
#define HAVE_POLL 1

/* Define to 1 if you have the <poll.h> header file. */
#define HAVE_POLL_H 1

/* Define to 1 if you have the `posix_spawnp' function. */
#define HAVE_POSIX_SPAWNP 1

/* Define to 1 if you have the <process.h> header file. */
/* #undef HAVE_PROCESS_H */

/* Define to 1 if you have the <pwd.h> header file. */
#define HAVE_PWD_H 1

/* Define to 1 if you have the `readdir_r' function. */
#define HAVE_READDIR_R 1

/* Define to 1 if you have the `readlink' function. */
#define HAVE_READLINK 1

/* Define to 1 if you have the `readlinkat' function. */
#define HAVE_READLINKAT 1

/* Define to 1 if you have the <regex.h> header file. */
#define HAVE_REGEX_H 1

/* Define to 1 if you have the `select' function. */
#define HAVE_SELECT 1

/* Define to 1 if you have the `setenv' function. */
#define HAVE_SETENV 1

/* Define to 1 if you have the `setlocale' function. */
#define HAVE_SETLOCALE 1

/* Define to 1 if you have the `sigaction' function. */
#define HAVE_SIGACTION 1

/* Define to 1 if you have the <signal.h> header file. */
#define HAVE_SIGNAL_H 1

/* Define to 1 if you have the <spawn.h> header file. */
#define HAVE_SPAWN_H 1

/* Define to 1 if you have the `statfs' function. */
#define HAVE_STATFS 1

/* Define to 1 if you have the `statvfs' function. */
#define HAVE_STATVFS 1

/* Define to 1 if `stat' has the bug that it succeeds when given the
   zero-length file name argument. */
/* #undef HAVE_STAT_EMPTY_STRING_BUG */

/* Define to 1 if you have the <stdarg.h> header file. */
#define HAVE_STDARG_H 1

/* Define to 1 if you have the <stdint.h> header file. */
#define HAVE_STDINT_H 1

/* Define to 1 if you have the <stdlib.h> header file. */
#define HAVE_STDLIB_H 1

/* Define to 1 if you have the `strchr' function. */
#define HAVE_STRCHR 1

/* Define to 1 if you have the `strdup' function. */
#define HAVE_STRDUP 1

/* Define to 1 if you have the `strerror' function. */
#define HAVE_STRERROR 1

/* Define to 1 if you have the `strerror_r' function. */
#define HAVE_STRERROR_R 1

/* Define to 1 if you have the `strftime' function. */
#define HAVE_STRFTIME 1

/* Define to 1 if you have the <strings.h> header file. */
#define HAVE_STRINGS_H 1

/* Define to 1 if you have the <string.h> header file. */
#define HAVE_STRING_H 1

/* Define to 1 if you have the `strrchr' function. */
#define HAVE_STRRCHR 1

/* Define to 1 if `f_namemax' is a member of `struct statfs'. */
/* #undef HAVE_STRUCT_STATFS_F_NAMEMAX */

/* Define to 1 if `f_iosize' is a member of `struct statvfs'. */
/* #undef HAVE_STRUCT_STATVFS_F_IOSIZE */

/* Define to 1 if `st_birthtime' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIME */

/* Define to 1 if `st_birthtimespec.tv_nsec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC_TV_NSEC */

/* Define to 1 if `st_blksize' is a member of `struct stat'. */
#define HAVE_STRUCT_STAT_ST_BLKSIZE 1

/* Define to 1 if `st_flags' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_FLAGS */

/* Define to 1 if `st_mtimespec.tv_nsec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC */

/* Define to 1 if `st_mtime_n' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIME_N */

/* Define to 1 if `st_mtime_usec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIME_USEC */

/* Define to 1 if `st_mtim.tv_nsec' is a member of `struct stat'. */
#define HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC 1

/* Define to 1 if `st_umtime' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_UMTIME */

/* Define to 1 if `tm_gmtoff' is a member of `struct tm'. */
#define HAVE_STRUCT_TM_TM_GMTOFF 1

/* Define to 1 if `__tm_gmtoff' is a member of `struct tm'. */
/* #undef HAVE_STRUCT_TM___TM_GMTOFF */

/* Define to 1 if you have the `symlink' function. */
#define HAVE_SYMLINK 1

/* Define to 1 if you have the <sys/acl.h> header file. */
/* #undef HAVE_SYS_ACL_H */

/* Define to 1 if you have the <sys/cdefs.h> header file. */
#define HAVE_SYS_CDEFS_H 1

/* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.
   */
/* #undef HAVE_SYS_DIR_H */

/* Define to 1 if you have the <sys/ea.h> header file. */
/* #undef HAVE_SYS_EA_H */

/* Define to 1 if you have the <sys/extattr.h> header file. */
/* #undef HAVE_SYS_EXTATTR_H */

/* Define to 1 if you have the <sys/ioctl.h> header file. */
#define HAVE_SYS_IOCTL_H 1

/* Define to 1 if you have the <sys/mkdev.h> header file. */
/* #undef HAVE_SYS_MKDEV_H */

/* Define to 1 if you have the <sys/mount.h> header file. */
/* #undef HAVE_SYS_MOUNT_H */

/* Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.
   */
/* #undef HAVE_SYS_NDIR_H */

/* Define to 1 if you have the <sys/param.h> header file. */
#define HAVE_SYS_PARAM_H 1

/* Define to 1 if you have the <sys/poll.h> header file. */
#define HAVE_SYS_POLL_H 1

/* Define to 1 if you have the <sys/select.h> header file. */
#define HAVE_SYS_SELECT_H 1

/* Define to 1 if you have the <sys/statfs.h> header file. */
#define HAVE_SYS_STATFS_H 1

/* Define to 1 if you have the <sys/statvfs.h> header file. */
#define HAVE_SYS_STATVFS_H 1

/* Define to 1 if you have the <sys/stat.h> header file. */
#define HAVE_SYS_STAT_H 1

/* Define to 1 if you have the <sys/time.h> header file. */
#define HAVE_SYS_TIME_H 1

/* Define to 1 if you have the <sys/types.h> header file. */
#define HAVE_SYS_TYPES_H 1

/* Define to 1 if you have the <sys/utime.h> header file. */
/* #undef HAVE_SYS_UTIME_H */

/* Define to 1 if you have the <sys/utsname.h> header file. */
#define HAVE_SYS_UTSNAME_H 1

/* Define to 1 if you have the <sys/vfs.h> header file. */
#define HAVE_SYS_VFS_H 1

/* Define to 1 if you have <sys/wait.h> that is POSIX.1 compatible. */
#define HAVE_SYS_WAIT_H 1

/* Define to 1 if you have the <sys/xattr.h> header file. */
/* #undef HAVE_SYS_XATTR_H */

/* Define to 1 if you have the `timegm' function. */
#define HAVE_TIMEGM 1

/* Define to 1 if you have the <time.h> header file. */
#define HAVE_TIME_H 1

/* Define to 1 if you have the `tzset' function. */
#define HAVE_TZSET 1

/* Define to 1 if you have the <unistd.h> header file. */
#define HAVE_UNISTD_H 1

/* Define to 1 if you have the `unsetenv' function. */
#define HAVE_UNSETENV 1

/* Define to 1 if the system has the type `unsigned long long'. */
/* #undef HAVE_UNSIGNED_LONG_LONG */

/* Define to 1 if the system has the type `unsigned long long int'. */
/* #undef HAVE_UNSIGNED_LONG_LONG_INT */

/* Define to 1 if you have the `utime' function. */
#define HAVE_UTIME 1

/* Define to 1 if you have the `utimensat' function. */
#define HAVE_UTIMENSAT 1

/* Define to 1 if you have the `utimes' function. */
#define HAVE_UTIMES 1

/* Define to 1 if you have the <utime.h> header file. */
#define HAVE_UTIME_H 1

/* Define to 1 if you have the `vfork' function. */
#define HAVE_VFORK 1

/* Define to 1 if you have the `vprintf' function. */
#define HAVE_VPRINTF 1

/* Define to 1 if you have the <wchar.h> header file. */
#define HAVE_WCHAR_H 1

/* Define to 1 if the system has the type `wchar_t'. */
#define HAVE_WCHAR_T 1

/* Define to 1 if you have the `wcrtomb' function. */
#define HAVE_WCRTOMB 1

/* Define to 1 if you have the `wcscmp' function. */
#define HAVE_WCSCMP 1

/* Define to 1 if you have the `wcscpy' function. */
#define HAVE_WCSCPY 1

/* Define to 1 if you have the `wcslen' function. */
#define HAVE_WCSLEN 1

/* Define to 1 if you have the `wctomb' function. */
#define HAVE_WCTOMB 1

/* Define to 1 if you have the <wctype.h> header file. */
#define HAVE_WCTYPE_H 1

/* Define to 1 if you have the <wincrypt.h> header file. */
/* #undef HAVE_WINCRYPT_H */

/* Define to 1 if you have the <windows.h> header file. */
/* #undef HAVE_WINDOWS_H */

/* Define to 1 if you have the <winioctl.h> header file. */
/* #undef HAVE_WINIOCTL_H */

/* Define to 1 if you have _CrtSetReportMode in <crtdbg.h>  */
/* #undef HAVE__CrtSetReportMode */

/* Define to 1 if you have the `wmemcmp' function. */
#define HAVE_WMEMCMP 1

/* Define to 1 if you have the `wmemcpy' function. */
#define HAVE_WMEMCPY 1

/* Define to 1 if you have a working EXT2_IOC_GETFLAGS */
/* #undef HAVE_WORKING_EXT2_IOC_GETFLAGS */

/* Define to 1 if you have the <zlib.h> header file. */
#define HAVE_ZLIB_H 1

/* Define to 1 if you have the `_ctime64_s' function. */
/* #undef HAVE__CTIME64_S */

/* Define to 1 if you have the `_fseeki64' function. */
/* #undef HAVE__FSEEKI64 */

/* Define to 1 if you have the `_get_timezone' function. */
/* #undef HAVE__GET_TIMEZONE */

/* Define to 1 if you have the `_localtime64_s' function. */
/* #undef HAVE__LOCALTIME64_S */

/* Define to 1 if you have the `_mkgmtime64' function. */
/* #undef HAVE__MKGMTIME64 */

/* Define as const if the declaration of iconv() needs const. */
#define ICONV_CONST 

/* Version number of libarchive as a single integer */
#define LIBARCHIVE_VERSION_NUMBER "3001002"

/* Version number of libarchive */
#define LIBARCHIVE_VERSION_STRING "3.1.2"

/* Define to 1 if `lstat' dereferences a symlink specified with a trailing
   slash. */
/* #undef LSTAT_FOLLOWS_SLASHED_SYMLINK */

/* Define to 1 if `major', `minor', and `makedev' are declared in <mkdev.h>.
   */
/* #undef MAJOR_IN_MKDEV */

/* Define to 1 if `major', `minor', and `makedev' are declared in
   <sysmacros.h>. */
#define MAJOR_IN_SYSMACROS 1

/* Define to 1 if your C compiler doesn't accept -c and -o together. */
/* #undef NO_MINUS_C_MINUS_O */

/* The size of `wchar_t', as computed by sizeof. */
#define SIZEOF_WCHAR_T 4

/* Define to 1 if strerror_r returns char *. */
/* #undef STRERROR_R_CHAR_P */

/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
#define TIME_WITH_SYS_TIME 1

/*
 * Some platform requires a macro to use extension functions.
 */
#define SAFE_TO_DEFINE_EXTENSIONS 1
#ifdef SAFE_TO_DEFINE_EXTENSIONS
/* Enable extensions on AIX 3, Interix.  */
#ifndef _ALL_SOURCE
# define _ALL_SOURCE 1
#endif
/* Enable GNU extensions on systems that have them.  */
#ifndef _GNU_SOURCE
# define _GNU_SOURCE 1
#endif
/* Enable threading extensions on Solaris.  */
#ifndef _POSIX_PTHREAD_SEMANTICS
# define _POSIX_PTHREAD_SEMANTICS 1
#endif
/* Enable extensions on HP NonStop.  */
#ifndef _TANDEM_SOURCE
# define _TANDEM_SOURCE 1
#endif
/* Enable general extensions on Solaris.  */
#ifndef __EXTENSIONS__
# define __EXTENSIONS__ 1
#endif
#endif /* SAFE_TO_DEFINE_EXTENSIONS */

/* Version number of package */
#define VERSION "3.1.2"

/* Number of bits in a file offset, on hosts where this is settable. */
/* #undef _FILE_OFFSET_BITS */

/* Define to 1 to make fseeko visible on some hosts (e.g. glibc 2.2). */
/* #undef _LARGEFILE_SOURCE */

/* Define for large files, on AIX-style hosts. */
/* #undef _LARGE_FILES */

/* Define for Windows to use Windows 2000+ APIs. */
/* #undef _WIN32_WINNT */
/* #undef WINVER */

/* Define to empty if `const' does not conform to ANSI C. */
/* #undef const */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef gid_t */

/* Define to `unsigned long' if <sys/types.h> does not define. */
/* #undef id_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef mode_t */

/* Define to `long long' if <sys/types.h> does not define. */
/* #undef off_t */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef pid_t */

/* Define to `unsigned int' if <sys/types.h> does not define. */
/* #undef size_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef ssize_t */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef uid_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef intptr_t */

/* Define to `unsigned int' if <sys/types.h> does not define. */
/* #undef uintptr_t */


#define ARCHIVE_SHA1_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA1_LIBC
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = (DWORD)bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. Nettle
 * 6. OpenSSL
 * 7. libmd
 * 8. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive_sha1_ctx ctx;
  archive_sha1_init(&ctx);
  archive_sha1_update(&ctx, *argv, argc);
  archive_sha1_final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA256_LIBC failed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3577880829/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3577880829.dir/build.make CMakeFiles/cmTryCompileExec3577880829.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3577880829.dir/check_crypto_md.c.o
/usr/bin/gcc   -w  -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2 -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmlibarchive/libarchive -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec3577880829.dir/check_crypto_md.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1186:0:
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: fatal error: sha2.h: No such file or directory
 #include <sha2.h>
                  ^
compilation terminated.
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec3577880829.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec3577880829/fast] Error 2

Source file was:
/* config.h.  Generated from build/cmake/config.h.in by cmake configure */
#if defined(__osf__)
# define _OSF_SOURCE
#endif

/*
 * Ensure we have C99-style int64_t, etc, all defined.
 */

/* First, we need to know if the system has already defined them. */
#define HAVE_INT16_T
#define HAVE_INT32_T
#define HAVE_INT64_T
#define HAVE_INTMAX_T

#define HAVE_UINT8_T
#define HAVE_UINT16_T
#define HAVE_UINT32_T
#define HAVE_UINT64_T
#define HAVE_UINTMAX_T

/* We might have the types we want under other spellings. */
/* #undef HAVE___INT64 */
/* #undef HAVE_U_INT64_T */
/* #undef HAVE_UNSIGNED___INT64 */

/* The sizes of various standard integer types. */
#define SIZE_OF_SHORT 2
#define SIZE_OF_INT 4
#define SIZE_OF_LONG 8
#define SIZE_OF_LONG_LONG 8
#define SIZE_OF_UNSIGNED_SHORT 2
#define SIZE_OF_UNSIGNED 4
#define SIZE_OF_UNSIGNED_LONG 8
#define SIZE_OF_UNSIGNED_LONG_LONG 8

/*
 * If we lack int64_t, define it to the first of __int64, int, long, and long long
 * that exists and is the right size.
 */
#if !defined(HAVE_INT64_T) && defined(HAVE___INT64)
typedef __int64 int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_INT == 8
typedef int int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_LONG == 8
typedef long int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_LONG_LONG == 8
typedef long long int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T)
#error No 64-bit integer type was found.
#endif

/*
 * Similarly for int32_t
 */
#if !defined(HAVE_INT32_T) && SIZE_OF_INT == 4
typedef long int32_t;
#define HAVE_INT32_T
#endif

#if !defined(HAVE_INT32_T) && SIZE_OF_LONG == 4
typedef long int32_t;
#define HAVE_INT32_T
#endif

#if !defined(HAVE_INT32_T)
#error No 32-bit integer type was found.
#endif

/*
 * Similarly for int16_t
 */
#if !defined(HAVE_INT16_T) && SIZE_OF_INT == 2
typedef int int16_t;
#define HAVE_INT16_T
#endif

#if !defined(HAVE_INT16_T) && SIZE_OF_SHORT == 2
typedef short int16_t;
#define HAVE_INT16_T
#endif

#if !defined(HAVE_INT16_T)
#error No 16-bit integer type was found.
#endif

/*
 * Similarly for uint64_t
 */
#if !defined(HAVE_UINT64_T) && defined(HAVE_UNSIGNED___INT64)
typedef unsigned __int64 uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED == 8
typedef unsigned uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED_LONG == 8
typedef unsigned long uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED_LONG_LONG == 8
typedef unsigned long long uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T)
#error No 64-bit unsigned integer type was found.
#endif


/*
 * Similarly for uint32_t
 */
#if !defined(HAVE_UINT32_T) && SIZE_OF_UNSIGNED == 4
typedef unsigned uint32_t;
#define HAVE_UINT32_T
#endif

#if !defined(HAVE_UINT32_T) && SIZE_OF_UNSIGNED_LONG == 4
typedef unsigned long uint32_t;
#define HAVE_UINT32_T
#endif

#if !defined(HAVE_UINT32_T)
#error No 32-bit unsigned integer type was found.
#endif

/*
 * Similarly for uint16_t
 */
#if !defined(HAVE_UINT16_T) && SIZE_OF_UNSIGNED == 2
typedef unsigned uint16_t;
#define HAVE_UINT16_T
#endif

#if !defined(HAVE_UINT16_T) && SIZE_OF_UNSIGNED_SHORT == 2
typedef unsigned short uint16_t;
#define HAVE_UINT16_T
#endif

#if !defined(HAVE_UINT16_T)
#error No 16-bit unsigned integer type was found.
#endif

/*
 * Similarly for uint8_t
 */
#if !defined(HAVE_UINT8_T)
typedef unsigned char uint8_t;
#define HAVE_UINT8_T
#endif

#if !defined(HAVE_UINT16_T)
#error No 8-bit unsigned integer type was found.
#endif

/* Define intmax_t and uintmax_t if they are not already defined. */
#if !defined(HAVE_INTMAX_T)
typedef int64_t intmax_t;
#define INTMAX_MIN INT64_MIN
#define INTMAX_MAX INT64_MAX
#endif

#if !defined(HAVE_UINTMAX_T)
typedef uint64_t uintmax_t;
#endif

/* Define ZLIB_WINAPI if zlib was built on Visual Studio. */
/* #undef ZLIB_WINAPI */

/* MD5 via ARCHIVE_CRYPTO_MD5_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_MD5_LIBC */

/* MD5 via ARCHIVE_CRYPTO_MD5_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_MD5_LIBSYSTEM */

/* MD5 via ARCHIVE_CRYPTO_MD5_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_MD5_NETTLE */

/* MD5 via ARCHIVE_CRYPTO_MD5_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_MD5_OPENSSL */

/* MD5 via ARCHIVE_CRYPTO_MD5_WIN supported. */
/* #undef ARCHIVE_CRYPTO_MD5_WIN */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_LIBC */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_NETTLE */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_OPENSSL */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_LIBC */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_LIBSYSTEM */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_NETTLE */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_OPENSSL */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_WIN */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC2 */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC3 */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBSYSTEM */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_NETTLE */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_OPENSSL */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_WIN */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC2 */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC3 */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBSYSTEM */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_NETTLE */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_OPENSSL */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_WIN */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC2 */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC3 */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBSYSTEM */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_NETTLE */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_OPENSSL */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_WIN */

/* Version number of bsdcpio */
#define BSDCPIO_VERSION_STRING "3.1.2"

/* Version number of bsdtar */
#define BSDTAR_VERSION_STRING "3.1.2"

/* Define to 1 if you have the `acl_create_entry' function. */
/* #undef HAVE_ACL_CREATE_ENTRY */

/* Define to 1 if you have the `acl_get_link' function. */
/* #undef HAVE_ACL_GET_LINK */

/* Define to 1 if you have the `acl_get_link_np' function. */
/* #undef HAVE_ACL_GET_LINK_NP */

/* Define to 1 if you have the `acl_get_perm' function. */
/* #undef HAVE_ACL_GET_PERM */

/* Define to 1 if you have the `acl_get_perm_np' function. */
/* #undef HAVE_ACL_GET_PERM_NP */

/* Define to 1 if you have the `acl_init' function. */
/* #undef HAVE_ACL_INIT */

/* Define to 1 if you have the <acl/libacl.h> header file. */
/* #undef HAVE_ACL_LIBACL_H */

/* Define to 1 if the system has the type `acl_permset_t'. */
/* #undef HAVE_ACL_PERMSET_T */

/* Define to 1 if you have the `acl_set_fd' function. */
/* #undef HAVE_ACL_SET_FD */

/* Define to 1 if you have the `acl_set_fd_np' function. */
/* #undef HAVE_ACL_SET_FD_NP */

/* Define to 1 if you have the `acl_set_file' function. */
/* #undef HAVE_ACL_SET_FILE */

/* True for systems with POSIX ACL support */
/* #undef HAVE_ACL_USER */

/* Define to 1 if you have the <attr/xattr.h> header file. */
/* #undef HAVE_ATTR_XATTR_H */

/* Define to 1 if you have the <bsdxml.h> header file. */
/* #undef HAVE_BSDXML_H */

/* Define to 1 if you have the <bzlib.h> header file. */
#define HAVE_BZLIB_H 1

/* Define to 1 if you have the `chflags' function. */
/* #undef HAVE_CHFLAGS */

/* Define to 1 if you have the `chown' function. */
#define HAVE_CHOWN 1

/* Define to 1 if you have the `chroot' function. */
#define HAVE_CHROOT 1

/* Define to 1 if you have the <copyfile.h> header file. */
/* #undef HAVE_COPYFILE_H */

/* Define to 1 if you have the `ctime_r' function. */
#define HAVE_CTIME_R 1

/* Define to 1 if you have the <ctype.h> header file. */
#define HAVE_CTYPE_H 1

/* Define to 1 if you have the `cygwin_conv_path' function. */
/* #undef HAVE_CYGWIN_CONV_PATH */

/* Define to 1 if you have the declaration of `INT64_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_INT64_MAX 1

/* Define to 1 if you have the declaration of `INT64_MIN', and to 0 if you
   don't. */
#define HAVE_DECL_INT64_MIN 1

/* Define to 1 if you have the declaration of `SIZE_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_SIZE_MAX 1

/* Define to 1 if you have the declaration of `SSIZE_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_SSIZE_MAX 1

/* Define to 1 if you have the declaration of `strerror_r', and to 0 if you
   don't. */
#define HAVE_DECL_STRERROR_R 1

/* Define to 1 if you have the declaration of `UINT32_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_UINT32_MAX 1

/* Define to 1 if you have the declaration of `UINT64_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_UINT64_MAX 1

/* Define to 1 if you have the <direct.h> header file. */
/* #undef HAVE_DIRECT_H */

/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.
   */
#define HAVE_DIRENT_H 1

/* Define to 1 if you have the `dirfd' function. */
#define HAVE_DIRFD 1

/* Define to 1 if you have the <dlfcn.h> header file. */
#define HAVE_DLFCN_H 1

/* Define to 1 if you don't have `vprintf' but do have `_doprnt.' */
/* #undef HAVE_DOPRNT */

/* Define to 1 if nl_langinfo supports D_MD_ORDER */
/* #undef HAVE_D_MD_ORDER */

/* A possible errno value for invalid file format errors */
/* #undef HAVE_EFTYPE */

/* A possible errno value for invalid file format errors */
#define HAVE_EILSEQ 1

/* Define to 1 if you have the <errno.h> header file. */
#define HAVE_ERRNO_H 1

/* Define to 1 if you have the <expat.h> header file. */
/* #undef HAVE_EXPAT_H */

/* Define to 1 if you have the <ext2fs/ext2_fs.h> header file. */
/* #undef HAVE_EXT2FS_EXT2_FS_H */

/* Define to 1 if you have the `extattr_get_file' function. */
/* #undef HAVE_EXTATTR_GET_FILE */

/* Define to 1 if you have the `extattr_list_file' function. */
/* #undef HAVE_EXTATTR_LIST_FILE */

/* Define to 1 if you have the `extattr_set_fd' function. */
/* #undef HAVE_EXTATTR_SET_FD */

/* Define to 1 if you have the `extattr_set_file' function. */
/* #undef HAVE_EXTATTR_SET_FILE */

/* Define to 1 if EXTATTR_NAMESPACE_USER is defined in sys/extattr.h. */
/* #undef HAVE_DECL_EXTATTR_NAMESPACE_USER */

/* Define to 1 if you have the `fchdir' function. */
#define HAVE_FCHDIR 1

/* Define to 1 if you have the `fchflags' function. */
/* #undef HAVE_FCHFLAGS */

/* Define to 1 if you have the `fchmod' function. */
#define HAVE_FCHMOD 1

/* Define to 1 if you have the `fchown' function. */
#define HAVE_FCHOWN 1

/* Define to 1 if you have the `fcntl' function. */
#define HAVE_FCNTL 1

/* Define to 1 if you have the <fcntl.h> header file. */
#define HAVE_FCNTL_H 1

/* Define to 1 if you have the `fdopendir' function. */
#define HAVE_FDOPENDIR 1

/* Define to 1 if you have the `fgetea' function. */
/* #undef HAVE_FGETEA */

/* Define to 1 if you have the `fgetxattr' function. */
/* #undef HAVE_FGETXATTR */

/* Define to 1 if you have the `flistea' function. */
/* #undef HAVE_FLISTEA */

/* Define to 1 if you have the `flistxattr' function. */
/* #undef HAVE_FLISTXATTR */

/* Define to 1 if you have the `fork' function. */
#define HAVE_FORK 1

/* Define to 1 if fseeko (and presumably ftello) exists and is declared. */
#define HAVE_FSEEKO 1

/* Define to 1 if you have the `fsetea' function. */
/* #undef HAVE_FSETEA */

/* Define to 1 if you have the `fsetxattr' function. */
/* #undef HAVE_FSETXATTR */

/* Define to 1 if you have the `fstat' function. */
#define HAVE_FSTAT 1

/* Define to 1 if you have the `fstatat' function. */
#define HAVE_FSTATAT 1

/* Define to 1 if you have the `fstatfs' function. */
#define HAVE_FSTATFS 1

/* Define to 1 if you have the `fstatvfs' function. */
#define HAVE_FSTATVFS 1

/* Define to 1 if you have the `ftruncate' function. */
#define HAVE_FTRUNCATE 1

/* Define to 1 if you have the `futimens' function. */
#define HAVE_FUTIMENS 1

/* Define to 1 if you have the `futimes' function. */
#define HAVE_FUTIMES 1

/* Define to 1 if you have the `futimesat' function. */
#define HAVE_FUTIMESAT 1

/* Define to 1 if you have the `getea' function. */
/* #undef HAVE_GETEA */

/* Define to 1 if you have the `geteuid' function. */
#define HAVE_GETEUID 1

/* Define to 1 if you have the `getgrgid_r' function. */
#define HAVE_GETGRGID_R 1

/* Define to 1 if you have the `getgrnam_r' function. */
#define HAVE_GETGRNAM_R 1

/* Define to 1 if you have the `getpid' function. */
#define HAVE_GETPID 1

/* Define to 1 if you have the `getpwnam_r' function. */
#define HAVE_GETPWNAM_R 1

/* Define to 1 if you have the `getpwuid_r' function. */
#define HAVE_GETPWUID_R 1

/* Define to 1 if you have the `getvfsbyname' function. */
/* #undef HAVE_GETVFSBYNAME */

/* Define to 1 if you have the `getxattr' function. */
/* #undef HAVE_GETXATTR */

/* Define to 1 if you have the `gmtime_r' function. */
#define HAVE_GMTIME_R 1

/* Define to 1 if you have the <grp.h> header file. */
#define HAVE_GRP_H 1

/* Define to 1 if you have the `iconv' function. */
/* #undef HAVE_ICONV */

/* Define to 1 if you have the <iconv.h> header file. */
/* #undef HAVE_ICONV_H */

/* Define to 1 if you have the <inttypes.h> header file. */
#define HAVE_INTTYPES_H 1

/* Define to 1 if you have the <io.h> header file. */
/* #undef HAVE_IO_H */

/* Define to 1 if you have the <langinfo.h> header file. */
#define HAVE_LANGINFO_H 1

/* Define to 1 if you have the `lchflags' function. */
/* #undef HAVE_LCHFLAGS */

/* Define to 1 if you have the `lchmod' function. */
/* #undef HAVE_LCHMOD */

/* Define to 1 if you have the `lchown' function. */
#define HAVE_LCHOWN 1

/* Define to 1 if you have the `lgetea' function. */
/* #undef HAVE_LGETEA */

/* Define to 1 if you have the `lgetxattr' function. */
/* #undef HAVE_LGETXATTR */

/* Define to 1 if you have the `acl' library (-lacl). */
/* #undef HAVE_LIBACL */

/* Define to 1 if you have the `attr' library (-lattr). */
/* #undef HAVE_LIBATTR */

/* Define to 1 if you have the `bsdxml' library (-lbsdxml). */
/* #undef HAVE_LIBBSDXML */

/* Define to 1 if you have the `bz2' library (-lbz2). */
#define HAVE_LIBBZ2 1

/* Define to 1 if you have the `expat' library (-lexpat). */
/* #undef HAVE_LIBEXPAT */

/* Define to 1 if you have the `gcc' library (-lgcc). */
/* #undef HAVE_LIBGCC */

/* Define to 1 if you have the `lzma' library (-llzma). */
/* #undef HAVE_LIBLZMA */

/* Define to 1 if you have the `lzmadec' library (-llzmadec). */
/* #undef HAVE_LIBLZMADEC */

/* Define to 1 if you have the `lzo2' library (-llzo2). */
/* #undef HAVE_LIBLZO2 */

/* Define to 1 if you have the `nettle' library (-lnettle). */
/* #undef HAVE_LIBNETTLE */

/* Define to 1 if you have the `pcre' library (-lpcre). */
/* #undef HAVE_LIBPCRE */

/* Define to 1 if you have the `pcreposix' library (-lpcreposix). */
/* #undef HAVE_LIBPCREPOSIX */

/* Define to 1 if you have the `xml2' library (-lxml2). */
/* #undef HAVE_LIBXML2 */

/* Define to 1 if you have the <libxml/xmlreader.h> header file. */
/* #undef HAVE_LIBXML_XMLREADER_H */

/* Define to 1 if you have the <libxml/xmlwriter.h> header file. */
/* #undef HAVE_LIBXML_XMLWRITER_H */

/* Define to 1 if you have the `z' library (-lz). */
#define HAVE_LIBZ 1

/* Define to 1 if you have the <limits.h> header file. */
#define HAVE_LIMITS_H 1

/* Define to 1 if you have the `link' function. */
#define HAVE_LINK 1

/* Define to 1 if you have the <linux/types.h> header file. */
#define HAVE_LINUX_TYPES_H 1

/* Define to 1 if you have the <linux/fiemap.h> header file. */
#define HAVE_LINUX_FIEMAP_H 1

/* Define to 1 if you have the <linux/fs.h> header file. */
#define HAVE_LINUX_FS_H 1

/* Define to 1 if you have the <linux/magic.h> header file. */
#define HAVE_LINUX_MAGIC_H 1

/* Define to 1 if you have the <linux/types.h> header file. */
#define HAVE_LINUX_TYPES_H 1

/* Define to 1 if you have the `listea' function. */
/* #undef HAVE_LISTEA */

/* Define to 1 if you have the `listxattr' function. */
/* #undef HAVE_LISTXATTR */

/* Define to 1 if you have the `llistea' function. */
/* #undef HAVE_LLISTEA */

/* Define to 1 if you have the `llistxattr' function. */
/* #undef HAVE_LLISTXATTR */

/* Define to 1 if you have the <localcharset.h> header file. */
/* #undef HAVE_LOCALCHARSET_H */

/* Define to 1 if you have the `locale_charset' function. */
/* #undef HAVE_LOCALE_CHARSET */

/* Define to 1 if you have the <locale.h> header file. */
#define HAVE_LOCALE_H 1

/* Define to 1 if you have the `localtime_r' function. */
#define HAVE_LOCALTIME_R 1

/* Define to 1 if the system has the type `long long int'. */
/* #undef HAVE_LONG_LONG_INT */

/* Define to 1 if you have the `lsetea' function. */
/* #undef HAVE_LSETEA */

/* Define to 1 if you have the `lsetxattr' function. */
/* #undef HAVE_LSETXATTR */

/* Define to 1 if you have the `lstat' function. */
#define HAVE_LSTAT 1

/* Define to 1 if `lstat' has the bug that it succeeds when given the
   zero-length file name argument. */
/* #undef HAVE_LSTAT_EMPTY_STRING_BUG */

/* Define to 1 if you have the `lutimes' function. */
#define HAVE_LUTIMES 1

/* Define to 1 if you have the <lzmadec.h> header file. */
/* #undef HAVE_LZMADEC_H */

/* Define to 1 if you have the <lzma.h> header file. */
/* #undef HAVE_LZMA_H */

/* Define to 1 if you have the <lzo/lzo1x.h> header file. */
/* #undef HAVE_LZO_LZO1X_H */

/* Define to 1 if you have the <lzo/lzoconf.h> header file. */
/* #undef HAVE_LZO_LZOCONF_H */

/* Define to 1 if you have the `mbrtowc' function. */
#define HAVE_MBRTOWC 1

/* Define to 1 if you have the `memmove' function. */
#define HAVE_MEMMOVE 1

/* Define to 1 if you have the <memory.h> header file. */
#define HAVE_MEMORY_H 1

/* Define to 1 if you have the `mkdir' function. */
#define HAVE_MKDIR 1

/* Define to 1 if you have the `mkfifo' function. */
#define HAVE_MKFIFO 1

/* Define to 1 if you have the `mknod' function. */
#define HAVE_MKNOD 1

/* Define to 1 if you have the `mkstemp' function. */
#define HAVE_MKSTEMP 1

/* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */
/* #undef HAVE_NDIR_H */

/* Define to 1 if you have the <nettle/md5.h> header file. */
/* #undef HAVE_NETTLE_MD5_H */

/* Define to 1 if you have the <nettle/ripemd160.h> header file. */
/* #undef HAVE_NETTLE_RIPEMD160_H */

/* Define to 1 if you have the <nettle/sha.h> header file. */
/* #undef HAVE_NETTLE_SHA_H */

/* Define to 1 if you have the `nl_langinfo' function. */
#define HAVE_NL_LANGINFO 1

/* Define to 1 if you have the `openat' function. */
#define HAVE_OPENAT 1

/* Define to 1 if you have the <paths.h> header file. */
#define HAVE_PATHS_H 1

/* Define to 1 if you have the <pcreposix.h> header file. */
/* #undef HAVE_PCREPOSIX_H */

/* Define to 1 if you have the `pipe' function. */
#define HAVE_PIPE 1

/* Define to 1 if you have the `poll' function. */
#define HAVE_POLL 1

/* Define to 1 if you have the <poll.h> header file. */
#define HAVE_POLL_H 1

/* Define to 1 if you have the `posix_spawnp' function. */
#define HAVE_POSIX_SPAWNP 1

/* Define to 1 if you have the <process.h> header file. */
/* #undef HAVE_PROCESS_H */

/* Define to 1 if you have the <pwd.h> header file. */
#define HAVE_PWD_H 1

/* Define to 1 if you have the `readdir_r' function. */
#define HAVE_READDIR_R 1

/* Define to 1 if you have the `readlink' function. */
#define HAVE_READLINK 1

/* Define to 1 if you have the `readlinkat' function. */
#define HAVE_READLINKAT 1

/* Define to 1 if you have the <regex.h> header file. */
#define HAVE_REGEX_H 1

/* Define to 1 if you have the `select' function. */
#define HAVE_SELECT 1

/* Define to 1 if you have the `setenv' function. */
#define HAVE_SETENV 1

/* Define to 1 if you have the `setlocale' function. */
#define HAVE_SETLOCALE 1

/* Define to 1 if you have the `sigaction' function. */
#define HAVE_SIGACTION 1

/* Define to 1 if you have the <signal.h> header file. */
#define HAVE_SIGNAL_H 1

/* Define to 1 if you have the <spawn.h> header file. */
#define HAVE_SPAWN_H 1

/* Define to 1 if you have the `statfs' function. */
#define HAVE_STATFS 1

/* Define to 1 if you have the `statvfs' function. */
#define HAVE_STATVFS 1

/* Define to 1 if `stat' has the bug that it succeeds when given the
   zero-length file name argument. */
/* #undef HAVE_STAT_EMPTY_STRING_BUG */

/* Define to 1 if you have the <stdarg.h> header file. */
#define HAVE_STDARG_H 1

/* Define to 1 if you have the <stdint.h> header file. */
#define HAVE_STDINT_H 1

/* Define to 1 if you have the <stdlib.h> header file. */
#define HAVE_STDLIB_H 1

/* Define to 1 if you have the `strchr' function. */
#define HAVE_STRCHR 1

/* Define to 1 if you have the `strdup' function. */
#define HAVE_STRDUP 1

/* Define to 1 if you have the `strerror' function. */
#define HAVE_STRERROR 1

/* Define to 1 if you have the `strerror_r' function. */
#define HAVE_STRERROR_R 1

/* Define to 1 if you have the `strftime' function. */
#define HAVE_STRFTIME 1

/* Define to 1 if you have the <strings.h> header file. */
#define HAVE_STRINGS_H 1

/* Define to 1 if you have the <string.h> header file. */
#define HAVE_STRING_H 1

/* Define to 1 if you have the `strrchr' function. */
#define HAVE_STRRCHR 1

/* Define to 1 if `f_namemax' is a member of `struct statfs'. */
/* #undef HAVE_STRUCT_STATFS_F_NAMEMAX */

/* Define to 1 if `f_iosize' is a member of `struct statvfs'. */
/* #undef HAVE_STRUCT_STATVFS_F_IOSIZE */

/* Define to 1 if `st_birthtime' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIME */

/* Define to 1 if `st_birthtimespec.tv_nsec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC_TV_NSEC */

/* Define to 1 if `st_blksize' is a member of `struct stat'. */
#define HAVE_STRUCT_STAT_ST_BLKSIZE 1

/* Define to 1 if `st_flags' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_FLAGS */

/* Define to 1 if `st_mtimespec.tv_nsec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC */

/* Define to 1 if `st_mtime_n' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIME_N */

/* Define to 1 if `st_mtime_usec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIME_USEC */

/* Define to 1 if `st_mtim.tv_nsec' is a member of `struct stat'. */
#define HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC 1

/* Define to 1 if `st_umtime' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_UMTIME */

/* Define to 1 if `tm_gmtoff' is a member of `struct tm'. */
#define HAVE_STRUCT_TM_TM_GMTOFF 1

/* Define to 1 if `__tm_gmtoff' is a member of `struct tm'. */
/* #undef HAVE_STRUCT_TM___TM_GMTOFF */

/* Define to 1 if you have the `symlink' function. */
#define HAVE_SYMLINK 1

/* Define to 1 if you have the <sys/acl.h> header file. */
/* #undef HAVE_SYS_ACL_H */

/* Define to 1 if you have the <sys/cdefs.h> header file. */
#define HAVE_SYS_CDEFS_H 1

/* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.
   */
/* #undef HAVE_SYS_DIR_H */

/* Define to 1 if you have the <sys/ea.h> header file. */
/* #undef HAVE_SYS_EA_H */

/* Define to 1 if you have the <sys/extattr.h> header file. */
/* #undef HAVE_SYS_EXTATTR_H */

/* Define to 1 if you have the <sys/ioctl.h> header file. */
#define HAVE_SYS_IOCTL_H 1

/* Define to 1 if you have the <sys/mkdev.h> header file. */
/* #undef HAVE_SYS_MKDEV_H */

/* Define to 1 if you have the <sys/mount.h> header file. */
/* #undef HAVE_SYS_MOUNT_H */

/* Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.
   */
/* #undef HAVE_SYS_NDIR_H */

/* Define to 1 if you have the <sys/param.h> header file. */
#define HAVE_SYS_PARAM_H 1

/* Define to 1 if you have the <sys/poll.h> header file. */
#define HAVE_SYS_POLL_H 1

/* Define to 1 if you have the <sys/select.h> header file. */
#define HAVE_SYS_SELECT_H 1

/* Define to 1 if you have the <sys/statfs.h> header file. */
#define HAVE_SYS_STATFS_H 1

/* Define to 1 if you have the <sys/statvfs.h> header file. */
#define HAVE_SYS_STATVFS_H 1

/* Define to 1 if you have the <sys/stat.h> header file. */
#define HAVE_SYS_STAT_H 1

/* Define to 1 if you have the <sys/time.h> header file. */
#define HAVE_SYS_TIME_H 1

/* Define to 1 if you have the <sys/types.h> header file. */
#define HAVE_SYS_TYPES_H 1

/* Define to 1 if you have the <sys/utime.h> header file. */
/* #undef HAVE_SYS_UTIME_H */

/* Define to 1 if you have the <sys/utsname.h> header file. */
#define HAVE_SYS_UTSNAME_H 1

/* Define to 1 if you have the <sys/vfs.h> header file. */
#define HAVE_SYS_VFS_H 1

/* Define to 1 if you have <sys/wait.h> that is POSIX.1 compatible. */
#define HAVE_SYS_WAIT_H 1

/* Define to 1 if you have the <sys/xattr.h> header file. */
/* #undef HAVE_SYS_XATTR_H */

/* Define to 1 if you have the `timegm' function. */
#define HAVE_TIMEGM 1

/* Define to 1 if you have the <time.h> header file. */
#define HAVE_TIME_H 1

/* Define to 1 if you have the `tzset' function. */
#define HAVE_TZSET 1

/* Define to 1 if you have the <unistd.h> header file. */
#define HAVE_UNISTD_H 1

/* Define to 1 if you have the `unsetenv' function. */
#define HAVE_UNSETENV 1

/* Define to 1 if the system has the type `unsigned long long'. */
/* #undef HAVE_UNSIGNED_LONG_LONG */

/* Define to 1 if the system has the type `unsigned long long int'. */
/* #undef HAVE_UNSIGNED_LONG_LONG_INT */

/* Define to 1 if you have the `utime' function. */
#define HAVE_UTIME 1

/* Define to 1 if you have the `utimensat' function. */
#define HAVE_UTIMENSAT 1

/* Define to 1 if you have the `utimes' function. */
#define HAVE_UTIMES 1

/* Define to 1 if you have the <utime.h> header file. */
#define HAVE_UTIME_H 1

/* Define to 1 if you have the `vfork' function. */
#define HAVE_VFORK 1

/* Define to 1 if you have the `vprintf' function. */
#define HAVE_VPRINTF 1

/* Define to 1 if you have the <wchar.h> header file. */
#define HAVE_WCHAR_H 1

/* Define to 1 if the system has the type `wchar_t'. */
#define HAVE_WCHAR_T 1

/* Define to 1 if you have the `wcrtomb' function. */
#define HAVE_WCRTOMB 1

/* Define to 1 if you have the `wcscmp' function. */
#define HAVE_WCSCMP 1

/* Define to 1 if you have the `wcscpy' function. */
#define HAVE_WCSCPY 1

/* Define to 1 if you have the `wcslen' function. */
#define HAVE_WCSLEN 1

/* Define to 1 if you have the `wctomb' function. */
#define HAVE_WCTOMB 1

/* Define to 1 if you have the <wctype.h> header file. */
#define HAVE_WCTYPE_H 1

/* Define to 1 if you have the <wincrypt.h> header file. */
/* #undef HAVE_WINCRYPT_H */

/* Define to 1 if you have the <windows.h> header file. */
/* #undef HAVE_WINDOWS_H */

/* Define to 1 if you have the <winioctl.h> header file. */
/* #undef HAVE_WINIOCTL_H */

/* Define to 1 if you have _CrtSetReportMode in <crtdbg.h>  */
/* #undef HAVE__CrtSetReportMode */

/* Define to 1 if you have the `wmemcmp' function. */
#define HAVE_WMEMCMP 1

/* Define to 1 if you have the `wmemcpy' function. */
#define HAVE_WMEMCPY 1

/* Define to 1 if you have a working EXT2_IOC_GETFLAGS */
/* #undef HAVE_WORKING_EXT2_IOC_GETFLAGS */

/* Define to 1 if you have the <zlib.h> header file. */
#define HAVE_ZLIB_H 1

/* Define to 1 if you have the `_ctime64_s' function. */
/* #undef HAVE__CTIME64_S */

/* Define to 1 if you have the `_fseeki64' function. */
/* #undef HAVE__FSEEKI64 */

/* Define to 1 if you have the `_get_timezone' function. */
/* #undef HAVE__GET_TIMEZONE */

/* Define to 1 if you have the `_localtime64_s' function. */
/* #undef HAVE__LOCALTIME64_S */

/* Define to 1 if you have the `_mkgmtime64' function. */
/* #undef HAVE__MKGMTIME64 */

/* Define as const if the declaration of iconv() needs const. */
#define ICONV_CONST 

/* Version number of libarchive as a single integer */
#define LIBARCHIVE_VERSION_NUMBER "3001002"

/* Version number of libarchive */
#define LIBARCHIVE_VERSION_STRING "3.1.2"

/* Define to 1 if `lstat' dereferences a symlink specified with a trailing
   slash. */
/* #undef LSTAT_FOLLOWS_SLASHED_SYMLINK */

/* Define to 1 if `major', `minor', and `makedev' are declared in <mkdev.h>.
   */
/* #undef MAJOR_IN_MKDEV */

/* Define to 1 if `major', `minor', and `makedev' are declared in
   <sysmacros.h>. */
#define MAJOR_IN_SYSMACROS 1

/* Define to 1 if your C compiler doesn't accept -c and -o together. */
/* #undef NO_MINUS_C_MINUS_O */

/* The size of `wchar_t', as computed by sizeof. */
#define SIZEOF_WCHAR_T 4

/* Define to 1 if strerror_r returns char *. */
/* #undef STRERROR_R_CHAR_P */

/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
#define TIME_WITH_SYS_TIME 1

/*
 * Some platform requires a macro to use extension functions.
 */
#define SAFE_TO_DEFINE_EXTENSIONS 1
#ifdef SAFE_TO_DEFINE_EXTENSIONS
/* Enable extensions on AIX 3, Interix.  */
#ifndef _ALL_SOURCE
# define _ALL_SOURCE 1
#endif
/* Enable GNU extensions on systems that have them.  */
#ifndef _GNU_SOURCE
# define _GNU_SOURCE 1
#endif
/* Enable threading extensions on Solaris.  */
#ifndef _POSIX_PTHREAD_SEMANTICS
# define _POSIX_PTHREAD_SEMANTICS 1
#endif
/* Enable extensions on HP NonStop.  */
#ifndef _TANDEM_SOURCE
# define _TANDEM_SOURCE 1
#endif
/* Enable general extensions on Solaris.  */
#ifndef __EXTENSIONS__
# define __EXTENSIONS__ 1
#endif
#endif /* SAFE_TO_DEFINE_EXTENSIONS */

/* Version number of package */
#define VERSION "3.1.2"

/* Number of bits in a file offset, on hosts where this is settable. */
/* #undef _FILE_OFFSET_BITS */

/* Define to 1 to make fseeko visible on some hosts (e.g. glibc 2.2). */
/* #undef _LARGEFILE_SOURCE */

/* Define for large files, on AIX-style hosts. */
/* #undef _LARGE_FILES */

/* Define for Windows to use Windows 2000+ APIs. */
/* #undef _WIN32_WINNT */
/* #undef WINVER */

/* Define to empty if `const' does not conform to ANSI C. */
/* #undef const */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef gid_t */

/* Define to `unsigned long' if <sys/types.h> does not define. */
/* #undef id_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef mode_t */

/* Define to `long long' if <sys/types.h> does not define. */
/* #undef off_t */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef pid_t */

/* Define to `unsigned int' if <sys/types.h> does not define. */
/* #undef size_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef ssize_t */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef uid_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef intptr_t */

/* Define to `unsigned int' if <sys/types.h> does not define. */
/* #undef uintptr_t */


#define ARCHIVE_SHA256_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA256_LIBC
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = (DWORD)bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. Nettle
 * 6. OpenSSL
 * 7. libmd
 * 8. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive_sha256_ctx ctx;
  archive_sha256_init(&ctx);
  archive_sha256_update(&ctx, *argv, argc);
  archive_sha256_final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA384_LIBC failed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2569768556/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2569768556.dir/build.make CMakeFiles/cmTryCompileExec2569768556.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2569768556.dir/check_crypto_md.c.o
/usr/bin/gcc   -w  -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2 -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmlibarchive/libarchive -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec2569768556.dir/check_crypto_md.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1186:0:
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: fatal error: sha2.h: No such file or directory
 #include <sha2.h>
                  ^
compilation terminated.
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec2569768556.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec2569768556/fast] Error 2

Source file was:
/* config.h.  Generated from build/cmake/config.h.in by cmake configure */
#if defined(__osf__)
# define _OSF_SOURCE
#endif

/*
 * Ensure we have C99-style int64_t, etc, all defined.
 */

/* First, we need to know if the system has already defined them. */
#define HAVE_INT16_T
#define HAVE_INT32_T
#define HAVE_INT64_T
#define HAVE_INTMAX_T

#define HAVE_UINT8_T
#define HAVE_UINT16_T
#define HAVE_UINT32_T
#define HAVE_UINT64_T
#define HAVE_UINTMAX_T

/* We might have the types we want under other spellings. */
/* #undef HAVE___INT64 */
/* #undef HAVE_U_INT64_T */
/* #undef HAVE_UNSIGNED___INT64 */

/* The sizes of various standard integer types. */
#define SIZE_OF_SHORT 2
#define SIZE_OF_INT 4
#define SIZE_OF_LONG 8
#define SIZE_OF_LONG_LONG 8
#define SIZE_OF_UNSIGNED_SHORT 2
#define SIZE_OF_UNSIGNED 4
#define SIZE_OF_UNSIGNED_LONG 8
#define SIZE_OF_UNSIGNED_LONG_LONG 8

/*
 * If we lack int64_t, define it to the first of __int64, int, long, and long long
 * that exists and is the right size.
 */
#if !defined(HAVE_INT64_T) && defined(HAVE___INT64)
typedef __int64 int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_INT == 8
typedef int int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_LONG == 8
typedef long int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_LONG_LONG == 8
typedef long long int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T)
#error No 64-bit integer type was found.
#endif

/*
 * Similarly for int32_t
 */
#if !defined(HAVE_INT32_T) && SIZE_OF_INT == 4
typedef long int32_t;
#define HAVE_INT32_T
#endif

#if !defined(HAVE_INT32_T) && SIZE_OF_LONG == 4
typedef long int32_t;
#define HAVE_INT32_T
#endif

#if !defined(HAVE_INT32_T)
#error No 32-bit integer type was found.
#endif

/*
 * Similarly for int16_t
 */
#if !defined(HAVE_INT16_T) && SIZE_OF_INT == 2
typedef int int16_t;
#define HAVE_INT16_T
#endif

#if !defined(HAVE_INT16_T) && SIZE_OF_SHORT == 2
typedef short int16_t;
#define HAVE_INT16_T
#endif

#if !defined(HAVE_INT16_T)
#error No 16-bit integer type was found.
#endif

/*
 * Similarly for uint64_t
 */
#if !defined(HAVE_UINT64_T) && defined(HAVE_UNSIGNED___INT64)
typedef unsigned __int64 uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED == 8
typedef unsigned uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED_LONG == 8
typedef unsigned long uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED_LONG_LONG == 8
typedef unsigned long long uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T)
#error No 64-bit unsigned integer type was found.
#endif


/*
 * Similarly for uint32_t
 */
#if !defined(HAVE_UINT32_T) && SIZE_OF_UNSIGNED == 4
typedef unsigned uint32_t;
#define HAVE_UINT32_T
#endif

#if !defined(HAVE_UINT32_T) && SIZE_OF_UNSIGNED_LONG == 4
typedef unsigned long uint32_t;
#define HAVE_UINT32_T
#endif

#if !defined(HAVE_UINT32_T)
#error No 32-bit unsigned integer type was found.
#endif

/*
 * Similarly for uint16_t
 */
#if !defined(HAVE_UINT16_T) && SIZE_OF_UNSIGNED == 2
typedef unsigned uint16_t;
#define HAVE_UINT16_T
#endif

#if !defined(HAVE_UINT16_T) && SIZE_OF_UNSIGNED_SHORT == 2
typedef unsigned short uint16_t;
#define HAVE_UINT16_T
#endif

#if !defined(HAVE_UINT16_T)
#error No 16-bit unsigned integer type was found.
#endif

/*
 * Similarly for uint8_t
 */
#if !defined(HAVE_UINT8_T)
typedef unsigned char uint8_t;
#define HAVE_UINT8_T
#endif

#if !defined(HAVE_UINT16_T)
#error No 8-bit unsigned integer type was found.
#endif

/* Define intmax_t and uintmax_t if they are not already defined. */
#if !defined(HAVE_INTMAX_T)
typedef int64_t intmax_t;
#define INTMAX_MIN INT64_MIN
#define INTMAX_MAX INT64_MAX
#endif

#if !defined(HAVE_UINTMAX_T)
typedef uint64_t uintmax_t;
#endif

/* Define ZLIB_WINAPI if zlib was built on Visual Studio. */
/* #undef ZLIB_WINAPI */

/* MD5 via ARCHIVE_CRYPTO_MD5_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_MD5_LIBC */

/* MD5 via ARCHIVE_CRYPTO_MD5_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_MD5_LIBSYSTEM */

/* MD5 via ARCHIVE_CRYPTO_MD5_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_MD5_NETTLE */

/* MD5 via ARCHIVE_CRYPTO_MD5_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_MD5_OPENSSL */

/* MD5 via ARCHIVE_CRYPTO_MD5_WIN supported. */
/* #undef ARCHIVE_CRYPTO_MD5_WIN */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_LIBC */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_NETTLE */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_OPENSSL */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_LIBC */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_LIBSYSTEM */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_NETTLE */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_OPENSSL */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_WIN */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC2 */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC3 */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBSYSTEM */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_NETTLE */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_OPENSSL */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_WIN */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC2 */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC3 */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBSYSTEM */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_NETTLE */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_OPENSSL */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_WIN */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC2 */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC3 */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBSYSTEM */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_NETTLE */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_OPENSSL */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_WIN */

/* Version number of bsdcpio */
#define BSDCPIO_VERSION_STRING "3.1.2"

/* Version number of bsdtar */
#define BSDTAR_VERSION_STRING "3.1.2"

/* Define to 1 if you have the `acl_create_entry' function. */
/* #undef HAVE_ACL_CREATE_ENTRY */

/* Define to 1 if you have the `acl_get_link' function. */
/* #undef HAVE_ACL_GET_LINK */

/* Define to 1 if you have the `acl_get_link_np' function. */
/* #undef HAVE_ACL_GET_LINK_NP */

/* Define to 1 if you have the `acl_get_perm' function. */
/* #undef HAVE_ACL_GET_PERM */

/* Define to 1 if you have the `acl_get_perm_np' function. */
/* #undef HAVE_ACL_GET_PERM_NP */

/* Define to 1 if you have the `acl_init' function. */
/* #undef HAVE_ACL_INIT */

/* Define to 1 if you have the <acl/libacl.h> header file. */
/* #undef HAVE_ACL_LIBACL_H */

/* Define to 1 if the system has the type `acl_permset_t'. */
/* #undef HAVE_ACL_PERMSET_T */

/* Define to 1 if you have the `acl_set_fd' function. */
/* #undef HAVE_ACL_SET_FD */

/* Define to 1 if you have the `acl_set_fd_np' function. */
/* #undef HAVE_ACL_SET_FD_NP */

/* Define to 1 if you have the `acl_set_file' function. */
/* #undef HAVE_ACL_SET_FILE */

/* True for systems with POSIX ACL support */
/* #undef HAVE_ACL_USER */

/* Define to 1 if you have the <attr/xattr.h> header file. */
/* #undef HAVE_ATTR_XATTR_H */

/* Define to 1 if you have the <bsdxml.h> header file. */
/* #undef HAVE_BSDXML_H */

/* Define to 1 if you have the <bzlib.h> header file. */
#define HAVE_BZLIB_H 1

/* Define to 1 if you have the `chflags' function. */
/* #undef HAVE_CHFLAGS */

/* Define to 1 if you have the `chown' function. */
#define HAVE_CHOWN 1

/* Define to 1 if you have the `chroot' function. */
#define HAVE_CHROOT 1

/* Define to 1 if you have the <copyfile.h> header file. */
/* #undef HAVE_COPYFILE_H */

/* Define to 1 if you have the `ctime_r' function. */
#define HAVE_CTIME_R 1

/* Define to 1 if you have the <ctype.h> header file. */
#define HAVE_CTYPE_H 1

/* Define to 1 if you have the `cygwin_conv_path' function. */
/* #undef HAVE_CYGWIN_CONV_PATH */

/* Define to 1 if you have the declaration of `INT64_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_INT64_MAX 1

/* Define to 1 if you have the declaration of `INT64_MIN', and to 0 if you
   don't. */
#define HAVE_DECL_INT64_MIN 1

/* Define to 1 if you have the declaration of `SIZE_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_SIZE_MAX 1

/* Define to 1 if you have the declaration of `SSIZE_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_SSIZE_MAX 1

/* Define to 1 if you have the declaration of `strerror_r', and to 0 if you
   don't. */
#define HAVE_DECL_STRERROR_R 1

/* Define to 1 if you have the declaration of `UINT32_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_UINT32_MAX 1

/* Define to 1 if you have the declaration of `UINT64_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_UINT64_MAX 1

/* Define to 1 if you have the <direct.h> header file. */
/* #undef HAVE_DIRECT_H */

/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.
   */
#define HAVE_DIRENT_H 1

/* Define to 1 if you have the `dirfd' function. */
#define HAVE_DIRFD 1

/* Define to 1 if you have the <dlfcn.h> header file. */
#define HAVE_DLFCN_H 1

/* Define to 1 if you don't have `vprintf' but do have `_doprnt.' */
/* #undef HAVE_DOPRNT */

/* Define to 1 if nl_langinfo supports D_MD_ORDER */
/* #undef HAVE_D_MD_ORDER */

/* A possible errno value for invalid file format errors */
/* #undef HAVE_EFTYPE */

/* A possible errno value for invalid file format errors */
#define HAVE_EILSEQ 1

/* Define to 1 if you have the <errno.h> header file. */
#define HAVE_ERRNO_H 1

/* Define to 1 if you have the <expat.h> header file. */
/* #undef HAVE_EXPAT_H */

/* Define to 1 if you have the <ext2fs/ext2_fs.h> header file. */
/* #undef HAVE_EXT2FS_EXT2_FS_H */

/* Define to 1 if you have the `extattr_get_file' function. */
/* #undef HAVE_EXTATTR_GET_FILE */

/* Define to 1 if you have the `extattr_list_file' function. */
/* #undef HAVE_EXTATTR_LIST_FILE */

/* Define to 1 if you have the `extattr_set_fd' function. */
/* #undef HAVE_EXTATTR_SET_FD */

/* Define to 1 if you have the `extattr_set_file' function. */
/* #undef HAVE_EXTATTR_SET_FILE */

/* Define to 1 if EXTATTR_NAMESPACE_USER is defined in sys/extattr.h. */
/* #undef HAVE_DECL_EXTATTR_NAMESPACE_USER */

/* Define to 1 if you have the `fchdir' function. */
#define HAVE_FCHDIR 1

/* Define to 1 if you have the `fchflags' function. */
/* #undef HAVE_FCHFLAGS */

/* Define to 1 if you have the `fchmod' function. */
#define HAVE_FCHMOD 1

/* Define to 1 if you have the `fchown' function. */
#define HAVE_FCHOWN 1

/* Define to 1 if you have the `fcntl' function. */
#define HAVE_FCNTL 1

/* Define to 1 if you have the <fcntl.h> header file. */
#define HAVE_FCNTL_H 1

/* Define to 1 if you have the `fdopendir' function. */
#define HAVE_FDOPENDIR 1

/* Define to 1 if you have the `fgetea' function. */
/* #undef HAVE_FGETEA */

/* Define to 1 if you have the `fgetxattr' function. */
/* #undef HAVE_FGETXATTR */

/* Define to 1 if you have the `flistea' function. */
/* #undef HAVE_FLISTEA */

/* Define to 1 if you have the `flistxattr' function. */
/* #undef HAVE_FLISTXATTR */

/* Define to 1 if you have the `fork' function. */
#define HAVE_FORK 1

/* Define to 1 if fseeko (and presumably ftello) exists and is declared. */
#define HAVE_FSEEKO 1

/* Define to 1 if you have the `fsetea' function. */
/* #undef HAVE_FSETEA */

/* Define to 1 if you have the `fsetxattr' function. */
/* #undef HAVE_FSETXATTR */

/* Define to 1 if you have the `fstat' function. */
#define HAVE_FSTAT 1

/* Define to 1 if you have the `fstatat' function. */
#define HAVE_FSTATAT 1

/* Define to 1 if you have the `fstatfs' function. */
#define HAVE_FSTATFS 1

/* Define to 1 if you have the `fstatvfs' function. */
#define HAVE_FSTATVFS 1

/* Define to 1 if you have the `ftruncate' function. */
#define HAVE_FTRUNCATE 1

/* Define to 1 if you have the `futimens' function. */
#define HAVE_FUTIMENS 1

/* Define to 1 if you have the `futimes' function. */
#define HAVE_FUTIMES 1

/* Define to 1 if you have the `futimesat' function. */
#define HAVE_FUTIMESAT 1

/* Define to 1 if you have the `getea' function. */
/* #undef HAVE_GETEA */

/* Define to 1 if you have the `geteuid' function. */
#define HAVE_GETEUID 1

/* Define to 1 if you have the `getgrgid_r' function. */
#define HAVE_GETGRGID_R 1

/* Define to 1 if you have the `getgrnam_r' function. */
#define HAVE_GETGRNAM_R 1

/* Define to 1 if you have the `getpid' function. */
#define HAVE_GETPID 1

/* Define to 1 if you have the `getpwnam_r' function. */
#define HAVE_GETPWNAM_R 1

/* Define to 1 if you have the `getpwuid_r' function. */
#define HAVE_GETPWUID_R 1

/* Define to 1 if you have the `getvfsbyname' function. */
/* #undef HAVE_GETVFSBYNAME */

/* Define to 1 if you have the `getxattr' function. */
/* #undef HAVE_GETXATTR */

/* Define to 1 if you have the `gmtime_r' function. */
#define HAVE_GMTIME_R 1

/* Define to 1 if you have the <grp.h> header file. */
#define HAVE_GRP_H 1

/* Define to 1 if you have the `iconv' function. */
/* #undef HAVE_ICONV */

/* Define to 1 if you have the <iconv.h> header file. */
/* #undef HAVE_ICONV_H */

/* Define to 1 if you have the <inttypes.h> header file. */
#define HAVE_INTTYPES_H 1

/* Define to 1 if you have the <io.h> header file. */
/* #undef HAVE_IO_H */

/* Define to 1 if you have the <langinfo.h> header file. */
#define HAVE_LANGINFO_H 1

/* Define to 1 if you have the `lchflags' function. */
/* #undef HAVE_LCHFLAGS */

/* Define to 1 if you have the `lchmod' function. */
/* #undef HAVE_LCHMOD */

/* Define to 1 if you have the `lchown' function. */
#define HAVE_LCHOWN 1

/* Define to 1 if you have the `lgetea' function. */
/* #undef HAVE_LGETEA */

/* Define to 1 if you have the `lgetxattr' function. */
/* #undef HAVE_LGETXATTR */

/* Define to 1 if you have the `acl' library (-lacl). */
/* #undef HAVE_LIBACL */

/* Define to 1 if you have the `attr' library (-lattr). */
/* #undef HAVE_LIBATTR */

/* Define to 1 if you have the `bsdxml' library (-lbsdxml). */
/* #undef HAVE_LIBBSDXML */

/* Define to 1 if you have the `bz2' library (-lbz2). */
#define HAVE_LIBBZ2 1

/* Define to 1 if you have the `expat' library (-lexpat). */
/* #undef HAVE_LIBEXPAT */

/* Define to 1 if you have the `gcc' library (-lgcc). */
/* #undef HAVE_LIBGCC */

/* Define to 1 if you have the `lzma' library (-llzma). */
/* #undef HAVE_LIBLZMA */

/* Define to 1 if you have the `lzmadec' library (-llzmadec). */
/* #undef HAVE_LIBLZMADEC */

/* Define to 1 if you have the `lzo2' library (-llzo2). */
/* #undef HAVE_LIBLZO2 */

/* Define to 1 if you have the `nettle' library (-lnettle). */
/* #undef HAVE_LIBNETTLE */

/* Define to 1 if you have the `pcre' library (-lpcre). */
/* #undef HAVE_LIBPCRE */

/* Define to 1 if you have the `pcreposix' library (-lpcreposix). */
/* #undef HAVE_LIBPCREPOSIX */

/* Define to 1 if you have the `xml2' library (-lxml2). */
/* #undef HAVE_LIBXML2 */

/* Define to 1 if you have the <libxml/xmlreader.h> header file. */
/* #undef HAVE_LIBXML_XMLREADER_H */

/* Define to 1 if you have the <libxml/xmlwriter.h> header file. */
/* #undef HAVE_LIBXML_XMLWRITER_H */

/* Define to 1 if you have the `z' library (-lz). */
#define HAVE_LIBZ 1

/* Define to 1 if you have the <limits.h> header file. */
#define HAVE_LIMITS_H 1

/* Define to 1 if you have the `link' function. */
#define HAVE_LINK 1

/* Define to 1 if you have the <linux/types.h> header file. */
#define HAVE_LINUX_TYPES_H 1

/* Define to 1 if you have the <linux/fiemap.h> header file. */
#define HAVE_LINUX_FIEMAP_H 1

/* Define to 1 if you have the <linux/fs.h> header file. */
#define HAVE_LINUX_FS_H 1

/* Define to 1 if you have the <linux/magic.h> header file. */
#define HAVE_LINUX_MAGIC_H 1

/* Define to 1 if you have the <linux/types.h> header file. */
#define HAVE_LINUX_TYPES_H 1

/* Define to 1 if you have the `listea' function. */
/* #undef HAVE_LISTEA */

/* Define to 1 if you have the `listxattr' function. */
/* #undef HAVE_LISTXATTR */

/* Define to 1 if you have the `llistea' function. */
/* #undef HAVE_LLISTEA */

/* Define to 1 if you have the `llistxattr' function. */
/* #undef HAVE_LLISTXATTR */

/* Define to 1 if you have the <localcharset.h> header file. */
/* #undef HAVE_LOCALCHARSET_H */

/* Define to 1 if you have the `locale_charset' function. */
/* #undef HAVE_LOCALE_CHARSET */

/* Define to 1 if you have the <locale.h> header file. */
#define HAVE_LOCALE_H 1

/* Define to 1 if you have the `localtime_r' function. */
#define HAVE_LOCALTIME_R 1

/* Define to 1 if the system has the type `long long int'. */
/* #undef HAVE_LONG_LONG_INT */

/* Define to 1 if you have the `lsetea' function. */
/* #undef HAVE_LSETEA */

/* Define to 1 if you have the `lsetxattr' function. */
/* #undef HAVE_LSETXATTR */

/* Define to 1 if you have the `lstat' function. */
#define HAVE_LSTAT 1

/* Define to 1 if `lstat' has the bug that it succeeds when given the
   zero-length file name argument. */
/* #undef HAVE_LSTAT_EMPTY_STRING_BUG */

/* Define to 1 if you have the `lutimes' function. */
#define HAVE_LUTIMES 1

/* Define to 1 if you have the <lzmadec.h> header file. */
/* #undef HAVE_LZMADEC_H */

/* Define to 1 if you have the <lzma.h> header file. */
/* #undef HAVE_LZMA_H */

/* Define to 1 if you have the <lzo/lzo1x.h> header file. */
/* #undef HAVE_LZO_LZO1X_H */

/* Define to 1 if you have the <lzo/lzoconf.h> header file. */
/* #undef HAVE_LZO_LZOCONF_H */

/* Define to 1 if you have the `mbrtowc' function. */
#define HAVE_MBRTOWC 1

/* Define to 1 if you have the `memmove' function. */
#define HAVE_MEMMOVE 1

/* Define to 1 if you have the <memory.h> header file. */
#define HAVE_MEMORY_H 1

/* Define to 1 if you have the `mkdir' function. */
#define HAVE_MKDIR 1

/* Define to 1 if you have the `mkfifo' function. */
#define HAVE_MKFIFO 1

/* Define to 1 if you have the `mknod' function. */
#define HAVE_MKNOD 1

/* Define to 1 if you have the `mkstemp' function. */
#define HAVE_MKSTEMP 1

/* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */
/* #undef HAVE_NDIR_H */

/* Define to 1 if you have the <nettle/md5.h> header file. */
/* #undef HAVE_NETTLE_MD5_H */

/* Define to 1 if you have the <nettle/ripemd160.h> header file. */
/* #undef HAVE_NETTLE_RIPEMD160_H */

/* Define to 1 if you have the <nettle/sha.h> header file. */
/* #undef HAVE_NETTLE_SHA_H */

/* Define to 1 if you have the `nl_langinfo' function. */
#define HAVE_NL_LANGINFO 1

/* Define to 1 if you have the `openat' function. */
#define HAVE_OPENAT 1

/* Define to 1 if you have the <paths.h> header file. */
#define HAVE_PATHS_H 1

/* Define to 1 if you have the <pcreposix.h> header file. */
/* #undef HAVE_PCREPOSIX_H */

/* Define to 1 if you have the `pipe' function. */
#define HAVE_PIPE 1

/* Define to 1 if you have the `poll' function. */
#define HAVE_POLL 1

/* Define to 1 if you have the <poll.h> header file. */
#define HAVE_POLL_H 1

/* Define to 1 if you have the `posix_spawnp' function. */
#define HAVE_POSIX_SPAWNP 1

/* Define to 1 if you have the <process.h> header file. */
/* #undef HAVE_PROCESS_H */

/* Define to 1 if you have the <pwd.h> header file. */
#define HAVE_PWD_H 1

/* Define to 1 if you have the `readdir_r' function. */
#define HAVE_READDIR_R 1

/* Define to 1 if you have the `readlink' function. */
#define HAVE_READLINK 1

/* Define to 1 if you have the `readlinkat' function. */
#define HAVE_READLINKAT 1

/* Define to 1 if you have the <regex.h> header file. */
#define HAVE_REGEX_H 1

/* Define to 1 if you have the `select' function. */
#define HAVE_SELECT 1

/* Define to 1 if you have the `setenv' function. */
#define HAVE_SETENV 1

/* Define to 1 if you have the `setlocale' function. */
#define HAVE_SETLOCALE 1

/* Define to 1 if you have the `sigaction' function. */
#define HAVE_SIGACTION 1

/* Define to 1 if you have the <signal.h> header file. */
#define HAVE_SIGNAL_H 1

/* Define to 1 if you have the <spawn.h> header file. */
#define HAVE_SPAWN_H 1

/* Define to 1 if you have the `statfs' function. */
#define HAVE_STATFS 1

/* Define to 1 if you have the `statvfs' function. */
#define HAVE_STATVFS 1

/* Define to 1 if `stat' has the bug that it succeeds when given the
   zero-length file name argument. */
/* #undef HAVE_STAT_EMPTY_STRING_BUG */

/* Define to 1 if you have the <stdarg.h> header file. */
#define HAVE_STDARG_H 1

/* Define to 1 if you have the <stdint.h> header file. */
#define HAVE_STDINT_H 1

/* Define to 1 if you have the <stdlib.h> header file. */
#define HAVE_STDLIB_H 1

/* Define to 1 if you have the `strchr' function. */
#define HAVE_STRCHR 1

/* Define to 1 if you have the `strdup' function. */
#define HAVE_STRDUP 1

/* Define to 1 if you have the `strerror' function. */
#define HAVE_STRERROR 1

/* Define to 1 if you have the `strerror_r' function. */
#define HAVE_STRERROR_R 1

/* Define to 1 if you have the `strftime' function. */
#define HAVE_STRFTIME 1

/* Define to 1 if you have the <strings.h> header file. */
#define HAVE_STRINGS_H 1

/* Define to 1 if you have the <string.h> header file. */
#define HAVE_STRING_H 1

/* Define to 1 if you have the `strrchr' function. */
#define HAVE_STRRCHR 1

/* Define to 1 if `f_namemax' is a member of `struct statfs'. */
/* #undef HAVE_STRUCT_STATFS_F_NAMEMAX */

/* Define to 1 if `f_iosize' is a member of `struct statvfs'. */
/* #undef HAVE_STRUCT_STATVFS_F_IOSIZE */

/* Define to 1 if `st_birthtime' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIME */

/* Define to 1 if `st_birthtimespec.tv_nsec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC_TV_NSEC */

/* Define to 1 if `st_blksize' is a member of `struct stat'. */
#define HAVE_STRUCT_STAT_ST_BLKSIZE 1

/* Define to 1 if `st_flags' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_FLAGS */

/* Define to 1 if `st_mtimespec.tv_nsec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC */

/* Define to 1 if `st_mtime_n' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIME_N */

/* Define to 1 if `st_mtime_usec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIME_USEC */

/* Define to 1 if `st_mtim.tv_nsec' is a member of `struct stat'. */
#define HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC 1

/* Define to 1 if `st_umtime' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_UMTIME */

/* Define to 1 if `tm_gmtoff' is a member of `struct tm'. */
#define HAVE_STRUCT_TM_TM_GMTOFF 1

/* Define to 1 if `__tm_gmtoff' is a member of `struct tm'. */
/* #undef HAVE_STRUCT_TM___TM_GMTOFF */

/* Define to 1 if you have the `symlink' function. */
#define HAVE_SYMLINK 1

/* Define to 1 if you have the <sys/acl.h> header file. */
/* #undef HAVE_SYS_ACL_H */

/* Define to 1 if you have the <sys/cdefs.h> header file. */
#define HAVE_SYS_CDEFS_H 1

/* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.
   */
/* #undef HAVE_SYS_DIR_H */

/* Define to 1 if you have the <sys/ea.h> header file. */
/* #undef HAVE_SYS_EA_H */

/* Define to 1 if you have the <sys/extattr.h> header file. */
/* #undef HAVE_SYS_EXTATTR_H */

/* Define to 1 if you have the <sys/ioctl.h> header file. */
#define HAVE_SYS_IOCTL_H 1

/* Define to 1 if you have the <sys/mkdev.h> header file. */
/* #undef HAVE_SYS_MKDEV_H */

/* Define to 1 if you have the <sys/mount.h> header file. */
/* #undef HAVE_SYS_MOUNT_H */

/* Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.
   */
/* #undef HAVE_SYS_NDIR_H */

/* Define to 1 if you have the <sys/param.h> header file. */
#define HAVE_SYS_PARAM_H 1

/* Define to 1 if you have the <sys/poll.h> header file. */
#define HAVE_SYS_POLL_H 1

/* Define to 1 if you have the <sys/select.h> header file. */
#define HAVE_SYS_SELECT_H 1

/* Define to 1 if you have the <sys/statfs.h> header file. */
#define HAVE_SYS_STATFS_H 1

/* Define to 1 if you have the <sys/statvfs.h> header file. */
#define HAVE_SYS_STATVFS_H 1

/* Define to 1 if you have the <sys/stat.h> header file. */
#define HAVE_SYS_STAT_H 1

/* Define to 1 if you have the <sys/time.h> header file. */
#define HAVE_SYS_TIME_H 1

/* Define to 1 if you have the <sys/types.h> header file. */
#define HAVE_SYS_TYPES_H 1

/* Define to 1 if you have the <sys/utime.h> header file. */
/* #undef HAVE_SYS_UTIME_H */

/* Define to 1 if you have the <sys/utsname.h> header file. */
#define HAVE_SYS_UTSNAME_H 1

/* Define to 1 if you have the <sys/vfs.h> header file. */
#define HAVE_SYS_VFS_H 1

/* Define to 1 if you have <sys/wait.h> that is POSIX.1 compatible. */
#define HAVE_SYS_WAIT_H 1

/* Define to 1 if you have the <sys/xattr.h> header file. */
/* #undef HAVE_SYS_XATTR_H */

/* Define to 1 if you have the `timegm' function. */
#define HAVE_TIMEGM 1

/* Define to 1 if you have the <time.h> header file. */
#define HAVE_TIME_H 1

/* Define to 1 if you have the `tzset' function. */
#define HAVE_TZSET 1

/* Define to 1 if you have the <unistd.h> header file. */
#define HAVE_UNISTD_H 1

/* Define to 1 if you have the `unsetenv' function. */
#define HAVE_UNSETENV 1

/* Define to 1 if the system has the type `unsigned long long'. */
/* #undef HAVE_UNSIGNED_LONG_LONG */

/* Define to 1 if the system has the type `unsigned long long int'. */
/* #undef HAVE_UNSIGNED_LONG_LONG_INT */

/* Define to 1 if you have the `utime' function. */
#define HAVE_UTIME 1

/* Define to 1 if you have the `utimensat' function. */
#define HAVE_UTIMENSAT 1

/* Define to 1 if you have the `utimes' function. */
#define HAVE_UTIMES 1

/* Define to 1 if you have the <utime.h> header file. */
#define HAVE_UTIME_H 1

/* Define to 1 if you have the `vfork' function. */
#define HAVE_VFORK 1

/* Define to 1 if you have the `vprintf' function. */
#define HAVE_VPRINTF 1

/* Define to 1 if you have the <wchar.h> header file. */
#define HAVE_WCHAR_H 1

/* Define to 1 if the system has the type `wchar_t'. */
#define HAVE_WCHAR_T 1

/* Define to 1 if you have the `wcrtomb' function. */
#define HAVE_WCRTOMB 1

/* Define to 1 if you have the `wcscmp' function. */
#define HAVE_WCSCMP 1

/* Define to 1 if you have the `wcscpy' function. */
#define HAVE_WCSCPY 1

/* Define to 1 if you have the `wcslen' function. */
#define HAVE_WCSLEN 1

/* Define to 1 if you have the `wctomb' function. */
#define HAVE_WCTOMB 1

/* Define to 1 if you have the <wctype.h> header file. */
#define HAVE_WCTYPE_H 1

/* Define to 1 if you have the <wincrypt.h> header file. */
/* #undef HAVE_WINCRYPT_H */

/* Define to 1 if you have the <windows.h> header file. */
/* #undef HAVE_WINDOWS_H */

/* Define to 1 if you have the <winioctl.h> header file. */
/* #undef HAVE_WINIOCTL_H */

/* Define to 1 if you have _CrtSetReportMode in <crtdbg.h>  */
/* #undef HAVE__CrtSetReportMode */

/* Define to 1 if you have the `wmemcmp' function. */
#define HAVE_WMEMCMP 1

/* Define to 1 if you have the `wmemcpy' function. */
#define HAVE_WMEMCPY 1

/* Define to 1 if you have a working EXT2_IOC_GETFLAGS */
/* #undef HAVE_WORKING_EXT2_IOC_GETFLAGS */

/* Define to 1 if you have the <zlib.h> header file. */
#define HAVE_ZLIB_H 1

/* Define to 1 if you have the `_ctime64_s' function. */
/* #undef HAVE__CTIME64_S */

/* Define to 1 if you have the `_fseeki64' function. */
/* #undef HAVE__FSEEKI64 */

/* Define to 1 if you have the `_get_timezone' function. */
/* #undef HAVE__GET_TIMEZONE */

/* Define to 1 if you have the `_localtime64_s' function. */
/* #undef HAVE__LOCALTIME64_S */

/* Define to 1 if you have the `_mkgmtime64' function. */
/* #undef HAVE__MKGMTIME64 */

/* Define as const if the declaration of iconv() needs const. */
#define ICONV_CONST 

/* Version number of libarchive as a single integer */
#define LIBARCHIVE_VERSION_NUMBER "3001002"

/* Version number of libarchive */
#define LIBARCHIVE_VERSION_STRING "3.1.2"

/* Define to 1 if `lstat' dereferences a symlink specified with a trailing
   slash. */
/* #undef LSTAT_FOLLOWS_SLASHED_SYMLINK */

/* Define to 1 if `major', `minor', and `makedev' are declared in <mkdev.h>.
   */
/* #undef MAJOR_IN_MKDEV */

/* Define to 1 if `major', `minor', and `makedev' are declared in
   <sysmacros.h>. */
#define MAJOR_IN_SYSMACROS 1

/* Define to 1 if your C compiler doesn't accept -c and -o together. */
/* #undef NO_MINUS_C_MINUS_O */

/* The size of `wchar_t', as computed by sizeof. */
#define SIZEOF_WCHAR_T 4

/* Define to 1 if strerror_r returns char *. */
/* #undef STRERROR_R_CHAR_P */

/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
#define TIME_WITH_SYS_TIME 1

/*
 * Some platform requires a macro to use extension functions.
 */
#define SAFE_TO_DEFINE_EXTENSIONS 1
#ifdef SAFE_TO_DEFINE_EXTENSIONS
/* Enable extensions on AIX 3, Interix.  */
#ifndef _ALL_SOURCE
# define _ALL_SOURCE 1
#endif
/* Enable GNU extensions on systems that have them.  */
#ifndef _GNU_SOURCE
# define _GNU_SOURCE 1
#endif
/* Enable threading extensions on Solaris.  */
#ifndef _POSIX_PTHREAD_SEMANTICS
# define _POSIX_PTHREAD_SEMANTICS 1
#endif
/* Enable extensions on HP NonStop.  */
#ifndef _TANDEM_SOURCE
# define _TANDEM_SOURCE 1
#endif
/* Enable general extensions on Solaris.  */
#ifndef __EXTENSIONS__
# define __EXTENSIONS__ 1
#endif
#endif /* SAFE_TO_DEFINE_EXTENSIONS */

/* Version number of package */
#define VERSION "3.1.2"

/* Number of bits in a file offset, on hosts where this is settable. */
/* #undef _FILE_OFFSET_BITS */

/* Define to 1 to make fseeko visible on some hosts (e.g. glibc 2.2). */
/* #undef _LARGEFILE_SOURCE */

/* Define for large files, on AIX-style hosts. */
/* #undef _LARGE_FILES */

/* Define for Windows to use Windows 2000+ APIs. */
/* #undef _WIN32_WINNT */
/* #undef WINVER */

/* Define to empty if `const' does not conform to ANSI C. */
/* #undef const */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef gid_t */

/* Define to `unsigned long' if <sys/types.h> does not define. */
/* #undef id_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef mode_t */

/* Define to `long long' if <sys/types.h> does not define. */
/* #undef off_t */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef pid_t */

/* Define to `unsigned int' if <sys/types.h> does not define. */
/* #undef size_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef ssize_t */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef uid_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef intptr_t */

/* Define to `unsigned int' if <sys/types.h> does not define. */
/* #undef uintptr_t */


#define ARCHIVE_SHA384_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA384_LIBC
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = (DWORD)bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. Nettle
 * 6. OpenSSL
 * 7. libmd
 * 8. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive_sha384_ctx ctx;
  archive_sha384_init(&ctx);
  archive_sha384_update(&ctx, *argv, argc);
  archive_sha384_final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA512_LIBC failed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3172870823/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3172870823.dir/build.make CMakeFiles/cmTryCompileExec3172870823.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3172870823.dir/check_crypto_md.c.o
/usr/bin/gcc   -w  -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2 -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmlibarchive/libarchive -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec3172870823.dir/check_crypto_md.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1186:0:
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: fatal error: sha2.h: No such file or directory
 #include <sha2.h>
                  ^
compilation terminated.
make[5]: *** [CMakeFiles/cmTryCompileExec3172870823.dir/check_crypto_md.c.o] Error 1
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec3172870823/fast] Error 2

Source file was:
/* config.h.  Generated from build/cmake/config.h.in by cmake configure */
#if defined(__osf__)
# define _OSF_SOURCE
#endif

/*
 * Ensure we have C99-style int64_t, etc, all defined.
 */

/* First, we need to know if the system has already defined them. */
#define HAVE_INT16_T
#define HAVE_INT32_T
#define HAVE_INT64_T
#define HAVE_INTMAX_T

#define HAVE_UINT8_T
#define HAVE_UINT16_T
#define HAVE_UINT32_T
#define HAVE_UINT64_T
#define HAVE_UINTMAX_T

/* We might have the types we want under other spellings. */
/* #undef HAVE___INT64 */
/* #undef HAVE_U_INT64_T */
/* #undef HAVE_UNSIGNED___INT64 */

/* The sizes of various standard integer types. */
#define SIZE_OF_SHORT 2
#define SIZE_OF_INT 4
#define SIZE_OF_LONG 8
#define SIZE_OF_LONG_LONG 8
#define SIZE_OF_UNSIGNED_SHORT 2
#define SIZE_OF_UNSIGNED 4
#define SIZE_OF_UNSIGNED_LONG 8
#define SIZE_OF_UNSIGNED_LONG_LONG 8

/*
 * If we lack int64_t, define it to the first of __int64, int, long, and long long
 * that exists and is the right size.
 */
#if !defined(HAVE_INT64_T) && defined(HAVE___INT64)
typedef __int64 int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_INT == 8
typedef int int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_LONG == 8
typedef long int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_LONG_LONG == 8
typedef long long int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T)
#error No 64-bit integer type was found.
#endif

/*
 * Similarly for int32_t
 */
#if !defined(HAVE_INT32_T) && SIZE_OF_INT == 4
typedef long int32_t;
#define HAVE_INT32_T
#endif

#if !defined(HAVE_INT32_T) && SIZE_OF_LONG == 4
typedef long int32_t;
#define HAVE_INT32_T
#endif

#if !defined(HAVE_INT32_T)
#error No 32-bit integer type was found.
#endif

/*
 * Similarly for int16_t
 */
#if !defined(HAVE_INT16_T) && SIZE_OF_INT == 2
typedef int int16_t;
#define HAVE_INT16_T
#endif

#if !defined(HAVE_INT16_T) && SIZE_OF_SHORT == 2
typedef short int16_t;
#define HAVE_INT16_T
#endif

#if !defined(HAVE_INT16_T)
#error No 16-bit integer type was found.
#endif

/*
 * Similarly for uint64_t
 */
#if !defined(HAVE_UINT64_T) && defined(HAVE_UNSIGNED___INT64)
typedef unsigned __int64 uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED == 8
typedef unsigned uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED_LONG == 8
typedef unsigned long uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED_LONG_LONG == 8
typedef unsigned long long uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T)
#error No 64-bit unsigned integer type was found.
#endif


/*
 * Similarly for uint32_t
 */
#if !defined(HAVE_UINT32_T) && SIZE_OF_UNSIGNED == 4
typedef unsigned uint32_t;
#define HAVE_UINT32_T
#endif

#if !defined(HAVE_UINT32_T) && SIZE_OF_UNSIGNED_LONG == 4
typedef unsigned long uint32_t;
#define HAVE_UINT32_T
#endif

#if !defined(HAVE_UINT32_T)
#error No 32-bit unsigned integer type was found.
#endif

/*
 * Similarly for uint16_t
 */
#if !defined(HAVE_UINT16_T) && SIZE_OF_UNSIGNED == 2
typedef unsigned uint16_t;
#define HAVE_UINT16_T
#endif

#if !defined(HAVE_UINT16_T) && SIZE_OF_UNSIGNED_SHORT == 2
typedef unsigned short uint16_t;
#define HAVE_UINT16_T
#endif

#if !defined(HAVE_UINT16_T)
#error No 16-bit unsigned integer type was found.
#endif

/*
 * Similarly for uint8_t
 */
#if !defined(HAVE_UINT8_T)
typedef unsigned char uint8_t;
#define HAVE_UINT8_T
#endif

#if !defined(HAVE_UINT16_T)
#error No 8-bit unsigned integer type was found.
#endif

/* Define intmax_t and uintmax_t if they are not already defined. */
#if !defined(HAVE_INTMAX_T)
typedef int64_t intmax_t;
#define INTMAX_MIN INT64_MIN
#define INTMAX_MAX INT64_MAX
#endif

#if !defined(HAVE_UINTMAX_T)
typedef uint64_t uintmax_t;
#endif

/* Define ZLIB_WINAPI if zlib was built on Visual Studio. */
/* #undef ZLIB_WINAPI */

/* MD5 via ARCHIVE_CRYPTO_MD5_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_MD5_LIBC */

/* MD5 via ARCHIVE_CRYPTO_MD5_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_MD5_LIBSYSTEM */

/* MD5 via ARCHIVE_CRYPTO_MD5_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_MD5_NETTLE */

/* MD5 via ARCHIVE_CRYPTO_MD5_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_MD5_OPENSSL */

/* MD5 via ARCHIVE_CRYPTO_MD5_WIN supported. */
/* #undef ARCHIVE_CRYPTO_MD5_WIN */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_LIBC */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_NETTLE */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_OPENSSL */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_LIBC */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_LIBSYSTEM */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_NETTLE */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_OPENSSL */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_WIN */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC2 */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC3 */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBSYSTEM */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_NETTLE */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_OPENSSL */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_WIN */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC2 */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC3 */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBSYSTEM */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_NETTLE */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_OPENSSL */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_WIN */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC2 */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC3 */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBSYSTEM */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_NETTLE */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_OPENSSL */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_WIN */

/* Version number of bsdcpio */
#define BSDCPIO_VERSION_STRING "3.1.2"

/* Version number of bsdtar */
#define BSDTAR_VERSION_STRING "3.1.2"

/* Define to 1 if you have the `acl_create_entry' function. */
/* #undef HAVE_ACL_CREATE_ENTRY */

/* Define to 1 if you have the `acl_get_link' function. */
/* #undef HAVE_ACL_GET_LINK */

/* Define to 1 if you have the `acl_get_link_np' function. */
/* #undef HAVE_ACL_GET_LINK_NP */

/* Define to 1 if you have the `acl_get_perm' function. */
/* #undef HAVE_ACL_GET_PERM */

/* Define to 1 if you have the `acl_get_perm_np' function. */
/* #undef HAVE_ACL_GET_PERM_NP */

/* Define to 1 if you have the `acl_init' function. */
/* #undef HAVE_ACL_INIT */

/* Define to 1 if you have the <acl/libacl.h> header file. */
/* #undef HAVE_ACL_LIBACL_H */

/* Define to 1 if the system has the type `acl_permset_t'. */
/* #undef HAVE_ACL_PERMSET_T */

/* Define to 1 if you have the `acl_set_fd' function. */
/* #undef HAVE_ACL_SET_FD */

/* Define to 1 if you have the `acl_set_fd_np' function. */
/* #undef HAVE_ACL_SET_FD_NP */

/* Define to 1 if you have the `acl_set_file' function. */
/* #undef HAVE_ACL_SET_FILE */

/* True for systems with POSIX ACL support */
/* #undef HAVE_ACL_USER */

/* Define to 1 if you have the <attr/xattr.h> header file. */
/* #undef HAVE_ATTR_XATTR_H */

/* Define to 1 if you have the <bsdxml.h> header file. */
/* #undef HAVE_BSDXML_H */

/* Define to 1 if you have the <bzlib.h> header file. */
#define HAVE_BZLIB_H 1

/* Define to 1 if you have the `chflags' function. */
/* #undef HAVE_CHFLAGS */

/* Define to 1 if you have the `chown' function. */
#define HAVE_CHOWN 1

/* Define to 1 if you have the `chroot' function. */
#define HAVE_CHROOT 1

/* Define to 1 if you have the <copyfile.h> header file. */
/* #undef HAVE_COPYFILE_H */

/* Define to 1 if you have the `ctime_r' function. */
#define HAVE_CTIME_R 1

/* Define to 1 if you have the <ctype.h> header file. */
#define HAVE_CTYPE_H 1

/* Define to 1 if you have the `cygwin_conv_path' function. */
/* #undef HAVE_CYGWIN_CONV_PATH */

/* Define to 1 if you have the declaration of `INT64_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_INT64_MAX 1

/* Define to 1 if you have the declaration of `INT64_MIN', and to 0 if you
   don't. */
#define HAVE_DECL_INT64_MIN 1

/* Define to 1 if you have the declaration of `SIZE_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_SIZE_MAX 1

/* Define to 1 if you have the declaration of `SSIZE_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_SSIZE_MAX 1

/* Define to 1 if you have the declaration of `strerror_r', and to 0 if you
   don't. */
#define HAVE_DECL_STRERROR_R 1

/* Define to 1 if you have the declaration of `UINT32_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_UINT32_MAX 1

/* Define to 1 if you have the declaration of `UINT64_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_UINT64_MAX 1

/* Define to 1 if you have the <direct.h> header file. */
/* #undef HAVE_DIRECT_H */

/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.
   */
#define HAVE_DIRENT_H 1

/* Define to 1 if you have the `dirfd' function. */
#define HAVE_DIRFD 1

/* Define to 1 if you have the <dlfcn.h> header file. */
#define HAVE_DLFCN_H 1

/* Define to 1 if you don't have `vprintf' but do have `_doprnt.' */
/* #undef HAVE_DOPRNT */

/* Define to 1 if nl_langinfo supports D_MD_ORDER */
/* #undef HAVE_D_MD_ORDER */

/* A possible errno value for invalid file format errors */
/* #undef HAVE_EFTYPE */

/* A possible errno value for invalid file format errors */
#define HAVE_EILSEQ 1

/* Define to 1 if you have the <errno.h> header file. */
#define HAVE_ERRNO_H 1

/* Define to 1 if you have the <expat.h> header file. */
/* #undef HAVE_EXPAT_H */

/* Define to 1 if you have the <ext2fs/ext2_fs.h> header file. */
/* #undef HAVE_EXT2FS_EXT2_FS_H */

/* Define to 1 if you have the `extattr_get_file' function. */
/* #undef HAVE_EXTATTR_GET_FILE */

/* Define to 1 if you have the `extattr_list_file' function. */
/* #undef HAVE_EXTATTR_LIST_FILE */

/* Define to 1 if you have the `extattr_set_fd' function. */
/* #undef HAVE_EXTATTR_SET_FD */

/* Define to 1 if you have the `extattr_set_file' function. */
/* #undef HAVE_EXTATTR_SET_FILE */

/* Define to 1 if EXTATTR_NAMESPACE_USER is defined in sys/extattr.h. */
/* #undef HAVE_DECL_EXTATTR_NAMESPACE_USER */

/* Define to 1 if you have the `fchdir' function. */
#define HAVE_FCHDIR 1

/* Define to 1 if you have the `fchflags' function. */
/* #undef HAVE_FCHFLAGS */

/* Define to 1 if you have the `fchmod' function. */
#define HAVE_FCHMOD 1

/* Define to 1 if you have the `fchown' function. */
#define HAVE_FCHOWN 1

/* Define to 1 if you have the `fcntl' function. */
#define HAVE_FCNTL 1

/* Define to 1 if you have the <fcntl.h> header file. */
#define HAVE_FCNTL_H 1

/* Define to 1 if you have the `fdopendir' function. */
#define HAVE_FDOPENDIR 1

/* Define to 1 if you have the `fgetea' function. */
/* #undef HAVE_FGETEA */

/* Define to 1 if you have the `fgetxattr' function. */
/* #undef HAVE_FGETXATTR */

/* Define to 1 if you have the `flistea' function. */
/* #undef HAVE_FLISTEA */

/* Define to 1 if you have the `flistxattr' function. */
/* #undef HAVE_FLISTXATTR */

/* Define to 1 if you have the `fork' function. */
#define HAVE_FORK 1

/* Define to 1 if fseeko (and presumably ftello) exists and is declared. */
#define HAVE_FSEEKO 1

/* Define to 1 if you have the `fsetea' function. */
/* #undef HAVE_FSETEA */

/* Define to 1 if you have the `fsetxattr' function. */
/* #undef HAVE_FSETXATTR */

/* Define to 1 if you have the `fstat' function. */
#define HAVE_FSTAT 1

/* Define to 1 if you have the `fstatat' function. */
#define HAVE_FSTATAT 1

/* Define to 1 if you have the `fstatfs' function. */
#define HAVE_FSTATFS 1

/* Define to 1 if you have the `fstatvfs' function. */
#define HAVE_FSTATVFS 1

/* Define to 1 if you have the `ftruncate' function. */
#define HAVE_FTRUNCATE 1

/* Define to 1 if you have the `futimens' function. */
#define HAVE_FUTIMENS 1

/* Define to 1 if you have the `futimes' function. */
#define HAVE_FUTIMES 1

/* Define to 1 if you have the `futimesat' function. */
#define HAVE_FUTIMESAT 1

/* Define to 1 if you have the `getea' function. */
/* #undef HAVE_GETEA */

/* Define to 1 if you have the `geteuid' function. */
#define HAVE_GETEUID 1

/* Define to 1 if you have the `getgrgid_r' function. */
#define HAVE_GETGRGID_R 1

/* Define to 1 if you have the `getgrnam_r' function. */
#define HAVE_GETGRNAM_R 1

/* Define to 1 if you have the `getpid' function. */
#define HAVE_GETPID 1

/* Define to 1 if you have the `getpwnam_r' function. */
#define HAVE_GETPWNAM_R 1

/* Define to 1 if you have the `getpwuid_r' function. */
#define HAVE_GETPWUID_R 1

/* Define to 1 if you have the `getvfsbyname' function. */
/* #undef HAVE_GETVFSBYNAME */

/* Define to 1 if you have the `getxattr' function. */
/* #undef HAVE_GETXATTR */

/* Define to 1 if you have the `gmtime_r' function. */
#define HAVE_GMTIME_R 1

/* Define to 1 if you have the <grp.h> header file. */
#define HAVE_GRP_H 1

/* Define to 1 if you have the `iconv' function. */
/* #undef HAVE_ICONV */

/* Define to 1 if you have the <iconv.h> header file. */
/* #undef HAVE_ICONV_H */

/* Define to 1 if you have the <inttypes.h> header file. */
#define HAVE_INTTYPES_H 1

/* Define to 1 if you have the <io.h> header file. */
/* #undef HAVE_IO_H */

/* Define to 1 if you have the <langinfo.h> header file. */
#define HAVE_LANGINFO_H 1

/* Define to 1 if you have the `lchflags' function. */
/* #undef HAVE_LCHFLAGS */

/* Define to 1 if you have the `lchmod' function. */
/* #undef HAVE_LCHMOD */

/* Define to 1 if you have the `lchown' function. */
#define HAVE_LCHOWN 1

/* Define to 1 if you have the `lgetea' function. */
/* #undef HAVE_LGETEA */

/* Define to 1 if you have the `lgetxattr' function. */
/* #undef HAVE_LGETXATTR */

/* Define to 1 if you have the `acl' library (-lacl). */
/* #undef HAVE_LIBACL */

/* Define to 1 if you have the `attr' library (-lattr). */
/* #undef HAVE_LIBATTR */

/* Define to 1 if you have the `bsdxml' library (-lbsdxml). */
/* #undef HAVE_LIBBSDXML */

/* Define to 1 if you have the `bz2' library (-lbz2). */
#define HAVE_LIBBZ2 1

/* Define to 1 if you have the `expat' library (-lexpat). */
/* #undef HAVE_LIBEXPAT */

/* Define to 1 if you have the `gcc' library (-lgcc). */
/* #undef HAVE_LIBGCC */

/* Define to 1 if you have the `lzma' library (-llzma). */
/* #undef HAVE_LIBLZMA */

/* Define to 1 if you have the `lzmadec' library (-llzmadec). */
/* #undef HAVE_LIBLZMADEC */

/* Define to 1 if you have the `lzo2' library (-llzo2). */
/* #undef HAVE_LIBLZO2 */

/* Define to 1 if you have the `nettle' library (-lnettle). */
/* #undef HAVE_LIBNETTLE */

/* Define to 1 if you have the `pcre' library (-lpcre). */
/* #undef HAVE_LIBPCRE */

/* Define to 1 if you have the `pcreposix' library (-lpcreposix). */
/* #undef HAVE_LIBPCREPOSIX */

/* Define to 1 if you have the `xml2' library (-lxml2). */
/* #undef HAVE_LIBXML2 */

/* Define to 1 if you have the <libxml/xmlreader.h> header file. */
/* #undef HAVE_LIBXML_XMLREADER_H */

/* Define to 1 if you have the <libxml/xmlwriter.h> header file. */
/* #undef HAVE_LIBXML_XMLWRITER_H */

/* Define to 1 if you have the `z' library (-lz). */
#define HAVE_LIBZ 1

/* Define to 1 if you have the <limits.h> header file. */
#define HAVE_LIMITS_H 1

/* Define to 1 if you have the `link' function. */
#define HAVE_LINK 1

/* Define to 1 if you have the <linux/types.h> header file. */
#define HAVE_LINUX_TYPES_H 1

/* Define to 1 if you have the <linux/fiemap.h> header file. */
#define HAVE_LINUX_FIEMAP_H 1

/* Define to 1 if you have the <linux/fs.h> header file. */
#define HAVE_LINUX_FS_H 1

/* Define to 1 if you have the <linux/magic.h> header file. */
#define HAVE_LINUX_MAGIC_H 1

/* Define to 1 if you have the <linux/types.h> header file. */
#define HAVE_LINUX_TYPES_H 1

/* Define to 1 if you have the `listea' function. */
/* #undef HAVE_LISTEA */

/* Define to 1 if you have the `listxattr' function. */
/* #undef HAVE_LISTXATTR */

/* Define to 1 if you have the `llistea' function. */
/* #undef HAVE_LLISTEA */

/* Define to 1 if you have the `llistxattr' function. */
/* #undef HAVE_LLISTXATTR */

/* Define to 1 if you have the <localcharset.h> header file. */
/* #undef HAVE_LOCALCHARSET_H */

/* Define to 1 if you have the `locale_charset' function. */
/* #undef HAVE_LOCALE_CHARSET */

/* Define to 1 if you have the <locale.h> header file. */
#define HAVE_LOCALE_H 1

/* Define to 1 if you have the `localtime_r' function. */
#define HAVE_LOCALTIME_R 1

/* Define to 1 if the system has the type `long long int'. */
/* #undef HAVE_LONG_LONG_INT */

/* Define to 1 if you have the `lsetea' function. */
/* #undef HAVE_LSETEA */

/* Define to 1 if you have the `lsetxattr' function. */
/* #undef HAVE_LSETXATTR */

/* Define to 1 if you have the `lstat' function. */
#define HAVE_LSTAT 1

/* Define to 1 if `lstat' has the bug that it succeeds when given the
   zero-length file name argument. */
/* #undef HAVE_LSTAT_EMPTY_STRING_BUG */

/* Define to 1 if you have the `lutimes' function. */
#define HAVE_LUTIMES 1

/* Define to 1 if you have the <lzmadec.h> header file. */
/* #undef HAVE_LZMADEC_H */

/* Define to 1 if you have the <lzma.h> header file. */
/* #undef HAVE_LZMA_H */

/* Define to 1 if you have the <lzo/lzo1x.h> header file. */
/* #undef HAVE_LZO_LZO1X_H */

/* Define to 1 if you have the <lzo/lzoconf.h> header file. */
/* #undef HAVE_LZO_LZOCONF_H */

/* Define to 1 if you have the `mbrtowc' function. */
#define HAVE_MBRTOWC 1

/* Define to 1 if you have the `memmove' function. */
#define HAVE_MEMMOVE 1

/* Define to 1 if you have the <memory.h> header file. */
#define HAVE_MEMORY_H 1

/* Define to 1 if you have the `mkdir' function. */
#define HAVE_MKDIR 1

/* Define to 1 if you have the `mkfifo' function. */
#define HAVE_MKFIFO 1

/* Define to 1 if you have the `mknod' function. */
#define HAVE_MKNOD 1

/* Define to 1 if you have the `mkstemp' function. */
#define HAVE_MKSTEMP 1

/* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */
/* #undef HAVE_NDIR_H */

/* Define to 1 if you have the <nettle/md5.h> header file. */
/* #undef HAVE_NETTLE_MD5_H */

/* Define to 1 if you have the <nettle/ripemd160.h> header file. */
/* #undef HAVE_NETTLE_RIPEMD160_H */

/* Define to 1 if you have the <nettle/sha.h> header file. */
/* #undef HAVE_NETTLE_SHA_H */

/* Define to 1 if you have the `nl_langinfo' function. */
#define HAVE_NL_LANGINFO 1

/* Define to 1 if you have the `openat' function. */
#define HAVE_OPENAT 1

/* Define to 1 if you have the <paths.h> header file. */
#define HAVE_PATHS_H 1

/* Define to 1 if you have the <pcreposix.h> header file. */
/* #undef HAVE_PCREPOSIX_H */

/* Define to 1 if you have the `pipe' function. */
#define HAVE_PIPE 1

/* Define to 1 if you have the `poll' function. */
#define HAVE_POLL 1

/* Define to 1 if you have the <poll.h> header file. */
#define HAVE_POLL_H 1

/* Define to 1 if you have the `posix_spawnp' function. */
#define HAVE_POSIX_SPAWNP 1

/* Define to 1 if you have the <process.h> header file. */
/* #undef HAVE_PROCESS_H */

/* Define to 1 if you have the <pwd.h> header file. */
#define HAVE_PWD_H 1

/* Define to 1 if you have the `readdir_r' function. */
#define HAVE_READDIR_R 1

/* Define to 1 if you have the `readlink' function. */
#define HAVE_READLINK 1

/* Define to 1 if you have the `readlinkat' function. */
#define HAVE_READLINKAT 1

/* Define to 1 if you have the <regex.h> header file. */
#define HAVE_REGEX_H 1

/* Define to 1 if you have the `select' function. */
#define HAVE_SELECT 1

/* Define to 1 if you have the `setenv' function. */
#define HAVE_SETENV 1

/* Define to 1 if you have the `setlocale' function. */
#define HAVE_SETLOCALE 1

/* Define to 1 if you have the `sigaction' function. */
#define HAVE_SIGACTION 1

/* Define to 1 if you have the <signal.h> header file. */
#define HAVE_SIGNAL_H 1

/* Define to 1 if you have the <spawn.h> header file. */
#define HAVE_SPAWN_H 1

/* Define to 1 if you have the `statfs' function. */
#define HAVE_STATFS 1

/* Define to 1 if you have the `statvfs' function. */
#define HAVE_STATVFS 1

/* Define to 1 if `stat' has the bug that it succeeds when given the
   zero-length file name argument. */
/* #undef HAVE_STAT_EMPTY_STRING_BUG */

/* Define to 1 if you have the <stdarg.h> header file. */
#define HAVE_STDARG_H 1

/* Define to 1 if you have the <stdint.h> header file. */
#define HAVE_STDINT_H 1

/* Define to 1 if you have the <stdlib.h> header file. */
#define HAVE_STDLIB_H 1

/* Define to 1 if you have the `strchr' function. */
#define HAVE_STRCHR 1

/* Define to 1 if you have the `strdup' function. */
#define HAVE_STRDUP 1

/* Define to 1 if you have the `strerror' function. */
#define HAVE_STRERROR 1

/* Define to 1 if you have the `strerror_r' function. */
#define HAVE_STRERROR_R 1

/* Define to 1 if you have the `strftime' function. */
#define HAVE_STRFTIME 1

/* Define to 1 if you have the <strings.h> header file. */
#define HAVE_STRINGS_H 1

/* Define to 1 if you have the <string.h> header file. */
#define HAVE_STRING_H 1

/* Define to 1 if you have the `strrchr' function. */
#define HAVE_STRRCHR 1

/* Define to 1 if `f_namemax' is a member of `struct statfs'. */
/* #undef HAVE_STRUCT_STATFS_F_NAMEMAX */

/* Define to 1 if `f_iosize' is a member of `struct statvfs'. */
/* #undef HAVE_STRUCT_STATVFS_F_IOSIZE */

/* Define to 1 if `st_birthtime' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIME */

/* Define to 1 if `st_birthtimespec.tv_nsec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC_TV_NSEC */

/* Define to 1 if `st_blksize' is a member of `struct stat'. */
#define HAVE_STRUCT_STAT_ST_BLKSIZE 1

/* Define to 1 if `st_flags' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_FLAGS */

/* Define to 1 if `st_mtimespec.tv_nsec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC */

/* Define to 1 if `st_mtime_n' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIME_N */

/* Define to 1 if `st_mtime_usec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIME_USEC */

/* Define to 1 if `st_mtim.tv_nsec' is a member of `struct stat'. */
#define HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC 1

/* Define to 1 if `st_umtime' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_UMTIME */

/* Define to 1 if `tm_gmtoff' is a member of `struct tm'. */
#define HAVE_STRUCT_TM_TM_GMTOFF 1

/* Define to 1 if `__tm_gmtoff' is a member of `struct tm'. */
/* #undef HAVE_STRUCT_TM___TM_GMTOFF */

/* Define to 1 if you have the `symlink' function. */
#define HAVE_SYMLINK 1

/* Define to 1 if you have the <sys/acl.h> header file. */
/* #undef HAVE_SYS_ACL_H */

/* Define to 1 if you have the <sys/cdefs.h> header file. */
#define HAVE_SYS_CDEFS_H 1

/* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.
   */
/* #undef HAVE_SYS_DIR_H */

/* Define to 1 if you have the <sys/ea.h> header file. */
/* #undef HAVE_SYS_EA_H */

/* Define to 1 if you have the <sys/extattr.h> header file. */
/* #undef HAVE_SYS_EXTATTR_H */

/* Define to 1 if you have the <sys/ioctl.h> header file. */
#define HAVE_SYS_IOCTL_H 1

/* Define to 1 if you have the <sys/mkdev.h> header file. */
/* #undef HAVE_SYS_MKDEV_H */

/* Define to 1 if you have the <sys/mount.h> header file. */
/* #undef HAVE_SYS_MOUNT_H */

/* Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.
   */
/* #undef HAVE_SYS_NDIR_H */

/* Define to 1 if you have the <sys/param.h> header file. */
#define HAVE_SYS_PARAM_H 1

/* Define to 1 if you have the <sys/poll.h> header file. */
#define HAVE_SYS_POLL_H 1

/* Define to 1 if you have the <sys/select.h> header file. */
#define HAVE_SYS_SELECT_H 1

/* Define to 1 if you have the <sys/statfs.h> header file. */
#define HAVE_SYS_STATFS_H 1

/* Define to 1 if you have the <sys/statvfs.h> header file. */
#define HAVE_SYS_STATVFS_H 1

/* Define to 1 if you have the <sys/stat.h> header file. */
#define HAVE_SYS_STAT_H 1

/* Define to 1 if you have the <sys/time.h> header file. */
#define HAVE_SYS_TIME_H 1

/* Define to 1 if you have the <sys/types.h> header file. */
#define HAVE_SYS_TYPES_H 1

/* Define to 1 if you have the <sys/utime.h> header file. */
/* #undef HAVE_SYS_UTIME_H */

/* Define to 1 if you have the <sys/utsname.h> header file. */
#define HAVE_SYS_UTSNAME_H 1

/* Define to 1 if you have the <sys/vfs.h> header file. */
#define HAVE_SYS_VFS_H 1

/* Define to 1 if you have <sys/wait.h> that is POSIX.1 compatible. */
#define HAVE_SYS_WAIT_H 1

/* Define to 1 if you have the <sys/xattr.h> header file. */
/* #undef HAVE_SYS_XATTR_H */

/* Define to 1 if you have the `timegm' function. */
#define HAVE_TIMEGM 1

/* Define to 1 if you have the <time.h> header file. */
#define HAVE_TIME_H 1

/* Define to 1 if you have the `tzset' function. */
#define HAVE_TZSET 1

/* Define to 1 if you have the <unistd.h> header file. */
#define HAVE_UNISTD_H 1

/* Define to 1 if you have the `unsetenv' function. */
#define HAVE_UNSETENV 1

/* Define to 1 if the system has the type `unsigned long long'. */
/* #undef HAVE_UNSIGNED_LONG_LONG */

/* Define to 1 if the system has the type `unsigned long long int'. */
/* #undef HAVE_UNSIGNED_LONG_LONG_INT */

/* Define to 1 if you have the `utime' function. */
#define HAVE_UTIME 1

/* Define to 1 if you have the `utimensat' function. */
#define HAVE_UTIMENSAT 1

/* Define to 1 if you have the `utimes' function. */
#define HAVE_UTIMES 1

/* Define to 1 if you have the <utime.h> header file. */
#define HAVE_UTIME_H 1

/* Define to 1 if you have the `vfork' function. */
#define HAVE_VFORK 1

/* Define to 1 if you have the `vprintf' function. */
#define HAVE_VPRINTF 1

/* Define to 1 if you have the <wchar.h> header file. */
#define HAVE_WCHAR_H 1

/* Define to 1 if the system has the type `wchar_t'. */
#define HAVE_WCHAR_T 1

/* Define to 1 if you have the `wcrtomb' function. */
#define HAVE_WCRTOMB 1

/* Define to 1 if you have the `wcscmp' function. */
#define HAVE_WCSCMP 1

/* Define to 1 if you have the `wcscpy' function. */
#define HAVE_WCSCPY 1

/* Define to 1 if you have the `wcslen' function. */
#define HAVE_WCSLEN 1

/* Define to 1 if you have the `wctomb' function. */
#define HAVE_WCTOMB 1

/* Define to 1 if you have the <wctype.h> header file. */
#define HAVE_WCTYPE_H 1

/* Define to 1 if you have the <wincrypt.h> header file. */
/* #undef HAVE_WINCRYPT_H */

/* Define to 1 if you have the <windows.h> header file. */
/* #undef HAVE_WINDOWS_H */

/* Define to 1 if you have the <winioctl.h> header file. */
/* #undef HAVE_WINIOCTL_H */

/* Define to 1 if you have _CrtSetReportMode in <crtdbg.h>  */
/* #undef HAVE__CrtSetReportMode */

/* Define to 1 if you have the `wmemcmp' function. */
#define HAVE_WMEMCMP 1

/* Define to 1 if you have the `wmemcpy' function. */
#define HAVE_WMEMCPY 1

/* Define to 1 if you have a working EXT2_IOC_GETFLAGS */
/* #undef HAVE_WORKING_EXT2_IOC_GETFLAGS */

/* Define to 1 if you have the <zlib.h> header file. */
#define HAVE_ZLIB_H 1

/* Define to 1 if you have the `_ctime64_s' function. */
/* #undef HAVE__CTIME64_S */

/* Define to 1 if you have the `_fseeki64' function. */
/* #undef HAVE__FSEEKI64 */

/* Define to 1 if you have the `_get_timezone' function. */
/* #undef HAVE__GET_TIMEZONE */

/* Define to 1 if you have the `_localtime64_s' function. */
/* #undef HAVE__LOCALTIME64_S */

/* Define to 1 if you have the `_mkgmtime64' function. */
/* #undef HAVE__MKGMTIME64 */

/* Define as const if the declaration of iconv() needs const. */
#define ICONV_CONST 

/* Version number of libarchive as a single integer */
#define LIBARCHIVE_VERSION_NUMBER "3001002"

/* Version number of libarchive */
#define LIBARCHIVE_VERSION_STRING "3.1.2"

/* Define to 1 if `lstat' dereferences a symlink specified with a trailing
   slash. */
/* #undef LSTAT_FOLLOWS_SLASHED_SYMLINK */

/* Define to 1 if `major', `minor', and `makedev' are declared in <mkdev.h>.
   */
/* #undef MAJOR_IN_MKDEV */

/* Define to 1 if `major', `minor', and `makedev' are declared in
   <sysmacros.h>. */
#define MAJOR_IN_SYSMACROS 1

/* Define to 1 if your C compiler doesn't accept -c and -o together. */
/* #undef NO_MINUS_C_MINUS_O */

/* The size of `wchar_t', as computed by sizeof. */
#define SIZEOF_WCHAR_T 4

/* Define to 1 if strerror_r returns char *. */
/* #undef STRERROR_R_CHAR_P */

/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
#define TIME_WITH_SYS_TIME 1

/*
 * Some platform requires a macro to use extension functions.
 */
#define SAFE_TO_DEFINE_EXTENSIONS 1
#ifdef SAFE_TO_DEFINE_EXTENSIONS
/* Enable extensions on AIX 3, Interix.  */
#ifndef _ALL_SOURCE
# define _ALL_SOURCE 1
#endif
/* Enable GNU extensions on systems that have them.  */
#ifndef _GNU_SOURCE
# define _GNU_SOURCE 1
#endif
/* Enable threading extensions on Solaris.  */
#ifndef _POSIX_PTHREAD_SEMANTICS
# define _POSIX_PTHREAD_SEMANTICS 1
#endif
/* Enable extensions on HP NonStop.  */
#ifndef _TANDEM_SOURCE
# define _TANDEM_SOURCE 1
#endif
/* Enable general extensions on Solaris.  */
#ifndef __EXTENSIONS__
# define __EXTENSIONS__ 1
#endif
#endif /* SAFE_TO_DEFINE_EXTENSIONS */

/* Version number of package */
#define VERSION "3.1.2"

/* Number of bits in a file offset, on hosts where this is settable. */
/* #undef _FILE_OFFSET_BITS */

/* Define to 1 to make fseeko visible on some hosts (e.g. glibc 2.2). */
/* #undef _LARGEFILE_SOURCE */

/* Define for large files, on AIX-style hosts. */
/* #undef _LARGE_FILES */

/* Define for Windows to use Windows 2000+ APIs. */
/* #undef _WIN32_WINNT */
/* #undef WINVER */

/* Define to empty if `const' does not conform to ANSI C. */
/* #undef const */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef gid_t */

/* Define to `unsigned long' if <sys/types.h> does not define. */
/* #undef id_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef mode_t */

/* Define to `long long' if <sys/types.h> does not define. */
/* #undef off_t */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef pid_t */

/* Define to `unsigned int' if <sys/types.h> does not define. */
/* #undef size_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef ssize_t */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef uid_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef intptr_t */

/* Define to `unsigned int' if <sys/types.h> does not define. */
/* #undef uintptr_t */


#define ARCHIVE_SHA512_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA512_LIBC
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = (DWORD)bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. Nettle
 * 6. OpenSSL
 * 7. libmd
 * 8. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive_sha512_ctx ctx;
  archive_sha512_init(&ctx);
  archive_sha512_update(&ctx, *argv, argc);
  archive_sha512_final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA256_LIBC2 failed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec329972296/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec329972296.dir/build.make CMakeFiles/cmTryCompileExec329972296.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec329972296.dir/check_crypto_md.c.o
/usr/bin/gcc   -w  -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2 -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmlibarchive/libarchive -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec329972296.dir/check_crypto_md.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1186:0:
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: fatal error: sha2.h: No such file or directory
 #include <sha2.h>
                  ^
compilation terminated.
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec329972296.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec329972296/fast] Error 2

Source file was:
/* config.h.  Generated from build/cmake/config.h.in by cmake configure */
#if defined(__osf__)
# define _OSF_SOURCE
#endif

/*
 * Ensure we have C99-style int64_t, etc, all defined.
 */

/* First, we need to know if the system has already defined them. */
#define HAVE_INT16_T
#define HAVE_INT32_T
#define HAVE_INT64_T
#define HAVE_INTMAX_T

#define HAVE_UINT8_T
#define HAVE_UINT16_T
#define HAVE_UINT32_T
#define HAVE_UINT64_T
#define HAVE_UINTMAX_T

/* We might have the types we want under other spellings. */
/* #undef HAVE___INT64 */
/* #undef HAVE_U_INT64_T */
/* #undef HAVE_UNSIGNED___INT64 */

/* The sizes of various standard integer types. */
#define SIZE_OF_SHORT 2
#define SIZE_OF_INT 4
#define SIZE_OF_LONG 8
#define SIZE_OF_LONG_LONG 8
#define SIZE_OF_UNSIGNED_SHORT 2
#define SIZE_OF_UNSIGNED 4
#define SIZE_OF_UNSIGNED_LONG 8
#define SIZE_OF_UNSIGNED_LONG_LONG 8

/*
 * If we lack int64_t, define it to the first of __int64, int, long, and long long
 * that exists and is the right size.
 */
#if !defined(HAVE_INT64_T) && defined(HAVE___INT64)
typedef __int64 int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_INT == 8
typedef int int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_LONG == 8
typedef long int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_LONG_LONG == 8
typedef long long int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T)
#error No 64-bit integer type was found.
#endif

/*
 * Similarly for int32_t
 */
#if !defined(HAVE_INT32_T) && SIZE_OF_INT == 4
typedef long int32_t;
#define HAVE_INT32_T
#endif

#if !defined(HAVE_INT32_T) && SIZE_OF_LONG == 4
typedef long int32_t;
#define HAVE_INT32_T
#endif

#if !defined(HAVE_INT32_T)
#error No 32-bit integer type was found.
#endif

/*
 * Similarly for int16_t
 */
#if !defined(HAVE_INT16_T) && SIZE_OF_INT == 2
typedef int int16_t;
#define HAVE_INT16_T
#endif

#if !defined(HAVE_INT16_T) && SIZE_OF_SHORT == 2
typedef short int16_t;
#define HAVE_INT16_T
#endif

#if !defined(HAVE_INT16_T)
#error No 16-bit integer type was found.
#endif

/*
 * Similarly for uint64_t
 */
#if !defined(HAVE_UINT64_T) && defined(HAVE_UNSIGNED___INT64)
typedef unsigned __int64 uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED == 8
typedef unsigned uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED_LONG == 8
typedef unsigned long uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED_LONG_LONG == 8
typedef unsigned long long uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T)
#error No 64-bit unsigned integer type was found.
#endif


/*
 * Similarly for uint32_t
 */
#if !defined(HAVE_UINT32_T) && SIZE_OF_UNSIGNED == 4
typedef unsigned uint32_t;
#define HAVE_UINT32_T
#endif

#if !defined(HAVE_UINT32_T) && SIZE_OF_UNSIGNED_LONG == 4
typedef unsigned long uint32_t;
#define HAVE_UINT32_T
#endif

#if !defined(HAVE_UINT32_T)
#error No 32-bit unsigned integer type was found.
#endif

/*
 * Similarly for uint16_t
 */
#if !defined(HAVE_UINT16_T) && SIZE_OF_UNSIGNED == 2
typedef unsigned uint16_t;
#define HAVE_UINT16_T
#endif

#if !defined(HAVE_UINT16_T) && SIZE_OF_UNSIGNED_SHORT == 2
typedef unsigned short uint16_t;
#define HAVE_UINT16_T
#endif

#if !defined(HAVE_UINT16_T)
#error No 16-bit unsigned integer type was found.
#endif

/*
 * Similarly for uint8_t
 */
#if !defined(HAVE_UINT8_T)
typedef unsigned char uint8_t;
#define HAVE_UINT8_T
#endif

#if !defined(HAVE_UINT16_T)
#error No 8-bit unsigned integer type was found.
#endif

/* Define intmax_t and uintmax_t if they are not already defined. */
#if !defined(HAVE_INTMAX_T)
typedef int64_t intmax_t;
#define INTMAX_MIN INT64_MIN
#define INTMAX_MAX INT64_MAX
#endif

#if !defined(HAVE_UINTMAX_T)
typedef uint64_t uintmax_t;
#endif

/* Define ZLIB_WINAPI if zlib was built on Visual Studio. */
/* #undef ZLIB_WINAPI */

/* MD5 via ARCHIVE_CRYPTO_MD5_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_MD5_LIBC */

/* MD5 via ARCHIVE_CRYPTO_MD5_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_MD5_LIBSYSTEM */

/* MD5 via ARCHIVE_CRYPTO_MD5_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_MD5_NETTLE */

/* MD5 via ARCHIVE_CRYPTO_MD5_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_MD5_OPENSSL */

/* MD5 via ARCHIVE_CRYPTO_MD5_WIN supported. */
/* #undef ARCHIVE_CRYPTO_MD5_WIN */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_LIBC */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_NETTLE */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_OPENSSL */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_LIBC */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_LIBSYSTEM */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_NETTLE */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_OPENSSL */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_WIN */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC2 */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC3 */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBSYSTEM */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_NETTLE */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_OPENSSL */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_WIN */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC2 */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC3 */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBSYSTEM */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_NETTLE */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_OPENSSL */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_WIN */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC2 */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC3 */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBSYSTEM */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_NETTLE */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_OPENSSL */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_WIN */

/* Version number of bsdcpio */
#define BSDCPIO_VERSION_STRING "3.1.2"

/* Version number of bsdtar */
#define BSDTAR_VERSION_STRING "3.1.2"

/* Define to 1 if you have the `acl_create_entry' function. */
/* #undef HAVE_ACL_CREATE_ENTRY */

/* Define to 1 if you have the `acl_get_link' function. */
/* #undef HAVE_ACL_GET_LINK */

/* Define to 1 if you have the `acl_get_link_np' function. */
/* #undef HAVE_ACL_GET_LINK_NP */

/* Define to 1 if you have the `acl_get_perm' function. */
/* #undef HAVE_ACL_GET_PERM */

/* Define to 1 if you have the `acl_get_perm_np' function. */
/* #undef HAVE_ACL_GET_PERM_NP */

/* Define to 1 if you have the `acl_init' function. */
/* #undef HAVE_ACL_INIT */

/* Define to 1 if you have the <acl/libacl.h> header file. */
/* #undef HAVE_ACL_LIBACL_H */

/* Define to 1 if the system has the type `acl_permset_t'. */
/* #undef HAVE_ACL_PERMSET_T */

/* Define to 1 if you have the `acl_set_fd' function. */
/* #undef HAVE_ACL_SET_FD */

/* Define to 1 if you have the `acl_set_fd_np' function. */
/* #undef HAVE_ACL_SET_FD_NP */

/* Define to 1 if you have the `acl_set_file' function. */
/* #undef HAVE_ACL_SET_FILE */

/* True for systems with POSIX ACL support */
/* #undef HAVE_ACL_USER */

/* Define to 1 if you have the <attr/xattr.h> header file. */
/* #undef HAVE_ATTR_XATTR_H */

/* Define to 1 if you have the <bsdxml.h> header file. */
/* #undef HAVE_BSDXML_H */

/* Define to 1 if you have the <bzlib.h> header file. */
#define HAVE_BZLIB_H 1

/* Define to 1 if you have the `chflags' function. */
/* #undef HAVE_CHFLAGS */

/* Define to 1 if you have the `chown' function. */
#define HAVE_CHOWN 1

/* Define to 1 if you have the `chroot' function. */
#define HAVE_CHROOT 1

/* Define to 1 if you have the <copyfile.h> header file. */
/* #undef HAVE_COPYFILE_H */

/* Define to 1 if you have the `ctime_r' function. */
#define HAVE_CTIME_R 1

/* Define to 1 if you have the <ctype.h> header file. */
#define HAVE_CTYPE_H 1

/* Define to 1 if you have the `cygwin_conv_path' function. */
/* #undef HAVE_CYGWIN_CONV_PATH */

/* Define to 1 if you have the declaration of `INT64_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_INT64_MAX 1

/* Define to 1 if you have the declaration of `INT64_MIN', and to 0 if you
   don't. */
#define HAVE_DECL_INT64_MIN 1

/* Define to 1 if you have the declaration of `SIZE_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_SIZE_MAX 1

/* Define to 1 if you have the declaration of `SSIZE_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_SSIZE_MAX 1

/* Define to 1 if you have the declaration of `strerror_r', and to 0 if you
   don't. */
#define HAVE_DECL_STRERROR_R 1

/* Define to 1 if you have the declaration of `UINT32_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_UINT32_MAX 1

/* Define to 1 if you have the declaration of `UINT64_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_UINT64_MAX 1

/* Define to 1 if you have the <direct.h> header file. */
/* #undef HAVE_DIRECT_H */

/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.
   */
#define HAVE_DIRENT_H 1

/* Define to 1 if you have the `dirfd' function. */
#define HAVE_DIRFD 1

/* Define to 1 if you have the <dlfcn.h> header file. */
#define HAVE_DLFCN_H 1

/* Define to 1 if you don't have `vprintf' but do have `_doprnt.' */
/* #undef HAVE_DOPRNT */

/* Define to 1 if nl_langinfo supports D_MD_ORDER */
/* #undef HAVE_D_MD_ORDER */

/* A possible errno value for invalid file format errors */
/* #undef HAVE_EFTYPE */

/* A possible errno value for invalid file format errors */
#define HAVE_EILSEQ 1

/* Define to 1 if you have the <errno.h> header file. */
#define HAVE_ERRNO_H 1

/* Define to 1 if you have the <expat.h> header file. */
/* #undef HAVE_EXPAT_H */

/* Define to 1 if you have the <ext2fs/ext2_fs.h> header file. */
/* #undef HAVE_EXT2FS_EXT2_FS_H */

/* Define to 1 if you have the `extattr_get_file' function. */
/* #undef HAVE_EXTATTR_GET_FILE */

/* Define to 1 if you have the `extattr_list_file' function. */
/* #undef HAVE_EXTATTR_LIST_FILE */

/* Define to 1 if you have the `extattr_set_fd' function. */
/* #undef HAVE_EXTATTR_SET_FD */

/* Define to 1 if you have the `extattr_set_file' function. */
/* #undef HAVE_EXTATTR_SET_FILE */

/* Define to 1 if EXTATTR_NAMESPACE_USER is defined in sys/extattr.h. */
/* #undef HAVE_DECL_EXTATTR_NAMESPACE_USER */

/* Define to 1 if you have the `fchdir' function. */
#define HAVE_FCHDIR 1

/* Define to 1 if you have the `fchflags' function. */
/* #undef HAVE_FCHFLAGS */

/* Define to 1 if you have the `fchmod' function. */
#define HAVE_FCHMOD 1

/* Define to 1 if you have the `fchown' function. */
#define HAVE_FCHOWN 1

/* Define to 1 if you have the `fcntl' function. */
#define HAVE_FCNTL 1

/* Define to 1 if you have the <fcntl.h> header file. */
#define HAVE_FCNTL_H 1

/* Define to 1 if you have the `fdopendir' function. */
#define HAVE_FDOPENDIR 1

/* Define to 1 if you have the `fgetea' function. */
/* #undef HAVE_FGETEA */

/* Define to 1 if you have the `fgetxattr' function. */
/* #undef HAVE_FGETXATTR */

/* Define to 1 if you have the `flistea' function. */
/* #undef HAVE_FLISTEA */

/* Define to 1 if you have the `flistxattr' function. */
/* #undef HAVE_FLISTXATTR */

/* Define to 1 if you have the `fork' function. */
#define HAVE_FORK 1

/* Define to 1 if fseeko (and presumably ftello) exists and is declared. */
#define HAVE_FSEEKO 1

/* Define to 1 if you have the `fsetea' function. */
/* #undef HAVE_FSETEA */

/* Define to 1 if you have the `fsetxattr' function. */
/* #undef HAVE_FSETXATTR */

/* Define to 1 if you have the `fstat' function. */
#define HAVE_FSTAT 1

/* Define to 1 if you have the `fstatat' function. */
#define HAVE_FSTATAT 1

/* Define to 1 if you have the `fstatfs' function. */
#define HAVE_FSTATFS 1

/* Define to 1 if you have the `fstatvfs' function. */
#define HAVE_FSTATVFS 1

/* Define to 1 if you have the `ftruncate' function. */
#define HAVE_FTRUNCATE 1

/* Define to 1 if you have the `futimens' function. */
#define HAVE_FUTIMENS 1

/* Define to 1 if you have the `futimes' function. */
#define HAVE_FUTIMES 1

/* Define to 1 if you have the `futimesat' function. */
#define HAVE_FUTIMESAT 1

/* Define to 1 if you have the `getea' function. */
/* #undef HAVE_GETEA */

/* Define to 1 if you have the `geteuid' function. */
#define HAVE_GETEUID 1

/* Define to 1 if you have the `getgrgid_r' function. */
#define HAVE_GETGRGID_R 1

/* Define to 1 if you have the `getgrnam_r' function. */
#define HAVE_GETGRNAM_R 1

/* Define to 1 if you have the `getpid' function. */
#define HAVE_GETPID 1

/* Define to 1 if you have the `getpwnam_r' function. */
#define HAVE_GETPWNAM_R 1

/* Define to 1 if you have the `getpwuid_r' function. */
#define HAVE_GETPWUID_R 1

/* Define to 1 if you have the `getvfsbyname' function. */
/* #undef HAVE_GETVFSBYNAME */

/* Define to 1 if you have the `getxattr' function. */
/* #undef HAVE_GETXATTR */

/* Define to 1 if you have the `gmtime_r' function. */
#define HAVE_GMTIME_R 1

/* Define to 1 if you have the <grp.h> header file. */
#define HAVE_GRP_H 1

/* Define to 1 if you have the `iconv' function. */
/* #undef HAVE_ICONV */

/* Define to 1 if you have the <iconv.h> header file. */
/* #undef HAVE_ICONV_H */

/* Define to 1 if you have the <inttypes.h> header file. */
#define HAVE_INTTYPES_H 1

/* Define to 1 if you have the <io.h> header file. */
/* #undef HAVE_IO_H */

/* Define to 1 if you have the <langinfo.h> header file. */
#define HAVE_LANGINFO_H 1

/* Define to 1 if you have the `lchflags' function. */
/* #undef HAVE_LCHFLAGS */

/* Define to 1 if you have the `lchmod' function. */
/* #undef HAVE_LCHMOD */

/* Define to 1 if you have the `lchown' function. */
#define HAVE_LCHOWN 1

/* Define to 1 if you have the `lgetea' function. */
/* #undef HAVE_LGETEA */

/* Define to 1 if you have the `lgetxattr' function. */
/* #undef HAVE_LGETXATTR */

/* Define to 1 if you have the `acl' library (-lacl). */
/* #undef HAVE_LIBACL */

/* Define to 1 if you have the `attr' library (-lattr). */
/* #undef HAVE_LIBATTR */

/* Define to 1 if you have the `bsdxml' library (-lbsdxml). */
/* #undef HAVE_LIBBSDXML */

/* Define to 1 if you have the `bz2' library (-lbz2). */
#define HAVE_LIBBZ2 1

/* Define to 1 if you have the `expat' library (-lexpat). */
/* #undef HAVE_LIBEXPAT */

/* Define to 1 if you have the `gcc' library (-lgcc). */
/* #undef HAVE_LIBGCC */

/* Define to 1 if you have the `lzma' library (-llzma). */
/* #undef HAVE_LIBLZMA */

/* Define to 1 if you have the `lzmadec' library (-llzmadec). */
/* #undef HAVE_LIBLZMADEC */

/* Define to 1 if you have the `lzo2' library (-llzo2). */
/* #undef HAVE_LIBLZO2 */

/* Define to 1 if you have the `nettle' library (-lnettle). */
/* #undef HAVE_LIBNETTLE */

/* Define to 1 if you have the `pcre' library (-lpcre). */
/* #undef HAVE_LIBPCRE */

/* Define to 1 if you have the `pcreposix' library (-lpcreposix). */
/* #undef HAVE_LIBPCREPOSIX */

/* Define to 1 if you have the `xml2' library (-lxml2). */
/* #undef HAVE_LIBXML2 */

/* Define to 1 if you have the <libxml/xmlreader.h> header file. */
/* #undef HAVE_LIBXML_XMLREADER_H */

/* Define to 1 if you have the <libxml/xmlwriter.h> header file. */
/* #undef HAVE_LIBXML_XMLWRITER_H */

/* Define to 1 if you have the `z' library (-lz). */
#define HAVE_LIBZ 1

/* Define to 1 if you have the <limits.h> header file. */
#define HAVE_LIMITS_H 1

/* Define to 1 if you have the `link' function. */
#define HAVE_LINK 1

/* Define to 1 if you have the <linux/types.h> header file. */
#define HAVE_LINUX_TYPES_H 1

/* Define to 1 if you have the <linux/fiemap.h> header file. */
#define HAVE_LINUX_FIEMAP_H 1

/* Define to 1 if you have the <linux/fs.h> header file. */
#define HAVE_LINUX_FS_H 1

/* Define to 1 if you have the <linux/magic.h> header file. */
#define HAVE_LINUX_MAGIC_H 1

/* Define to 1 if you have the <linux/types.h> header file. */
#define HAVE_LINUX_TYPES_H 1

/* Define to 1 if you have the `listea' function. */
/* #undef HAVE_LISTEA */

/* Define to 1 if you have the `listxattr' function. */
/* #undef HAVE_LISTXATTR */

/* Define to 1 if you have the `llistea' function. */
/* #undef HAVE_LLISTEA */

/* Define to 1 if you have the `llistxattr' function. */
/* #undef HAVE_LLISTXATTR */

/* Define to 1 if you have the <localcharset.h> header file. */
/* #undef HAVE_LOCALCHARSET_H */

/* Define to 1 if you have the `locale_charset' function. */
/* #undef HAVE_LOCALE_CHARSET */

/* Define to 1 if you have the <locale.h> header file. */
#define HAVE_LOCALE_H 1

/* Define to 1 if you have the `localtime_r' function. */
#define HAVE_LOCALTIME_R 1

/* Define to 1 if the system has the type `long long int'. */
/* #undef HAVE_LONG_LONG_INT */

/* Define to 1 if you have the `lsetea' function. */
/* #undef HAVE_LSETEA */

/* Define to 1 if you have the `lsetxattr' function. */
/* #undef HAVE_LSETXATTR */

/* Define to 1 if you have the `lstat' function. */
#define HAVE_LSTAT 1

/* Define to 1 if `lstat' has the bug that it succeeds when given the
   zero-length file name argument. */
/* #undef HAVE_LSTAT_EMPTY_STRING_BUG */

/* Define to 1 if you have the `lutimes' function. */
#define HAVE_LUTIMES 1

/* Define to 1 if you have the <lzmadec.h> header file. */
/* #undef HAVE_LZMADEC_H */

/* Define to 1 if you have the <lzma.h> header file. */
/* #undef HAVE_LZMA_H */

/* Define to 1 if you have the <lzo/lzo1x.h> header file. */
/* #undef HAVE_LZO_LZO1X_H */

/* Define to 1 if you have the <lzo/lzoconf.h> header file. */
/* #undef HAVE_LZO_LZOCONF_H */

/* Define to 1 if you have the `mbrtowc' function. */
#define HAVE_MBRTOWC 1

/* Define to 1 if you have the `memmove' function. */
#define HAVE_MEMMOVE 1

/* Define to 1 if you have the <memory.h> header file. */
#define HAVE_MEMORY_H 1

/* Define to 1 if you have the `mkdir' function. */
#define HAVE_MKDIR 1

/* Define to 1 if you have the `mkfifo' function. */
#define HAVE_MKFIFO 1

/* Define to 1 if you have the `mknod' function. */
#define HAVE_MKNOD 1

/* Define to 1 if you have the `mkstemp' function. */
#define HAVE_MKSTEMP 1

/* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */
/* #undef HAVE_NDIR_H */

/* Define to 1 if you have the <nettle/md5.h> header file. */
/* #undef HAVE_NETTLE_MD5_H */

/* Define to 1 if you have the <nettle/ripemd160.h> header file. */
/* #undef HAVE_NETTLE_RIPEMD160_H */

/* Define to 1 if you have the <nettle/sha.h> header file. */
/* #undef HAVE_NETTLE_SHA_H */

/* Define to 1 if you have the `nl_langinfo' function. */
#define HAVE_NL_LANGINFO 1

/* Define to 1 if you have the `openat' function. */
#define HAVE_OPENAT 1

/* Define to 1 if you have the <paths.h> header file. */
#define HAVE_PATHS_H 1

/* Define to 1 if you have the <pcreposix.h> header file. */
/* #undef HAVE_PCREPOSIX_H */

/* Define to 1 if you have the `pipe' function. */
#define HAVE_PIPE 1

/* Define to 1 if you have the `poll' function. */
#define HAVE_POLL 1

/* Define to 1 if you have the <poll.h> header file. */
#define HAVE_POLL_H 1

/* Define to 1 if you have the `posix_spawnp' function. */
#define HAVE_POSIX_SPAWNP 1

/* Define to 1 if you have the <process.h> header file. */
/* #undef HAVE_PROCESS_H */

/* Define to 1 if you have the <pwd.h> header file. */
#define HAVE_PWD_H 1

/* Define to 1 if you have the `readdir_r' function. */
#define HAVE_READDIR_R 1

/* Define to 1 if you have the `readlink' function. */
#define HAVE_READLINK 1

/* Define to 1 if you have the `readlinkat' function. */
#define HAVE_READLINKAT 1

/* Define to 1 if you have the <regex.h> header file. */
#define HAVE_REGEX_H 1

/* Define to 1 if you have the `select' function. */
#define HAVE_SELECT 1

/* Define to 1 if you have the `setenv' function. */
#define HAVE_SETENV 1

/* Define to 1 if you have the `setlocale' function. */
#define HAVE_SETLOCALE 1

/* Define to 1 if you have the `sigaction' function. */
#define HAVE_SIGACTION 1

/* Define to 1 if you have the <signal.h> header file. */
#define HAVE_SIGNAL_H 1

/* Define to 1 if you have the <spawn.h> header file. */
#define HAVE_SPAWN_H 1

/* Define to 1 if you have the `statfs' function. */
#define HAVE_STATFS 1

/* Define to 1 if you have the `statvfs' function. */
#define HAVE_STATVFS 1

/* Define to 1 if `stat' has the bug that it succeeds when given the
   zero-length file name argument. */
/* #undef HAVE_STAT_EMPTY_STRING_BUG */

/* Define to 1 if you have the <stdarg.h> header file. */
#define HAVE_STDARG_H 1

/* Define to 1 if you have the <stdint.h> header file. */
#define HAVE_STDINT_H 1

/* Define to 1 if you have the <stdlib.h> header file. */
#define HAVE_STDLIB_H 1

/* Define to 1 if you have the `strchr' function. */
#define HAVE_STRCHR 1

/* Define to 1 if you have the `strdup' function. */
#define HAVE_STRDUP 1

/* Define to 1 if you have the `strerror' function. */
#define HAVE_STRERROR 1

/* Define to 1 if you have the `strerror_r' function. */
#define HAVE_STRERROR_R 1

/* Define to 1 if you have the `strftime' function. */
#define HAVE_STRFTIME 1

/* Define to 1 if you have the <strings.h> header file. */
#define HAVE_STRINGS_H 1

/* Define to 1 if you have the <string.h> header file. */
#define HAVE_STRING_H 1

/* Define to 1 if you have the `strrchr' function. */
#define HAVE_STRRCHR 1

/* Define to 1 if `f_namemax' is a member of `struct statfs'. */
/* #undef HAVE_STRUCT_STATFS_F_NAMEMAX */

/* Define to 1 if `f_iosize' is a member of `struct statvfs'. */
/* #undef HAVE_STRUCT_STATVFS_F_IOSIZE */

/* Define to 1 if `st_birthtime' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIME */

/* Define to 1 if `st_birthtimespec.tv_nsec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC_TV_NSEC */

/* Define to 1 if `st_blksize' is a member of `struct stat'. */
#define HAVE_STRUCT_STAT_ST_BLKSIZE 1

/* Define to 1 if `st_flags' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_FLAGS */

/* Define to 1 if `st_mtimespec.tv_nsec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC */

/* Define to 1 if `st_mtime_n' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIME_N */

/* Define to 1 if `st_mtime_usec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIME_USEC */

/* Define to 1 if `st_mtim.tv_nsec' is a member of `struct stat'. */
#define HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC 1

/* Define to 1 if `st_umtime' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_UMTIME */

/* Define to 1 if `tm_gmtoff' is a member of `struct tm'. */
#define HAVE_STRUCT_TM_TM_GMTOFF 1

/* Define to 1 if `__tm_gmtoff' is a member of `struct tm'. */
/* #undef HAVE_STRUCT_TM___TM_GMTOFF */

/* Define to 1 if you have the `symlink' function. */
#define HAVE_SYMLINK 1

/* Define to 1 if you have the <sys/acl.h> header file. */
/* #undef HAVE_SYS_ACL_H */

/* Define to 1 if you have the <sys/cdefs.h> header file. */
#define HAVE_SYS_CDEFS_H 1

/* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.
   */
/* #undef HAVE_SYS_DIR_H */

/* Define to 1 if you have the <sys/ea.h> header file. */
/* #undef HAVE_SYS_EA_H */

/* Define to 1 if you have the <sys/extattr.h> header file. */
/* #undef HAVE_SYS_EXTATTR_H */

/* Define to 1 if you have the <sys/ioctl.h> header file. */
#define HAVE_SYS_IOCTL_H 1

/* Define to 1 if you have the <sys/mkdev.h> header file. */
/* #undef HAVE_SYS_MKDEV_H */

/* Define to 1 if you have the <sys/mount.h> header file. */
/* #undef HAVE_SYS_MOUNT_H */

/* Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.
   */
/* #undef HAVE_SYS_NDIR_H */

/* Define to 1 if you have the <sys/param.h> header file. */
#define HAVE_SYS_PARAM_H 1

/* Define to 1 if you have the <sys/poll.h> header file. */
#define HAVE_SYS_POLL_H 1

/* Define to 1 if you have the <sys/select.h> header file. */
#define HAVE_SYS_SELECT_H 1

/* Define to 1 if you have the <sys/statfs.h> header file. */
#define HAVE_SYS_STATFS_H 1

/* Define to 1 if you have the <sys/statvfs.h> header file. */
#define HAVE_SYS_STATVFS_H 1

/* Define to 1 if you have the <sys/stat.h> header file. */
#define HAVE_SYS_STAT_H 1

/* Define to 1 if you have the <sys/time.h> header file. */
#define HAVE_SYS_TIME_H 1

/* Define to 1 if you have the <sys/types.h> header file. */
#define HAVE_SYS_TYPES_H 1

/* Define to 1 if you have the <sys/utime.h> header file. */
/* #undef HAVE_SYS_UTIME_H */

/* Define to 1 if you have the <sys/utsname.h> header file. */
#define HAVE_SYS_UTSNAME_H 1

/* Define to 1 if you have the <sys/vfs.h> header file. */
#define HAVE_SYS_VFS_H 1

/* Define to 1 if you have <sys/wait.h> that is POSIX.1 compatible. */
#define HAVE_SYS_WAIT_H 1

/* Define to 1 if you have the <sys/xattr.h> header file. */
/* #undef HAVE_SYS_XATTR_H */

/* Define to 1 if you have the `timegm' function. */
#define HAVE_TIMEGM 1

/* Define to 1 if you have the <time.h> header file. */
#define HAVE_TIME_H 1

/* Define to 1 if you have the `tzset' function. */
#define HAVE_TZSET 1

/* Define to 1 if you have the <unistd.h> header file. */
#define HAVE_UNISTD_H 1

/* Define to 1 if you have the `unsetenv' function. */
#define HAVE_UNSETENV 1

/* Define to 1 if the system has the type `unsigned long long'. */
/* #undef HAVE_UNSIGNED_LONG_LONG */

/* Define to 1 if the system has the type `unsigned long long int'. */
/* #undef HAVE_UNSIGNED_LONG_LONG_INT */

/* Define to 1 if you have the `utime' function. */
#define HAVE_UTIME 1

/* Define to 1 if you have the `utimensat' function. */
#define HAVE_UTIMENSAT 1

/* Define to 1 if you have the `utimes' function. */
#define HAVE_UTIMES 1

/* Define to 1 if you have the <utime.h> header file. */
#define HAVE_UTIME_H 1

/* Define to 1 if you have the `vfork' function. */
#define HAVE_VFORK 1

/* Define to 1 if you have the `vprintf' function. */
#define HAVE_VPRINTF 1

/* Define to 1 if you have the <wchar.h> header file. */
#define HAVE_WCHAR_H 1

/* Define to 1 if the system has the type `wchar_t'. */
#define HAVE_WCHAR_T 1

/* Define to 1 if you have the `wcrtomb' function. */
#define HAVE_WCRTOMB 1

/* Define to 1 if you have the `wcscmp' function. */
#define HAVE_WCSCMP 1

/* Define to 1 if you have the `wcscpy' function. */
#define HAVE_WCSCPY 1

/* Define to 1 if you have the `wcslen' function. */
#define HAVE_WCSLEN 1

/* Define to 1 if you have the `wctomb' function. */
#define HAVE_WCTOMB 1

/* Define to 1 if you have the <wctype.h> header file. */
#define HAVE_WCTYPE_H 1

/* Define to 1 if you have the <wincrypt.h> header file. */
/* #undef HAVE_WINCRYPT_H */

/* Define to 1 if you have the <windows.h> header file. */
/* #undef HAVE_WINDOWS_H */

/* Define to 1 if you have the <winioctl.h> header file. */
/* #undef HAVE_WINIOCTL_H */

/* Define to 1 if you have _CrtSetReportMode in <crtdbg.h>  */
/* #undef HAVE__CrtSetReportMode */

/* Define to 1 if you have the `wmemcmp' function. */
#define HAVE_WMEMCMP 1

/* Define to 1 if you have the `wmemcpy' function. */
#define HAVE_WMEMCPY 1

/* Define to 1 if you have a working EXT2_IOC_GETFLAGS */
/* #undef HAVE_WORKING_EXT2_IOC_GETFLAGS */

/* Define to 1 if you have the <zlib.h> header file. */
#define HAVE_ZLIB_H 1

/* Define to 1 if you have the `_ctime64_s' function. */
/* #undef HAVE__CTIME64_S */

/* Define to 1 if you have the `_fseeki64' function. */
/* #undef HAVE__FSEEKI64 */

/* Define to 1 if you have the `_get_timezone' function. */
/* #undef HAVE__GET_TIMEZONE */

/* Define to 1 if you have the `_localtime64_s' function. */
/* #undef HAVE__LOCALTIME64_S */

/* Define to 1 if you have the `_mkgmtime64' function. */
/* #undef HAVE__MKGMTIME64 */

/* Define as const if the declaration of iconv() needs const. */
#define ICONV_CONST 

/* Version number of libarchive as a single integer */
#define LIBARCHIVE_VERSION_NUMBER "3001002"

/* Version number of libarchive */
#define LIBARCHIVE_VERSION_STRING "3.1.2"

/* Define to 1 if `lstat' dereferences a symlink specified with a trailing
   slash. */
/* #undef LSTAT_FOLLOWS_SLASHED_SYMLINK */

/* Define to 1 if `major', `minor', and `makedev' are declared in <mkdev.h>.
   */
/* #undef MAJOR_IN_MKDEV */

/* Define to 1 if `major', `minor', and `makedev' are declared in
   <sysmacros.h>. */
#define MAJOR_IN_SYSMACROS 1

/* Define to 1 if your C compiler doesn't accept -c and -o together. */
/* #undef NO_MINUS_C_MINUS_O */

/* The size of `wchar_t', as computed by sizeof. */
#define SIZEOF_WCHAR_T 4

/* Define to 1 if strerror_r returns char *. */
/* #undef STRERROR_R_CHAR_P */

/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
#define TIME_WITH_SYS_TIME 1

/*
 * Some platform requires a macro to use extension functions.
 */
#define SAFE_TO_DEFINE_EXTENSIONS 1
#ifdef SAFE_TO_DEFINE_EXTENSIONS
/* Enable extensions on AIX 3, Interix.  */
#ifndef _ALL_SOURCE
# define _ALL_SOURCE 1
#endif
/* Enable GNU extensions on systems that have them.  */
#ifndef _GNU_SOURCE
# define _GNU_SOURCE 1
#endif
/* Enable threading extensions on Solaris.  */
#ifndef _POSIX_PTHREAD_SEMANTICS
# define _POSIX_PTHREAD_SEMANTICS 1
#endif
/* Enable extensions on HP NonStop.  */
#ifndef _TANDEM_SOURCE
# define _TANDEM_SOURCE 1
#endif
/* Enable general extensions on Solaris.  */
#ifndef __EXTENSIONS__
# define __EXTENSIONS__ 1
#endif
#endif /* SAFE_TO_DEFINE_EXTENSIONS */

/* Version number of package */
#define VERSION "3.1.2"

/* Number of bits in a file offset, on hosts where this is settable. */
/* #undef _FILE_OFFSET_BITS */

/* Define to 1 to make fseeko visible on some hosts (e.g. glibc 2.2). */
/* #undef _LARGEFILE_SOURCE */

/* Define for large files, on AIX-style hosts. */
/* #undef _LARGE_FILES */

/* Define for Windows to use Windows 2000+ APIs. */
/* #undef _WIN32_WINNT */
/* #undef WINVER */

/* Define to empty if `const' does not conform to ANSI C. */
/* #undef const */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef gid_t */

/* Define to `unsigned long' if <sys/types.h> does not define. */
/* #undef id_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef mode_t */

/* Define to `long long' if <sys/types.h> does not define. */
/* #undef off_t */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef pid_t */

/* Define to `unsigned int' if <sys/types.h> does not define. */
/* #undef size_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef ssize_t */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef uid_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef intptr_t */

/* Define to `unsigned int' if <sys/types.h> does not define. */
/* #undef uintptr_t */


#define ARCHIVE_SHA256_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA256_LIBC2
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = (DWORD)bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. Nettle
 * 6. OpenSSL
 * 7. libmd
 * 8. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive_sha256_ctx ctx;
  archive_sha256_init(&ctx);
  archive_sha256_update(&ctx, *argv, argc);
  archive_sha256_final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA384_LIBC2 failed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec518414214/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec518414214.dir/build.make CMakeFiles/cmTryCompileExec518414214.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec518414214.dir/check_crypto_md.c.o
/usr/bin/gcc   -w  -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2 -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmlibarchive/libarchive -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec518414214.dir/check_crypto_md.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1186:0:
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: fatal error: sha2.h: No such file or directory
 #include <sha2.h>
                  ^
compilation terminated.
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec518414214.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec518414214/fast] Error 2

Source file was:
/* config.h.  Generated from build/cmake/config.h.in by cmake configure */
#if defined(__osf__)
# define _OSF_SOURCE
#endif

/*
 * Ensure we have C99-style int64_t, etc, all defined.
 */

/* First, we need to know if the system has already defined them. */
#define HAVE_INT16_T
#define HAVE_INT32_T
#define HAVE_INT64_T
#define HAVE_INTMAX_T

#define HAVE_UINT8_T
#define HAVE_UINT16_T
#define HAVE_UINT32_T
#define HAVE_UINT64_T
#define HAVE_UINTMAX_T

/* We might have the types we want under other spellings. */
/* #undef HAVE___INT64 */
/* #undef HAVE_U_INT64_T */
/* #undef HAVE_UNSIGNED___INT64 */

/* The sizes of various standard integer types. */
#define SIZE_OF_SHORT 2
#define SIZE_OF_INT 4
#define SIZE_OF_LONG 8
#define SIZE_OF_LONG_LONG 8
#define SIZE_OF_UNSIGNED_SHORT 2
#define SIZE_OF_UNSIGNED 4
#define SIZE_OF_UNSIGNED_LONG 8
#define SIZE_OF_UNSIGNED_LONG_LONG 8

/*
 * If we lack int64_t, define it to the first of __int64, int, long, and long long
 * that exists and is the right size.
 */
#if !defined(HAVE_INT64_T) && defined(HAVE___INT64)
typedef __int64 int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_INT == 8
typedef int int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_LONG == 8
typedef long int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_LONG_LONG == 8
typedef long long int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T)
#error No 64-bit integer type was found.
#endif

/*
 * Similarly for int32_t
 */
#if !defined(HAVE_INT32_T) && SIZE_OF_INT == 4
typedef long int32_t;
#define HAVE_INT32_T
#endif

#if !defined(HAVE_INT32_T) && SIZE_OF_LONG == 4
typedef long int32_t;
#define HAVE_INT32_T
#endif

#if !defined(HAVE_INT32_T)
#error No 32-bit integer type was found.
#endif

/*
 * Similarly for int16_t
 */
#if !defined(HAVE_INT16_T) && SIZE_OF_INT == 2
typedef int int16_t;
#define HAVE_INT16_T
#endif

#if !defined(HAVE_INT16_T) && SIZE_OF_SHORT == 2
typedef short int16_t;
#define HAVE_INT16_T
#endif

#if !defined(HAVE_INT16_T)
#error No 16-bit integer type was found.
#endif

/*
 * Similarly for uint64_t
 */
#if !defined(HAVE_UINT64_T) && defined(HAVE_UNSIGNED___INT64)
typedef unsigned __int64 uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED == 8
typedef unsigned uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED_LONG == 8
typedef unsigned long uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED_LONG_LONG == 8
typedef unsigned long long uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T)
#error No 64-bit unsigned integer type was found.
#endif


/*
 * Similarly for uint32_t
 */
#if !defined(HAVE_UINT32_T) && SIZE_OF_UNSIGNED == 4
typedef unsigned uint32_t;
#define HAVE_UINT32_T
#endif

#if !defined(HAVE_UINT32_T) && SIZE_OF_UNSIGNED_LONG == 4
typedef unsigned long uint32_t;
#define HAVE_UINT32_T
#endif

#if !defined(HAVE_UINT32_T)
#error No 32-bit unsigned integer type was found.
#endif

/*
 * Similarly for uint16_t
 */
#if !defined(HAVE_UINT16_T) && SIZE_OF_UNSIGNED == 2
typedef unsigned uint16_t;
#define HAVE_UINT16_T
#endif

#if !defined(HAVE_UINT16_T) && SIZE_OF_UNSIGNED_SHORT == 2
typedef unsigned short uint16_t;
#define HAVE_UINT16_T
#endif

#if !defined(HAVE_UINT16_T)
#error No 16-bit unsigned integer type was found.
#endif

/*
 * Similarly for uint8_t
 */
#if !defined(HAVE_UINT8_T)
typedef unsigned char uint8_t;
#define HAVE_UINT8_T
#endif

#if !defined(HAVE_UINT16_T)
#error No 8-bit unsigned integer type was found.
#endif

/* Define intmax_t and uintmax_t if they are not already defined. */
#if !defined(HAVE_INTMAX_T)
typedef int64_t intmax_t;
#define INTMAX_MIN INT64_MIN
#define INTMAX_MAX INT64_MAX
#endif

#if !defined(HAVE_UINTMAX_T)
typedef uint64_t uintmax_t;
#endif

/* Define ZLIB_WINAPI if zlib was built on Visual Studio. */
/* #undef ZLIB_WINAPI */

/* MD5 via ARCHIVE_CRYPTO_MD5_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_MD5_LIBC */

/* MD5 via ARCHIVE_CRYPTO_MD5_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_MD5_LIBSYSTEM */

/* MD5 via ARCHIVE_CRYPTO_MD5_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_MD5_NETTLE */

/* MD5 via ARCHIVE_CRYPTO_MD5_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_MD5_OPENSSL */

/* MD5 via ARCHIVE_CRYPTO_MD5_WIN supported. */
/* #undef ARCHIVE_CRYPTO_MD5_WIN */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_LIBC */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_NETTLE */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_OPENSSL */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_LIBC */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_LIBSYSTEM */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_NETTLE */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_OPENSSL */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_WIN */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC2 */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC3 */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBSYSTEM */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_NETTLE */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_OPENSSL */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_WIN */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC2 */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC3 */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBSYSTEM */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_NETTLE */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_OPENSSL */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_WIN */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC2 */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC3 */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBSYSTEM */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_NETTLE */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_OPENSSL */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_WIN */

/* Version number of bsdcpio */
#define BSDCPIO_VERSION_STRING "3.1.2"

/* Version number of bsdtar */
#define BSDTAR_VERSION_STRING "3.1.2"

/* Define to 1 if you have the `acl_create_entry' function. */
/* #undef HAVE_ACL_CREATE_ENTRY */

/* Define to 1 if you have the `acl_get_link' function. */
/* #undef HAVE_ACL_GET_LINK */

/* Define to 1 if you have the `acl_get_link_np' function. */
/* #undef HAVE_ACL_GET_LINK_NP */

/* Define to 1 if you have the `acl_get_perm' function. */
/* #undef HAVE_ACL_GET_PERM */

/* Define to 1 if you have the `acl_get_perm_np' function. */
/* #undef HAVE_ACL_GET_PERM_NP */

/* Define to 1 if you have the `acl_init' function. */
/* #undef HAVE_ACL_INIT */

/* Define to 1 if you have the <acl/libacl.h> header file. */
/* #undef HAVE_ACL_LIBACL_H */

/* Define to 1 if the system has the type `acl_permset_t'. */
/* #undef HAVE_ACL_PERMSET_T */

/* Define to 1 if you have the `acl_set_fd' function. */
/* #undef HAVE_ACL_SET_FD */

/* Define to 1 if you have the `acl_set_fd_np' function. */
/* #undef HAVE_ACL_SET_FD_NP */

/* Define to 1 if you have the `acl_set_file' function. */
/* #undef HAVE_ACL_SET_FILE */

/* True for systems with POSIX ACL support */
/* #undef HAVE_ACL_USER */

/* Define to 1 if you have the <attr/xattr.h> header file. */
/* #undef HAVE_ATTR_XATTR_H */

/* Define to 1 if you have the <bsdxml.h> header file. */
/* #undef HAVE_BSDXML_H */

/* Define to 1 if you have the <bzlib.h> header file. */
#define HAVE_BZLIB_H 1

/* Define to 1 if you have the `chflags' function. */
/* #undef HAVE_CHFLAGS */

/* Define to 1 if you have the `chown' function. */
#define HAVE_CHOWN 1

/* Define to 1 if you have the `chroot' function. */
#define HAVE_CHROOT 1

/* Define to 1 if you have the <copyfile.h> header file. */
/* #undef HAVE_COPYFILE_H */

/* Define to 1 if you have the `ctime_r' function. */
#define HAVE_CTIME_R 1

/* Define to 1 if you have the <ctype.h> header file. */
#define HAVE_CTYPE_H 1

/* Define to 1 if you have the `cygwin_conv_path' function. */
/* #undef HAVE_CYGWIN_CONV_PATH */

/* Define to 1 if you have the declaration of `INT64_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_INT64_MAX 1

/* Define to 1 if you have the declaration of `INT64_MIN', and to 0 if you
   don't. */
#define HAVE_DECL_INT64_MIN 1

/* Define to 1 if you have the declaration of `SIZE_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_SIZE_MAX 1

/* Define to 1 if you have the declaration of `SSIZE_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_SSIZE_MAX 1

/* Define to 1 if you have the declaration of `strerror_r', and to 0 if you
   don't. */
#define HAVE_DECL_STRERROR_R 1

/* Define to 1 if you have the declaration of `UINT32_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_UINT32_MAX 1

/* Define to 1 if you have the declaration of `UINT64_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_UINT64_MAX 1

/* Define to 1 if you have the <direct.h> header file. */
/* #undef HAVE_DIRECT_H */

/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.
   */
#define HAVE_DIRENT_H 1

/* Define to 1 if you have the `dirfd' function. */
#define HAVE_DIRFD 1

/* Define to 1 if you have the <dlfcn.h> header file. */
#define HAVE_DLFCN_H 1

/* Define to 1 if you don't have `vprintf' but do have `_doprnt.' */
/* #undef HAVE_DOPRNT */

/* Define to 1 if nl_langinfo supports D_MD_ORDER */
/* #undef HAVE_D_MD_ORDER */

/* A possible errno value for invalid file format errors */
/* #undef HAVE_EFTYPE */

/* A possible errno value for invalid file format errors */
#define HAVE_EILSEQ 1

/* Define to 1 if you have the <errno.h> header file. */
#define HAVE_ERRNO_H 1

/* Define to 1 if you have the <expat.h> header file. */
/* #undef HAVE_EXPAT_H */

/* Define to 1 if you have the <ext2fs/ext2_fs.h> header file. */
/* #undef HAVE_EXT2FS_EXT2_FS_H */

/* Define to 1 if you have the `extattr_get_file' function. */
/* #undef HAVE_EXTATTR_GET_FILE */

/* Define to 1 if you have the `extattr_list_file' function. */
/* #undef HAVE_EXTATTR_LIST_FILE */

/* Define to 1 if you have the `extattr_set_fd' function. */
/* #undef HAVE_EXTATTR_SET_FD */

/* Define to 1 if you have the `extattr_set_file' function. */
/* #undef HAVE_EXTATTR_SET_FILE */

/* Define to 1 if EXTATTR_NAMESPACE_USER is defined in sys/extattr.h. */
/* #undef HAVE_DECL_EXTATTR_NAMESPACE_USER */

/* Define to 1 if you have the `fchdir' function. */
#define HAVE_FCHDIR 1

/* Define to 1 if you have the `fchflags' function. */
/* #undef HAVE_FCHFLAGS */

/* Define to 1 if you have the `fchmod' function. */
#define HAVE_FCHMOD 1

/* Define to 1 if you have the `fchown' function. */
#define HAVE_FCHOWN 1

/* Define to 1 if you have the `fcntl' function. */
#define HAVE_FCNTL 1

/* Define to 1 if you have the <fcntl.h> header file. */
#define HAVE_FCNTL_H 1

/* Define to 1 if you have the `fdopendir' function. */
#define HAVE_FDOPENDIR 1

/* Define to 1 if you have the `fgetea' function. */
/* #undef HAVE_FGETEA */

/* Define to 1 if you have the `fgetxattr' function. */
/* #undef HAVE_FGETXATTR */

/* Define to 1 if you have the `flistea' function. */
/* #undef HAVE_FLISTEA */

/* Define to 1 if you have the `flistxattr' function. */
/* #undef HAVE_FLISTXATTR */

/* Define to 1 if you have the `fork' function. */
#define HAVE_FORK 1

/* Define to 1 if fseeko (and presumably ftello) exists and is declared. */
#define HAVE_FSEEKO 1

/* Define to 1 if you have the `fsetea' function. */
/* #undef HAVE_FSETEA */

/* Define to 1 if you have the `fsetxattr' function. */
/* #undef HAVE_FSETXATTR */

/* Define to 1 if you have the `fstat' function. */
#define HAVE_FSTAT 1

/* Define to 1 if you have the `fstatat' function. */
#define HAVE_FSTATAT 1

/* Define to 1 if you have the `fstatfs' function. */
#define HAVE_FSTATFS 1

/* Define to 1 if you have the `fstatvfs' function. */
#define HAVE_FSTATVFS 1

/* Define to 1 if you have the `ftruncate' function. */
#define HAVE_FTRUNCATE 1

/* Define to 1 if you have the `futimens' function. */
#define HAVE_FUTIMENS 1

/* Define to 1 if you have the `futimes' function. */
#define HAVE_FUTIMES 1

/* Define to 1 if you have the `futimesat' function. */
#define HAVE_FUTIMESAT 1

/* Define to 1 if you have the `getea' function. */
/* #undef HAVE_GETEA */

/* Define to 1 if you have the `geteuid' function. */
#define HAVE_GETEUID 1

/* Define to 1 if you have the `getgrgid_r' function. */
#define HAVE_GETGRGID_R 1

/* Define to 1 if you have the `getgrnam_r' function. */
#define HAVE_GETGRNAM_R 1

/* Define to 1 if you have the `getpid' function. */
#define HAVE_GETPID 1

/* Define to 1 if you have the `getpwnam_r' function. */
#define HAVE_GETPWNAM_R 1

/* Define to 1 if you have the `getpwuid_r' function. */
#define HAVE_GETPWUID_R 1

/* Define to 1 if you have the `getvfsbyname' function. */
/* #undef HAVE_GETVFSBYNAME */

/* Define to 1 if you have the `getxattr' function. */
/* #undef HAVE_GETXATTR */

/* Define to 1 if you have the `gmtime_r' function. */
#define HAVE_GMTIME_R 1

/* Define to 1 if you have the <grp.h> header file. */
#define HAVE_GRP_H 1

/* Define to 1 if you have the `iconv' function. */
/* #undef HAVE_ICONV */

/* Define to 1 if you have the <iconv.h> header file. */
/* #undef HAVE_ICONV_H */

/* Define to 1 if you have the <inttypes.h> header file. */
#define HAVE_INTTYPES_H 1

/* Define to 1 if you have the <io.h> header file. */
/* #undef HAVE_IO_H */

/* Define to 1 if you have the <langinfo.h> header file. */
#define HAVE_LANGINFO_H 1

/* Define to 1 if you have the `lchflags' function. */
/* #undef HAVE_LCHFLAGS */

/* Define to 1 if you have the `lchmod' function. */
/* #undef HAVE_LCHMOD */

/* Define to 1 if you have the `lchown' function. */
#define HAVE_LCHOWN 1

/* Define to 1 if you have the `lgetea' function. */
/* #undef HAVE_LGETEA */

/* Define to 1 if you have the `lgetxattr' function. */
/* #undef HAVE_LGETXATTR */

/* Define to 1 if you have the `acl' library (-lacl). */
/* #undef HAVE_LIBACL */

/* Define to 1 if you have the `attr' library (-lattr). */
/* #undef HAVE_LIBATTR */

/* Define to 1 if you have the `bsdxml' library (-lbsdxml). */
/* #undef HAVE_LIBBSDXML */

/* Define to 1 if you have the `bz2' library (-lbz2). */
#define HAVE_LIBBZ2 1

/* Define to 1 if you have the `expat' library (-lexpat). */
/* #undef HAVE_LIBEXPAT */

/* Define to 1 if you have the `gcc' library (-lgcc). */
/* #undef HAVE_LIBGCC */

/* Define to 1 if you have the `lzma' library (-llzma). */
/* #undef HAVE_LIBLZMA */

/* Define to 1 if you have the `lzmadec' library (-llzmadec). */
/* #undef HAVE_LIBLZMADEC */

/* Define to 1 if you have the `lzo2' library (-llzo2). */
/* #undef HAVE_LIBLZO2 */

/* Define to 1 if you have the `nettle' library (-lnettle). */
/* #undef HAVE_LIBNETTLE */

/* Define to 1 if you have the `pcre' library (-lpcre). */
/* #undef HAVE_LIBPCRE */

/* Define to 1 if you have the `pcreposix' library (-lpcreposix). */
/* #undef HAVE_LIBPCREPOSIX */

/* Define to 1 if you have the `xml2' library (-lxml2). */
/* #undef HAVE_LIBXML2 */

/* Define to 1 if you have the <libxml/xmlreader.h> header file. */
/* #undef HAVE_LIBXML_XMLREADER_H */

/* Define to 1 if you have the <libxml/xmlwriter.h> header file. */
/* #undef HAVE_LIBXML_XMLWRITER_H */

/* Define to 1 if you have the `z' library (-lz). */
#define HAVE_LIBZ 1

/* Define to 1 if you have the <limits.h> header file. */
#define HAVE_LIMITS_H 1

/* Define to 1 if you have the `link' function. */
#define HAVE_LINK 1

/* Define to 1 if you have the <linux/types.h> header file. */
#define HAVE_LINUX_TYPES_H 1

/* Define to 1 if you have the <linux/fiemap.h> header file. */
#define HAVE_LINUX_FIEMAP_H 1

/* Define to 1 if you have the <linux/fs.h> header file. */
#define HAVE_LINUX_FS_H 1

/* Define to 1 if you have the <linux/magic.h> header file. */
#define HAVE_LINUX_MAGIC_H 1

/* Define to 1 if you have the <linux/types.h> header file. */
#define HAVE_LINUX_TYPES_H 1

/* Define to 1 if you have the `listea' function. */
/* #undef HAVE_LISTEA */

/* Define to 1 if you have the `listxattr' function. */
/* #undef HAVE_LISTXATTR */

/* Define to 1 if you have the `llistea' function. */
/* #undef HAVE_LLISTEA */

/* Define to 1 if you have the `llistxattr' function. */
/* #undef HAVE_LLISTXATTR */

/* Define to 1 if you have the <localcharset.h> header file. */
/* #undef HAVE_LOCALCHARSET_H */

/* Define to 1 if you have the `locale_charset' function. */
/* #undef HAVE_LOCALE_CHARSET */

/* Define to 1 if you have the <locale.h> header file. */
#define HAVE_LOCALE_H 1

/* Define to 1 if you have the `localtime_r' function. */
#define HAVE_LOCALTIME_R 1

/* Define to 1 if the system has the type `long long int'. */
/* #undef HAVE_LONG_LONG_INT */

/* Define to 1 if you have the `lsetea' function. */
/* #undef HAVE_LSETEA */

/* Define to 1 if you have the `lsetxattr' function. */
/* #undef HAVE_LSETXATTR */

/* Define to 1 if you have the `lstat' function. */
#define HAVE_LSTAT 1

/* Define to 1 if `lstat' has the bug that it succeeds when given the
   zero-length file name argument. */
/* #undef HAVE_LSTAT_EMPTY_STRING_BUG */

/* Define to 1 if you have the `lutimes' function. */
#define HAVE_LUTIMES 1

/* Define to 1 if you have the <lzmadec.h> header file. */
/* #undef HAVE_LZMADEC_H */

/* Define to 1 if you have the <lzma.h> header file. */
/* #undef HAVE_LZMA_H */

/* Define to 1 if you have the <lzo/lzo1x.h> header file. */
/* #undef HAVE_LZO_LZO1X_H */

/* Define to 1 if you have the <lzo/lzoconf.h> header file. */
/* #undef HAVE_LZO_LZOCONF_H */

/* Define to 1 if you have the `mbrtowc' function. */
#define HAVE_MBRTOWC 1

/* Define to 1 if you have the `memmove' function. */
#define HAVE_MEMMOVE 1

/* Define to 1 if you have the <memory.h> header file. */
#define HAVE_MEMORY_H 1

/* Define to 1 if you have the `mkdir' function. */
#define HAVE_MKDIR 1

/* Define to 1 if you have the `mkfifo' function. */
#define HAVE_MKFIFO 1

/* Define to 1 if you have the `mknod' function. */
#define HAVE_MKNOD 1

/* Define to 1 if you have the `mkstemp' function. */
#define HAVE_MKSTEMP 1

/* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */
/* #undef HAVE_NDIR_H */

/* Define to 1 if you have the <nettle/md5.h> header file. */
/* #undef HAVE_NETTLE_MD5_H */

/* Define to 1 if you have the <nettle/ripemd160.h> header file. */
/* #undef HAVE_NETTLE_RIPEMD160_H */

/* Define to 1 if you have the <nettle/sha.h> header file. */
/* #undef HAVE_NETTLE_SHA_H */

/* Define to 1 if you have the `nl_langinfo' function. */
#define HAVE_NL_LANGINFO 1

/* Define to 1 if you have the `openat' function. */
#define HAVE_OPENAT 1

/* Define to 1 if you have the <paths.h> header file. */
#define HAVE_PATHS_H 1

/* Define to 1 if you have the <pcreposix.h> header file. */
/* #undef HAVE_PCREPOSIX_H */

/* Define to 1 if you have the `pipe' function. */
#define HAVE_PIPE 1

/* Define to 1 if you have the `poll' function. */
#define HAVE_POLL 1

/* Define to 1 if you have the <poll.h> header file. */
#define HAVE_POLL_H 1

/* Define to 1 if you have the `posix_spawnp' function. */
#define HAVE_POSIX_SPAWNP 1

/* Define to 1 if you have the <process.h> header file. */
/* #undef HAVE_PROCESS_H */

/* Define to 1 if you have the <pwd.h> header file. */
#define HAVE_PWD_H 1

/* Define to 1 if you have the `readdir_r' function. */
#define HAVE_READDIR_R 1

/* Define to 1 if you have the `readlink' function. */
#define HAVE_READLINK 1

/* Define to 1 if you have the `readlinkat' function. */
#define HAVE_READLINKAT 1

/* Define to 1 if you have the <regex.h> header file. */
#define HAVE_REGEX_H 1

/* Define to 1 if you have the `select' function. */
#define HAVE_SELECT 1

/* Define to 1 if you have the `setenv' function. */
#define HAVE_SETENV 1

/* Define to 1 if you have the `setlocale' function. */
#define HAVE_SETLOCALE 1

/* Define to 1 if you have the `sigaction' function. */
#define HAVE_SIGACTION 1

/* Define to 1 if you have the <signal.h> header file. */
#define HAVE_SIGNAL_H 1

/* Define to 1 if you have the <spawn.h> header file. */
#define HAVE_SPAWN_H 1

/* Define to 1 if you have the `statfs' function. */
#define HAVE_STATFS 1

/* Define to 1 if you have the `statvfs' function. */
#define HAVE_STATVFS 1

/* Define to 1 if `stat' has the bug that it succeeds when given the
   zero-length file name argument. */
/* #undef HAVE_STAT_EMPTY_STRING_BUG */

/* Define to 1 if you have the <stdarg.h> header file. */
#define HAVE_STDARG_H 1

/* Define to 1 if you have the <stdint.h> header file. */
#define HAVE_STDINT_H 1

/* Define to 1 if you have the <stdlib.h> header file. */
#define HAVE_STDLIB_H 1

/* Define to 1 if you have the `strchr' function. */
#define HAVE_STRCHR 1

/* Define to 1 if you have the `strdup' function. */
#define HAVE_STRDUP 1

/* Define to 1 if you have the `strerror' function. */
#define HAVE_STRERROR 1

/* Define to 1 if you have the `strerror_r' function. */
#define HAVE_STRERROR_R 1

/* Define to 1 if you have the `strftime' function. */
#define HAVE_STRFTIME 1

/* Define to 1 if you have the <strings.h> header file. */
#define HAVE_STRINGS_H 1

/* Define to 1 if you have the <string.h> header file. */
#define HAVE_STRING_H 1

/* Define to 1 if you have the `strrchr' function. */
#define HAVE_STRRCHR 1

/* Define to 1 if `f_namemax' is a member of `struct statfs'. */
/* #undef HAVE_STRUCT_STATFS_F_NAMEMAX */

/* Define to 1 if `f_iosize' is a member of `struct statvfs'. */
/* #undef HAVE_STRUCT_STATVFS_F_IOSIZE */

/* Define to 1 if `st_birthtime' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIME */

/* Define to 1 if `st_birthtimespec.tv_nsec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC_TV_NSEC */

/* Define to 1 if `st_blksize' is a member of `struct stat'. */
#define HAVE_STRUCT_STAT_ST_BLKSIZE 1

/* Define to 1 if `st_flags' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_FLAGS */

/* Define to 1 if `st_mtimespec.tv_nsec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC */

/* Define to 1 if `st_mtime_n' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIME_N */

/* Define to 1 if `st_mtime_usec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIME_USEC */

/* Define to 1 if `st_mtim.tv_nsec' is a member of `struct stat'. */
#define HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC 1

/* Define to 1 if `st_umtime' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_UMTIME */

/* Define to 1 if `tm_gmtoff' is a member of `struct tm'. */
#define HAVE_STRUCT_TM_TM_GMTOFF 1

/* Define to 1 if `__tm_gmtoff' is a member of `struct tm'. */
/* #undef HAVE_STRUCT_TM___TM_GMTOFF */

/* Define to 1 if you have the `symlink' function. */
#define HAVE_SYMLINK 1

/* Define to 1 if you have the <sys/acl.h> header file. */
/* #undef HAVE_SYS_ACL_H */

/* Define to 1 if you have the <sys/cdefs.h> header file. */
#define HAVE_SYS_CDEFS_H 1

/* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.
   */
/* #undef HAVE_SYS_DIR_H */

/* Define to 1 if you have the <sys/ea.h> header file. */
/* #undef HAVE_SYS_EA_H */

/* Define to 1 if you have the <sys/extattr.h> header file. */
/* #undef HAVE_SYS_EXTATTR_H */

/* Define to 1 if you have the <sys/ioctl.h> header file. */
#define HAVE_SYS_IOCTL_H 1

/* Define to 1 if you have the <sys/mkdev.h> header file. */
/* #undef HAVE_SYS_MKDEV_H */

/* Define to 1 if you have the <sys/mount.h> header file. */
/* #undef HAVE_SYS_MOUNT_H */

/* Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.
   */
/* #undef HAVE_SYS_NDIR_H */

/* Define to 1 if you have the <sys/param.h> header file. */
#define HAVE_SYS_PARAM_H 1

/* Define to 1 if you have the <sys/poll.h> header file. */
#define HAVE_SYS_POLL_H 1

/* Define to 1 if you have the <sys/select.h> header file. */
#define HAVE_SYS_SELECT_H 1

/* Define to 1 if you have the <sys/statfs.h> header file. */
#define HAVE_SYS_STATFS_H 1

/* Define to 1 if you have the <sys/statvfs.h> header file. */
#define HAVE_SYS_STATVFS_H 1

/* Define to 1 if you have the <sys/stat.h> header file. */
#define HAVE_SYS_STAT_H 1

/* Define to 1 if you have the <sys/time.h> header file. */
#define HAVE_SYS_TIME_H 1

/* Define to 1 if you have the <sys/types.h> header file. */
#define HAVE_SYS_TYPES_H 1

/* Define to 1 if you have the <sys/utime.h> header file. */
/* #undef HAVE_SYS_UTIME_H */

/* Define to 1 if you have the <sys/utsname.h> header file. */
#define HAVE_SYS_UTSNAME_H 1

/* Define to 1 if you have the <sys/vfs.h> header file. */
#define HAVE_SYS_VFS_H 1

/* Define to 1 if you have <sys/wait.h> that is POSIX.1 compatible. */
#define HAVE_SYS_WAIT_H 1

/* Define to 1 if you have the <sys/xattr.h> header file. */
/* #undef HAVE_SYS_XATTR_H */

/* Define to 1 if you have the `timegm' function. */
#define HAVE_TIMEGM 1

/* Define to 1 if you have the <time.h> header file. */
#define HAVE_TIME_H 1

/* Define to 1 if you have the `tzset' function. */
#define HAVE_TZSET 1

/* Define to 1 if you have the <unistd.h> header file. */
#define HAVE_UNISTD_H 1

/* Define to 1 if you have the `unsetenv' function. */
#define HAVE_UNSETENV 1

/* Define to 1 if the system has the type `unsigned long long'. */
/* #undef HAVE_UNSIGNED_LONG_LONG */

/* Define to 1 if the system has the type `unsigned long long int'. */
/* #undef HAVE_UNSIGNED_LONG_LONG_INT */

/* Define to 1 if you have the `utime' function. */
#define HAVE_UTIME 1

/* Define to 1 if you have the `utimensat' function. */
#define HAVE_UTIMENSAT 1

/* Define to 1 if you have the `utimes' function. */
#define HAVE_UTIMES 1

/* Define to 1 if you have the <utime.h> header file. */
#define HAVE_UTIME_H 1

/* Define to 1 if you have the `vfork' function. */
#define HAVE_VFORK 1

/* Define to 1 if you have the `vprintf' function. */
#define HAVE_VPRINTF 1

/* Define to 1 if you have the <wchar.h> header file. */
#define HAVE_WCHAR_H 1

/* Define to 1 if the system has the type `wchar_t'. */
#define HAVE_WCHAR_T 1

/* Define to 1 if you have the `wcrtomb' function. */
#define HAVE_WCRTOMB 1

/* Define to 1 if you have the `wcscmp' function. */
#define HAVE_WCSCMP 1

/* Define to 1 if you have the `wcscpy' function. */
#define HAVE_WCSCPY 1

/* Define to 1 if you have the `wcslen' function. */
#define HAVE_WCSLEN 1

/* Define to 1 if you have the `wctomb' function. */
#define HAVE_WCTOMB 1

/* Define to 1 if you have the <wctype.h> header file. */
#define HAVE_WCTYPE_H 1

/* Define to 1 if you have the <wincrypt.h> header file. */
/* #undef HAVE_WINCRYPT_H */

/* Define to 1 if you have the <windows.h> header file. */
/* #undef HAVE_WINDOWS_H */

/* Define to 1 if you have the <winioctl.h> header file. */
/* #undef HAVE_WINIOCTL_H */

/* Define to 1 if you have _CrtSetReportMode in <crtdbg.h>  */
/* #undef HAVE__CrtSetReportMode */

/* Define to 1 if you have the `wmemcmp' function. */
#define HAVE_WMEMCMP 1

/* Define to 1 if you have the `wmemcpy' function. */
#define HAVE_WMEMCPY 1

/* Define to 1 if you have a working EXT2_IOC_GETFLAGS */
/* #undef HAVE_WORKING_EXT2_IOC_GETFLAGS */

/* Define to 1 if you have the <zlib.h> header file. */
#define HAVE_ZLIB_H 1

/* Define to 1 if you have the `_ctime64_s' function. */
/* #undef HAVE__CTIME64_S */

/* Define to 1 if you have the `_fseeki64' function. */
/* #undef HAVE__FSEEKI64 */

/* Define to 1 if you have the `_get_timezone' function. */
/* #undef HAVE__GET_TIMEZONE */

/* Define to 1 if you have the `_localtime64_s' function. */
/* #undef HAVE__LOCALTIME64_S */

/* Define to 1 if you have the `_mkgmtime64' function. */
/* #undef HAVE__MKGMTIME64 */

/* Define as const if the declaration of iconv() needs const. */
#define ICONV_CONST 

/* Version number of libarchive as a single integer */
#define LIBARCHIVE_VERSION_NUMBER "3001002"

/* Version number of libarchive */
#define LIBARCHIVE_VERSION_STRING "3.1.2"

/* Define to 1 if `lstat' dereferences a symlink specified with a trailing
   slash. */
/* #undef LSTAT_FOLLOWS_SLASHED_SYMLINK */

/* Define to 1 if `major', `minor', and `makedev' are declared in <mkdev.h>.
   */
/* #undef MAJOR_IN_MKDEV */

/* Define to 1 if `major', `minor', and `makedev' are declared in
   <sysmacros.h>. */
#define MAJOR_IN_SYSMACROS 1

/* Define to 1 if your C compiler doesn't accept -c and -o together. */
/* #undef NO_MINUS_C_MINUS_O */

/* The size of `wchar_t', as computed by sizeof. */
#define SIZEOF_WCHAR_T 4

/* Define to 1 if strerror_r returns char *. */
/* #undef STRERROR_R_CHAR_P */

/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
#define TIME_WITH_SYS_TIME 1

/*
 * Some platform requires a macro to use extension functions.
 */
#define SAFE_TO_DEFINE_EXTENSIONS 1
#ifdef SAFE_TO_DEFINE_EXTENSIONS
/* Enable extensions on AIX 3, Interix.  */
#ifndef _ALL_SOURCE
# define _ALL_SOURCE 1
#endif
/* Enable GNU extensions on systems that have them.  */
#ifndef _GNU_SOURCE
# define _GNU_SOURCE 1
#endif
/* Enable threading extensions on Solaris.  */
#ifndef _POSIX_PTHREAD_SEMANTICS
# define _POSIX_PTHREAD_SEMANTICS 1
#endif
/* Enable extensions on HP NonStop.  */
#ifndef _TANDEM_SOURCE
# define _TANDEM_SOURCE 1
#endif
/* Enable general extensions on Solaris.  */
#ifndef __EXTENSIONS__
# define __EXTENSIONS__ 1
#endif
#endif /* SAFE_TO_DEFINE_EXTENSIONS */

/* Version number of package */
#define VERSION "3.1.2"

/* Number of bits in a file offset, on hosts where this is settable. */
/* #undef _FILE_OFFSET_BITS */

/* Define to 1 to make fseeko visible on some hosts (e.g. glibc 2.2). */
/* #undef _LARGEFILE_SOURCE */

/* Define for large files, on AIX-style hosts. */
/* #undef _LARGE_FILES */

/* Define for Windows to use Windows 2000+ APIs. */
/* #undef _WIN32_WINNT */
/* #undef WINVER */

/* Define to empty if `const' does not conform to ANSI C. */
/* #undef const */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef gid_t */

/* Define to `unsigned long' if <sys/types.h> does not define. */
/* #undef id_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef mode_t */

/* Define to `long long' if <sys/types.h> does not define. */
/* #undef off_t */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef pid_t */

/* Define to `unsigned int' if <sys/types.h> does not define. */
/* #undef size_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef ssize_t */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef uid_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef intptr_t */

/* Define to `unsigned int' if <sys/types.h> does not define. */
/* #undef uintptr_t */


#define ARCHIVE_SHA384_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA384_LIBC2
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = (DWORD)bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. Nettle
 * 6. OpenSSL
 * 7. libmd
 * 8. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive_sha384_ctx ctx;
  archive_sha384_init(&ctx);
  archive_sha384_update(&ctx, *argv, argc);
  archive_sha384_final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA512_LIBC2 failed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec754748795/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec754748795.dir/build.make CMakeFiles/cmTryCompileExec754748795.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec754748795.dir/check_crypto_md.c.o
/usr/bin/gcc   -w  -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2 -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmlibarchive/libarchive -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec754748795.dir/check_crypto_md.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1186:0:
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: fatal error: sha2.h: No such file or directory
 #include <sha2.h>
                  ^
compilation terminated.
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec754748795.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec754748795/fast] Error 2

Source file was:
/* config.h.  Generated from build/cmake/config.h.in by cmake configure */
#if defined(__osf__)
# define _OSF_SOURCE
#endif

/*
 * Ensure we have C99-style int64_t, etc, all defined.
 */

/* First, we need to know if the system has already defined them. */
#define HAVE_INT16_T
#define HAVE_INT32_T
#define HAVE_INT64_T
#define HAVE_INTMAX_T

#define HAVE_UINT8_T
#define HAVE_UINT16_T
#define HAVE_UINT32_T
#define HAVE_UINT64_T
#define HAVE_UINTMAX_T

/* We might have the types we want under other spellings. */
/* #undef HAVE___INT64 */
/* #undef HAVE_U_INT64_T */
/* #undef HAVE_UNSIGNED___INT64 */

/* The sizes of various standard integer types. */
#define SIZE_OF_SHORT 2
#define SIZE_OF_INT 4
#define SIZE_OF_LONG 8
#define SIZE_OF_LONG_LONG 8
#define SIZE_OF_UNSIGNED_SHORT 2
#define SIZE_OF_UNSIGNED 4
#define SIZE_OF_UNSIGNED_LONG 8
#define SIZE_OF_UNSIGNED_LONG_LONG 8

/*
 * If we lack int64_t, define it to the first of __int64, int, long, and long long
 * that exists and is the right size.
 */
#if !defined(HAVE_INT64_T) && defined(HAVE___INT64)
typedef __int64 int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_INT == 8
typedef int int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_LONG == 8
typedef long int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_LONG_LONG == 8
typedef long long int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T)
#error No 64-bit integer type was found.
#endif

/*
 * Similarly for int32_t
 */
#if !defined(HAVE_INT32_T) && SIZE_OF_INT == 4
typedef long int32_t;
#define HAVE_INT32_T
#endif

#if !defined(HAVE_INT32_T) && SIZE_OF_LONG == 4
typedef long int32_t;
#define HAVE_INT32_T
#endif

#if !defined(HAVE_INT32_T)
#error No 32-bit integer type was found.
#endif

/*
 * Similarly for int16_t
 */
#if !defined(HAVE_INT16_T) && SIZE_OF_INT == 2
typedef int int16_t;
#define HAVE_INT16_T
#endif

#if !defined(HAVE_INT16_T) && SIZE_OF_SHORT == 2
typedef short int16_t;
#define HAVE_INT16_T
#endif

#if !defined(HAVE_INT16_T)
#error No 16-bit integer type was found.
#endif

/*
 * Similarly for uint64_t
 */
#if !defined(HAVE_UINT64_T) && defined(HAVE_UNSIGNED___INT64)
typedef unsigned __int64 uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED == 8
typedef unsigned uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED_LONG == 8
typedef unsigned long uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED_LONG_LONG == 8
typedef unsigned long long uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T)
#error No 64-bit unsigned integer type was found.
#endif


/*
 * Similarly for uint32_t
 */
#if !defined(HAVE_UINT32_T) && SIZE_OF_UNSIGNED == 4
typedef unsigned uint32_t;
#define HAVE_UINT32_T
#endif

#if !defined(HAVE_UINT32_T) && SIZE_OF_UNSIGNED_LONG == 4
typedef unsigned long uint32_t;
#define HAVE_UINT32_T
#endif

#if !defined(HAVE_UINT32_T)
#error No 32-bit unsigned integer type was found.
#endif

/*
 * Similarly for uint16_t
 */
#if !defined(HAVE_UINT16_T) && SIZE_OF_UNSIGNED == 2
typedef unsigned uint16_t;
#define HAVE_UINT16_T
#endif

#if !defined(HAVE_UINT16_T) && SIZE_OF_UNSIGNED_SHORT == 2
typedef unsigned short uint16_t;
#define HAVE_UINT16_T
#endif

#if !defined(HAVE_UINT16_T)
#error No 16-bit unsigned integer type was found.
#endif

/*
 * Similarly for uint8_t
 */
#if !defined(HAVE_UINT8_T)
typedef unsigned char uint8_t;
#define HAVE_UINT8_T
#endif

#if !defined(HAVE_UINT16_T)
#error No 8-bit unsigned integer type was found.
#endif

/* Define intmax_t and uintmax_t if they are not already defined. */
#if !defined(HAVE_INTMAX_T)
typedef int64_t intmax_t;
#define INTMAX_MIN INT64_MIN
#define INTMAX_MAX INT64_MAX
#endif

#if !defined(HAVE_UINTMAX_T)
typedef uint64_t uintmax_t;
#endif

/* Define ZLIB_WINAPI if zlib was built on Visual Studio. */
/* #undef ZLIB_WINAPI */

/* MD5 via ARCHIVE_CRYPTO_MD5_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_MD5_LIBC */

/* MD5 via ARCHIVE_CRYPTO_MD5_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_MD5_LIBSYSTEM */

/* MD5 via ARCHIVE_CRYPTO_MD5_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_MD5_NETTLE */

/* MD5 via ARCHIVE_CRYPTO_MD5_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_MD5_OPENSSL */

/* MD5 via ARCHIVE_CRYPTO_MD5_WIN supported. */
/* #undef ARCHIVE_CRYPTO_MD5_WIN */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_LIBC */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_NETTLE */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_OPENSSL */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_LIBC */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_LIBSYSTEM */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_NETTLE */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_OPENSSL */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_WIN */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC2 */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC3 */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBSYSTEM */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_NETTLE */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_OPENSSL */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_WIN */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC2 */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC3 */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBSYSTEM */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_NETTLE */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_OPENSSL */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_WIN */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC2 */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC3 */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBSYSTEM */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_NETTLE */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_OPENSSL */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_WIN */

/* Version number of bsdcpio */
#define BSDCPIO_VERSION_STRING "3.1.2"

/* Version number of bsdtar */
#define BSDTAR_VERSION_STRING "3.1.2"

/* Define to 1 if you have the `acl_create_entry' function. */
/* #undef HAVE_ACL_CREATE_ENTRY */

/* Define to 1 if you have the `acl_get_link' function. */
/* #undef HAVE_ACL_GET_LINK */

/* Define to 1 if you have the `acl_get_link_np' function. */
/* #undef HAVE_ACL_GET_LINK_NP */

/* Define to 1 if you have the `acl_get_perm' function. */
/* #undef HAVE_ACL_GET_PERM */

/* Define to 1 if you have the `acl_get_perm_np' function. */
/* #undef HAVE_ACL_GET_PERM_NP */

/* Define to 1 if you have the `acl_init' function. */
/* #undef HAVE_ACL_INIT */

/* Define to 1 if you have the <acl/libacl.h> header file. */
/* #undef HAVE_ACL_LIBACL_H */

/* Define to 1 if the system has the type `acl_permset_t'. */
/* #undef HAVE_ACL_PERMSET_T */

/* Define to 1 if you have the `acl_set_fd' function. */
/* #undef HAVE_ACL_SET_FD */

/* Define to 1 if you have the `acl_set_fd_np' function. */
/* #undef HAVE_ACL_SET_FD_NP */

/* Define to 1 if you have the `acl_set_file' function. */
/* #undef HAVE_ACL_SET_FILE */

/* True for systems with POSIX ACL support */
/* #undef HAVE_ACL_USER */

/* Define to 1 if you have the <attr/xattr.h> header file. */
/* #undef HAVE_ATTR_XATTR_H */

/* Define to 1 if you have the <bsdxml.h> header file. */
/* #undef HAVE_BSDXML_H */

/* Define to 1 if you have the <bzlib.h> header file. */
#define HAVE_BZLIB_H 1

/* Define to 1 if you have the `chflags' function. */
/* #undef HAVE_CHFLAGS */

/* Define to 1 if you have the `chown' function. */
#define HAVE_CHOWN 1

/* Define to 1 if you have the `chroot' function. */
#define HAVE_CHROOT 1

/* Define to 1 if you have the <copyfile.h> header file. */
/* #undef HAVE_COPYFILE_H */

/* Define to 1 if you have the `ctime_r' function. */
#define HAVE_CTIME_R 1

/* Define to 1 if you have the <ctype.h> header file. */
#define HAVE_CTYPE_H 1

/* Define to 1 if you have the `cygwin_conv_path' function. */
/* #undef HAVE_CYGWIN_CONV_PATH */

/* Define to 1 if you have the declaration of `INT64_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_INT64_MAX 1

/* Define to 1 if you have the declaration of `INT64_MIN', and to 0 if you
   don't. */
#define HAVE_DECL_INT64_MIN 1

/* Define to 1 if you have the declaration of `SIZE_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_SIZE_MAX 1

/* Define to 1 if you have the declaration of `SSIZE_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_SSIZE_MAX 1

/* Define to 1 if you have the declaration of `strerror_r', and to 0 if you
   don't. */
#define HAVE_DECL_STRERROR_R 1

/* Define to 1 if you have the declaration of `UINT32_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_UINT32_MAX 1

/* Define to 1 if you have the declaration of `UINT64_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_UINT64_MAX 1

/* Define to 1 if you have the <direct.h> header file. */
/* #undef HAVE_DIRECT_H */

/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.
   */
#define HAVE_DIRENT_H 1

/* Define to 1 if you have the `dirfd' function. */
#define HAVE_DIRFD 1

/* Define to 1 if you have the <dlfcn.h> header file. */
#define HAVE_DLFCN_H 1

/* Define to 1 if you don't have `vprintf' but do have `_doprnt.' */
/* #undef HAVE_DOPRNT */

/* Define to 1 if nl_langinfo supports D_MD_ORDER */
/* #undef HAVE_D_MD_ORDER */

/* A possible errno value for invalid file format errors */
/* #undef HAVE_EFTYPE */

/* A possible errno value for invalid file format errors */
#define HAVE_EILSEQ 1

/* Define to 1 if you have the <errno.h> header file. */
#define HAVE_ERRNO_H 1

/* Define to 1 if you have the <expat.h> header file. */
/* #undef HAVE_EXPAT_H */

/* Define to 1 if you have the <ext2fs/ext2_fs.h> header file. */
/* #undef HAVE_EXT2FS_EXT2_FS_H */

/* Define to 1 if you have the `extattr_get_file' function. */
/* #undef HAVE_EXTATTR_GET_FILE */

/* Define to 1 if you have the `extattr_list_file' function. */
/* #undef HAVE_EXTATTR_LIST_FILE */

/* Define to 1 if you have the `extattr_set_fd' function. */
/* #undef HAVE_EXTATTR_SET_FD */

/* Define to 1 if you have the `extattr_set_file' function. */
/* #undef HAVE_EXTATTR_SET_FILE */

/* Define to 1 if EXTATTR_NAMESPACE_USER is defined in sys/extattr.h. */
/* #undef HAVE_DECL_EXTATTR_NAMESPACE_USER */

/* Define to 1 if you have the `fchdir' function. */
#define HAVE_FCHDIR 1

/* Define to 1 if you have the `fchflags' function. */
/* #undef HAVE_FCHFLAGS */

/* Define to 1 if you have the `fchmod' function. */
#define HAVE_FCHMOD 1

/* Define to 1 if you have the `fchown' function. */
#define HAVE_FCHOWN 1

/* Define to 1 if you have the `fcntl' function. */
#define HAVE_FCNTL 1

/* Define to 1 if you have the <fcntl.h> header file. */
#define HAVE_FCNTL_H 1

/* Define to 1 if you have the `fdopendir' function. */
#define HAVE_FDOPENDIR 1

/* Define to 1 if you have the `fgetea' function. */
/* #undef HAVE_FGETEA */

/* Define to 1 if you have the `fgetxattr' function. */
/* #undef HAVE_FGETXATTR */

/* Define to 1 if you have the `flistea' function. */
/* #undef HAVE_FLISTEA */

/* Define to 1 if you have the `flistxattr' function. */
/* #undef HAVE_FLISTXATTR */

/* Define to 1 if you have the `fork' function. */
#define HAVE_FORK 1

/* Define to 1 if fseeko (and presumably ftello) exists and is declared. */
#define HAVE_FSEEKO 1

/* Define to 1 if you have the `fsetea' function. */
/* #undef HAVE_FSETEA */

/* Define to 1 if you have the `fsetxattr' function. */
/* #undef HAVE_FSETXATTR */

/* Define to 1 if you have the `fstat' function. */
#define HAVE_FSTAT 1

/* Define to 1 if you have the `fstatat' function. */
#define HAVE_FSTATAT 1

/* Define to 1 if you have the `fstatfs' function. */
#define HAVE_FSTATFS 1

/* Define to 1 if you have the `fstatvfs' function. */
#define HAVE_FSTATVFS 1

/* Define to 1 if you have the `ftruncate' function. */
#define HAVE_FTRUNCATE 1

/* Define to 1 if you have the `futimens' function. */
#define HAVE_FUTIMENS 1

/* Define to 1 if you have the `futimes' function. */
#define HAVE_FUTIMES 1

/* Define to 1 if you have the `futimesat' function. */
#define HAVE_FUTIMESAT 1

/* Define to 1 if you have the `getea' function. */
/* #undef HAVE_GETEA */

/* Define to 1 if you have the `geteuid' function. */
#define HAVE_GETEUID 1

/* Define to 1 if you have the `getgrgid_r' function. */
#define HAVE_GETGRGID_R 1

/* Define to 1 if you have the `getgrnam_r' function. */
#define HAVE_GETGRNAM_R 1

/* Define to 1 if you have the `getpid' function. */
#define HAVE_GETPID 1

/* Define to 1 if you have the `getpwnam_r' function. */
#define HAVE_GETPWNAM_R 1

/* Define to 1 if you have the `getpwuid_r' function. */
#define HAVE_GETPWUID_R 1

/* Define to 1 if you have the `getvfsbyname' function. */
/* #undef HAVE_GETVFSBYNAME */

/* Define to 1 if you have the `getxattr' function. */
/* #undef HAVE_GETXATTR */

/* Define to 1 if you have the `gmtime_r' function. */
#define HAVE_GMTIME_R 1

/* Define to 1 if you have the <grp.h> header file. */
#define HAVE_GRP_H 1

/* Define to 1 if you have the `iconv' function. */
/* #undef HAVE_ICONV */

/* Define to 1 if you have the <iconv.h> header file. */
/* #undef HAVE_ICONV_H */

/* Define to 1 if you have the <inttypes.h> header file. */
#define HAVE_INTTYPES_H 1

/* Define to 1 if you have the <io.h> header file. */
/* #undef HAVE_IO_H */

/* Define to 1 if you have the <langinfo.h> header file. */
#define HAVE_LANGINFO_H 1

/* Define to 1 if you have the `lchflags' function. */
/* #undef HAVE_LCHFLAGS */

/* Define to 1 if you have the `lchmod' function. */
/* #undef HAVE_LCHMOD */

/* Define to 1 if you have the `lchown' function. */
#define HAVE_LCHOWN 1

/* Define to 1 if you have the `lgetea' function. */
/* #undef HAVE_LGETEA */

/* Define to 1 if you have the `lgetxattr' function. */
/* #undef HAVE_LGETXATTR */

/* Define to 1 if you have the `acl' library (-lacl). */
/* #undef HAVE_LIBACL */

/* Define to 1 if you have the `attr' library (-lattr). */
/* #undef HAVE_LIBATTR */

/* Define to 1 if you have the `bsdxml' library (-lbsdxml). */
/* #undef HAVE_LIBBSDXML */

/* Define to 1 if you have the `bz2' library (-lbz2). */
#define HAVE_LIBBZ2 1

/* Define to 1 if you have the `expat' library (-lexpat). */
/* #undef HAVE_LIBEXPAT */

/* Define to 1 if you have the `gcc' library (-lgcc). */
/* #undef HAVE_LIBGCC */

/* Define to 1 if you have the `lzma' library (-llzma). */
/* #undef HAVE_LIBLZMA */

/* Define to 1 if you have the `lzmadec' library (-llzmadec). */
/* #undef HAVE_LIBLZMADEC */

/* Define to 1 if you have the `lzo2' library (-llzo2). */
/* #undef HAVE_LIBLZO2 */

/* Define to 1 if you have the `nettle' library (-lnettle). */
/* #undef HAVE_LIBNETTLE */

/* Define to 1 if you have the `pcre' library (-lpcre). */
/* #undef HAVE_LIBPCRE */

/* Define to 1 if you have the `pcreposix' library (-lpcreposix). */
/* #undef HAVE_LIBPCREPOSIX */

/* Define to 1 if you have the `xml2' library (-lxml2). */
/* #undef HAVE_LIBXML2 */

/* Define to 1 if you have the <libxml/xmlreader.h> header file. */
/* #undef HAVE_LIBXML_XMLREADER_H */

/* Define to 1 if you have the <libxml/xmlwriter.h> header file. */
/* #undef HAVE_LIBXML_XMLWRITER_H */

/* Define to 1 if you have the `z' library (-lz). */
#define HAVE_LIBZ 1

/* Define to 1 if you have the <limits.h> header file. */
#define HAVE_LIMITS_H 1

/* Define to 1 if you have the `link' function. */
#define HAVE_LINK 1

/* Define to 1 if you have the <linux/types.h> header file. */
#define HAVE_LINUX_TYPES_H 1

/* Define to 1 if you have the <linux/fiemap.h> header file. */
#define HAVE_LINUX_FIEMAP_H 1

/* Define to 1 if you have the <linux/fs.h> header file. */
#define HAVE_LINUX_FS_H 1

/* Define to 1 if you have the <linux/magic.h> header file. */
#define HAVE_LINUX_MAGIC_H 1

/* Define to 1 if you have the <linux/types.h> header file. */
#define HAVE_LINUX_TYPES_H 1

/* Define to 1 if you have the `listea' function. */
/* #undef HAVE_LISTEA */

/* Define to 1 if you have the `listxattr' function. */
/* #undef HAVE_LISTXATTR */

/* Define to 1 if you have the `llistea' function. */
/* #undef HAVE_LLISTEA */

/* Define to 1 if you have the `llistxattr' function. */
/* #undef HAVE_LLISTXATTR */

/* Define to 1 if you have the <localcharset.h> header file. */
/* #undef HAVE_LOCALCHARSET_H */

/* Define to 1 if you have the `locale_charset' function. */
/* #undef HAVE_LOCALE_CHARSET */

/* Define to 1 if you have the <locale.h> header file. */
#define HAVE_LOCALE_H 1

/* Define to 1 if you have the `localtime_r' function. */
#define HAVE_LOCALTIME_R 1

/* Define to 1 if the system has the type `long long int'. */
/* #undef HAVE_LONG_LONG_INT */

/* Define to 1 if you have the `lsetea' function. */
/* #undef HAVE_LSETEA */

/* Define to 1 if you have the `lsetxattr' function. */
/* #undef HAVE_LSETXATTR */

/* Define to 1 if you have the `lstat' function. */
#define HAVE_LSTAT 1

/* Define to 1 if `lstat' has the bug that it succeeds when given the
   zero-length file name argument. */
/* #undef HAVE_LSTAT_EMPTY_STRING_BUG */

/* Define to 1 if you have the `lutimes' function. */
#define HAVE_LUTIMES 1

/* Define to 1 if you have the <lzmadec.h> header file. */
/* #undef HAVE_LZMADEC_H */

/* Define to 1 if you have the <lzma.h> header file. */
/* #undef HAVE_LZMA_H */

/* Define to 1 if you have the <lzo/lzo1x.h> header file. */
/* #undef HAVE_LZO_LZO1X_H */

/* Define to 1 if you have the <lzo/lzoconf.h> header file. */
/* #undef HAVE_LZO_LZOCONF_H */

/* Define to 1 if you have the `mbrtowc' function. */
#define HAVE_MBRTOWC 1

/* Define to 1 if you have the `memmove' function. */
#define HAVE_MEMMOVE 1

/* Define to 1 if you have the <memory.h> header file. */
#define HAVE_MEMORY_H 1

/* Define to 1 if you have the `mkdir' function. */
#define HAVE_MKDIR 1

/* Define to 1 if you have the `mkfifo' function. */
#define HAVE_MKFIFO 1

/* Define to 1 if you have the `mknod' function. */
#define HAVE_MKNOD 1

/* Define to 1 if you have the `mkstemp' function. */
#define HAVE_MKSTEMP 1

/* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */
/* #undef HAVE_NDIR_H */

/* Define to 1 if you have the <nettle/md5.h> header file. */
/* #undef HAVE_NETTLE_MD5_H */

/* Define to 1 if you have the <nettle/ripemd160.h> header file. */
/* #undef HAVE_NETTLE_RIPEMD160_H */

/* Define to 1 if you have the <nettle/sha.h> header file. */
/* #undef HAVE_NETTLE_SHA_H */

/* Define to 1 if you have the `nl_langinfo' function. */
#define HAVE_NL_LANGINFO 1

/* Define to 1 if you have the `openat' function. */
#define HAVE_OPENAT 1

/* Define to 1 if you have the <paths.h> header file. */
#define HAVE_PATHS_H 1

/* Define to 1 if you have the <pcreposix.h> header file. */
/* #undef HAVE_PCREPOSIX_H */

/* Define to 1 if you have the `pipe' function. */
#define HAVE_PIPE 1

/* Define to 1 if you have the `poll' function. */
#define HAVE_POLL 1

/* Define to 1 if you have the <poll.h> header file. */
#define HAVE_POLL_H 1

/* Define to 1 if you have the `posix_spawnp' function. */
#define HAVE_POSIX_SPAWNP 1

/* Define to 1 if you have the <process.h> header file. */
/* #undef HAVE_PROCESS_H */

/* Define to 1 if you have the <pwd.h> header file. */
#define HAVE_PWD_H 1

/* Define to 1 if you have the `readdir_r' function. */
#define HAVE_READDIR_R 1

/* Define to 1 if you have the `readlink' function. */
#define HAVE_READLINK 1

/* Define to 1 if you have the `readlinkat' function. */
#define HAVE_READLINKAT 1

/* Define to 1 if you have the <regex.h> header file. */
#define HAVE_REGEX_H 1

/* Define to 1 if you have the `select' function. */
#define HAVE_SELECT 1

/* Define to 1 if you have the `setenv' function. */
#define HAVE_SETENV 1

/* Define to 1 if you have the `setlocale' function. */
#define HAVE_SETLOCALE 1

/* Define to 1 if you have the `sigaction' function. */
#define HAVE_SIGACTION 1

/* Define to 1 if you have the <signal.h> header file. */
#define HAVE_SIGNAL_H 1

/* Define to 1 if you have the <spawn.h> header file. */
#define HAVE_SPAWN_H 1

/* Define to 1 if you have the `statfs' function. */
#define HAVE_STATFS 1

/* Define to 1 if you have the `statvfs' function. */
#define HAVE_STATVFS 1

/* Define to 1 if `stat' has the bug that it succeeds when given the
   zero-length file name argument. */
/* #undef HAVE_STAT_EMPTY_STRING_BUG */

/* Define to 1 if you have the <stdarg.h> header file. */
#define HAVE_STDARG_H 1

/* Define to 1 if you have the <stdint.h> header file. */
#define HAVE_STDINT_H 1

/* Define to 1 if you have the <stdlib.h> header file. */
#define HAVE_STDLIB_H 1

/* Define to 1 if you have the `strchr' function. */
#define HAVE_STRCHR 1

/* Define to 1 if you have the `strdup' function. */
#define HAVE_STRDUP 1

/* Define to 1 if you have the `strerror' function. */
#define HAVE_STRERROR 1

/* Define to 1 if you have the `strerror_r' function. */
#define HAVE_STRERROR_R 1

/* Define to 1 if you have the `strftime' function. */
#define HAVE_STRFTIME 1

/* Define to 1 if you have the <strings.h> header file. */
#define HAVE_STRINGS_H 1

/* Define to 1 if you have the <string.h> header file. */
#define HAVE_STRING_H 1

/* Define to 1 if you have the `strrchr' function. */
#define HAVE_STRRCHR 1

/* Define to 1 if `f_namemax' is a member of `struct statfs'. */
/* #undef HAVE_STRUCT_STATFS_F_NAMEMAX */

/* Define to 1 if `f_iosize' is a member of `struct statvfs'. */
/* #undef HAVE_STRUCT_STATVFS_F_IOSIZE */

/* Define to 1 if `st_birthtime' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIME */

/* Define to 1 if `st_birthtimespec.tv_nsec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC_TV_NSEC */

/* Define to 1 if `st_blksize' is a member of `struct stat'. */
#define HAVE_STRUCT_STAT_ST_BLKSIZE 1

/* Define to 1 if `st_flags' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_FLAGS */

/* Define to 1 if `st_mtimespec.tv_nsec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC */

/* Define to 1 if `st_mtime_n' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIME_N */

/* Define to 1 if `st_mtime_usec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIME_USEC */

/* Define to 1 if `st_mtim.tv_nsec' is a member of `struct stat'. */
#define HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC 1

/* Define to 1 if `st_umtime' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_UMTIME */

/* Define to 1 if `tm_gmtoff' is a member of `struct tm'. */
#define HAVE_STRUCT_TM_TM_GMTOFF 1

/* Define to 1 if `__tm_gmtoff' is a member of `struct tm'. */
/* #undef HAVE_STRUCT_TM___TM_GMTOFF */

/* Define to 1 if you have the `symlink' function. */
#define HAVE_SYMLINK 1

/* Define to 1 if you have the <sys/acl.h> header file. */
/* #undef HAVE_SYS_ACL_H */

/* Define to 1 if you have the <sys/cdefs.h> header file. */
#define HAVE_SYS_CDEFS_H 1

/* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.
   */
/* #undef HAVE_SYS_DIR_H */

/* Define to 1 if you have the <sys/ea.h> header file. */
/* #undef HAVE_SYS_EA_H */

/* Define to 1 if you have the <sys/extattr.h> header file. */
/* #undef HAVE_SYS_EXTATTR_H */

/* Define to 1 if you have the <sys/ioctl.h> header file. */
#define HAVE_SYS_IOCTL_H 1

/* Define to 1 if you have the <sys/mkdev.h> header file. */
/* #undef HAVE_SYS_MKDEV_H */

/* Define to 1 if you have the <sys/mount.h> header file. */
/* #undef HAVE_SYS_MOUNT_H */

/* Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.
   */
/* #undef HAVE_SYS_NDIR_H */

/* Define to 1 if you have the <sys/param.h> header file. */
#define HAVE_SYS_PARAM_H 1

/* Define to 1 if you have the <sys/poll.h> header file. */
#define HAVE_SYS_POLL_H 1

/* Define to 1 if you have the <sys/select.h> header file. */
#define HAVE_SYS_SELECT_H 1

/* Define to 1 if you have the <sys/statfs.h> header file. */
#define HAVE_SYS_STATFS_H 1

/* Define to 1 if you have the <sys/statvfs.h> header file. */
#define HAVE_SYS_STATVFS_H 1

/* Define to 1 if you have the <sys/stat.h> header file. */
#define HAVE_SYS_STAT_H 1

/* Define to 1 if you have the <sys/time.h> header file. */
#define HAVE_SYS_TIME_H 1

/* Define to 1 if you have the <sys/types.h> header file. */
#define HAVE_SYS_TYPES_H 1

/* Define to 1 if you have the <sys/utime.h> header file. */
/* #undef HAVE_SYS_UTIME_H */

/* Define to 1 if you have the <sys/utsname.h> header file. */
#define HAVE_SYS_UTSNAME_H 1

/* Define to 1 if you have the <sys/vfs.h> header file. */
#define HAVE_SYS_VFS_H 1

/* Define to 1 if you have <sys/wait.h> that is POSIX.1 compatible. */
#define HAVE_SYS_WAIT_H 1

/* Define to 1 if you have the <sys/xattr.h> header file. */
/* #undef HAVE_SYS_XATTR_H */

/* Define to 1 if you have the `timegm' function. */
#define HAVE_TIMEGM 1

/* Define to 1 if you have the <time.h> header file. */
#define HAVE_TIME_H 1

/* Define to 1 if you have the `tzset' function. */
#define HAVE_TZSET 1

/* Define to 1 if you have the <unistd.h> header file. */
#define HAVE_UNISTD_H 1

/* Define to 1 if you have the `unsetenv' function. */
#define HAVE_UNSETENV 1

/* Define to 1 if the system has the type `unsigned long long'. */
/* #undef HAVE_UNSIGNED_LONG_LONG */

/* Define to 1 if the system has the type `unsigned long long int'. */
/* #undef HAVE_UNSIGNED_LONG_LONG_INT */

/* Define to 1 if you have the `utime' function. */
#define HAVE_UTIME 1

/* Define to 1 if you have the `utimensat' function. */
#define HAVE_UTIMENSAT 1

/* Define to 1 if you have the `utimes' function. */
#define HAVE_UTIMES 1

/* Define to 1 if you have the <utime.h> header file. */
#define HAVE_UTIME_H 1

/* Define to 1 if you have the `vfork' function. */
#define HAVE_VFORK 1

/* Define to 1 if you have the `vprintf' function. */
#define HAVE_VPRINTF 1

/* Define to 1 if you have the <wchar.h> header file. */
#define HAVE_WCHAR_H 1

/* Define to 1 if the system has the type `wchar_t'. */
#define HAVE_WCHAR_T 1

/* Define to 1 if you have the `wcrtomb' function. */
#define HAVE_WCRTOMB 1

/* Define to 1 if you have the `wcscmp' function. */
#define HAVE_WCSCMP 1

/* Define to 1 if you have the `wcscpy' function. */
#define HAVE_WCSCPY 1

/* Define to 1 if you have the `wcslen' function. */
#define HAVE_WCSLEN 1

/* Define to 1 if you have the `wctomb' function. */
#define HAVE_WCTOMB 1

/* Define to 1 if you have the <wctype.h> header file. */
#define HAVE_WCTYPE_H 1

/* Define to 1 if you have the <wincrypt.h> header file. */
/* #undef HAVE_WINCRYPT_H */

/* Define to 1 if you have the <windows.h> header file. */
/* #undef HAVE_WINDOWS_H */

/* Define to 1 if you have the <winioctl.h> header file. */
/* #undef HAVE_WINIOCTL_H */

/* Define to 1 if you have _CrtSetReportMode in <crtdbg.h>  */
/* #undef HAVE__CrtSetReportMode */

/* Define to 1 if you have the `wmemcmp' function. */
#define HAVE_WMEMCMP 1

/* Define to 1 if you have the `wmemcpy' function. */
#define HAVE_WMEMCPY 1

/* Define to 1 if you have a working EXT2_IOC_GETFLAGS */
/* #undef HAVE_WORKING_EXT2_IOC_GETFLAGS */

/* Define to 1 if you have the <zlib.h> header file. */
#define HAVE_ZLIB_H 1

/* Define to 1 if you have the `_ctime64_s' function. */
/* #undef HAVE__CTIME64_S */

/* Define to 1 if you have the `_fseeki64' function. */
/* #undef HAVE__FSEEKI64 */

/* Define to 1 if you have the `_get_timezone' function. */
/* #undef HAVE__GET_TIMEZONE */

/* Define to 1 if you have the `_localtime64_s' function. */
/* #undef HAVE__LOCALTIME64_S */

/* Define to 1 if you have the `_mkgmtime64' function. */
/* #undef HAVE__MKGMTIME64 */

/* Define as const if the declaration of iconv() needs const. */
#define ICONV_CONST 

/* Version number of libarchive as a single integer */
#define LIBARCHIVE_VERSION_NUMBER "3001002"

/* Version number of libarchive */
#define LIBARCHIVE_VERSION_STRING "3.1.2"

/* Define to 1 if `lstat' dereferences a symlink specified with a trailing
   slash. */
/* #undef LSTAT_FOLLOWS_SLASHED_SYMLINK */

/* Define to 1 if `major', `minor', and `makedev' are declared in <mkdev.h>.
   */
/* #undef MAJOR_IN_MKDEV */

/* Define to 1 if `major', `minor', and `makedev' are declared in
   <sysmacros.h>. */
#define MAJOR_IN_SYSMACROS 1

/* Define to 1 if your C compiler doesn't accept -c and -o together. */
/* #undef NO_MINUS_C_MINUS_O */

/* The size of `wchar_t', as computed by sizeof. */
#define SIZEOF_WCHAR_T 4

/* Define to 1 if strerror_r returns char *. */
/* #undef STRERROR_R_CHAR_P */

/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
#define TIME_WITH_SYS_TIME 1

/*
 * Some platform requires a macro to use extension functions.
 */
#define SAFE_TO_DEFINE_EXTENSIONS 1
#ifdef SAFE_TO_DEFINE_EXTENSIONS
/* Enable extensions on AIX 3, Interix.  */
#ifndef _ALL_SOURCE
# define _ALL_SOURCE 1
#endif
/* Enable GNU extensions on systems that have them.  */
#ifndef _GNU_SOURCE
# define _GNU_SOURCE 1
#endif
/* Enable threading extensions on Solaris.  */
#ifndef _POSIX_PTHREAD_SEMANTICS
# define _POSIX_PTHREAD_SEMANTICS 1
#endif
/* Enable extensions on HP NonStop.  */
#ifndef _TANDEM_SOURCE
# define _TANDEM_SOURCE 1
#endif
/* Enable general extensions on Solaris.  */
#ifndef __EXTENSIONS__
# define __EXTENSIONS__ 1
#endif
#endif /* SAFE_TO_DEFINE_EXTENSIONS */

/* Version number of package */
#define VERSION "3.1.2"

/* Number of bits in a file offset, on hosts where this is settable. */
/* #undef _FILE_OFFSET_BITS */

/* Define to 1 to make fseeko visible on some hosts (e.g. glibc 2.2). */
/* #undef _LARGEFILE_SOURCE */

/* Define for large files, on AIX-style hosts. */
/* #undef _LARGE_FILES */

/* Define for Windows to use Windows 2000+ APIs. */
/* #undef _WIN32_WINNT */
/* #undef WINVER */

/* Define to empty if `const' does not conform to ANSI C. */
/* #undef const */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef gid_t */

/* Define to `unsigned long' if <sys/types.h> does not define. */
/* #undef id_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef mode_t */

/* Define to `long long' if <sys/types.h> does not define. */
/* #undef off_t */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef pid_t */

/* Define to `unsigned int' if <sys/types.h> does not define. */
/* #undef size_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef ssize_t */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef uid_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef intptr_t */

/* Define to `unsigned int' if <sys/types.h> does not define. */
/* #undef uintptr_t */


#define ARCHIVE_SHA512_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA512_LIBC2
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = (DWORD)bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. Nettle
 * 6. OpenSSL
 * 7. libmd
 * 8. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive_sha512_ctx ctx;
  archive_sha512_init(&ctx);
  archive_sha512_update(&ctx, *argv, argc);
  archive_sha512_final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA256_LIBC3 failed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3022669490/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3022669490.dir/build.make CMakeFiles/cmTryCompileExec3022669490.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3022669490.dir/check_crypto_md.c.o
/usr/bin/gcc   -w  -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2 -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmlibarchive/libarchive -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec3022669490.dir/check_crypto_md.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1186:0:
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: fatal error: sha2.h: No such file or directory
 #include <sha2.h>
                  ^
compilation terminated.
make[5]: *** [CMakeFiles/cmTryCompileExec3022669490.dir/check_crypto_md.c.o] Error 1
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec3022669490/fast] Error 2

Source file was:
/* config.h.  Generated from build/cmake/config.h.in by cmake configure */
#if defined(__osf__)
# define _OSF_SOURCE
#endif

/*
 * Ensure we have C99-style int64_t, etc, all defined.
 */

/* First, we need to know if the system has already defined them. */
#define HAVE_INT16_T
#define HAVE_INT32_T
#define HAVE_INT64_T
#define HAVE_INTMAX_T

#define HAVE_UINT8_T
#define HAVE_UINT16_T
#define HAVE_UINT32_T
#define HAVE_UINT64_T
#define HAVE_UINTMAX_T

/* We might have the types we want under other spellings. */
/* #undef HAVE___INT64 */
/* #undef HAVE_U_INT64_T */
/* #undef HAVE_UNSIGNED___INT64 */

/* The sizes of various standard integer types. */
#define SIZE_OF_SHORT 2
#define SIZE_OF_INT 4
#define SIZE_OF_LONG 8
#define SIZE_OF_LONG_LONG 8
#define SIZE_OF_UNSIGNED_SHORT 2
#define SIZE_OF_UNSIGNED 4
#define SIZE_OF_UNSIGNED_LONG 8
#define SIZE_OF_UNSIGNED_LONG_LONG 8

/*
 * If we lack int64_t, define it to the first of __int64, int, long, and long long
 * that exists and is the right size.
 */
#if !defined(HAVE_INT64_T) && defined(HAVE___INT64)
typedef __int64 int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_INT == 8
typedef int int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_LONG == 8
typedef long int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_LONG_LONG == 8
typedef long long int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T)
#error No 64-bit integer type was found.
#endif

/*
 * Similarly for int32_t
 */
#if !defined(HAVE_INT32_T) && SIZE_OF_INT == 4
typedef long int32_t;
#define HAVE_INT32_T
#endif

#if !defined(HAVE_INT32_T) && SIZE_OF_LONG == 4
typedef long int32_t;
#define HAVE_INT32_T
#endif

#if !defined(HAVE_INT32_T)
#error No 32-bit integer type was found.
#endif

/*
 * Similarly for int16_t
 */
#if !defined(HAVE_INT16_T) && SIZE_OF_INT == 2
typedef int int16_t;
#define HAVE_INT16_T
#endif

#if !defined(HAVE_INT16_T) && SIZE_OF_SHORT == 2
typedef short int16_t;
#define HAVE_INT16_T
#endif

#if !defined(HAVE_INT16_T)
#error No 16-bit integer type was found.
#endif

/*
 * Similarly for uint64_t
 */
#if !defined(HAVE_UINT64_T) && defined(HAVE_UNSIGNED___INT64)
typedef unsigned __int64 uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED == 8
typedef unsigned uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED_LONG == 8
typedef unsigned long uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED_LONG_LONG == 8
typedef unsigned long long uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T)
#error No 64-bit unsigned integer type was found.
#endif


/*
 * Similarly for uint32_t
 */
#if !defined(HAVE_UINT32_T) && SIZE_OF_UNSIGNED == 4
typedef unsigned uint32_t;
#define HAVE_UINT32_T
#endif

#if !defined(HAVE_UINT32_T) && SIZE_OF_UNSIGNED_LONG == 4
typedef unsigned long uint32_t;
#define HAVE_UINT32_T
#endif

#if !defined(HAVE_UINT32_T)
#error No 32-bit unsigned integer type was found.
#endif

/*
 * Similarly for uint16_t
 */
#if !defined(HAVE_UINT16_T) && SIZE_OF_UNSIGNED == 2
typedef unsigned uint16_t;
#define HAVE_UINT16_T
#endif

#if !defined(HAVE_UINT16_T) && SIZE_OF_UNSIGNED_SHORT == 2
typedef unsigned short uint16_t;
#define HAVE_UINT16_T
#endif

#if !defined(HAVE_UINT16_T)
#error No 16-bit unsigned integer type was found.
#endif

/*
 * Similarly for uint8_t
 */
#if !defined(HAVE_UINT8_T)
typedef unsigned char uint8_t;
#define HAVE_UINT8_T
#endif

#if !defined(HAVE_UINT16_T)
#error No 8-bit unsigned integer type was found.
#endif

/* Define intmax_t and uintmax_t if they are not already defined. */
#if !defined(HAVE_INTMAX_T)
typedef int64_t intmax_t;
#define INTMAX_MIN INT64_MIN
#define INTMAX_MAX INT64_MAX
#endif

#if !defined(HAVE_UINTMAX_T)
typedef uint64_t uintmax_t;
#endif

/* Define ZLIB_WINAPI if zlib was built on Visual Studio. */
/* #undef ZLIB_WINAPI */

/* MD5 via ARCHIVE_CRYPTO_MD5_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_MD5_LIBC */

/* MD5 via ARCHIVE_CRYPTO_MD5_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_MD5_LIBSYSTEM */

/* MD5 via ARCHIVE_CRYPTO_MD5_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_MD5_NETTLE */

/* MD5 via ARCHIVE_CRYPTO_MD5_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_MD5_OPENSSL */

/* MD5 via ARCHIVE_CRYPTO_MD5_WIN supported. */
/* #undef ARCHIVE_CRYPTO_MD5_WIN */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_LIBC */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_NETTLE */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_OPENSSL */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_LIBC */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_LIBSYSTEM */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_NETTLE */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_OPENSSL */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_WIN */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC2 */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC3 */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBSYSTEM */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_NETTLE */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_OPENSSL */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_WIN */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC2 */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC3 */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBSYSTEM */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_NETTLE */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_OPENSSL */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_WIN */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC2 */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC3 */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBSYSTEM */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_NETTLE */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_OPENSSL */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_WIN */

/* Version number of bsdcpio */
#define BSDCPIO_VERSION_STRING "3.1.2"

/* Version number of bsdtar */
#define BSDTAR_VERSION_STRING "3.1.2"

/* Define to 1 if you have the `acl_create_entry' function. */
/* #undef HAVE_ACL_CREATE_ENTRY */

/* Define to 1 if you have the `acl_get_link' function. */
/* #undef HAVE_ACL_GET_LINK */

/* Define to 1 if you have the `acl_get_link_np' function. */
/* #undef HAVE_ACL_GET_LINK_NP */

/* Define to 1 if you have the `acl_get_perm' function. */
/* #undef HAVE_ACL_GET_PERM */

/* Define to 1 if you have the `acl_get_perm_np' function. */
/* #undef HAVE_ACL_GET_PERM_NP */

/* Define to 1 if you have the `acl_init' function. */
/* #undef HAVE_ACL_INIT */

/* Define to 1 if you have the <acl/libacl.h> header file. */
/* #undef HAVE_ACL_LIBACL_H */

/* Define to 1 if the system has the type `acl_permset_t'. */
/* #undef HAVE_ACL_PERMSET_T */

/* Define to 1 if you have the `acl_set_fd' function. */
/* #undef HAVE_ACL_SET_FD */

/* Define to 1 if you have the `acl_set_fd_np' function. */
/* #undef HAVE_ACL_SET_FD_NP */

/* Define to 1 if you have the `acl_set_file' function. */
/* #undef HAVE_ACL_SET_FILE */

/* True for systems with POSIX ACL support */
/* #undef HAVE_ACL_USER */

/* Define to 1 if you have the <attr/xattr.h> header file. */
/* #undef HAVE_ATTR_XATTR_H */

/* Define to 1 if you have the <bsdxml.h> header file. */
/* #undef HAVE_BSDXML_H */

/* Define to 1 if you have the <bzlib.h> header file. */
#define HAVE_BZLIB_H 1

/* Define to 1 if you have the `chflags' function. */
/* #undef HAVE_CHFLAGS */

/* Define to 1 if you have the `chown' function. */
#define HAVE_CHOWN 1

/* Define to 1 if you have the `chroot' function. */
#define HAVE_CHROOT 1

/* Define to 1 if you have the <copyfile.h> header file. */
/* #undef HAVE_COPYFILE_H */

/* Define to 1 if you have the `ctime_r' function. */
#define HAVE_CTIME_R 1

/* Define to 1 if you have the <ctype.h> header file. */
#define HAVE_CTYPE_H 1

/* Define to 1 if you have the `cygwin_conv_path' function. */
/* #undef HAVE_CYGWIN_CONV_PATH */

/* Define to 1 if you have the declaration of `INT64_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_INT64_MAX 1

/* Define to 1 if you have the declaration of `INT64_MIN', and to 0 if you
   don't. */
#define HAVE_DECL_INT64_MIN 1

/* Define to 1 if you have the declaration of `SIZE_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_SIZE_MAX 1

/* Define to 1 if you have the declaration of `SSIZE_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_SSIZE_MAX 1

/* Define to 1 if you have the declaration of `strerror_r', and to 0 if you
   don't. */
#define HAVE_DECL_STRERROR_R 1

/* Define to 1 if you have the declaration of `UINT32_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_UINT32_MAX 1

/* Define to 1 if you have the declaration of `UINT64_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_UINT64_MAX 1

/* Define to 1 if you have the <direct.h> header file. */
/* #undef HAVE_DIRECT_H */

/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.
   */
#define HAVE_DIRENT_H 1

/* Define to 1 if you have the `dirfd' function. */
#define HAVE_DIRFD 1

/* Define to 1 if you have the <dlfcn.h> header file. */
#define HAVE_DLFCN_H 1

/* Define to 1 if you don't have `vprintf' but do have `_doprnt.' */
/* #undef HAVE_DOPRNT */

/* Define to 1 if nl_langinfo supports D_MD_ORDER */
/* #undef HAVE_D_MD_ORDER */

/* A possible errno value for invalid file format errors */
/* #undef HAVE_EFTYPE */

/* A possible errno value for invalid file format errors */
#define HAVE_EILSEQ 1

/* Define to 1 if you have the <errno.h> header file. */
#define HAVE_ERRNO_H 1

/* Define to 1 if you have the <expat.h> header file. */
/* #undef HAVE_EXPAT_H */

/* Define to 1 if you have the <ext2fs/ext2_fs.h> header file. */
/* #undef HAVE_EXT2FS_EXT2_FS_H */

/* Define to 1 if you have the `extattr_get_file' function. */
/* #undef HAVE_EXTATTR_GET_FILE */

/* Define to 1 if you have the `extattr_list_file' function. */
/* #undef HAVE_EXTATTR_LIST_FILE */

/* Define to 1 if you have the `extattr_set_fd' function. */
/* #undef HAVE_EXTATTR_SET_FD */

/* Define to 1 if you have the `extattr_set_file' function. */
/* #undef HAVE_EXTATTR_SET_FILE */

/* Define to 1 if EXTATTR_NAMESPACE_USER is defined in sys/extattr.h. */
/* #undef HAVE_DECL_EXTATTR_NAMESPACE_USER */

/* Define to 1 if you have the `fchdir' function. */
#define HAVE_FCHDIR 1

/* Define to 1 if you have the `fchflags' function. */
/* #undef HAVE_FCHFLAGS */

/* Define to 1 if you have the `fchmod' function. */
#define HAVE_FCHMOD 1

/* Define to 1 if you have the `fchown' function. */
#define HAVE_FCHOWN 1

/* Define to 1 if you have the `fcntl' function. */
#define HAVE_FCNTL 1

/* Define to 1 if you have the <fcntl.h> header file. */
#define HAVE_FCNTL_H 1

/* Define to 1 if you have the `fdopendir' function. */
#define HAVE_FDOPENDIR 1

/* Define to 1 if you have the `fgetea' function. */
/* #undef HAVE_FGETEA */

/* Define to 1 if you have the `fgetxattr' function. */
/* #undef HAVE_FGETXATTR */

/* Define to 1 if you have the `flistea' function. */
/* #undef HAVE_FLISTEA */

/* Define to 1 if you have the `flistxattr' function. */
/* #undef HAVE_FLISTXATTR */

/* Define to 1 if you have the `fork' function. */
#define HAVE_FORK 1

/* Define to 1 if fseeko (and presumably ftello) exists and is declared. */
#define HAVE_FSEEKO 1

/* Define to 1 if you have the `fsetea' function. */
/* #undef HAVE_FSETEA */

/* Define to 1 if you have the `fsetxattr' function. */
/* #undef HAVE_FSETXATTR */

/* Define to 1 if you have the `fstat' function. */
#define HAVE_FSTAT 1

/* Define to 1 if you have the `fstatat' function. */
#define HAVE_FSTATAT 1

/* Define to 1 if you have the `fstatfs' function. */
#define HAVE_FSTATFS 1

/* Define to 1 if you have the `fstatvfs' function. */
#define HAVE_FSTATVFS 1

/* Define to 1 if you have the `ftruncate' function. */
#define HAVE_FTRUNCATE 1

/* Define to 1 if you have the `futimens' function. */
#define HAVE_FUTIMENS 1

/* Define to 1 if you have the `futimes' function. */
#define HAVE_FUTIMES 1

/* Define to 1 if you have the `futimesat' function. */
#define HAVE_FUTIMESAT 1

/* Define to 1 if you have the `getea' function. */
/* #undef HAVE_GETEA */

/* Define to 1 if you have the `geteuid' function. */
#define HAVE_GETEUID 1

/* Define to 1 if you have the `getgrgid_r' function. */
#define HAVE_GETGRGID_R 1

/* Define to 1 if you have the `getgrnam_r' function. */
#define HAVE_GETGRNAM_R 1

/* Define to 1 if you have the `getpid' function. */
#define HAVE_GETPID 1

/* Define to 1 if you have the `getpwnam_r' function. */
#define HAVE_GETPWNAM_R 1

/* Define to 1 if you have the `getpwuid_r' function. */
#define HAVE_GETPWUID_R 1

/* Define to 1 if you have the `getvfsbyname' function. */
/* #undef HAVE_GETVFSBYNAME */

/* Define to 1 if you have the `getxattr' function. */
/* #undef HAVE_GETXATTR */

/* Define to 1 if you have the `gmtime_r' function. */
#define HAVE_GMTIME_R 1

/* Define to 1 if you have the <grp.h> header file. */
#define HAVE_GRP_H 1

/* Define to 1 if you have the `iconv' function. */
/* #undef HAVE_ICONV */

/* Define to 1 if you have the <iconv.h> header file. */
/* #undef HAVE_ICONV_H */

/* Define to 1 if you have the <inttypes.h> header file. */
#define HAVE_INTTYPES_H 1

/* Define to 1 if you have the <io.h> header file. */
/* #undef HAVE_IO_H */

/* Define to 1 if you have the <langinfo.h> header file. */
#define HAVE_LANGINFO_H 1

/* Define to 1 if you have the `lchflags' function. */
/* #undef HAVE_LCHFLAGS */

/* Define to 1 if you have the `lchmod' function. */
/* #undef HAVE_LCHMOD */

/* Define to 1 if you have the `lchown' function. */
#define HAVE_LCHOWN 1

/* Define to 1 if you have the `lgetea' function. */
/* #undef HAVE_LGETEA */

/* Define to 1 if you have the `lgetxattr' function. */
/* #undef HAVE_LGETXATTR */

/* Define to 1 if you have the `acl' library (-lacl). */
/* #undef HAVE_LIBACL */

/* Define to 1 if you have the `attr' library (-lattr). */
/* #undef HAVE_LIBATTR */

/* Define to 1 if you have the `bsdxml' library (-lbsdxml). */
/* #undef HAVE_LIBBSDXML */

/* Define to 1 if you have the `bz2' library (-lbz2). */
#define HAVE_LIBBZ2 1

/* Define to 1 if you have the `expat' library (-lexpat). */
/* #undef HAVE_LIBEXPAT */

/* Define to 1 if you have the `gcc' library (-lgcc). */
/* #undef HAVE_LIBGCC */

/* Define to 1 if you have the `lzma' library (-llzma). */
/* #undef HAVE_LIBLZMA */

/* Define to 1 if you have the `lzmadec' library (-llzmadec). */
/* #undef HAVE_LIBLZMADEC */

/* Define to 1 if you have the `lzo2' library (-llzo2). */
/* #undef HAVE_LIBLZO2 */

/* Define to 1 if you have the `nettle' library (-lnettle). */
/* #undef HAVE_LIBNETTLE */

/* Define to 1 if you have the `pcre' library (-lpcre). */
/* #undef HAVE_LIBPCRE */

/* Define to 1 if you have the `pcreposix' library (-lpcreposix). */
/* #undef HAVE_LIBPCREPOSIX */

/* Define to 1 if you have the `xml2' library (-lxml2). */
/* #undef HAVE_LIBXML2 */

/* Define to 1 if you have the <libxml/xmlreader.h> header file. */
/* #undef HAVE_LIBXML_XMLREADER_H */

/* Define to 1 if you have the <libxml/xmlwriter.h> header file. */
/* #undef HAVE_LIBXML_XMLWRITER_H */

/* Define to 1 if you have the `z' library (-lz). */
#define HAVE_LIBZ 1

/* Define to 1 if you have the <limits.h> header file. */
#define HAVE_LIMITS_H 1

/* Define to 1 if you have the `link' function. */
#define HAVE_LINK 1

/* Define to 1 if you have the <linux/types.h> header file. */
#define HAVE_LINUX_TYPES_H 1

/* Define to 1 if you have the <linux/fiemap.h> header file. */
#define HAVE_LINUX_FIEMAP_H 1

/* Define to 1 if you have the <linux/fs.h> header file. */
#define HAVE_LINUX_FS_H 1

/* Define to 1 if you have the <linux/magic.h> header file. */
#define HAVE_LINUX_MAGIC_H 1

/* Define to 1 if you have the <linux/types.h> header file. */
#define HAVE_LINUX_TYPES_H 1

/* Define to 1 if you have the `listea' function. */
/* #undef HAVE_LISTEA */

/* Define to 1 if you have the `listxattr' function. */
/* #undef HAVE_LISTXATTR */

/* Define to 1 if you have the `llistea' function. */
/* #undef HAVE_LLISTEA */

/* Define to 1 if you have the `llistxattr' function. */
/* #undef HAVE_LLISTXATTR */

/* Define to 1 if you have the <localcharset.h> header file. */
/* #undef HAVE_LOCALCHARSET_H */

/* Define to 1 if you have the `locale_charset' function. */
/* #undef HAVE_LOCALE_CHARSET */

/* Define to 1 if you have the <locale.h> header file. */
#define HAVE_LOCALE_H 1

/* Define to 1 if you have the `localtime_r' function. */
#define HAVE_LOCALTIME_R 1

/* Define to 1 if the system has the type `long long int'. */
/* #undef HAVE_LONG_LONG_INT */

/* Define to 1 if you have the `lsetea' function. */
/* #undef HAVE_LSETEA */

/* Define to 1 if you have the `lsetxattr' function. */
/* #undef HAVE_LSETXATTR */

/* Define to 1 if you have the `lstat' function. */
#define HAVE_LSTAT 1

/* Define to 1 if `lstat' has the bug that it succeeds when given the
   zero-length file name argument. */
/* #undef HAVE_LSTAT_EMPTY_STRING_BUG */

/* Define to 1 if you have the `lutimes' function. */
#define HAVE_LUTIMES 1

/* Define to 1 if you have the <lzmadec.h> header file. */
/* #undef HAVE_LZMADEC_H */

/* Define to 1 if you have the <lzma.h> header file. */
/* #undef HAVE_LZMA_H */

/* Define to 1 if you have the <lzo/lzo1x.h> header file. */
/* #undef HAVE_LZO_LZO1X_H */

/* Define to 1 if you have the <lzo/lzoconf.h> header file. */
/* #undef HAVE_LZO_LZOCONF_H */

/* Define to 1 if you have the `mbrtowc' function. */
#define HAVE_MBRTOWC 1

/* Define to 1 if you have the `memmove' function. */
#define HAVE_MEMMOVE 1

/* Define to 1 if you have the <memory.h> header file. */
#define HAVE_MEMORY_H 1

/* Define to 1 if you have the `mkdir' function. */
#define HAVE_MKDIR 1

/* Define to 1 if you have the `mkfifo' function. */
#define HAVE_MKFIFO 1

/* Define to 1 if you have the `mknod' function. */
#define HAVE_MKNOD 1

/* Define to 1 if you have the `mkstemp' function. */
#define HAVE_MKSTEMP 1

/* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */
/* #undef HAVE_NDIR_H */

/* Define to 1 if you have the <nettle/md5.h> header file. */
/* #undef HAVE_NETTLE_MD5_H */

/* Define to 1 if you have the <nettle/ripemd160.h> header file. */
/* #undef HAVE_NETTLE_RIPEMD160_H */

/* Define to 1 if you have the <nettle/sha.h> header file. */
/* #undef HAVE_NETTLE_SHA_H */

/* Define to 1 if you have the `nl_langinfo' function. */
#define HAVE_NL_LANGINFO 1

/* Define to 1 if you have the `openat' function. */
#define HAVE_OPENAT 1

/* Define to 1 if you have the <paths.h> header file. */
#define HAVE_PATHS_H 1

/* Define to 1 if you have the <pcreposix.h> header file. */
/* #undef HAVE_PCREPOSIX_H */

/* Define to 1 if you have the `pipe' function. */
#define HAVE_PIPE 1

/* Define to 1 if you have the `poll' function. */
#define HAVE_POLL 1

/* Define to 1 if you have the <poll.h> header file. */
#define HAVE_POLL_H 1

/* Define to 1 if you have the `posix_spawnp' function. */
#define HAVE_POSIX_SPAWNP 1

/* Define to 1 if you have the <process.h> header file. */
/* #undef HAVE_PROCESS_H */

/* Define to 1 if you have the <pwd.h> header file. */
#define HAVE_PWD_H 1

/* Define to 1 if you have the `readdir_r' function. */
#define HAVE_READDIR_R 1

/* Define to 1 if you have the `readlink' function. */
#define HAVE_READLINK 1

/* Define to 1 if you have the `readlinkat' function. */
#define HAVE_READLINKAT 1

/* Define to 1 if you have the <regex.h> header file. */
#define HAVE_REGEX_H 1

/* Define to 1 if you have the `select' function. */
#define HAVE_SELECT 1

/* Define to 1 if you have the `setenv' function. */
#define HAVE_SETENV 1

/* Define to 1 if you have the `setlocale' function. */
#define HAVE_SETLOCALE 1

/* Define to 1 if you have the `sigaction' function. */
#define HAVE_SIGACTION 1

/* Define to 1 if you have the <signal.h> header file. */
#define HAVE_SIGNAL_H 1

/* Define to 1 if you have the <spawn.h> header file. */
#define HAVE_SPAWN_H 1

/* Define to 1 if you have the `statfs' function. */
#define HAVE_STATFS 1

/* Define to 1 if you have the `statvfs' function. */
#define HAVE_STATVFS 1

/* Define to 1 if `stat' has the bug that it succeeds when given the
   zero-length file name argument. */
/* #undef HAVE_STAT_EMPTY_STRING_BUG */

/* Define to 1 if you have the <stdarg.h> header file. */
#define HAVE_STDARG_H 1

/* Define to 1 if you have the <stdint.h> header file. */
#define HAVE_STDINT_H 1

/* Define to 1 if you have the <stdlib.h> header file. */
#define HAVE_STDLIB_H 1

/* Define to 1 if you have the `strchr' function. */
#define HAVE_STRCHR 1

/* Define to 1 if you have the `strdup' function. */
#define HAVE_STRDUP 1

/* Define to 1 if you have the `strerror' function. */
#define HAVE_STRERROR 1

/* Define to 1 if you have the `strerror_r' function. */
#define HAVE_STRERROR_R 1

/* Define to 1 if you have the `strftime' function. */
#define HAVE_STRFTIME 1

/* Define to 1 if you have the <strings.h> header file. */
#define HAVE_STRINGS_H 1

/* Define to 1 if you have the <string.h> header file. */
#define HAVE_STRING_H 1

/* Define to 1 if you have the `strrchr' function. */
#define HAVE_STRRCHR 1

/* Define to 1 if `f_namemax' is a member of `struct statfs'. */
/* #undef HAVE_STRUCT_STATFS_F_NAMEMAX */

/* Define to 1 if `f_iosize' is a member of `struct statvfs'. */
/* #undef HAVE_STRUCT_STATVFS_F_IOSIZE */

/* Define to 1 if `st_birthtime' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIME */

/* Define to 1 if `st_birthtimespec.tv_nsec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC_TV_NSEC */

/* Define to 1 if `st_blksize' is a member of `struct stat'. */
#define HAVE_STRUCT_STAT_ST_BLKSIZE 1

/* Define to 1 if `st_flags' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_FLAGS */

/* Define to 1 if `st_mtimespec.tv_nsec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC */

/* Define to 1 if `st_mtime_n' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIME_N */

/* Define to 1 if `st_mtime_usec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIME_USEC */

/* Define to 1 if `st_mtim.tv_nsec' is a member of `struct stat'. */
#define HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC 1

/* Define to 1 if `st_umtime' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_UMTIME */

/* Define to 1 if `tm_gmtoff' is a member of `struct tm'. */
#define HAVE_STRUCT_TM_TM_GMTOFF 1

/* Define to 1 if `__tm_gmtoff' is a member of `struct tm'. */
/* #undef HAVE_STRUCT_TM___TM_GMTOFF */

/* Define to 1 if you have the `symlink' function. */
#define HAVE_SYMLINK 1

/* Define to 1 if you have the <sys/acl.h> header file. */
/* #undef HAVE_SYS_ACL_H */

/* Define to 1 if you have the <sys/cdefs.h> header file. */
#define HAVE_SYS_CDEFS_H 1

/* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.
   */
/* #undef HAVE_SYS_DIR_H */

/* Define to 1 if you have the <sys/ea.h> header file. */
/* #undef HAVE_SYS_EA_H */

/* Define to 1 if you have the <sys/extattr.h> header file. */
/* #undef HAVE_SYS_EXTATTR_H */

/* Define to 1 if you have the <sys/ioctl.h> header file. */
#define HAVE_SYS_IOCTL_H 1

/* Define to 1 if you have the <sys/mkdev.h> header file. */
/* #undef HAVE_SYS_MKDEV_H */

/* Define to 1 if you have the <sys/mount.h> header file. */
/* #undef HAVE_SYS_MOUNT_H */

/* Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.
   */
/* #undef HAVE_SYS_NDIR_H */

/* Define to 1 if you have the <sys/param.h> header file. */
#define HAVE_SYS_PARAM_H 1

/* Define to 1 if you have the <sys/poll.h> header file. */
#define HAVE_SYS_POLL_H 1

/* Define to 1 if you have the <sys/select.h> header file. */
#define HAVE_SYS_SELECT_H 1

/* Define to 1 if you have the <sys/statfs.h> header file. */
#define HAVE_SYS_STATFS_H 1

/* Define to 1 if you have the <sys/statvfs.h> header file. */
#define HAVE_SYS_STATVFS_H 1

/* Define to 1 if you have the <sys/stat.h> header file. */
#define HAVE_SYS_STAT_H 1

/* Define to 1 if you have the <sys/time.h> header file. */
#define HAVE_SYS_TIME_H 1

/* Define to 1 if you have the <sys/types.h> header file. */
#define HAVE_SYS_TYPES_H 1

/* Define to 1 if you have the <sys/utime.h> header file. */
/* #undef HAVE_SYS_UTIME_H */

/* Define to 1 if you have the <sys/utsname.h> header file. */
#define HAVE_SYS_UTSNAME_H 1

/* Define to 1 if you have the <sys/vfs.h> header file. */
#define HAVE_SYS_VFS_H 1

/* Define to 1 if you have <sys/wait.h> that is POSIX.1 compatible. */
#define HAVE_SYS_WAIT_H 1

/* Define to 1 if you have the <sys/xattr.h> header file. */
/* #undef HAVE_SYS_XATTR_H */

/* Define to 1 if you have the `timegm' function. */
#define HAVE_TIMEGM 1

/* Define to 1 if you have the <time.h> header file. */
#define HAVE_TIME_H 1

/* Define to 1 if you have the `tzset' function. */
#define HAVE_TZSET 1

/* Define to 1 if you have the <unistd.h> header file. */
#define HAVE_UNISTD_H 1

/* Define to 1 if you have the `unsetenv' function. */
#define HAVE_UNSETENV 1

/* Define to 1 if the system has the type `unsigned long long'. */
/* #undef HAVE_UNSIGNED_LONG_LONG */

/* Define to 1 if the system has the type `unsigned long long int'. */
/* #undef HAVE_UNSIGNED_LONG_LONG_INT */

/* Define to 1 if you have the `utime' function. */
#define HAVE_UTIME 1

/* Define to 1 if you have the `utimensat' function. */
#define HAVE_UTIMENSAT 1

/* Define to 1 if you have the `utimes' function. */
#define HAVE_UTIMES 1

/* Define to 1 if you have the <utime.h> header file. */
#define HAVE_UTIME_H 1

/* Define to 1 if you have the `vfork' function. */
#define HAVE_VFORK 1

/* Define to 1 if you have the `vprintf' function. */
#define HAVE_VPRINTF 1

/* Define to 1 if you have the <wchar.h> header file. */
#define HAVE_WCHAR_H 1

/* Define to 1 if the system has the type `wchar_t'. */
#define HAVE_WCHAR_T 1

/* Define to 1 if you have the `wcrtomb' function. */
#define HAVE_WCRTOMB 1

/* Define to 1 if you have the `wcscmp' function. */
#define HAVE_WCSCMP 1

/* Define to 1 if you have the `wcscpy' function. */
#define HAVE_WCSCPY 1

/* Define to 1 if you have the `wcslen' function. */
#define HAVE_WCSLEN 1

/* Define to 1 if you have the `wctomb' function. */
#define HAVE_WCTOMB 1

/* Define to 1 if you have the <wctype.h> header file. */
#define HAVE_WCTYPE_H 1

/* Define to 1 if you have the <wincrypt.h> header file. */
/* #undef HAVE_WINCRYPT_H */

/* Define to 1 if you have the <windows.h> header file. */
/* #undef HAVE_WINDOWS_H */

/* Define to 1 if you have the <winioctl.h> header file. */
/* #undef HAVE_WINIOCTL_H */

/* Define to 1 if you have _CrtSetReportMode in <crtdbg.h>  */
/* #undef HAVE__CrtSetReportMode */

/* Define to 1 if you have the `wmemcmp' function. */
#define HAVE_WMEMCMP 1

/* Define to 1 if you have the `wmemcpy' function. */
#define HAVE_WMEMCPY 1

/* Define to 1 if you have a working EXT2_IOC_GETFLAGS */
/* #undef HAVE_WORKING_EXT2_IOC_GETFLAGS */

/* Define to 1 if you have the <zlib.h> header file. */
#define HAVE_ZLIB_H 1

/* Define to 1 if you have the `_ctime64_s' function. */
/* #undef HAVE__CTIME64_S */

/* Define to 1 if you have the `_fseeki64' function. */
/* #undef HAVE__FSEEKI64 */

/* Define to 1 if you have the `_get_timezone' function. */
/* #undef HAVE__GET_TIMEZONE */

/* Define to 1 if you have the `_localtime64_s' function. */
/* #undef HAVE__LOCALTIME64_S */

/* Define to 1 if you have the `_mkgmtime64' function. */
/* #undef HAVE__MKGMTIME64 */

/* Define as const if the declaration of iconv() needs const. */
#define ICONV_CONST 

/* Version number of libarchive as a single integer */
#define LIBARCHIVE_VERSION_NUMBER "3001002"

/* Version number of libarchive */
#define LIBARCHIVE_VERSION_STRING "3.1.2"

/* Define to 1 if `lstat' dereferences a symlink specified with a trailing
   slash. */
/* #undef LSTAT_FOLLOWS_SLASHED_SYMLINK */

/* Define to 1 if `major', `minor', and `makedev' are declared in <mkdev.h>.
   */
/* #undef MAJOR_IN_MKDEV */

/* Define to 1 if `major', `minor', and `makedev' are declared in
   <sysmacros.h>. */
#define MAJOR_IN_SYSMACROS 1

/* Define to 1 if your C compiler doesn't accept -c and -o together. */
/* #undef NO_MINUS_C_MINUS_O */

/* The size of `wchar_t', as computed by sizeof. */
#define SIZEOF_WCHAR_T 4

/* Define to 1 if strerror_r returns char *. */
/* #undef STRERROR_R_CHAR_P */

/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
#define TIME_WITH_SYS_TIME 1

/*
 * Some platform requires a macro to use extension functions.
 */
#define SAFE_TO_DEFINE_EXTENSIONS 1
#ifdef SAFE_TO_DEFINE_EXTENSIONS
/* Enable extensions on AIX 3, Interix.  */
#ifndef _ALL_SOURCE
# define _ALL_SOURCE 1
#endif
/* Enable GNU extensions on systems that have them.  */
#ifndef _GNU_SOURCE
# define _GNU_SOURCE 1
#endif
/* Enable threading extensions on Solaris.  */
#ifndef _POSIX_PTHREAD_SEMANTICS
# define _POSIX_PTHREAD_SEMANTICS 1
#endif
/* Enable extensions on HP NonStop.  */
#ifndef _TANDEM_SOURCE
# define _TANDEM_SOURCE 1
#endif
/* Enable general extensions on Solaris.  */
#ifndef __EXTENSIONS__
# define __EXTENSIONS__ 1
#endif
#endif /* SAFE_TO_DEFINE_EXTENSIONS */

/* Version number of package */
#define VERSION "3.1.2"

/* Number of bits in a file offset, on hosts where this is settable. */
/* #undef _FILE_OFFSET_BITS */

/* Define to 1 to make fseeko visible on some hosts (e.g. glibc 2.2). */
/* #undef _LARGEFILE_SOURCE */

/* Define for large files, on AIX-style hosts. */
/* #undef _LARGE_FILES */

/* Define for Windows to use Windows 2000+ APIs. */
/* #undef _WIN32_WINNT */
/* #undef WINVER */

/* Define to empty if `const' does not conform to ANSI C. */
/* #undef const */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef gid_t */

/* Define to `unsigned long' if <sys/types.h> does not define. */
/* #undef id_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef mode_t */

/* Define to `long long' if <sys/types.h> does not define. */
/* #undef off_t */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef pid_t */

/* Define to `unsigned int' if <sys/types.h> does not define. */
/* #undef size_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef ssize_t */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef uid_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef intptr_t */

/* Define to `unsigned int' if <sys/types.h> does not define. */
/* #undef uintptr_t */


#define ARCHIVE_SHA256_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA256_LIBC3
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = (DWORD)bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. Nettle
 * 6. OpenSSL
 * 7. libmd
 * 8. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive_sha256_ctx ctx;
  archive_sha256_init(&ctx);
  archive_sha256_update(&ctx, *argv, argc);
  archive_sha256_final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA384_LIBC3 failed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3425150578/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3425150578.dir/build.make CMakeFiles/cmTryCompileExec3425150578.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3425150578.dir/check_crypto_md.c.o
/usr/bin/gcc   -w  -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2 -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmlibarchive/libarchive -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec3425150578.dir/check_crypto_md.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1186:0:
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: fatal error: sha2.h: No such file or directory
 #include <sha2.h>
                  ^
compilation terminated.
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec3425150578.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec3425150578/fast] Error 2

Source file was:
/* config.h.  Generated from build/cmake/config.h.in by cmake configure */
#if defined(__osf__)
# define _OSF_SOURCE
#endif

/*
 * Ensure we have C99-style int64_t, etc, all defined.
 */

/* First, we need to know if the system has already defined them. */
#define HAVE_INT16_T
#define HAVE_INT32_T
#define HAVE_INT64_T
#define HAVE_INTMAX_T

#define HAVE_UINT8_T
#define HAVE_UINT16_T
#define HAVE_UINT32_T
#define HAVE_UINT64_T
#define HAVE_UINTMAX_T

/* We might have the types we want under other spellings. */
/* #undef HAVE___INT64 */
/* #undef HAVE_U_INT64_T */
/* #undef HAVE_UNSIGNED___INT64 */

/* The sizes of various standard integer types. */
#define SIZE_OF_SHORT 2
#define SIZE_OF_INT 4
#define SIZE_OF_LONG 8
#define SIZE_OF_LONG_LONG 8
#define SIZE_OF_UNSIGNED_SHORT 2
#define SIZE_OF_UNSIGNED 4
#define SIZE_OF_UNSIGNED_LONG 8
#define SIZE_OF_UNSIGNED_LONG_LONG 8

/*
 * If we lack int64_t, define it to the first of __int64, int, long, and long long
 * that exists and is the right size.
 */
#if !defined(HAVE_INT64_T) && defined(HAVE___INT64)
typedef __int64 int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_INT == 8
typedef int int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_LONG == 8
typedef long int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_LONG_LONG == 8
typedef long long int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T)
#error No 64-bit integer type was found.
#endif

/*
 * Similarly for int32_t
 */
#if !defined(HAVE_INT32_T) && SIZE_OF_INT == 4
typedef long int32_t;
#define HAVE_INT32_T
#endif

#if !defined(HAVE_INT32_T) && SIZE_OF_LONG == 4
typedef long int32_t;
#define HAVE_INT32_T
#endif

#if !defined(HAVE_INT32_T)
#error No 32-bit integer type was found.
#endif

/*
 * Similarly for int16_t
 */
#if !defined(HAVE_INT16_T) && SIZE_OF_INT == 2
typedef int int16_t;
#define HAVE_INT16_T
#endif

#if !defined(HAVE_INT16_T) && SIZE_OF_SHORT == 2
typedef short int16_t;
#define HAVE_INT16_T
#endif

#if !defined(HAVE_INT16_T)
#error No 16-bit integer type was found.
#endif

/*
 * Similarly for uint64_t
 */
#if !defined(HAVE_UINT64_T) && defined(HAVE_UNSIGNED___INT64)
typedef unsigned __int64 uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED == 8
typedef unsigned uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED_LONG == 8
typedef unsigned long uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED_LONG_LONG == 8
typedef unsigned long long uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T)
#error No 64-bit unsigned integer type was found.
#endif


/*
 * Similarly for uint32_t
 */
#if !defined(HAVE_UINT32_T) && SIZE_OF_UNSIGNED == 4
typedef unsigned uint32_t;
#define HAVE_UINT32_T
#endif

#if !defined(HAVE_UINT32_T) && SIZE_OF_UNSIGNED_LONG == 4
typedef unsigned long uint32_t;
#define HAVE_UINT32_T
#endif

#if !defined(HAVE_UINT32_T)
#error No 32-bit unsigned integer type was found.
#endif

/*
 * Similarly for uint16_t
 */
#if !defined(HAVE_UINT16_T) && SIZE_OF_UNSIGNED == 2
typedef unsigned uint16_t;
#define HAVE_UINT16_T
#endif

#if !defined(HAVE_UINT16_T) && SIZE_OF_UNSIGNED_SHORT == 2
typedef unsigned short uint16_t;
#define HAVE_UINT16_T
#endif

#if !defined(HAVE_UINT16_T)
#error No 16-bit unsigned integer type was found.
#endif

/*
 * Similarly for uint8_t
 */
#if !defined(HAVE_UINT8_T)
typedef unsigned char uint8_t;
#define HAVE_UINT8_T
#endif

#if !defined(HAVE_UINT16_T)
#error No 8-bit unsigned integer type was found.
#endif

/* Define intmax_t and uintmax_t if they are not already defined. */
#if !defined(HAVE_INTMAX_T)
typedef int64_t intmax_t;
#define INTMAX_MIN INT64_MIN
#define INTMAX_MAX INT64_MAX
#endif

#if !defined(HAVE_UINTMAX_T)
typedef uint64_t uintmax_t;
#endif

/* Define ZLIB_WINAPI if zlib was built on Visual Studio. */
/* #undef ZLIB_WINAPI */

/* MD5 via ARCHIVE_CRYPTO_MD5_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_MD5_LIBC */

/* MD5 via ARCHIVE_CRYPTO_MD5_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_MD5_LIBSYSTEM */

/* MD5 via ARCHIVE_CRYPTO_MD5_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_MD5_NETTLE */

/* MD5 via ARCHIVE_CRYPTO_MD5_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_MD5_OPENSSL */

/* MD5 via ARCHIVE_CRYPTO_MD5_WIN supported. */
/* #undef ARCHIVE_CRYPTO_MD5_WIN */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_LIBC */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_NETTLE */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_OPENSSL */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_LIBC */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_LIBSYSTEM */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_NETTLE */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_OPENSSL */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_WIN */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC2 */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC3 */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBSYSTEM */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_NETTLE */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_OPENSSL */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_WIN */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC2 */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC3 */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBSYSTEM */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_NETTLE */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_OPENSSL */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_WIN */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC2 */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC3 */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBSYSTEM */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_NETTLE */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_OPENSSL */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_WIN */

/* Version number of bsdcpio */
#define BSDCPIO_VERSION_STRING "3.1.2"

/* Version number of bsdtar */
#define BSDTAR_VERSION_STRING "3.1.2"

/* Define to 1 if you have the `acl_create_entry' function. */
/* #undef HAVE_ACL_CREATE_ENTRY */

/* Define to 1 if you have the `acl_get_link' function. */
/* #undef HAVE_ACL_GET_LINK */

/* Define to 1 if you have the `acl_get_link_np' function. */
/* #undef HAVE_ACL_GET_LINK_NP */

/* Define to 1 if you have the `acl_get_perm' function. */
/* #undef HAVE_ACL_GET_PERM */

/* Define to 1 if you have the `acl_get_perm_np' function. */
/* #undef HAVE_ACL_GET_PERM_NP */

/* Define to 1 if you have the `acl_init' function. */
/* #undef HAVE_ACL_INIT */

/* Define to 1 if you have the <acl/libacl.h> header file. */
/* #undef HAVE_ACL_LIBACL_H */

/* Define to 1 if the system has the type `acl_permset_t'. */
/* #undef HAVE_ACL_PERMSET_T */

/* Define to 1 if you have the `acl_set_fd' function. */
/* #undef HAVE_ACL_SET_FD */

/* Define to 1 if you have the `acl_set_fd_np' function. */
/* #undef HAVE_ACL_SET_FD_NP */

/* Define to 1 if you have the `acl_set_file' function. */
/* #undef HAVE_ACL_SET_FILE */

/* True for systems with POSIX ACL support */
/* #undef HAVE_ACL_USER */

/* Define to 1 if you have the <attr/xattr.h> header file. */
/* #undef HAVE_ATTR_XATTR_H */

/* Define to 1 if you have the <bsdxml.h> header file. */
/* #undef HAVE_BSDXML_H */

/* Define to 1 if you have the <bzlib.h> header file. */
#define HAVE_BZLIB_H 1

/* Define to 1 if you have the `chflags' function. */
/* #undef HAVE_CHFLAGS */

/* Define to 1 if you have the `chown' function. */
#define HAVE_CHOWN 1

/* Define to 1 if you have the `chroot' function. */
#define HAVE_CHROOT 1

/* Define to 1 if you have the <copyfile.h> header file. */
/* #undef HAVE_COPYFILE_H */

/* Define to 1 if you have the `ctime_r' function. */
#define HAVE_CTIME_R 1

/* Define to 1 if you have the <ctype.h> header file. */
#define HAVE_CTYPE_H 1

/* Define to 1 if you have the `cygwin_conv_path' function. */
/* #undef HAVE_CYGWIN_CONV_PATH */

/* Define to 1 if you have the declaration of `INT64_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_INT64_MAX 1

/* Define to 1 if you have the declaration of `INT64_MIN', and to 0 if you
   don't. */
#define HAVE_DECL_INT64_MIN 1

/* Define to 1 if you have the declaration of `SIZE_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_SIZE_MAX 1

/* Define to 1 if you have the declaration of `SSIZE_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_SSIZE_MAX 1

/* Define to 1 if you have the declaration of `strerror_r', and to 0 if you
   don't. */
#define HAVE_DECL_STRERROR_R 1

/* Define to 1 if you have the declaration of `UINT32_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_UINT32_MAX 1

/* Define to 1 if you have the declaration of `UINT64_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_UINT64_MAX 1

/* Define to 1 if you have the <direct.h> header file. */
/* #undef HAVE_DIRECT_H */

/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.
   */
#define HAVE_DIRENT_H 1

/* Define to 1 if you have the `dirfd' function. */
#define HAVE_DIRFD 1

/* Define to 1 if you have the <dlfcn.h> header file. */
#define HAVE_DLFCN_H 1

/* Define to 1 if you don't have `vprintf' but do have `_doprnt.' */
/* #undef HAVE_DOPRNT */

/* Define to 1 if nl_langinfo supports D_MD_ORDER */
/* #undef HAVE_D_MD_ORDER */

/* A possible errno value for invalid file format errors */
/* #undef HAVE_EFTYPE */

/* A possible errno value for invalid file format errors */
#define HAVE_EILSEQ 1

/* Define to 1 if you have the <errno.h> header file. */
#define HAVE_ERRNO_H 1

/* Define to 1 if you have the <expat.h> header file. */
/* #undef HAVE_EXPAT_H */

/* Define to 1 if you have the <ext2fs/ext2_fs.h> header file. */
/* #undef HAVE_EXT2FS_EXT2_FS_H */

/* Define to 1 if you have the `extattr_get_file' function. */
/* #undef HAVE_EXTATTR_GET_FILE */

/* Define to 1 if you have the `extattr_list_file' function. */
/* #undef HAVE_EXTATTR_LIST_FILE */

/* Define to 1 if you have the `extattr_set_fd' function. */
/* #undef HAVE_EXTATTR_SET_FD */

/* Define to 1 if you have the `extattr_set_file' function. */
/* #undef HAVE_EXTATTR_SET_FILE */

/* Define to 1 if EXTATTR_NAMESPACE_USER is defined in sys/extattr.h. */
/* #undef HAVE_DECL_EXTATTR_NAMESPACE_USER */

/* Define to 1 if you have the `fchdir' function. */
#define HAVE_FCHDIR 1

/* Define to 1 if you have the `fchflags' function. */
/* #undef HAVE_FCHFLAGS */

/* Define to 1 if you have the `fchmod' function. */
#define HAVE_FCHMOD 1

/* Define to 1 if you have the `fchown' function. */
#define HAVE_FCHOWN 1

/* Define to 1 if you have the `fcntl' function. */
#define HAVE_FCNTL 1

/* Define to 1 if you have the <fcntl.h> header file. */
#define HAVE_FCNTL_H 1

/* Define to 1 if you have the `fdopendir' function. */
#define HAVE_FDOPENDIR 1

/* Define to 1 if you have the `fgetea' function. */
/* #undef HAVE_FGETEA */

/* Define to 1 if you have the `fgetxattr' function. */
/* #undef HAVE_FGETXATTR */

/* Define to 1 if you have the `flistea' function. */
/* #undef HAVE_FLISTEA */

/* Define to 1 if you have the `flistxattr' function. */
/* #undef HAVE_FLISTXATTR */

/* Define to 1 if you have the `fork' function. */
#define HAVE_FORK 1

/* Define to 1 if fseeko (and presumably ftello) exists and is declared. */
#define HAVE_FSEEKO 1

/* Define to 1 if you have the `fsetea' function. */
/* #undef HAVE_FSETEA */

/* Define to 1 if you have the `fsetxattr' function. */
/* #undef HAVE_FSETXATTR */

/* Define to 1 if you have the `fstat' function. */
#define HAVE_FSTAT 1

/* Define to 1 if you have the `fstatat' function. */
#define HAVE_FSTATAT 1

/* Define to 1 if you have the `fstatfs' function. */
#define HAVE_FSTATFS 1

/* Define to 1 if you have the `fstatvfs' function. */
#define HAVE_FSTATVFS 1

/* Define to 1 if you have the `ftruncate' function. */
#define HAVE_FTRUNCATE 1

/* Define to 1 if you have the `futimens' function. */
#define HAVE_FUTIMENS 1

/* Define to 1 if you have the `futimes' function. */
#define HAVE_FUTIMES 1

/* Define to 1 if you have the `futimesat' function. */
#define HAVE_FUTIMESAT 1

/* Define to 1 if you have the `getea' function. */
/* #undef HAVE_GETEA */

/* Define to 1 if you have the `geteuid' function. */
#define HAVE_GETEUID 1

/* Define to 1 if you have the `getgrgid_r' function. */
#define HAVE_GETGRGID_R 1

/* Define to 1 if you have the `getgrnam_r' function. */
#define HAVE_GETGRNAM_R 1

/* Define to 1 if you have the `getpid' function. */
#define HAVE_GETPID 1

/* Define to 1 if you have the `getpwnam_r' function. */
#define HAVE_GETPWNAM_R 1

/* Define to 1 if you have the `getpwuid_r' function. */
#define HAVE_GETPWUID_R 1

/* Define to 1 if you have the `getvfsbyname' function. */
/* #undef HAVE_GETVFSBYNAME */

/* Define to 1 if you have the `getxattr' function. */
/* #undef HAVE_GETXATTR */

/* Define to 1 if you have the `gmtime_r' function. */
#define HAVE_GMTIME_R 1

/* Define to 1 if you have the <grp.h> header file. */
#define HAVE_GRP_H 1

/* Define to 1 if you have the `iconv' function. */
/* #undef HAVE_ICONV */

/* Define to 1 if you have the <iconv.h> header file. */
/* #undef HAVE_ICONV_H */

/* Define to 1 if you have the <inttypes.h> header file. */
#define HAVE_INTTYPES_H 1

/* Define to 1 if you have the <io.h> header file. */
/* #undef HAVE_IO_H */

/* Define to 1 if you have the <langinfo.h> header file. */
#define HAVE_LANGINFO_H 1

/* Define to 1 if you have the `lchflags' function. */
/* #undef HAVE_LCHFLAGS */

/* Define to 1 if you have the `lchmod' function. */
/* #undef HAVE_LCHMOD */

/* Define to 1 if you have the `lchown' function. */
#define HAVE_LCHOWN 1

/* Define to 1 if you have the `lgetea' function. */
/* #undef HAVE_LGETEA */

/* Define to 1 if you have the `lgetxattr' function. */
/* #undef HAVE_LGETXATTR */

/* Define to 1 if you have the `acl' library (-lacl). */
/* #undef HAVE_LIBACL */

/* Define to 1 if you have the `attr' library (-lattr). */
/* #undef HAVE_LIBATTR */

/* Define to 1 if you have the `bsdxml' library (-lbsdxml). */
/* #undef HAVE_LIBBSDXML */

/* Define to 1 if you have the `bz2' library (-lbz2). */
#define HAVE_LIBBZ2 1

/* Define to 1 if you have the `expat' library (-lexpat). */
/* #undef HAVE_LIBEXPAT */

/* Define to 1 if you have the `gcc' library (-lgcc). */
/* #undef HAVE_LIBGCC */

/* Define to 1 if you have the `lzma' library (-llzma). */
/* #undef HAVE_LIBLZMA */

/* Define to 1 if you have the `lzmadec' library (-llzmadec). */
/* #undef HAVE_LIBLZMADEC */

/* Define to 1 if you have the `lzo2' library (-llzo2). */
/* #undef HAVE_LIBLZO2 */

/* Define to 1 if you have the `nettle' library (-lnettle). */
/* #undef HAVE_LIBNETTLE */

/* Define to 1 if you have the `pcre' library (-lpcre). */
/* #undef HAVE_LIBPCRE */

/* Define to 1 if you have the `pcreposix' library (-lpcreposix). */
/* #undef HAVE_LIBPCREPOSIX */

/* Define to 1 if you have the `xml2' library (-lxml2). */
/* #undef HAVE_LIBXML2 */

/* Define to 1 if you have the <libxml/xmlreader.h> header file. */
/* #undef HAVE_LIBXML_XMLREADER_H */

/* Define to 1 if you have the <libxml/xmlwriter.h> header file. */
/* #undef HAVE_LIBXML_XMLWRITER_H */

/* Define to 1 if you have the `z' library (-lz). */
#define HAVE_LIBZ 1

/* Define to 1 if you have the <limits.h> header file. */
#define HAVE_LIMITS_H 1

/* Define to 1 if you have the `link' function. */
#define HAVE_LINK 1

/* Define to 1 if you have the <linux/types.h> header file. */
#define HAVE_LINUX_TYPES_H 1

/* Define to 1 if you have the <linux/fiemap.h> header file. */
#define HAVE_LINUX_FIEMAP_H 1

/* Define to 1 if you have the <linux/fs.h> header file. */
#define HAVE_LINUX_FS_H 1

/* Define to 1 if you have the <linux/magic.h> header file. */
#define HAVE_LINUX_MAGIC_H 1

/* Define to 1 if you have the <linux/types.h> header file. */
#define HAVE_LINUX_TYPES_H 1

/* Define to 1 if you have the `listea' function. */
/* #undef HAVE_LISTEA */

/* Define to 1 if you have the `listxattr' function. */
/* #undef HAVE_LISTXATTR */

/* Define to 1 if you have the `llistea' function. */
/* #undef HAVE_LLISTEA */

/* Define to 1 if you have the `llistxattr' function. */
/* #undef HAVE_LLISTXATTR */

/* Define to 1 if you have the <localcharset.h> header file. */
/* #undef HAVE_LOCALCHARSET_H */

/* Define to 1 if you have the `locale_charset' function. */
/* #undef HAVE_LOCALE_CHARSET */

/* Define to 1 if you have the <locale.h> header file. */
#define HAVE_LOCALE_H 1

/* Define to 1 if you have the `localtime_r' function. */
#define HAVE_LOCALTIME_R 1

/* Define to 1 if the system has the type `long long int'. */
/* #undef HAVE_LONG_LONG_INT */

/* Define to 1 if you have the `lsetea' function. */
/* #undef HAVE_LSETEA */

/* Define to 1 if you have the `lsetxattr' function. */
/* #undef HAVE_LSETXATTR */

/* Define to 1 if you have the `lstat' function. */
#define HAVE_LSTAT 1

/* Define to 1 if `lstat' has the bug that it succeeds when given the
   zero-length file name argument. */
/* #undef HAVE_LSTAT_EMPTY_STRING_BUG */

/* Define to 1 if you have the `lutimes' function. */
#define HAVE_LUTIMES 1

/* Define to 1 if you have the <lzmadec.h> header file. */
/* #undef HAVE_LZMADEC_H */

/* Define to 1 if you have the <lzma.h> header file. */
/* #undef HAVE_LZMA_H */

/* Define to 1 if you have the <lzo/lzo1x.h> header file. */
/* #undef HAVE_LZO_LZO1X_H */

/* Define to 1 if you have the <lzo/lzoconf.h> header file. */
/* #undef HAVE_LZO_LZOCONF_H */

/* Define to 1 if you have the `mbrtowc' function. */
#define HAVE_MBRTOWC 1

/* Define to 1 if you have the `memmove' function. */
#define HAVE_MEMMOVE 1

/* Define to 1 if you have the <memory.h> header file. */
#define HAVE_MEMORY_H 1

/* Define to 1 if you have the `mkdir' function. */
#define HAVE_MKDIR 1

/* Define to 1 if you have the `mkfifo' function. */
#define HAVE_MKFIFO 1

/* Define to 1 if you have the `mknod' function. */
#define HAVE_MKNOD 1

/* Define to 1 if you have the `mkstemp' function. */
#define HAVE_MKSTEMP 1

/* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */
/* #undef HAVE_NDIR_H */

/* Define to 1 if you have the <nettle/md5.h> header file. */
/* #undef HAVE_NETTLE_MD5_H */

/* Define to 1 if you have the <nettle/ripemd160.h> header file. */
/* #undef HAVE_NETTLE_RIPEMD160_H */

/* Define to 1 if you have the <nettle/sha.h> header file. */
/* #undef HAVE_NETTLE_SHA_H */

/* Define to 1 if you have the `nl_langinfo' function. */
#define HAVE_NL_LANGINFO 1

/* Define to 1 if you have the `openat' function. */
#define HAVE_OPENAT 1

/* Define to 1 if you have the <paths.h> header file. */
#define HAVE_PATHS_H 1

/* Define to 1 if you have the <pcreposix.h> header file. */
/* #undef HAVE_PCREPOSIX_H */

/* Define to 1 if you have the `pipe' function. */
#define HAVE_PIPE 1

/* Define to 1 if you have the `poll' function. */
#define HAVE_POLL 1

/* Define to 1 if you have the <poll.h> header file. */
#define HAVE_POLL_H 1

/* Define to 1 if you have the `posix_spawnp' function. */
#define HAVE_POSIX_SPAWNP 1

/* Define to 1 if you have the <process.h> header file. */
/* #undef HAVE_PROCESS_H */

/* Define to 1 if you have the <pwd.h> header file. */
#define HAVE_PWD_H 1

/* Define to 1 if you have the `readdir_r' function. */
#define HAVE_READDIR_R 1

/* Define to 1 if you have the `readlink' function. */
#define HAVE_READLINK 1

/* Define to 1 if you have the `readlinkat' function. */
#define HAVE_READLINKAT 1

/* Define to 1 if you have the <regex.h> header file. */
#define HAVE_REGEX_H 1

/* Define to 1 if you have the `select' function. */
#define HAVE_SELECT 1

/* Define to 1 if you have the `setenv' function. */
#define HAVE_SETENV 1

/* Define to 1 if you have the `setlocale' function. */
#define HAVE_SETLOCALE 1

/* Define to 1 if you have the `sigaction' function. */
#define HAVE_SIGACTION 1

/* Define to 1 if you have the <signal.h> header file. */
#define HAVE_SIGNAL_H 1

/* Define to 1 if you have the <spawn.h> header file. */
#define HAVE_SPAWN_H 1

/* Define to 1 if you have the `statfs' function. */
#define HAVE_STATFS 1

/* Define to 1 if you have the `statvfs' function. */
#define HAVE_STATVFS 1

/* Define to 1 if `stat' has the bug that it succeeds when given the
   zero-length file name argument. */
/* #undef HAVE_STAT_EMPTY_STRING_BUG */

/* Define to 1 if you have the <stdarg.h> header file. */
#define HAVE_STDARG_H 1

/* Define to 1 if you have the <stdint.h> header file. */
#define HAVE_STDINT_H 1

/* Define to 1 if you have the <stdlib.h> header file. */
#define HAVE_STDLIB_H 1

/* Define to 1 if you have the `strchr' function. */
#define HAVE_STRCHR 1

/* Define to 1 if you have the `strdup' function. */
#define HAVE_STRDUP 1

/* Define to 1 if you have the `strerror' function. */
#define HAVE_STRERROR 1

/* Define to 1 if you have the `strerror_r' function. */
#define HAVE_STRERROR_R 1

/* Define to 1 if you have the `strftime' function. */
#define HAVE_STRFTIME 1

/* Define to 1 if you have the <strings.h> header file. */
#define HAVE_STRINGS_H 1

/* Define to 1 if you have the <string.h> header file. */
#define HAVE_STRING_H 1

/* Define to 1 if you have the `strrchr' function. */
#define HAVE_STRRCHR 1

/* Define to 1 if `f_namemax' is a member of `struct statfs'. */
/* #undef HAVE_STRUCT_STATFS_F_NAMEMAX */

/* Define to 1 if `f_iosize' is a member of `struct statvfs'. */
/* #undef HAVE_STRUCT_STATVFS_F_IOSIZE */

/* Define to 1 if `st_birthtime' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIME */

/* Define to 1 if `st_birthtimespec.tv_nsec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC_TV_NSEC */

/* Define to 1 if `st_blksize' is a member of `struct stat'. */
#define HAVE_STRUCT_STAT_ST_BLKSIZE 1

/* Define to 1 if `st_flags' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_FLAGS */

/* Define to 1 if `st_mtimespec.tv_nsec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC */

/* Define to 1 if `st_mtime_n' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIME_N */

/* Define to 1 if `st_mtime_usec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIME_USEC */

/* Define to 1 if `st_mtim.tv_nsec' is a member of `struct stat'. */
#define HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC 1

/* Define to 1 if `st_umtime' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_UMTIME */

/* Define to 1 if `tm_gmtoff' is a member of `struct tm'. */
#define HAVE_STRUCT_TM_TM_GMTOFF 1

/* Define to 1 if `__tm_gmtoff' is a member of `struct tm'. */
/* #undef HAVE_STRUCT_TM___TM_GMTOFF */

/* Define to 1 if you have the `symlink' function. */
#define HAVE_SYMLINK 1

/* Define to 1 if you have the <sys/acl.h> header file. */
/* #undef HAVE_SYS_ACL_H */

/* Define to 1 if you have the <sys/cdefs.h> header file. */
#define HAVE_SYS_CDEFS_H 1

/* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.
   */
/* #undef HAVE_SYS_DIR_H */

/* Define to 1 if you have the <sys/ea.h> header file. */
/* #undef HAVE_SYS_EA_H */

/* Define to 1 if you have the <sys/extattr.h> header file. */
/* #undef HAVE_SYS_EXTATTR_H */

/* Define to 1 if you have the <sys/ioctl.h> header file. */
#define HAVE_SYS_IOCTL_H 1

/* Define to 1 if you have the <sys/mkdev.h> header file. */
/* #undef HAVE_SYS_MKDEV_H */

/* Define to 1 if you have the <sys/mount.h> header file. */
/* #undef HAVE_SYS_MOUNT_H */

/* Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.
   */
/* #undef HAVE_SYS_NDIR_H */

/* Define to 1 if you have the <sys/param.h> header file. */
#define HAVE_SYS_PARAM_H 1

/* Define to 1 if you have the <sys/poll.h> header file. */
#define HAVE_SYS_POLL_H 1

/* Define to 1 if you have the <sys/select.h> header file. */
#define HAVE_SYS_SELECT_H 1

/* Define to 1 if you have the <sys/statfs.h> header file. */
#define HAVE_SYS_STATFS_H 1

/* Define to 1 if you have the <sys/statvfs.h> header file. */
#define HAVE_SYS_STATVFS_H 1

/* Define to 1 if you have the <sys/stat.h> header file. */
#define HAVE_SYS_STAT_H 1

/* Define to 1 if you have the <sys/time.h> header file. */
#define HAVE_SYS_TIME_H 1

/* Define to 1 if you have the <sys/types.h> header file. */
#define HAVE_SYS_TYPES_H 1

/* Define to 1 if you have the <sys/utime.h> header file. */
/* #undef HAVE_SYS_UTIME_H */

/* Define to 1 if you have the <sys/utsname.h> header file. */
#define HAVE_SYS_UTSNAME_H 1

/* Define to 1 if you have the <sys/vfs.h> header file. */
#define HAVE_SYS_VFS_H 1

/* Define to 1 if you have <sys/wait.h> that is POSIX.1 compatible. */
#define HAVE_SYS_WAIT_H 1

/* Define to 1 if you have the <sys/xattr.h> header file. */
/* #undef HAVE_SYS_XATTR_H */

/* Define to 1 if you have the `timegm' function. */
#define HAVE_TIMEGM 1

/* Define to 1 if you have the <time.h> header file. */
#define HAVE_TIME_H 1

/* Define to 1 if you have the `tzset' function. */
#define HAVE_TZSET 1

/* Define to 1 if you have the <unistd.h> header file. */
#define HAVE_UNISTD_H 1

/* Define to 1 if you have the `unsetenv' function. */
#define HAVE_UNSETENV 1

/* Define to 1 if the system has the type `unsigned long long'. */
/* #undef HAVE_UNSIGNED_LONG_LONG */

/* Define to 1 if the system has the type `unsigned long long int'. */
/* #undef HAVE_UNSIGNED_LONG_LONG_INT */

/* Define to 1 if you have the `utime' function. */
#define HAVE_UTIME 1

/* Define to 1 if you have the `utimensat' function. */
#define HAVE_UTIMENSAT 1

/* Define to 1 if you have the `utimes' function. */
#define HAVE_UTIMES 1

/* Define to 1 if you have the <utime.h> header file. */
#define HAVE_UTIME_H 1

/* Define to 1 if you have the `vfork' function. */
#define HAVE_VFORK 1

/* Define to 1 if you have the `vprintf' function. */
#define HAVE_VPRINTF 1

/* Define to 1 if you have the <wchar.h> header file. */
#define HAVE_WCHAR_H 1

/* Define to 1 if the system has the type `wchar_t'. */
#define HAVE_WCHAR_T 1

/* Define to 1 if you have the `wcrtomb' function. */
#define HAVE_WCRTOMB 1

/* Define to 1 if you have the `wcscmp' function. */
#define HAVE_WCSCMP 1

/* Define to 1 if you have the `wcscpy' function. */
#define HAVE_WCSCPY 1

/* Define to 1 if you have the `wcslen' function. */
#define HAVE_WCSLEN 1

/* Define to 1 if you have the `wctomb' function. */
#define HAVE_WCTOMB 1

/* Define to 1 if you have the <wctype.h> header file. */
#define HAVE_WCTYPE_H 1

/* Define to 1 if you have the <wincrypt.h> header file. */
/* #undef HAVE_WINCRYPT_H */

/* Define to 1 if you have the <windows.h> header file. */
/* #undef HAVE_WINDOWS_H */

/* Define to 1 if you have the <winioctl.h> header file. */
/* #undef HAVE_WINIOCTL_H */

/* Define to 1 if you have _CrtSetReportMode in <crtdbg.h>  */
/* #undef HAVE__CrtSetReportMode */

/* Define to 1 if you have the `wmemcmp' function. */
#define HAVE_WMEMCMP 1

/* Define to 1 if you have the `wmemcpy' function. */
#define HAVE_WMEMCPY 1

/* Define to 1 if you have a working EXT2_IOC_GETFLAGS */
/* #undef HAVE_WORKING_EXT2_IOC_GETFLAGS */

/* Define to 1 if you have the <zlib.h> header file. */
#define HAVE_ZLIB_H 1

/* Define to 1 if you have the `_ctime64_s' function. */
/* #undef HAVE__CTIME64_S */

/* Define to 1 if you have the `_fseeki64' function. */
/* #undef HAVE__FSEEKI64 */

/* Define to 1 if you have the `_get_timezone' function. */
/* #undef HAVE__GET_TIMEZONE */

/* Define to 1 if you have the `_localtime64_s' function. */
/* #undef HAVE__LOCALTIME64_S */

/* Define to 1 if you have the `_mkgmtime64' function. */
/* #undef HAVE__MKGMTIME64 */

/* Define as const if the declaration of iconv() needs const. */
#define ICONV_CONST 

/* Version number of libarchive as a single integer */
#define LIBARCHIVE_VERSION_NUMBER "3001002"

/* Version number of libarchive */
#define LIBARCHIVE_VERSION_STRING "3.1.2"

/* Define to 1 if `lstat' dereferences a symlink specified with a trailing
   slash. */
/* #undef LSTAT_FOLLOWS_SLASHED_SYMLINK */

/* Define to 1 if `major', `minor', and `makedev' are declared in <mkdev.h>.
   */
/* #undef MAJOR_IN_MKDEV */

/* Define to 1 if `major', `minor', and `makedev' are declared in
   <sysmacros.h>. */
#define MAJOR_IN_SYSMACROS 1

/* Define to 1 if your C compiler doesn't accept -c and -o together. */
/* #undef NO_MINUS_C_MINUS_O */

/* The size of `wchar_t', as computed by sizeof. */
#define SIZEOF_WCHAR_T 4

/* Define to 1 if strerror_r returns char *. */
/* #undef STRERROR_R_CHAR_P */

/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
#define TIME_WITH_SYS_TIME 1

/*
 * Some platform requires a macro to use extension functions.
 */
#define SAFE_TO_DEFINE_EXTENSIONS 1
#ifdef SAFE_TO_DEFINE_EXTENSIONS
/* Enable extensions on AIX 3, Interix.  */
#ifndef _ALL_SOURCE
# define _ALL_SOURCE 1
#endif
/* Enable GNU extensions on systems that have them.  */
#ifndef _GNU_SOURCE
# define _GNU_SOURCE 1
#endif
/* Enable threading extensions on Solaris.  */
#ifndef _POSIX_PTHREAD_SEMANTICS
# define _POSIX_PTHREAD_SEMANTICS 1
#endif
/* Enable extensions on HP NonStop.  */
#ifndef _TANDEM_SOURCE
# define _TANDEM_SOURCE 1
#endif
/* Enable general extensions on Solaris.  */
#ifndef __EXTENSIONS__
# define __EXTENSIONS__ 1
#endif
#endif /* SAFE_TO_DEFINE_EXTENSIONS */

/* Version number of package */
#define VERSION "3.1.2"

/* Number of bits in a file offset, on hosts where this is settable. */
/* #undef _FILE_OFFSET_BITS */

/* Define to 1 to make fseeko visible on some hosts (e.g. glibc 2.2). */
/* #undef _LARGEFILE_SOURCE */

/* Define for large files, on AIX-style hosts. */
/* #undef _LARGE_FILES */

/* Define for Windows to use Windows 2000+ APIs. */
/* #undef _WIN32_WINNT */
/* #undef WINVER */

/* Define to empty if `const' does not conform to ANSI C. */
/* #undef const */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef gid_t */

/* Define to `unsigned long' if <sys/types.h> does not define. */
/* #undef id_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef mode_t */

/* Define to `long long' if <sys/types.h> does not define. */
/* #undef off_t */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef pid_t */

/* Define to `unsigned int' if <sys/types.h> does not define. */
/* #undef size_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef ssize_t */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef uid_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef intptr_t */

/* Define to `unsigned int' if <sys/types.h> does not define. */
/* #undef uintptr_t */


#define ARCHIVE_SHA384_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA384_LIBC3
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = (DWORD)bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. Nettle
 * 6. OpenSSL
 * 7. libmd
 * 8. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive_sha384_ctx ctx;
  archive_sha384_init(&ctx);
  archive_sha384_update(&ctx, *argv, argc);
  archive_sha384_final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA512_LIBC3 failed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3495343096/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3495343096.dir/build.make CMakeFiles/cmTryCompileExec3495343096.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3495343096.dir/check_crypto_md.c.o
/usr/bin/gcc   -w  -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2 -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmlibarchive/libarchive -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec3495343096.dir/check_crypto_md.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1186:0:
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: fatal error: sha2.h: No such file or directory
 #include <sha2.h>
                  ^
compilation terminated.
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec3495343096.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec3495343096/fast] Error 2

Source file was:
/* config.h.  Generated from build/cmake/config.h.in by cmake configure */
#if defined(__osf__)
# define _OSF_SOURCE
#endif

/*
 * Ensure we have C99-style int64_t, etc, all defined.
 */

/* First, we need to know if the system has already defined them. */
#define HAVE_INT16_T
#define HAVE_INT32_T
#define HAVE_INT64_T
#define HAVE_INTMAX_T

#define HAVE_UINT8_T
#define HAVE_UINT16_T
#define HAVE_UINT32_T
#define HAVE_UINT64_T
#define HAVE_UINTMAX_T

/* We might have the types we want under other spellings. */
/* #undef HAVE___INT64 */
/* #undef HAVE_U_INT64_T */
/* #undef HAVE_UNSIGNED___INT64 */

/* The sizes of various standard integer types. */
#define SIZE_OF_SHORT 2
#define SIZE_OF_INT 4
#define SIZE_OF_LONG 8
#define SIZE_OF_LONG_LONG 8
#define SIZE_OF_UNSIGNED_SHORT 2
#define SIZE_OF_UNSIGNED 4
#define SIZE_OF_UNSIGNED_LONG 8
#define SIZE_OF_UNSIGNED_LONG_LONG 8

/*
 * If we lack int64_t, define it to the first of __int64, int, long, and long long
 * that exists and is the right size.
 */
#if !defined(HAVE_INT64_T) && defined(HAVE___INT64)
typedef __int64 int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_INT == 8
typedef int int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_LONG == 8
typedef long int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_LONG_LONG == 8
typedef long long int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T)
#error No 64-bit integer type was found.
#endif

/*
 * Similarly for int32_t
 */
#if !defined(HAVE_INT32_T) && SIZE_OF_INT == 4
typedef long int32_t;
#define HAVE_INT32_T
#endif

#if !defined(HAVE_INT32_T) && SIZE_OF_LONG == 4
typedef long int32_t;
#define HAVE_INT32_T
#endif

#if !defined(HAVE_INT32_T)
#error No 32-bit integer type was found.
#endif

/*
 * Similarly for int16_t
 */
#if !defined(HAVE_INT16_T) && SIZE_OF_INT == 2
typedef int int16_t;
#define HAVE_INT16_T
#endif

#if !defined(HAVE_INT16_T) && SIZE_OF_SHORT == 2
typedef short int16_t;
#define HAVE_INT16_T
#endif

#if !defined(HAVE_INT16_T)
#error No 16-bit integer type was found.
#endif

/*
 * Similarly for uint64_t
 */
#if !defined(HAVE_UINT64_T) && defined(HAVE_UNSIGNED___INT64)
typedef unsigned __int64 uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED == 8
typedef unsigned uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED_LONG == 8
typedef unsigned long uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED_LONG_LONG == 8
typedef unsigned long long uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T)
#error No 64-bit unsigned integer type was found.
#endif


/*
 * Similarly for uint32_t
 */
#if !defined(HAVE_UINT32_T) && SIZE_OF_UNSIGNED == 4
typedef unsigned uint32_t;
#define HAVE_UINT32_T
#endif

#if !defined(HAVE_UINT32_T) && SIZE_OF_UNSIGNED_LONG == 4
typedef unsigned long uint32_t;
#define HAVE_UINT32_T
#endif

#if !defined(HAVE_UINT32_T)
#error No 32-bit unsigned integer type was found.
#endif

/*
 * Similarly for uint16_t
 */
#if !defined(HAVE_UINT16_T) && SIZE_OF_UNSIGNED == 2
typedef unsigned uint16_t;
#define HAVE_UINT16_T
#endif

#if !defined(HAVE_UINT16_T) && SIZE_OF_UNSIGNED_SHORT == 2
typedef unsigned short uint16_t;
#define HAVE_UINT16_T
#endif

#if !defined(HAVE_UINT16_T)
#error No 16-bit unsigned integer type was found.
#endif

/*
 * Similarly for uint8_t
 */
#if !defined(HAVE_UINT8_T)
typedef unsigned char uint8_t;
#define HAVE_UINT8_T
#endif

#if !defined(HAVE_UINT16_T)
#error No 8-bit unsigned integer type was found.
#endif

/* Define intmax_t and uintmax_t if they are not already defined. */
#if !defined(HAVE_INTMAX_T)
typedef int64_t intmax_t;
#define INTMAX_MIN INT64_MIN
#define INTMAX_MAX INT64_MAX
#endif

#if !defined(HAVE_UINTMAX_T)
typedef uint64_t uintmax_t;
#endif

/* Define ZLIB_WINAPI if zlib was built on Visual Studio. */
/* #undef ZLIB_WINAPI */

/* MD5 via ARCHIVE_CRYPTO_MD5_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_MD5_LIBC */

/* MD5 via ARCHIVE_CRYPTO_MD5_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_MD5_LIBSYSTEM */

/* MD5 via ARCHIVE_CRYPTO_MD5_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_MD5_NETTLE */

/* MD5 via ARCHIVE_CRYPTO_MD5_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_MD5_OPENSSL */

/* MD5 via ARCHIVE_CRYPTO_MD5_WIN supported. */
/* #undef ARCHIVE_CRYPTO_MD5_WIN */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_LIBC */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_NETTLE */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_OPENSSL */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_LIBC */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_LIBSYSTEM */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_NETTLE */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_OPENSSL */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_WIN */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC2 */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC3 */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBSYSTEM */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_NETTLE */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_OPENSSL */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_WIN */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC2 */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC3 */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBSYSTEM */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_NETTLE */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_OPENSSL */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_WIN */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC2 */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC3 */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBSYSTEM */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_NETTLE */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_OPENSSL */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_WIN */

/* Version number of bsdcpio */
#define BSDCPIO_VERSION_STRING "3.1.2"

/* Version number of bsdtar */
#define BSDTAR_VERSION_STRING "3.1.2"

/* Define to 1 if you have the `acl_create_entry' function. */
/* #undef HAVE_ACL_CREATE_ENTRY */

/* Define to 1 if you have the `acl_get_link' function. */
/* #undef HAVE_ACL_GET_LINK */

/* Define to 1 if you have the `acl_get_link_np' function. */
/* #undef HAVE_ACL_GET_LINK_NP */

/* Define to 1 if you have the `acl_get_perm' function. */
/* #undef HAVE_ACL_GET_PERM */

/* Define to 1 if you have the `acl_get_perm_np' function. */
/* #undef HAVE_ACL_GET_PERM_NP */

/* Define to 1 if you have the `acl_init' function. */
/* #undef HAVE_ACL_INIT */

/* Define to 1 if you have the <acl/libacl.h> header file. */
/* #undef HAVE_ACL_LIBACL_H */

/* Define to 1 if the system has the type `acl_permset_t'. */
/* #undef HAVE_ACL_PERMSET_T */

/* Define to 1 if you have the `acl_set_fd' function. */
/* #undef HAVE_ACL_SET_FD */

/* Define to 1 if you have the `acl_set_fd_np' function. */
/* #undef HAVE_ACL_SET_FD_NP */

/* Define to 1 if you have the `acl_set_file' function. */
/* #undef HAVE_ACL_SET_FILE */

/* True for systems with POSIX ACL support */
/* #undef HAVE_ACL_USER */

/* Define to 1 if you have the <attr/xattr.h> header file. */
/* #undef HAVE_ATTR_XATTR_H */

/* Define to 1 if you have the <bsdxml.h> header file. */
/* #undef HAVE_BSDXML_H */

/* Define to 1 if you have the <bzlib.h> header file. */
#define HAVE_BZLIB_H 1

/* Define to 1 if you have the `chflags' function. */
/* #undef HAVE_CHFLAGS */

/* Define to 1 if you have the `chown' function. */
#define HAVE_CHOWN 1

/* Define to 1 if you have the `chroot' function. */
#define HAVE_CHROOT 1

/* Define to 1 if you have the <copyfile.h> header file. */
/* #undef HAVE_COPYFILE_H */

/* Define to 1 if you have the `ctime_r' function. */
#define HAVE_CTIME_R 1

/* Define to 1 if you have the <ctype.h> header file. */
#define HAVE_CTYPE_H 1

/* Define to 1 if you have the `cygwin_conv_path' function. */
/* #undef HAVE_CYGWIN_CONV_PATH */

/* Define to 1 if you have the declaration of `INT64_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_INT64_MAX 1

/* Define to 1 if you have the declaration of `INT64_MIN', and to 0 if you
   don't. */
#define HAVE_DECL_INT64_MIN 1

/* Define to 1 if you have the declaration of `SIZE_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_SIZE_MAX 1

/* Define to 1 if you have the declaration of `SSIZE_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_SSIZE_MAX 1

/* Define to 1 if you have the declaration of `strerror_r', and to 0 if you
   don't. */
#define HAVE_DECL_STRERROR_R 1

/* Define to 1 if you have the declaration of `UINT32_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_UINT32_MAX 1

/* Define to 1 if you have the declaration of `UINT64_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_UINT64_MAX 1

/* Define to 1 if you have the <direct.h> header file. */
/* #undef HAVE_DIRECT_H */

/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.
   */
#define HAVE_DIRENT_H 1

/* Define to 1 if you have the `dirfd' function. */
#define HAVE_DIRFD 1

/* Define to 1 if you have the <dlfcn.h> header file. */
#define HAVE_DLFCN_H 1

/* Define to 1 if you don't have `vprintf' but do have `_doprnt.' */
/* #undef HAVE_DOPRNT */

/* Define to 1 if nl_langinfo supports D_MD_ORDER */
/* #undef HAVE_D_MD_ORDER */

/* A possible errno value for invalid file format errors */
/* #undef HAVE_EFTYPE */

/* A possible errno value for invalid file format errors */
#define HAVE_EILSEQ 1

/* Define to 1 if you have the <errno.h> header file. */
#define HAVE_ERRNO_H 1

/* Define to 1 if you have the <expat.h> header file. */
/* #undef HAVE_EXPAT_H */

/* Define to 1 if you have the <ext2fs/ext2_fs.h> header file. */
/* #undef HAVE_EXT2FS_EXT2_FS_H */

/* Define to 1 if you have the `extattr_get_file' function. */
/* #undef HAVE_EXTATTR_GET_FILE */

/* Define to 1 if you have the `extattr_list_file' function. */
/* #undef HAVE_EXTATTR_LIST_FILE */

/* Define to 1 if you have the `extattr_set_fd' function. */
/* #undef HAVE_EXTATTR_SET_FD */

/* Define to 1 if you have the `extattr_set_file' function. */
/* #undef HAVE_EXTATTR_SET_FILE */

/* Define to 1 if EXTATTR_NAMESPACE_USER is defined in sys/extattr.h. */
/* #undef HAVE_DECL_EXTATTR_NAMESPACE_USER */

/* Define to 1 if you have the `fchdir' function. */
#define HAVE_FCHDIR 1

/* Define to 1 if you have the `fchflags' function. */
/* #undef HAVE_FCHFLAGS */

/* Define to 1 if you have the `fchmod' function. */
#define HAVE_FCHMOD 1

/* Define to 1 if you have the `fchown' function. */
#define HAVE_FCHOWN 1

/* Define to 1 if you have the `fcntl' function. */
#define HAVE_FCNTL 1

/* Define to 1 if you have the <fcntl.h> header file. */
#define HAVE_FCNTL_H 1

/* Define to 1 if you have the `fdopendir' function. */
#define HAVE_FDOPENDIR 1

/* Define to 1 if you have the `fgetea' function. */
/* #undef HAVE_FGETEA */

/* Define to 1 if you have the `fgetxattr' function. */
/* #undef HAVE_FGETXATTR */

/* Define to 1 if you have the `flistea' function. */
/* #undef HAVE_FLISTEA */

/* Define to 1 if you have the `flistxattr' function. */
/* #undef HAVE_FLISTXATTR */

/* Define to 1 if you have the `fork' function. */
#define HAVE_FORK 1

/* Define to 1 if fseeko (and presumably ftello) exists and is declared. */
#define HAVE_FSEEKO 1

/* Define to 1 if you have the `fsetea' function. */
/* #undef HAVE_FSETEA */

/* Define to 1 if you have the `fsetxattr' function. */
/* #undef HAVE_FSETXATTR */

/* Define to 1 if you have the `fstat' function. */
#define HAVE_FSTAT 1

/* Define to 1 if you have the `fstatat' function. */
#define HAVE_FSTATAT 1

/* Define to 1 if you have the `fstatfs' function. */
#define HAVE_FSTATFS 1

/* Define to 1 if you have the `fstatvfs' function. */
#define HAVE_FSTATVFS 1

/* Define to 1 if you have the `ftruncate' function. */
#define HAVE_FTRUNCATE 1

/* Define to 1 if you have the `futimens' function. */
#define HAVE_FUTIMENS 1

/* Define to 1 if you have the `futimes' function. */
#define HAVE_FUTIMES 1

/* Define to 1 if you have the `futimesat' function. */
#define HAVE_FUTIMESAT 1

/* Define to 1 if you have the `getea' function. */
/* #undef HAVE_GETEA */

/* Define to 1 if you have the `geteuid' function. */
#define HAVE_GETEUID 1

/* Define to 1 if you have the `getgrgid_r' function. */
#define HAVE_GETGRGID_R 1

/* Define to 1 if you have the `getgrnam_r' function. */
#define HAVE_GETGRNAM_R 1

/* Define to 1 if you have the `getpid' function. */
#define HAVE_GETPID 1

/* Define to 1 if you have the `getpwnam_r' function. */
#define HAVE_GETPWNAM_R 1

/* Define to 1 if you have the `getpwuid_r' function. */
#define HAVE_GETPWUID_R 1

/* Define to 1 if you have the `getvfsbyname' function. */
/* #undef HAVE_GETVFSBYNAME */

/* Define to 1 if you have the `getxattr' function. */
/* #undef HAVE_GETXATTR */

/* Define to 1 if you have the `gmtime_r' function. */
#define HAVE_GMTIME_R 1

/* Define to 1 if you have the <grp.h> header file. */
#define HAVE_GRP_H 1

/* Define to 1 if you have the `iconv' function. */
/* #undef HAVE_ICONV */

/* Define to 1 if you have the <iconv.h> header file. */
/* #undef HAVE_ICONV_H */

/* Define to 1 if you have the <inttypes.h> header file. */
#define HAVE_INTTYPES_H 1

/* Define to 1 if you have the <io.h> header file. */
/* #undef HAVE_IO_H */

/* Define to 1 if you have the <langinfo.h> header file. */
#define HAVE_LANGINFO_H 1

/* Define to 1 if you have the `lchflags' function. */
/* #undef HAVE_LCHFLAGS */

/* Define to 1 if you have the `lchmod' function. */
/* #undef HAVE_LCHMOD */

/* Define to 1 if you have the `lchown' function. */
#define HAVE_LCHOWN 1

/* Define to 1 if you have the `lgetea' function. */
/* #undef HAVE_LGETEA */

/* Define to 1 if you have the `lgetxattr' function. */
/* #undef HAVE_LGETXATTR */

/* Define to 1 if you have the `acl' library (-lacl). */
/* #undef HAVE_LIBACL */

/* Define to 1 if you have the `attr' library (-lattr). */
/* #undef HAVE_LIBATTR */

/* Define to 1 if you have the `bsdxml' library (-lbsdxml). */
/* #undef HAVE_LIBBSDXML */

/* Define to 1 if you have the `bz2' library (-lbz2). */
#define HAVE_LIBBZ2 1

/* Define to 1 if you have the `expat' library (-lexpat). */
/* #undef HAVE_LIBEXPAT */

/* Define to 1 if you have the `gcc' library (-lgcc). */
/* #undef HAVE_LIBGCC */

/* Define to 1 if you have the `lzma' library (-llzma). */
/* #undef HAVE_LIBLZMA */

/* Define to 1 if you have the `lzmadec' library (-llzmadec). */
/* #undef HAVE_LIBLZMADEC */

/* Define to 1 if you have the `lzo2' library (-llzo2). */
/* #undef HAVE_LIBLZO2 */

/* Define to 1 if you have the `nettle' library (-lnettle). */
/* #undef HAVE_LIBNETTLE */

/* Define to 1 if you have the `pcre' library (-lpcre). */
/* #undef HAVE_LIBPCRE */

/* Define to 1 if you have the `pcreposix' library (-lpcreposix). */
/* #undef HAVE_LIBPCREPOSIX */

/* Define to 1 if you have the `xml2' library (-lxml2). */
/* #undef HAVE_LIBXML2 */

/* Define to 1 if you have the <libxml/xmlreader.h> header file. */
/* #undef HAVE_LIBXML_XMLREADER_H */

/* Define to 1 if you have the <libxml/xmlwriter.h> header file. */
/* #undef HAVE_LIBXML_XMLWRITER_H */

/* Define to 1 if you have the `z' library (-lz). */
#define HAVE_LIBZ 1

/* Define to 1 if you have the <limits.h> header file. */
#define HAVE_LIMITS_H 1

/* Define to 1 if you have the `link' function. */
#define HAVE_LINK 1

/* Define to 1 if you have the <linux/types.h> header file. */
#define HAVE_LINUX_TYPES_H 1

/* Define to 1 if you have the <linux/fiemap.h> header file. */
#define HAVE_LINUX_FIEMAP_H 1

/* Define to 1 if you have the <linux/fs.h> header file. */
#define HAVE_LINUX_FS_H 1

/* Define to 1 if you have the <linux/magic.h> header file. */
#define HAVE_LINUX_MAGIC_H 1

/* Define to 1 if you have the <linux/types.h> header file. */
#define HAVE_LINUX_TYPES_H 1

/* Define to 1 if you have the `listea' function. */
/* #undef HAVE_LISTEA */

/* Define to 1 if you have the `listxattr' function. */
/* #undef HAVE_LISTXATTR */

/* Define to 1 if you have the `llistea' function. */
/* #undef HAVE_LLISTEA */

/* Define to 1 if you have the `llistxattr' function. */
/* #undef HAVE_LLISTXATTR */

/* Define to 1 if you have the <localcharset.h> header file. */
/* #undef HAVE_LOCALCHARSET_H */

/* Define to 1 if you have the `locale_charset' function. */
/* #undef HAVE_LOCALE_CHARSET */

/* Define to 1 if you have the <locale.h> header file. */
#define HAVE_LOCALE_H 1

/* Define to 1 if you have the `localtime_r' function. */
#define HAVE_LOCALTIME_R 1

/* Define to 1 if the system has the type `long long int'. */
/* #undef HAVE_LONG_LONG_INT */

/* Define to 1 if you have the `lsetea' function. */
/* #undef HAVE_LSETEA */

/* Define to 1 if you have the `lsetxattr' function. */
/* #undef HAVE_LSETXATTR */

/* Define to 1 if you have the `lstat' function. */
#define HAVE_LSTAT 1

/* Define to 1 if `lstat' has the bug that it succeeds when given the
   zero-length file name argument. */
/* #undef HAVE_LSTAT_EMPTY_STRING_BUG */

/* Define to 1 if you have the `lutimes' function. */
#define HAVE_LUTIMES 1

/* Define to 1 if you have the <lzmadec.h> header file. */
/* #undef HAVE_LZMADEC_H */

/* Define to 1 if you have the <lzma.h> header file. */
/* #undef HAVE_LZMA_H */

/* Define to 1 if you have the <lzo/lzo1x.h> header file. */
/* #undef HAVE_LZO_LZO1X_H */

/* Define to 1 if you have the <lzo/lzoconf.h> header file. */
/* #undef HAVE_LZO_LZOCONF_H */

/* Define to 1 if you have the `mbrtowc' function. */
#define HAVE_MBRTOWC 1

/* Define to 1 if you have the `memmove' function. */
#define HAVE_MEMMOVE 1

/* Define to 1 if you have the <memory.h> header file. */
#define HAVE_MEMORY_H 1

/* Define to 1 if you have the `mkdir' function. */
#define HAVE_MKDIR 1

/* Define to 1 if you have the `mkfifo' function. */
#define HAVE_MKFIFO 1

/* Define to 1 if you have the `mknod' function. */
#define HAVE_MKNOD 1

/* Define to 1 if you have the `mkstemp' function. */
#define HAVE_MKSTEMP 1

/* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */
/* #undef HAVE_NDIR_H */

/* Define to 1 if you have the <nettle/md5.h> header file. */
/* #undef HAVE_NETTLE_MD5_H */

/* Define to 1 if you have the <nettle/ripemd160.h> header file. */
/* #undef HAVE_NETTLE_RIPEMD160_H */

/* Define to 1 if you have the <nettle/sha.h> header file. */
/* #undef HAVE_NETTLE_SHA_H */

/* Define to 1 if you have the `nl_langinfo' function. */
#define HAVE_NL_LANGINFO 1

/* Define to 1 if you have the `openat' function. */
#define HAVE_OPENAT 1

/* Define to 1 if you have the <paths.h> header file. */
#define HAVE_PATHS_H 1

/* Define to 1 if you have the <pcreposix.h> header file. */
/* #undef HAVE_PCREPOSIX_H */

/* Define to 1 if you have the `pipe' function. */
#define HAVE_PIPE 1

/* Define to 1 if you have the `poll' function. */
#define HAVE_POLL 1

/* Define to 1 if you have the <poll.h> header file. */
#define HAVE_POLL_H 1

/* Define to 1 if you have the `posix_spawnp' function. */
#define HAVE_POSIX_SPAWNP 1

/* Define to 1 if you have the <process.h> header file. */
/* #undef HAVE_PROCESS_H */

/* Define to 1 if you have the <pwd.h> header file. */
#define HAVE_PWD_H 1

/* Define to 1 if you have the `readdir_r' function. */
#define HAVE_READDIR_R 1

/* Define to 1 if you have the `readlink' function. */
#define HAVE_READLINK 1

/* Define to 1 if you have the `readlinkat' function. */
#define HAVE_READLINKAT 1

/* Define to 1 if you have the <regex.h> header file. */
#define HAVE_REGEX_H 1

/* Define to 1 if you have the `select' function. */
#define HAVE_SELECT 1

/* Define to 1 if you have the `setenv' function. */
#define HAVE_SETENV 1

/* Define to 1 if you have the `setlocale' function. */
#define HAVE_SETLOCALE 1

/* Define to 1 if you have the `sigaction' function. */
#define HAVE_SIGACTION 1

/* Define to 1 if you have the <signal.h> header file. */
#define HAVE_SIGNAL_H 1

/* Define to 1 if you have the <spawn.h> header file. */
#define HAVE_SPAWN_H 1

/* Define to 1 if you have the `statfs' function. */
#define HAVE_STATFS 1

/* Define to 1 if you have the `statvfs' function. */
#define HAVE_STATVFS 1

/* Define to 1 if `stat' has the bug that it succeeds when given the
   zero-length file name argument. */
/* #undef HAVE_STAT_EMPTY_STRING_BUG */

/* Define to 1 if you have the <stdarg.h> header file. */
#define HAVE_STDARG_H 1

/* Define to 1 if you have the <stdint.h> header file. */
#define HAVE_STDINT_H 1

/* Define to 1 if you have the <stdlib.h> header file. */
#define HAVE_STDLIB_H 1

/* Define to 1 if you have the `strchr' function. */
#define HAVE_STRCHR 1

/* Define to 1 if you have the `strdup' function. */
#define HAVE_STRDUP 1

/* Define to 1 if you have the `strerror' function. */
#define HAVE_STRERROR 1

/* Define to 1 if you have the `strerror_r' function. */
#define HAVE_STRERROR_R 1

/* Define to 1 if you have the `strftime' function. */
#define HAVE_STRFTIME 1

/* Define to 1 if you have the <strings.h> header file. */
#define HAVE_STRINGS_H 1

/* Define to 1 if you have the <string.h> header file. */
#define HAVE_STRING_H 1

/* Define to 1 if you have the `strrchr' function. */
#define HAVE_STRRCHR 1

/* Define to 1 if `f_namemax' is a member of `struct statfs'. */
/* #undef HAVE_STRUCT_STATFS_F_NAMEMAX */

/* Define to 1 if `f_iosize' is a member of `struct statvfs'. */
/* #undef HAVE_STRUCT_STATVFS_F_IOSIZE */

/* Define to 1 if `st_birthtime' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIME */

/* Define to 1 if `st_birthtimespec.tv_nsec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC_TV_NSEC */

/* Define to 1 if `st_blksize' is a member of `struct stat'. */
#define HAVE_STRUCT_STAT_ST_BLKSIZE 1

/* Define to 1 if `st_flags' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_FLAGS */

/* Define to 1 if `st_mtimespec.tv_nsec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC */

/* Define to 1 if `st_mtime_n' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIME_N */

/* Define to 1 if `st_mtime_usec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIME_USEC */

/* Define to 1 if `st_mtim.tv_nsec' is a member of `struct stat'. */
#define HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC 1

/* Define to 1 if `st_umtime' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_UMTIME */

/* Define to 1 if `tm_gmtoff' is a member of `struct tm'. */
#define HAVE_STRUCT_TM_TM_GMTOFF 1

/* Define to 1 if `__tm_gmtoff' is a member of `struct tm'. */
/* #undef HAVE_STRUCT_TM___TM_GMTOFF */

/* Define to 1 if you have the `symlink' function. */
#define HAVE_SYMLINK 1

/* Define to 1 if you have the <sys/acl.h> header file. */
/* #undef HAVE_SYS_ACL_H */

/* Define to 1 if you have the <sys/cdefs.h> header file. */
#define HAVE_SYS_CDEFS_H 1

/* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.
   */
/* #undef HAVE_SYS_DIR_H */

/* Define to 1 if you have the <sys/ea.h> header file. */
/* #undef HAVE_SYS_EA_H */

/* Define to 1 if you have the <sys/extattr.h> header file. */
/* #undef HAVE_SYS_EXTATTR_H */

/* Define to 1 if you have the <sys/ioctl.h> header file. */
#define HAVE_SYS_IOCTL_H 1

/* Define to 1 if you have the <sys/mkdev.h> header file. */
/* #undef HAVE_SYS_MKDEV_H */

/* Define to 1 if you have the <sys/mount.h> header file. */
/* #undef HAVE_SYS_MOUNT_H */

/* Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.
   */
/* #undef HAVE_SYS_NDIR_H */

/* Define to 1 if you have the <sys/param.h> header file. */
#define HAVE_SYS_PARAM_H 1

/* Define to 1 if you have the <sys/poll.h> header file. */
#define HAVE_SYS_POLL_H 1

/* Define to 1 if you have the <sys/select.h> header file. */
#define HAVE_SYS_SELECT_H 1

/* Define to 1 if you have the <sys/statfs.h> header file. */
#define HAVE_SYS_STATFS_H 1

/* Define to 1 if you have the <sys/statvfs.h> header file. */
#define HAVE_SYS_STATVFS_H 1

/* Define to 1 if you have the <sys/stat.h> header file. */
#define HAVE_SYS_STAT_H 1

/* Define to 1 if you have the <sys/time.h> header file. */
#define HAVE_SYS_TIME_H 1

/* Define to 1 if you have the <sys/types.h> header file. */
#define HAVE_SYS_TYPES_H 1

/* Define to 1 if you have the <sys/utime.h> header file. */
/* #undef HAVE_SYS_UTIME_H */

/* Define to 1 if you have the <sys/utsname.h> header file. */
#define HAVE_SYS_UTSNAME_H 1

/* Define to 1 if you have the <sys/vfs.h> header file. */
#define HAVE_SYS_VFS_H 1

/* Define to 1 if you have <sys/wait.h> that is POSIX.1 compatible. */
#define HAVE_SYS_WAIT_H 1

/* Define to 1 if you have the <sys/xattr.h> header file. */
/* #undef HAVE_SYS_XATTR_H */

/* Define to 1 if you have the `timegm' function. */
#define HAVE_TIMEGM 1

/* Define to 1 if you have the <time.h> header file. */
#define HAVE_TIME_H 1

/* Define to 1 if you have the `tzset' function. */
#define HAVE_TZSET 1

/* Define to 1 if you have the <unistd.h> header file. */
#define HAVE_UNISTD_H 1

/* Define to 1 if you have the `unsetenv' function. */
#define HAVE_UNSETENV 1

/* Define to 1 if the system has the type `unsigned long long'. */
/* #undef HAVE_UNSIGNED_LONG_LONG */

/* Define to 1 if the system has the type `unsigned long long int'. */
/* #undef HAVE_UNSIGNED_LONG_LONG_INT */

/* Define to 1 if you have the `utime' function. */
#define HAVE_UTIME 1

/* Define to 1 if you have the `utimensat' function. */
#define HAVE_UTIMENSAT 1

/* Define to 1 if you have the `utimes' function. */
#define HAVE_UTIMES 1

/* Define to 1 if you have the <utime.h> header file. */
#define HAVE_UTIME_H 1

/* Define to 1 if you have the `vfork' function. */
#define HAVE_VFORK 1

/* Define to 1 if you have the `vprintf' function. */
#define HAVE_VPRINTF 1

/* Define to 1 if you have the <wchar.h> header file. */
#define HAVE_WCHAR_H 1

/* Define to 1 if the system has the type `wchar_t'. */
#define HAVE_WCHAR_T 1

/* Define to 1 if you have the `wcrtomb' function. */
#define HAVE_WCRTOMB 1

/* Define to 1 if you have the `wcscmp' function. */
#define HAVE_WCSCMP 1

/* Define to 1 if you have the `wcscpy' function. */
#define HAVE_WCSCPY 1

/* Define to 1 if you have the `wcslen' function. */
#define HAVE_WCSLEN 1

/* Define to 1 if you have the `wctomb' function. */
#define HAVE_WCTOMB 1

/* Define to 1 if you have the <wctype.h> header file. */
#define HAVE_WCTYPE_H 1

/* Define to 1 if you have the <wincrypt.h> header file. */
/* #undef HAVE_WINCRYPT_H */

/* Define to 1 if you have the <windows.h> header file. */
/* #undef HAVE_WINDOWS_H */

/* Define to 1 if you have the <winioctl.h> header file. */
/* #undef HAVE_WINIOCTL_H */

/* Define to 1 if you have _CrtSetReportMode in <crtdbg.h>  */
/* #undef HAVE__CrtSetReportMode */

/* Define to 1 if you have the `wmemcmp' function. */
#define HAVE_WMEMCMP 1

/* Define to 1 if you have the `wmemcpy' function. */
#define HAVE_WMEMCPY 1

/* Define to 1 if you have a working EXT2_IOC_GETFLAGS */
/* #undef HAVE_WORKING_EXT2_IOC_GETFLAGS */

/* Define to 1 if you have the <zlib.h> header file. */
#define HAVE_ZLIB_H 1

/* Define to 1 if you have the `_ctime64_s' function. */
/* #undef HAVE__CTIME64_S */

/* Define to 1 if you have the `_fseeki64' function. */
/* #undef HAVE__FSEEKI64 */

/* Define to 1 if you have the `_get_timezone' function. */
/* #undef HAVE__GET_TIMEZONE */

/* Define to 1 if you have the `_localtime64_s' function. */
/* #undef HAVE__LOCALTIME64_S */

/* Define to 1 if you have the `_mkgmtime64' function. */
/* #undef HAVE__MKGMTIME64 */

/* Define as const if the declaration of iconv() needs const. */
#define ICONV_CONST 

/* Version number of libarchive as a single integer */
#define LIBARCHIVE_VERSION_NUMBER "3001002"

/* Version number of libarchive */
#define LIBARCHIVE_VERSION_STRING "3.1.2"

/* Define to 1 if `lstat' dereferences a symlink specified with a trailing
   slash. */
/* #undef LSTAT_FOLLOWS_SLASHED_SYMLINK */

/* Define to 1 if `major', `minor', and `makedev' are declared in <mkdev.h>.
   */
/* #undef MAJOR_IN_MKDEV */

/* Define to 1 if `major', `minor', and `makedev' are declared in
   <sysmacros.h>. */
#define MAJOR_IN_SYSMACROS 1

/* Define to 1 if your C compiler doesn't accept -c and -o together. */
/* #undef NO_MINUS_C_MINUS_O */

/* The size of `wchar_t', as computed by sizeof. */
#define SIZEOF_WCHAR_T 4

/* Define to 1 if strerror_r returns char *. */
/* #undef STRERROR_R_CHAR_P */

/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
#define TIME_WITH_SYS_TIME 1

/*
 * Some platform requires a macro to use extension functions.
 */
#define SAFE_TO_DEFINE_EXTENSIONS 1
#ifdef SAFE_TO_DEFINE_EXTENSIONS
/* Enable extensions on AIX 3, Interix.  */
#ifndef _ALL_SOURCE
# define _ALL_SOURCE 1
#endif
/* Enable GNU extensions on systems that have them.  */
#ifndef _GNU_SOURCE
# define _GNU_SOURCE 1
#endif
/* Enable threading extensions on Solaris.  */
#ifndef _POSIX_PTHREAD_SEMANTICS
# define _POSIX_PTHREAD_SEMANTICS 1
#endif
/* Enable extensions on HP NonStop.  */
#ifndef _TANDEM_SOURCE
# define _TANDEM_SOURCE 1
#endif
/* Enable general extensions on Solaris.  */
#ifndef __EXTENSIONS__
# define __EXTENSIONS__ 1
#endif
#endif /* SAFE_TO_DEFINE_EXTENSIONS */

/* Version number of package */
#define VERSION "3.1.2"

/* Number of bits in a file offset, on hosts where this is settable. */
/* #undef _FILE_OFFSET_BITS */

/* Define to 1 to make fseeko visible on some hosts (e.g. glibc 2.2). */
/* #undef _LARGEFILE_SOURCE */

/* Define for large files, on AIX-style hosts. */
/* #undef _LARGE_FILES */

/* Define for Windows to use Windows 2000+ APIs. */
/* #undef _WIN32_WINNT */
/* #undef WINVER */

/* Define to empty if `const' does not conform to ANSI C. */
/* #undef const */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef gid_t */

/* Define to `unsigned long' if <sys/types.h> does not define. */
/* #undef id_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef mode_t */

/* Define to `long long' if <sys/types.h> does not define. */
/* #undef off_t */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef pid_t */

/* Define to `unsigned int' if <sys/types.h> does not define. */
/* #undef size_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef ssize_t */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef uid_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef intptr_t */

/* Define to `unsigned int' if <sys/types.h> does not define. */
/* #undef uintptr_t */


#define ARCHIVE_SHA512_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA512_LIBC3
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = (DWORD)bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. Nettle
 * 6. OpenSSL
 * 7. libmd
 * 8. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive_sha512_ctx ctx;
  archive_sha512_init(&ctx);
  archive_sha512_update(&ctx, *argv, argc);
  archive_sha512_final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_MD5_LIBSYSTEM failed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3623021091/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3623021091.dir/build.make CMakeFiles/cmTryCompileExec3623021091.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3623021091.dir/check_crypto_md.c.o
/usr/bin/gcc   -w  -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2 -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmlibarchive/libarchive -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec3623021091.dir/check_crypto_md.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1186:0:
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:112:39: fatal error: CommonCrypto/CommonDigest.h: No such file or directory
 #include <CommonCrypto/CommonDigest.h>
                                       ^
compilation terminated.
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec3623021091.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec3623021091/fast] Error 2

Source file was:
/* config.h.  Generated from build/cmake/config.h.in by cmake configure */
#if defined(__osf__)
# define _OSF_SOURCE
#endif

/*
 * Ensure we have C99-style int64_t, etc, all defined.
 */

/* First, we need to know if the system has already defined them. */
#define HAVE_INT16_T
#define HAVE_INT32_T
#define HAVE_INT64_T
#define HAVE_INTMAX_T

#define HAVE_UINT8_T
#define HAVE_UINT16_T
#define HAVE_UINT32_T
#define HAVE_UINT64_T
#define HAVE_UINTMAX_T

/* We might have the types we want under other spellings. */
/* #undef HAVE___INT64 */
/* #undef HAVE_U_INT64_T */
/* #undef HAVE_UNSIGNED___INT64 */

/* The sizes of various standard integer types. */
#define SIZE_OF_SHORT 2
#define SIZE_OF_INT 4
#define SIZE_OF_LONG 8
#define SIZE_OF_LONG_LONG 8
#define SIZE_OF_UNSIGNED_SHORT 2
#define SIZE_OF_UNSIGNED 4
#define SIZE_OF_UNSIGNED_LONG 8
#define SIZE_OF_UNSIGNED_LONG_LONG 8

/*
 * If we lack int64_t, define it to the first of __int64, int, long, and long long
 * that exists and is the right size.
 */
#if !defined(HAVE_INT64_T) && defined(HAVE___INT64)
typedef __int64 int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_INT == 8
typedef int int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_LONG == 8
typedef long int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_LONG_LONG == 8
typedef long long int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T)
#error No 64-bit integer type was found.
#endif

/*
 * Similarly for int32_t
 */
#if !defined(HAVE_INT32_T) && SIZE_OF_INT == 4
typedef long int32_t;
#define HAVE_INT32_T
#endif

#if !defined(HAVE_INT32_T) && SIZE_OF_LONG == 4
typedef long int32_t;
#define HAVE_INT32_T
#endif

#if !defined(HAVE_INT32_T)
#error No 32-bit integer type was found.
#endif

/*
 * Similarly for int16_t
 */
#if !defined(HAVE_INT16_T) && SIZE_OF_INT == 2
typedef int int16_t;
#define HAVE_INT16_T
#endif

#if !defined(HAVE_INT16_T) && SIZE_OF_SHORT == 2
typedef short int16_t;
#define HAVE_INT16_T
#endif

#if !defined(HAVE_INT16_T)
#error No 16-bit integer type was found.
#endif

/*
 * Similarly for uint64_t
 */
#if !defined(HAVE_UINT64_T) && defined(HAVE_UNSIGNED___INT64)
typedef unsigned __int64 uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED == 8
typedef unsigned uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED_LONG == 8
typedef unsigned long uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED_LONG_LONG == 8
typedef unsigned long long uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T)
#error No 64-bit unsigned integer type was found.
#endif


/*
 * Similarly for uint32_t
 */
#if !defined(HAVE_UINT32_T) && SIZE_OF_UNSIGNED == 4
typedef unsigned uint32_t;
#define HAVE_UINT32_T
#endif

#if !defined(HAVE_UINT32_T) && SIZE_OF_UNSIGNED_LONG == 4
typedef unsigned long uint32_t;
#define HAVE_UINT32_T
#endif

#if !defined(HAVE_UINT32_T)
#error No 32-bit unsigned integer type was found.
#endif

/*
 * Similarly for uint16_t
 */
#if !defined(HAVE_UINT16_T) && SIZE_OF_UNSIGNED == 2
typedef unsigned uint16_t;
#define HAVE_UINT16_T
#endif

#if !defined(HAVE_UINT16_T) && SIZE_OF_UNSIGNED_SHORT == 2
typedef unsigned short uint16_t;
#define HAVE_UINT16_T
#endif

#if !defined(HAVE_UINT16_T)
#error No 16-bit unsigned integer type was found.
#endif

/*
 * Similarly for uint8_t
 */
#if !defined(HAVE_UINT8_T)
typedef unsigned char uint8_t;
#define HAVE_UINT8_T
#endif

#if !defined(HAVE_UINT16_T)
#error No 8-bit unsigned integer type was found.
#endif

/* Define intmax_t and uintmax_t if they are not already defined. */
#if !defined(HAVE_INTMAX_T)
typedef int64_t intmax_t;
#define INTMAX_MIN INT64_MIN
#define INTMAX_MAX INT64_MAX
#endif

#if !defined(HAVE_UINTMAX_T)
typedef uint64_t uintmax_t;
#endif

/* Define ZLIB_WINAPI if zlib was built on Visual Studio. */
/* #undef ZLIB_WINAPI */

/* MD5 via ARCHIVE_CRYPTO_MD5_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_MD5_LIBC */

/* MD5 via ARCHIVE_CRYPTO_MD5_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_MD5_LIBSYSTEM */

/* MD5 via ARCHIVE_CRYPTO_MD5_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_MD5_NETTLE */

/* MD5 via ARCHIVE_CRYPTO_MD5_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_MD5_OPENSSL */

/* MD5 via ARCHIVE_CRYPTO_MD5_WIN supported. */
/* #undef ARCHIVE_CRYPTO_MD5_WIN */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_LIBC */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_NETTLE */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_OPENSSL */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_LIBC */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_LIBSYSTEM */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_NETTLE */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_OPENSSL */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_WIN */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC2 */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC3 */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBSYSTEM */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_NETTLE */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_OPENSSL */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_WIN */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC2 */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC3 */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBSYSTEM */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_NETTLE */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_OPENSSL */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_WIN */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC2 */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC3 */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBSYSTEM */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_NETTLE */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_OPENSSL */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_WIN */

/* Version number of bsdcpio */
#define BSDCPIO_VERSION_STRING "3.1.2"

/* Version number of bsdtar */
#define BSDTAR_VERSION_STRING "3.1.2"

/* Define to 1 if you have the `acl_create_entry' function. */
/* #undef HAVE_ACL_CREATE_ENTRY */

/* Define to 1 if you have the `acl_get_link' function. */
/* #undef HAVE_ACL_GET_LINK */

/* Define to 1 if you have the `acl_get_link_np' function. */
/* #undef HAVE_ACL_GET_LINK_NP */

/* Define to 1 if you have the `acl_get_perm' function. */
/* #undef HAVE_ACL_GET_PERM */

/* Define to 1 if you have the `acl_get_perm_np' function. */
/* #undef HAVE_ACL_GET_PERM_NP */

/* Define to 1 if you have the `acl_init' function. */
/* #undef HAVE_ACL_INIT */

/* Define to 1 if you have the <acl/libacl.h> header file. */
/* #undef HAVE_ACL_LIBACL_H */

/* Define to 1 if the system has the type `acl_permset_t'. */
/* #undef HAVE_ACL_PERMSET_T */

/* Define to 1 if you have the `acl_set_fd' function. */
/* #undef HAVE_ACL_SET_FD */

/* Define to 1 if you have the `acl_set_fd_np' function. */
/* #undef HAVE_ACL_SET_FD_NP */

/* Define to 1 if you have the `acl_set_file' function. */
/* #undef HAVE_ACL_SET_FILE */

/* True for systems with POSIX ACL support */
/* #undef HAVE_ACL_USER */

/* Define to 1 if you have the <attr/xattr.h> header file. */
/* #undef HAVE_ATTR_XATTR_H */

/* Define to 1 if you have the <bsdxml.h> header file. */
/* #undef HAVE_BSDXML_H */

/* Define to 1 if you have the <bzlib.h> header file. */
#define HAVE_BZLIB_H 1

/* Define to 1 if you have the `chflags' function. */
/* #undef HAVE_CHFLAGS */

/* Define to 1 if you have the `chown' function. */
#define HAVE_CHOWN 1

/* Define to 1 if you have the `chroot' function. */
#define HAVE_CHROOT 1

/* Define to 1 if you have the <copyfile.h> header file. */
/* #undef HAVE_COPYFILE_H */

/* Define to 1 if you have the `ctime_r' function. */
#define HAVE_CTIME_R 1

/* Define to 1 if you have the <ctype.h> header file. */
#define HAVE_CTYPE_H 1

/* Define to 1 if you have the `cygwin_conv_path' function. */
/* #undef HAVE_CYGWIN_CONV_PATH */

/* Define to 1 if you have the declaration of `INT64_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_INT64_MAX 1

/* Define to 1 if you have the declaration of `INT64_MIN', and to 0 if you
   don't. */
#define HAVE_DECL_INT64_MIN 1

/* Define to 1 if you have the declaration of `SIZE_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_SIZE_MAX 1

/* Define to 1 if you have the declaration of `SSIZE_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_SSIZE_MAX 1

/* Define to 1 if you have the declaration of `strerror_r', and to 0 if you
   don't. */
#define HAVE_DECL_STRERROR_R 1

/* Define to 1 if you have the declaration of `UINT32_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_UINT32_MAX 1

/* Define to 1 if you have the declaration of `UINT64_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_UINT64_MAX 1

/* Define to 1 if you have the <direct.h> header file. */
/* #undef HAVE_DIRECT_H */

/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.
   */
#define HAVE_DIRENT_H 1

/* Define to 1 if you have the `dirfd' function. */
#define HAVE_DIRFD 1

/* Define to 1 if you have the <dlfcn.h> header file. */
#define HAVE_DLFCN_H 1

/* Define to 1 if you don't have `vprintf' but do have `_doprnt.' */
/* #undef HAVE_DOPRNT */

/* Define to 1 if nl_langinfo supports D_MD_ORDER */
/* #undef HAVE_D_MD_ORDER */

/* A possible errno value for invalid file format errors */
/* #undef HAVE_EFTYPE */

/* A possible errno value for invalid file format errors */
#define HAVE_EILSEQ 1

/* Define to 1 if you have the <errno.h> header file. */
#define HAVE_ERRNO_H 1

/* Define to 1 if you have the <expat.h> header file. */
/* #undef HAVE_EXPAT_H */

/* Define to 1 if you have the <ext2fs/ext2_fs.h> header file. */
/* #undef HAVE_EXT2FS_EXT2_FS_H */

/* Define to 1 if you have the `extattr_get_file' function. */
/* #undef HAVE_EXTATTR_GET_FILE */

/* Define to 1 if you have the `extattr_list_file' function. */
/* #undef HAVE_EXTATTR_LIST_FILE */

/* Define to 1 if you have the `extattr_set_fd' function. */
/* #undef HAVE_EXTATTR_SET_FD */

/* Define to 1 if you have the `extattr_set_file' function. */
/* #undef HAVE_EXTATTR_SET_FILE */

/* Define to 1 if EXTATTR_NAMESPACE_USER is defined in sys/extattr.h. */
/* #undef HAVE_DECL_EXTATTR_NAMESPACE_USER */

/* Define to 1 if you have the `fchdir' function. */
#define HAVE_FCHDIR 1

/* Define to 1 if you have the `fchflags' function. */
/* #undef HAVE_FCHFLAGS */

/* Define to 1 if you have the `fchmod' function. */
#define HAVE_FCHMOD 1

/* Define to 1 if you have the `fchown' function. */
#define HAVE_FCHOWN 1

/* Define to 1 if you have the `fcntl' function. */
#define HAVE_FCNTL 1

/* Define to 1 if you have the <fcntl.h> header file. */
#define HAVE_FCNTL_H 1

/* Define to 1 if you have the `fdopendir' function. */
#define HAVE_FDOPENDIR 1

/* Define to 1 if you have the `fgetea' function. */
/* #undef HAVE_FGETEA */

/* Define to 1 if you have the `fgetxattr' function. */
/* #undef HAVE_FGETXATTR */

/* Define to 1 if you have the `flistea' function. */
/* #undef HAVE_FLISTEA */

/* Define to 1 if you have the `flistxattr' function. */
/* #undef HAVE_FLISTXATTR */

/* Define to 1 if you have the `fork' function. */
#define HAVE_FORK 1

/* Define to 1 if fseeko (and presumably ftello) exists and is declared. */
#define HAVE_FSEEKO 1

/* Define to 1 if you have the `fsetea' function. */
/* #undef HAVE_FSETEA */

/* Define to 1 if you have the `fsetxattr' function. */
/* #undef HAVE_FSETXATTR */

/* Define to 1 if you have the `fstat' function. */
#define HAVE_FSTAT 1

/* Define to 1 if you have the `fstatat' function. */
#define HAVE_FSTATAT 1

/* Define to 1 if you have the `fstatfs' function. */
#define HAVE_FSTATFS 1

/* Define to 1 if you have the `fstatvfs' function. */
#define HAVE_FSTATVFS 1

/* Define to 1 if you have the `ftruncate' function. */
#define HAVE_FTRUNCATE 1

/* Define to 1 if you have the `futimens' function. */
#define HAVE_FUTIMENS 1

/* Define to 1 if you have the `futimes' function. */
#define HAVE_FUTIMES 1

/* Define to 1 if you have the `futimesat' function. */
#define HAVE_FUTIMESAT 1

/* Define to 1 if you have the `getea' function. */
/* #undef HAVE_GETEA */

/* Define to 1 if you have the `geteuid' function. */
#define HAVE_GETEUID 1

/* Define to 1 if you have the `getgrgid_r' function. */
#define HAVE_GETGRGID_R 1

/* Define to 1 if you have the `getgrnam_r' function. */
#define HAVE_GETGRNAM_R 1

/* Define to 1 if you have the `getpid' function. */
#define HAVE_GETPID 1

/* Define to 1 if you have the `getpwnam_r' function. */
#define HAVE_GETPWNAM_R 1

/* Define to 1 if you have the `getpwuid_r' function. */
#define HAVE_GETPWUID_R 1

/* Define to 1 if you have the `getvfsbyname' function. */
/* #undef HAVE_GETVFSBYNAME */

/* Define to 1 if you have the `getxattr' function. */
/* #undef HAVE_GETXATTR */

/* Define to 1 if you have the `gmtime_r' function. */
#define HAVE_GMTIME_R 1

/* Define to 1 if you have the <grp.h> header file. */
#define HAVE_GRP_H 1

/* Define to 1 if you have the `iconv' function. */
/* #undef HAVE_ICONV */

/* Define to 1 if you have the <iconv.h> header file. */
/* #undef HAVE_ICONV_H */

/* Define to 1 if you have the <inttypes.h> header file. */
#define HAVE_INTTYPES_H 1

/* Define to 1 if you have the <io.h> header file. */
/* #undef HAVE_IO_H */

/* Define to 1 if you have the <langinfo.h> header file. */
#define HAVE_LANGINFO_H 1

/* Define to 1 if you have the `lchflags' function. */
/* #undef HAVE_LCHFLAGS */

/* Define to 1 if you have the `lchmod' function. */
/* #undef HAVE_LCHMOD */

/* Define to 1 if you have the `lchown' function. */
#define HAVE_LCHOWN 1

/* Define to 1 if you have the `lgetea' function. */
/* #undef HAVE_LGETEA */

/* Define to 1 if you have the `lgetxattr' function. */
/* #undef HAVE_LGETXATTR */

/* Define to 1 if you have the `acl' library (-lacl). */
/* #undef HAVE_LIBACL */

/* Define to 1 if you have the `attr' library (-lattr). */
/* #undef HAVE_LIBATTR */

/* Define to 1 if you have the `bsdxml' library (-lbsdxml). */
/* #undef HAVE_LIBBSDXML */

/* Define to 1 if you have the `bz2' library (-lbz2). */
#define HAVE_LIBBZ2 1

/* Define to 1 if you have the `expat' library (-lexpat). */
/* #undef HAVE_LIBEXPAT */

/* Define to 1 if you have the `gcc' library (-lgcc). */
/* #undef HAVE_LIBGCC */

/* Define to 1 if you have the `lzma' library (-llzma). */
/* #undef HAVE_LIBLZMA */

/* Define to 1 if you have the `lzmadec' library (-llzmadec). */
/* #undef HAVE_LIBLZMADEC */

/* Define to 1 if you have the `lzo2' library (-llzo2). */
/* #undef HAVE_LIBLZO2 */

/* Define to 1 if you have the `nettle' library (-lnettle). */
/* #undef HAVE_LIBNETTLE */

/* Define to 1 if you have the `pcre' library (-lpcre). */
/* #undef HAVE_LIBPCRE */

/* Define to 1 if you have the `pcreposix' library (-lpcreposix). */
/* #undef HAVE_LIBPCREPOSIX */

/* Define to 1 if you have the `xml2' library (-lxml2). */
/* #undef HAVE_LIBXML2 */

/* Define to 1 if you have the <libxml/xmlreader.h> header file. */
/* #undef HAVE_LIBXML_XMLREADER_H */

/* Define to 1 if you have the <libxml/xmlwriter.h> header file. */
/* #undef HAVE_LIBXML_XMLWRITER_H */

/* Define to 1 if you have the `z' library (-lz). */
#define HAVE_LIBZ 1

/* Define to 1 if you have the <limits.h> header file. */
#define HAVE_LIMITS_H 1

/* Define to 1 if you have the `link' function. */
#define HAVE_LINK 1

/* Define to 1 if you have the <linux/types.h> header file. */
#define HAVE_LINUX_TYPES_H 1

/* Define to 1 if you have the <linux/fiemap.h> header file. */
#define HAVE_LINUX_FIEMAP_H 1

/* Define to 1 if you have the <linux/fs.h> header file. */
#define HAVE_LINUX_FS_H 1

/* Define to 1 if you have the <linux/magic.h> header file. */
#define HAVE_LINUX_MAGIC_H 1

/* Define to 1 if you have the <linux/types.h> header file. */
#define HAVE_LINUX_TYPES_H 1

/* Define to 1 if you have the `listea' function. */
/* #undef HAVE_LISTEA */

/* Define to 1 if you have the `listxattr' function. */
/* #undef HAVE_LISTXATTR */

/* Define to 1 if you have the `llistea' function. */
/* #undef HAVE_LLISTEA */

/* Define to 1 if you have the `llistxattr' function. */
/* #undef HAVE_LLISTXATTR */

/* Define to 1 if you have the <localcharset.h> header file. */
/* #undef HAVE_LOCALCHARSET_H */

/* Define to 1 if you have the `locale_charset' function. */
/* #undef HAVE_LOCALE_CHARSET */

/* Define to 1 if you have the <locale.h> header file. */
#define HAVE_LOCALE_H 1

/* Define to 1 if you have the `localtime_r' function. */
#define HAVE_LOCALTIME_R 1

/* Define to 1 if the system has the type `long long int'. */
/* #undef HAVE_LONG_LONG_INT */

/* Define to 1 if you have the `lsetea' function. */
/* #undef HAVE_LSETEA */

/* Define to 1 if you have the `lsetxattr' function. */
/* #undef HAVE_LSETXATTR */

/* Define to 1 if you have the `lstat' function. */
#define HAVE_LSTAT 1

/* Define to 1 if `lstat' has the bug that it succeeds when given the
   zero-length file name argument. */
/* #undef HAVE_LSTAT_EMPTY_STRING_BUG */

/* Define to 1 if you have the `lutimes' function. */
#define HAVE_LUTIMES 1

/* Define to 1 if you have the <lzmadec.h> header file. */
/* #undef HAVE_LZMADEC_H */

/* Define to 1 if you have the <lzma.h> header file. */
/* #undef HAVE_LZMA_H */

/* Define to 1 if you have the <lzo/lzo1x.h> header file. */
/* #undef HAVE_LZO_LZO1X_H */

/* Define to 1 if you have the <lzo/lzoconf.h> header file. */
/* #undef HAVE_LZO_LZOCONF_H */

/* Define to 1 if you have the `mbrtowc' function. */
#define HAVE_MBRTOWC 1

/* Define to 1 if you have the `memmove' function. */
#define HAVE_MEMMOVE 1

/* Define to 1 if you have the <memory.h> header file. */
#define HAVE_MEMORY_H 1

/* Define to 1 if you have the `mkdir' function. */
#define HAVE_MKDIR 1

/* Define to 1 if you have the `mkfifo' function. */
#define HAVE_MKFIFO 1

/* Define to 1 if you have the `mknod' function. */
#define HAVE_MKNOD 1

/* Define to 1 if you have the `mkstemp' function. */
#define HAVE_MKSTEMP 1

/* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */
/* #undef HAVE_NDIR_H */

/* Define to 1 if you have the <nettle/md5.h> header file. */
/* #undef HAVE_NETTLE_MD5_H */

/* Define to 1 if you have the <nettle/ripemd160.h> header file. */
/* #undef HAVE_NETTLE_RIPEMD160_H */

/* Define to 1 if you have the <nettle/sha.h> header file. */
/* #undef HAVE_NETTLE_SHA_H */

/* Define to 1 if you have the `nl_langinfo' function. */
#define HAVE_NL_LANGINFO 1

/* Define to 1 if you have the `openat' function. */
#define HAVE_OPENAT 1

/* Define to 1 if you have the <paths.h> header file. */
#define HAVE_PATHS_H 1

/* Define to 1 if you have the <pcreposix.h> header file. */
/* #undef HAVE_PCREPOSIX_H */

/* Define to 1 if you have the `pipe' function. */
#define HAVE_PIPE 1

/* Define to 1 if you have the `poll' function. */
#define HAVE_POLL 1

/* Define to 1 if you have the <poll.h> header file. */
#define HAVE_POLL_H 1

/* Define to 1 if you have the `posix_spawnp' function. */
#define HAVE_POSIX_SPAWNP 1

/* Define to 1 if you have the <process.h> header file. */
/* #undef HAVE_PROCESS_H */

/* Define to 1 if you have the <pwd.h> header file. */
#define HAVE_PWD_H 1

/* Define to 1 if you have the `readdir_r' function. */
#define HAVE_READDIR_R 1

/* Define to 1 if you have the `readlink' function. */
#define HAVE_READLINK 1

/* Define to 1 if you have the `readlinkat' function. */
#define HAVE_READLINKAT 1

/* Define to 1 if you have the <regex.h> header file. */
#define HAVE_REGEX_H 1

/* Define to 1 if you have the `select' function. */
#define HAVE_SELECT 1

/* Define to 1 if you have the `setenv' function. */
#define HAVE_SETENV 1

/* Define to 1 if you have the `setlocale' function. */
#define HAVE_SETLOCALE 1

/* Define to 1 if you have the `sigaction' function. */
#define HAVE_SIGACTION 1

/* Define to 1 if you have the <signal.h> header file. */
#define HAVE_SIGNAL_H 1

/* Define to 1 if you have the <spawn.h> header file. */
#define HAVE_SPAWN_H 1

/* Define to 1 if you have the `statfs' function. */
#define HAVE_STATFS 1

/* Define to 1 if you have the `statvfs' function. */
#define HAVE_STATVFS 1

/* Define to 1 if `stat' has the bug that it succeeds when given the
   zero-length file name argument. */
/* #undef HAVE_STAT_EMPTY_STRING_BUG */

/* Define to 1 if you have the <stdarg.h> header file. */
#define HAVE_STDARG_H 1

/* Define to 1 if you have the <stdint.h> header file. */
#define HAVE_STDINT_H 1

/* Define to 1 if you have the <stdlib.h> header file. */
#define HAVE_STDLIB_H 1

/* Define to 1 if you have the `strchr' function. */
#define HAVE_STRCHR 1

/* Define to 1 if you have the `strdup' function. */
#define HAVE_STRDUP 1

/* Define to 1 if you have the `strerror' function. */
#define HAVE_STRERROR 1

/* Define to 1 if you have the `strerror_r' function. */
#define HAVE_STRERROR_R 1

/* Define to 1 if you have the `strftime' function. */
#define HAVE_STRFTIME 1

/* Define to 1 if you have the <strings.h> header file. */
#define HAVE_STRINGS_H 1

/* Define to 1 if you have the <string.h> header file. */
#define HAVE_STRING_H 1

/* Define to 1 if you have the `strrchr' function. */
#define HAVE_STRRCHR 1

/* Define to 1 if `f_namemax' is a member of `struct statfs'. */
/* #undef HAVE_STRUCT_STATFS_F_NAMEMAX */

/* Define to 1 if `f_iosize' is a member of `struct statvfs'. */
/* #undef HAVE_STRUCT_STATVFS_F_IOSIZE */

/* Define to 1 if `st_birthtime' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIME */

/* Define to 1 if `st_birthtimespec.tv_nsec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC_TV_NSEC */

/* Define to 1 if `st_blksize' is a member of `struct stat'. */
#define HAVE_STRUCT_STAT_ST_BLKSIZE 1

/* Define to 1 if `st_flags' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_FLAGS */

/* Define to 1 if `st_mtimespec.tv_nsec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC */

/* Define to 1 if `st_mtime_n' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIME_N */

/* Define to 1 if `st_mtime_usec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIME_USEC */

/* Define to 1 if `st_mtim.tv_nsec' is a member of `struct stat'. */
#define HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC 1

/* Define to 1 if `st_umtime' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_UMTIME */

/* Define to 1 if `tm_gmtoff' is a member of `struct tm'. */
#define HAVE_STRUCT_TM_TM_GMTOFF 1

/* Define to 1 if `__tm_gmtoff' is a member of `struct tm'. */
/* #undef HAVE_STRUCT_TM___TM_GMTOFF */

/* Define to 1 if you have the `symlink' function. */
#define HAVE_SYMLINK 1

/* Define to 1 if you have the <sys/acl.h> header file. */
/* #undef HAVE_SYS_ACL_H */

/* Define to 1 if you have the <sys/cdefs.h> header file. */
#define HAVE_SYS_CDEFS_H 1

/* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.
   */
/* #undef HAVE_SYS_DIR_H */

/* Define to 1 if you have the <sys/ea.h> header file. */
/* #undef HAVE_SYS_EA_H */

/* Define to 1 if you have the <sys/extattr.h> header file. */
/* #undef HAVE_SYS_EXTATTR_H */

/* Define to 1 if you have the <sys/ioctl.h> header file. */
#define HAVE_SYS_IOCTL_H 1

/* Define to 1 if you have the <sys/mkdev.h> header file. */
/* #undef HAVE_SYS_MKDEV_H */

/* Define to 1 if you have the <sys/mount.h> header file. */
/* #undef HAVE_SYS_MOUNT_H */

/* Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.
   */
/* #undef HAVE_SYS_NDIR_H */

/* Define to 1 if you have the <sys/param.h> header file. */
#define HAVE_SYS_PARAM_H 1

/* Define to 1 if you have the <sys/poll.h> header file. */
#define HAVE_SYS_POLL_H 1

/* Define to 1 if you have the <sys/select.h> header file. */
#define HAVE_SYS_SELECT_H 1

/* Define to 1 if you have the <sys/statfs.h> header file. */
#define HAVE_SYS_STATFS_H 1

/* Define to 1 if you have the <sys/statvfs.h> header file. */
#define HAVE_SYS_STATVFS_H 1

/* Define to 1 if you have the <sys/stat.h> header file. */
#define HAVE_SYS_STAT_H 1

/* Define to 1 if you have the <sys/time.h> header file. */
#define HAVE_SYS_TIME_H 1

/* Define to 1 if you have the <sys/types.h> header file. */
#define HAVE_SYS_TYPES_H 1

/* Define to 1 if you have the <sys/utime.h> header file. */
/* #undef HAVE_SYS_UTIME_H */

/* Define to 1 if you have the <sys/utsname.h> header file. */
#define HAVE_SYS_UTSNAME_H 1

/* Define to 1 if you have the <sys/vfs.h> header file. */
#define HAVE_SYS_VFS_H 1

/* Define to 1 if you have <sys/wait.h> that is POSIX.1 compatible. */
#define HAVE_SYS_WAIT_H 1

/* Define to 1 if you have the <sys/xattr.h> header file. */
/* #undef HAVE_SYS_XATTR_H */

/* Define to 1 if you have the `timegm' function. */
#define HAVE_TIMEGM 1

/* Define to 1 if you have the <time.h> header file. */
#define HAVE_TIME_H 1

/* Define to 1 if you have the `tzset' function. */
#define HAVE_TZSET 1

/* Define to 1 if you have the <unistd.h> header file. */
#define HAVE_UNISTD_H 1

/* Define to 1 if you have the `unsetenv' function. */
#define HAVE_UNSETENV 1

/* Define to 1 if the system has the type `unsigned long long'. */
/* #undef HAVE_UNSIGNED_LONG_LONG */

/* Define to 1 if the system has the type `unsigned long long int'. */
/* #undef HAVE_UNSIGNED_LONG_LONG_INT */

/* Define to 1 if you have the `utime' function. */
#define HAVE_UTIME 1

/* Define to 1 if you have the `utimensat' function. */
#define HAVE_UTIMENSAT 1

/* Define to 1 if you have the `utimes' function. */
#define HAVE_UTIMES 1

/* Define to 1 if you have the <utime.h> header file. */
#define HAVE_UTIME_H 1

/* Define to 1 if you have the `vfork' function. */
#define HAVE_VFORK 1

/* Define to 1 if you have the `vprintf' function. */
#define HAVE_VPRINTF 1

/* Define to 1 if you have the <wchar.h> header file. */
#define HAVE_WCHAR_H 1

/* Define to 1 if the system has the type `wchar_t'. */
#define HAVE_WCHAR_T 1

/* Define to 1 if you have the `wcrtomb' function. */
#define HAVE_WCRTOMB 1

/* Define to 1 if you have the `wcscmp' function. */
#define HAVE_WCSCMP 1

/* Define to 1 if you have the `wcscpy' function. */
#define HAVE_WCSCPY 1

/* Define to 1 if you have the `wcslen' function. */
#define HAVE_WCSLEN 1

/* Define to 1 if you have the `wctomb' function. */
#define HAVE_WCTOMB 1

/* Define to 1 if you have the <wctype.h> header file. */
#define HAVE_WCTYPE_H 1

/* Define to 1 if you have the <wincrypt.h> header file. */
/* #undef HAVE_WINCRYPT_H */

/* Define to 1 if you have the <windows.h> header file. */
/* #undef HAVE_WINDOWS_H */

/* Define to 1 if you have the <winioctl.h> header file. */
/* #undef HAVE_WINIOCTL_H */

/* Define to 1 if you have _CrtSetReportMode in <crtdbg.h>  */
/* #undef HAVE__CrtSetReportMode */

/* Define to 1 if you have the `wmemcmp' function. */
#define HAVE_WMEMCMP 1

/* Define to 1 if you have the `wmemcpy' function. */
#define HAVE_WMEMCPY 1

/* Define to 1 if you have a working EXT2_IOC_GETFLAGS */
/* #undef HAVE_WORKING_EXT2_IOC_GETFLAGS */

/* Define to 1 if you have the <zlib.h> header file. */
#define HAVE_ZLIB_H 1

/* Define to 1 if you have the `_ctime64_s' function. */
/* #undef HAVE__CTIME64_S */

/* Define to 1 if you have the `_fseeki64' function. */
/* #undef HAVE__FSEEKI64 */

/* Define to 1 if you have the `_get_timezone' function. */
/* #undef HAVE__GET_TIMEZONE */

/* Define to 1 if you have the `_localtime64_s' function. */
/* #undef HAVE__LOCALTIME64_S */

/* Define to 1 if you have the `_mkgmtime64' function. */
/* #undef HAVE__MKGMTIME64 */

/* Define as const if the declaration of iconv() needs const. */
#define ICONV_CONST 

/* Version number of libarchive as a single integer */
#define LIBARCHIVE_VERSION_NUMBER "3001002"

/* Version number of libarchive */
#define LIBARCHIVE_VERSION_STRING "3.1.2"

/* Define to 1 if `lstat' dereferences a symlink specified with a trailing
   slash. */
/* #undef LSTAT_FOLLOWS_SLASHED_SYMLINK */

/* Define to 1 if `major', `minor', and `makedev' are declared in <mkdev.h>.
   */
/* #undef MAJOR_IN_MKDEV */

/* Define to 1 if `major', `minor', and `makedev' are declared in
   <sysmacros.h>. */
#define MAJOR_IN_SYSMACROS 1

/* Define to 1 if your C compiler doesn't accept -c and -o together. */
/* #undef NO_MINUS_C_MINUS_O */

/* The size of `wchar_t', as computed by sizeof. */
#define SIZEOF_WCHAR_T 4

/* Define to 1 if strerror_r returns char *. */
/* #undef STRERROR_R_CHAR_P */

/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
#define TIME_WITH_SYS_TIME 1

/*
 * Some platform requires a macro to use extension functions.
 */
#define SAFE_TO_DEFINE_EXTENSIONS 1
#ifdef SAFE_TO_DEFINE_EXTENSIONS
/* Enable extensions on AIX 3, Interix.  */
#ifndef _ALL_SOURCE
# define _ALL_SOURCE 1
#endif
/* Enable GNU extensions on systems that have them.  */
#ifndef _GNU_SOURCE
# define _GNU_SOURCE 1
#endif
/* Enable threading extensions on Solaris.  */
#ifndef _POSIX_PTHREAD_SEMANTICS
# define _POSIX_PTHREAD_SEMANTICS 1
#endif
/* Enable extensions on HP NonStop.  */
#ifndef _TANDEM_SOURCE
# define _TANDEM_SOURCE 1
#endif
/* Enable general extensions on Solaris.  */
#ifndef __EXTENSIONS__
# define __EXTENSIONS__ 1
#endif
#endif /* SAFE_TO_DEFINE_EXTENSIONS */

/* Version number of package */
#define VERSION "3.1.2"

/* Number of bits in a file offset, on hosts where this is settable. */
/* #undef _FILE_OFFSET_BITS */

/* Define to 1 to make fseeko visible on some hosts (e.g. glibc 2.2). */
/* #undef _LARGEFILE_SOURCE */

/* Define for large files, on AIX-style hosts. */
/* #undef _LARGE_FILES */

/* Define for Windows to use Windows 2000+ APIs. */
/* #undef _WIN32_WINNT */
/* #undef WINVER */

/* Define to empty if `const' does not conform to ANSI C. */
/* #undef const */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef gid_t */

/* Define to `unsigned long' if <sys/types.h> does not define. */
/* #undef id_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef mode_t */

/* Define to `long long' if <sys/types.h> does not define. */
/* #undef off_t */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef pid_t */

/* Define to `unsigned int' if <sys/types.h> does not define. */
/* #undef size_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef ssize_t */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef uid_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef intptr_t */

/* Define to `unsigned int' if <sys/types.h> does not define. */
/* #undef uintptr_t */


#define ARCHIVE_MD5_COMPILE_TEST
#define ARCHIVE_CRYPTO_MD5_LIBSYSTEM
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = (DWORD)bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. Nettle
 * 6. OpenSSL
 * 7. libmd
 * 8. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive_md5_ctx ctx;
  archive_md5_init(&ctx);
  archive_md5_update(&ctx, *argv, argc);
  archive_md5_final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA1_LIBSYSTEM failed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1031398242/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1031398242.dir/build.make CMakeFiles/cmTryCompileExec1031398242.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1031398242.dir/check_crypto_md.c.o
/usr/bin/gcc   -w  -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2 -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmlibarchive/libarchive -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec1031398242.dir/check_crypto_md.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1186:0:
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:112:39: fatal error: CommonCrypto/CommonDigest.h: No such file or directory
 #include <CommonCrypto/CommonDigest.h>
                                       ^
compilation terminated.
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec1031398242.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec1031398242/fast] Error 2

Source file was:
/* config.h.  Generated from build/cmake/config.h.in by cmake configure */
#if defined(__osf__)
# define _OSF_SOURCE
#endif

/*
 * Ensure we have C99-style int64_t, etc, all defined.
 */

/* First, we need to know if the system has already defined them. */
#define HAVE_INT16_T
#define HAVE_INT32_T
#define HAVE_INT64_T
#define HAVE_INTMAX_T

#define HAVE_UINT8_T
#define HAVE_UINT16_T
#define HAVE_UINT32_T
#define HAVE_UINT64_T
#define HAVE_UINTMAX_T

/* We might have the types we want under other spellings. */
/* #undef HAVE___INT64 */
/* #undef HAVE_U_INT64_T */
/* #undef HAVE_UNSIGNED___INT64 */

/* The sizes of various standard integer types. */
#define SIZE_OF_SHORT 2
#define SIZE_OF_INT 4
#define SIZE_OF_LONG 8
#define SIZE_OF_LONG_LONG 8
#define SIZE_OF_UNSIGNED_SHORT 2
#define SIZE_OF_UNSIGNED 4
#define SIZE_OF_UNSIGNED_LONG 8
#define SIZE_OF_UNSIGNED_LONG_LONG 8

/*
 * If we lack int64_t, define it to the first of __int64, int, long, and long long
 * that exists and is the right size.
 */
#if !defined(HAVE_INT64_T) && defined(HAVE___INT64)
typedef __int64 int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_INT == 8
typedef int int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_LONG == 8
typedef long int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_LONG_LONG == 8
typedef long long int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T)
#error No 64-bit integer type was found.
#endif

/*
 * Similarly for int32_t
 */
#if !defined(HAVE_INT32_T) && SIZE_OF_INT == 4
typedef long int32_t;
#define HAVE_INT32_T
#endif

#if !defined(HAVE_INT32_T) && SIZE_OF_LONG == 4
typedef long int32_t;
#define HAVE_INT32_T
#endif

#if !defined(HAVE_INT32_T)
#error No 32-bit integer type was found.
#endif

/*
 * Similarly for int16_t
 */
#if !defined(HAVE_INT16_T) && SIZE_OF_INT == 2
typedef int int16_t;
#define HAVE_INT16_T
#endif

#if !defined(HAVE_INT16_T) && SIZE_OF_SHORT == 2
typedef short int16_t;
#define HAVE_INT16_T
#endif

#if !defined(HAVE_INT16_T)
#error No 16-bit integer type was found.
#endif

/*
 * Similarly for uint64_t
 */
#if !defined(HAVE_UINT64_T) && defined(HAVE_UNSIGNED___INT64)
typedef unsigned __int64 uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED == 8
typedef unsigned uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED_LONG == 8
typedef unsigned long uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED_LONG_LONG == 8
typedef unsigned long long uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T)
#error No 64-bit unsigned integer type was found.
#endif


/*
 * Similarly for uint32_t
 */
#if !defined(HAVE_UINT32_T) && SIZE_OF_UNSIGNED == 4
typedef unsigned uint32_t;
#define HAVE_UINT32_T
#endif

#if !defined(HAVE_UINT32_T) && SIZE_OF_UNSIGNED_LONG == 4
typedef unsigned long uint32_t;
#define HAVE_UINT32_T
#endif

#if !defined(HAVE_UINT32_T)
#error No 32-bit unsigned integer type was found.
#endif

/*
 * Similarly for uint16_t
 */
#if !defined(HAVE_UINT16_T) && SIZE_OF_UNSIGNED == 2
typedef unsigned uint16_t;
#define HAVE_UINT16_T
#endif

#if !defined(HAVE_UINT16_T) && SIZE_OF_UNSIGNED_SHORT == 2
typedef unsigned short uint16_t;
#define HAVE_UINT16_T
#endif

#if !defined(HAVE_UINT16_T)
#error No 16-bit unsigned integer type was found.
#endif

/*
 * Similarly for uint8_t
 */
#if !defined(HAVE_UINT8_T)
typedef unsigned char uint8_t;
#define HAVE_UINT8_T
#endif

#if !defined(HAVE_UINT16_T)
#error No 8-bit unsigned integer type was found.
#endif

/* Define intmax_t and uintmax_t if they are not already defined. */
#if !defined(HAVE_INTMAX_T)
typedef int64_t intmax_t;
#define INTMAX_MIN INT64_MIN
#define INTMAX_MAX INT64_MAX
#endif

#if !defined(HAVE_UINTMAX_T)
typedef uint64_t uintmax_t;
#endif

/* Define ZLIB_WINAPI if zlib was built on Visual Studio. */
/* #undef ZLIB_WINAPI */

/* MD5 via ARCHIVE_CRYPTO_MD5_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_MD5_LIBC */

/* MD5 via ARCHIVE_CRYPTO_MD5_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_MD5_LIBSYSTEM */

/* MD5 via ARCHIVE_CRYPTO_MD5_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_MD5_NETTLE */

/* MD5 via ARCHIVE_CRYPTO_MD5_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_MD5_OPENSSL */

/* MD5 via ARCHIVE_CRYPTO_MD5_WIN supported. */
/* #undef ARCHIVE_CRYPTO_MD5_WIN */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_LIBC */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_NETTLE */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_OPENSSL */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_LIBC */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_LIBSYSTEM */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_NETTLE */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_OPENSSL */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_WIN */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC2 */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC3 */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBSYSTEM */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_NETTLE */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_OPENSSL */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_WIN */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC2 */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC3 */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBSYSTEM */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_NETTLE */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_OPENSSL */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_WIN */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC2 */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC3 */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBSYSTEM */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_NETTLE */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_OPENSSL */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_WIN */

/* Version number of bsdcpio */
#define BSDCPIO_VERSION_STRING "3.1.2"

/* Version number of bsdtar */
#define BSDTAR_VERSION_STRING "3.1.2"

/* Define to 1 if you have the `acl_create_entry' function. */
/* #undef HAVE_ACL_CREATE_ENTRY */

/* Define to 1 if you have the `acl_get_link' function. */
/* #undef HAVE_ACL_GET_LINK */

/* Define to 1 if you have the `acl_get_link_np' function. */
/* #undef HAVE_ACL_GET_LINK_NP */

/* Define to 1 if you have the `acl_get_perm' function. */
/* #undef HAVE_ACL_GET_PERM */

/* Define to 1 if you have the `acl_get_perm_np' function. */
/* #undef HAVE_ACL_GET_PERM_NP */

/* Define to 1 if you have the `acl_init' function. */
/* #undef HAVE_ACL_INIT */

/* Define to 1 if you have the <acl/libacl.h> header file. */
/* #undef HAVE_ACL_LIBACL_H */

/* Define to 1 if the system has the type `acl_permset_t'. */
/* #undef HAVE_ACL_PERMSET_T */

/* Define to 1 if you have the `acl_set_fd' function. */
/* #undef HAVE_ACL_SET_FD */

/* Define to 1 if you have the `acl_set_fd_np' function. */
/* #undef HAVE_ACL_SET_FD_NP */

/* Define to 1 if you have the `acl_set_file' function. */
/* #undef HAVE_ACL_SET_FILE */

/* True for systems with POSIX ACL support */
/* #undef HAVE_ACL_USER */

/* Define to 1 if you have the <attr/xattr.h> header file. */
/* #undef HAVE_ATTR_XATTR_H */

/* Define to 1 if you have the <bsdxml.h> header file. */
/* #undef HAVE_BSDXML_H */

/* Define to 1 if you have the <bzlib.h> header file. */
#define HAVE_BZLIB_H 1

/* Define to 1 if you have the `chflags' function. */
/* #undef HAVE_CHFLAGS */

/* Define to 1 if you have the `chown' function. */
#define HAVE_CHOWN 1

/* Define to 1 if you have the `chroot' function. */
#define HAVE_CHROOT 1

/* Define to 1 if you have the <copyfile.h> header file. */
/* #undef HAVE_COPYFILE_H */

/* Define to 1 if you have the `ctime_r' function. */
#define HAVE_CTIME_R 1

/* Define to 1 if you have the <ctype.h> header file. */
#define HAVE_CTYPE_H 1

/* Define to 1 if you have the `cygwin_conv_path' function. */
/* #undef HAVE_CYGWIN_CONV_PATH */

/* Define to 1 if you have the declaration of `INT64_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_INT64_MAX 1

/* Define to 1 if you have the declaration of `INT64_MIN', and to 0 if you
   don't. */
#define HAVE_DECL_INT64_MIN 1

/* Define to 1 if you have the declaration of `SIZE_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_SIZE_MAX 1

/* Define to 1 if you have the declaration of `SSIZE_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_SSIZE_MAX 1

/* Define to 1 if you have the declaration of `strerror_r', and to 0 if you
   don't. */
#define HAVE_DECL_STRERROR_R 1

/* Define to 1 if you have the declaration of `UINT32_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_UINT32_MAX 1

/* Define to 1 if you have the declaration of `UINT64_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_UINT64_MAX 1

/* Define to 1 if you have the <direct.h> header file. */
/* #undef HAVE_DIRECT_H */

/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.
   */
#define HAVE_DIRENT_H 1

/* Define to 1 if you have the `dirfd' function. */
#define HAVE_DIRFD 1

/* Define to 1 if you have the <dlfcn.h> header file. */
#define HAVE_DLFCN_H 1

/* Define to 1 if you don't have `vprintf' but do have `_doprnt.' */
/* #undef HAVE_DOPRNT */

/* Define to 1 if nl_langinfo supports D_MD_ORDER */
/* #undef HAVE_D_MD_ORDER */

/* A possible errno value for invalid file format errors */
/* #undef HAVE_EFTYPE */

/* A possible errno value for invalid file format errors */
#define HAVE_EILSEQ 1

/* Define to 1 if you have the <errno.h> header file. */
#define HAVE_ERRNO_H 1

/* Define to 1 if you have the <expat.h> header file. */
/* #undef HAVE_EXPAT_H */

/* Define to 1 if you have the <ext2fs/ext2_fs.h> header file. */
/* #undef HAVE_EXT2FS_EXT2_FS_H */

/* Define to 1 if you have the `extattr_get_file' function. */
/* #undef HAVE_EXTATTR_GET_FILE */

/* Define to 1 if you have the `extattr_list_file' function. */
/* #undef HAVE_EXTATTR_LIST_FILE */

/* Define to 1 if you have the `extattr_set_fd' function. */
/* #undef HAVE_EXTATTR_SET_FD */

/* Define to 1 if you have the `extattr_set_file' function. */
/* #undef HAVE_EXTATTR_SET_FILE */

/* Define to 1 if EXTATTR_NAMESPACE_USER is defined in sys/extattr.h. */
/* #undef HAVE_DECL_EXTATTR_NAMESPACE_USER */

/* Define to 1 if you have the `fchdir' function. */
#define HAVE_FCHDIR 1

/* Define to 1 if you have the `fchflags' function. */
/* #undef HAVE_FCHFLAGS */

/* Define to 1 if you have the `fchmod' function. */
#define HAVE_FCHMOD 1

/* Define to 1 if you have the `fchown' function. */
#define HAVE_FCHOWN 1

/* Define to 1 if you have the `fcntl' function. */
#define HAVE_FCNTL 1

/* Define to 1 if you have the <fcntl.h> header file. */
#define HAVE_FCNTL_H 1

/* Define to 1 if you have the `fdopendir' function. */
#define HAVE_FDOPENDIR 1

/* Define to 1 if you have the `fgetea' function. */
/* #undef HAVE_FGETEA */

/* Define to 1 if you have the `fgetxattr' function. */
/* #undef HAVE_FGETXATTR */

/* Define to 1 if you have the `flistea' function. */
/* #undef HAVE_FLISTEA */

/* Define to 1 if you have the `flistxattr' function. */
/* #undef HAVE_FLISTXATTR */

/* Define to 1 if you have the `fork' function. */
#define HAVE_FORK 1

/* Define to 1 if fseeko (and presumably ftello) exists and is declared. */
#define HAVE_FSEEKO 1

/* Define to 1 if you have the `fsetea' function. */
/* #undef HAVE_FSETEA */

/* Define to 1 if you have the `fsetxattr' function. */
/* #undef HAVE_FSETXATTR */

/* Define to 1 if you have the `fstat' function. */
#define HAVE_FSTAT 1

/* Define to 1 if you have the `fstatat' function. */
#define HAVE_FSTATAT 1

/* Define to 1 if you have the `fstatfs' function. */
#define HAVE_FSTATFS 1

/* Define to 1 if you have the `fstatvfs' function. */
#define HAVE_FSTATVFS 1

/* Define to 1 if you have the `ftruncate' function. */
#define HAVE_FTRUNCATE 1

/* Define to 1 if you have the `futimens' function. */
#define HAVE_FUTIMENS 1

/* Define to 1 if you have the `futimes' function. */
#define HAVE_FUTIMES 1

/* Define to 1 if you have the `futimesat' function. */
#define HAVE_FUTIMESAT 1

/* Define to 1 if you have the `getea' function. */
/* #undef HAVE_GETEA */

/* Define to 1 if you have the `geteuid' function. */
#define HAVE_GETEUID 1

/* Define to 1 if you have the `getgrgid_r' function. */
#define HAVE_GETGRGID_R 1

/* Define to 1 if you have the `getgrnam_r' function. */
#define HAVE_GETGRNAM_R 1

/* Define to 1 if you have the `getpid' function. */
#define HAVE_GETPID 1

/* Define to 1 if you have the `getpwnam_r' function. */
#define HAVE_GETPWNAM_R 1

/* Define to 1 if you have the `getpwuid_r' function. */
#define HAVE_GETPWUID_R 1

/* Define to 1 if you have the `getvfsbyname' function. */
/* #undef HAVE_GETVFSBYNAME */

/* Define to 1 if you have the `getxattr' function. */
/* #undef HAVE_GETXATTR */

/* Define to 1 if you have the `gmtime_r' function. */
#define HAVE_GMTIME_R 1

/* Define to 1 if you have the <grp.h> header file. */
#define HAVE_GRP_H 1

/* Define to 1 if you have the `iconv' function. */
/* #undef HAVE_ICONV */

/* Define to 1 if you have the <iconv.h> header file. */
/* #undef HAVE_ICONV_H */

/* Define to 1 if you have the <inttypes.h> header file. */
#define HAVE_INTTYPES_H 1

/* Define to 1 if you have the <io.h> header file. */
/* #undef HAVE_IO_H */

/* Define to 1 if you have the <langinfo.h> header file. */
#define HAVE_LANGINFO_H 1

/* Define to 1 if you have the `lchflags' function. */
/* #undef HAVE_LCHFLAGS */

/* Define to 1 if you have the `lchmod' function. */
/* #undef HAVE_LCHMOD */

/* Define to 1 if you have the `lchown' function. */
#define HAVE_LCHOWN 1

/* Define to 1 if you have the `lgetea' function. */
/* #undef HAVE_LGETEA */

/* Define to 1 if you have the `lgetxattr' function. */
/* #undef HAVE_LGETXATTR */

/* Define to 1 if you have the `acl' library (-lacl). */
/* #undef HAVE_LIBACL */

/* Define to 1 if you have the `attr' library (-lattr). */
/* #undef HAVE_LIBATTR */

/* Define to 1 if you have the `bsdxml' library (-lbsdxml). */
/* #undef HAVE_LIBBSDXML */

/* Define to 1 if you have the `bz2' library (-lbz2). */
#define HAVE_LIBBZ2 1

/* Define to 1 if you have the `expat' library (-lexpat). */
/* #undef HAVE_LIBEXPAT */

/* Define to 1 if you have the `gcc' library (-lgcc). */
/* #undef HAVE_LIBGCC */

/* Define to 1 if you have the `lzma' library (-llzma). */
/* #undef HAVE_LIBLZMA */

/* Define to 1 if you have the `lzmadec' library (-llzmadec). */
/* #undef HAVE_LIBLZMADEC */

/* Define to 1 if you have the `lzo2' library (-llzo2). */
/* #undef HAVE_LIBLZO2 */

/* Define to 1 if you have the `nettle' library (-lnettle). */
/* #undef HAVE_LIBNETTLE */

/* Define to 1 if you have the `pcre' library (-lpcre). */
/* #undef HAVE_LIBPCRE */

/* Define to 1 if you have the `pcreposix' library (-lpcreposix). */
/* #undef HAVE_LIBPCREPOSIX */

/* Define to 1 if you have the `xml2' library (-lxml2). */
/* #undef HAVE_LIBXML2 */

/* Define to 1 if you have the <libxml/xmlreader.h> header file. */
/* #undef HAVE_LIBXML_XMLREADER_H */

/* Define to 1 if you have the <libxml/xmlwriter.h> header file. */
/* #undef HAVE_LIBXML_XMLWRITER_H */

/* Define to 1 if you have the `z' library (-lz). */
#define HAVE_LIBZ 1

/* Define to 1 if you have the <limits.h> header file. */
#define HAVE_LIMITS_H 1

/* Define to 1 if you have the `link' function. */
#define HAVE_LINK 1

/* Define to 1 if you have the <linux/types.h> header file. */
#define HAVE_LINUX_TYPES_H 1

/* Define to 1 if you have the <linux/fiemap.h> header file. */
#define HAVE_LINUX_FIEMAP_H 1

/* Define to 1 if you have the <linux/fs.h> header file. */
#define HAVE_LINUX_FS_H 1

/* Define to 1 if you have the <linux/magic.h> header file. */
#define HAVE_LINUX_MAGIC_H 1

/* Define to 1 if you have the <linux/types.h> header file. */
#define HAVE_LINUX_TYPES_H 1

/* Define to 1 if you have the `listea' function. */
/* #undef HAVE_LISTEA */

/* Define to 1 if you have the `listxattr' function. */
/* #undef HAVE_LISTXATTR */

/* Define to 1 if you have the `llistea' function. */
/* #undef HAVE_LLISTEA */

/* Define to 1 if you have the `llistxattr' function. */
/* #undef HAVE_LLISTXATTR */

/* Define to 1 if you have the <localcharset.h> header file. */
/* #undef HAVE_LOCALCHARSET_H */

/* Define to 1 if you have the `locale_charset' function. */
/* #undef HAVE_LOCALE_CHARSET */

/* Define to 1 if you have the <locale.h> header file. */
#define HAVE_LOCALE_H 1

/* Define to 1 if you have the `localtime_r' function. */
#define HAVE_LOCALTIME_R 1

/* Define to 1 if the system has the type `long long int'. */
/* #undef HAVE_LONG_LONG_INT */

/* Define to 1 if you have the `lsetea' function. */
/* #undef HAVE_LSETEA */

/* Define to 1 if you have the `lsetxattr' function. */
/* #undef HAVE_LSETXATTR */

/* Define to 1 if you have the `lstat' function. */
#define HAVE_LSTAT 1

/* Define to 1 if `lstat' has the bug that it succeeds when given the
   zero-length file name argument. */
/* #undef HAVE_LSTAT_EMPTY_STRING_BUG */

/* Define to 1 if you have the `lutimes' function. */
#define HAVE_LUTIMES 1

/* Define to 1 if you have the <lzmadec.h> header file. */
/* #undef HAVE_LZMADEC_H */

/* Define to 1 if you have the <lzma.h> header file. */
/* #undef HAVE_LZMA_H */

/* Define to 1 if you have the <lzo/lzo1x.h> header file. */
/* #undef HAVE_LZO_LZO1X_H */

/* Define to 1 if you have the <lzo/lzoconf.h> header file. */
/* #undef HAVE_LZO_LZOCONF_H */

/* Define to 1 if you have the `mbrtowc' function. */
#define HAVE_MBRTOWC 1

/* Define to 1 if you have the `memmove' function. */
#define HAVE_MEMMOVE 1

/* Define to 1 if you have the <memory.h> header file. */
#define HAVE_MEMORY_H 1

/* Define to 1 if you have the `mkdir' function. */
#define HAVE_MKDIR 1

/* Define to 1 if you have the `mkfifo' function. */
#define HAVE_MKFIFO 1

/* Define to 1 if you have the `mknod' function. */
#define HAVE_MKNOD 1

/* Define to 1 if you have the `mkstemp' function. */
#define HAVE_MKSTEMP 1

/* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */
/* #undef HAVE_NDIR_H */

/* Define to 1 if you have the <nettle/md5.h> header file. */
/* #undef HAVE_NETTLE_MD5_H */

/* Define to 1 if you have the <nettle/ripemd160.h> header file. */
/* #undef HAVE_NETTLE_RIPEMD160_H */

/* Define to 1 if you have the <nettle/sha.h> header file. */
/* #undef HAVE_NETTLE_SHA_H */

/* Define to 1 if you have the `nl_langinfo' function. */
#define HAVE_NL_LANGINFO 1

/* Define to 1 if you have the `openat' function. */
#define HAVE_OPENAT 1

/* Define to 1 if you have the <paths.h> header file. */
#define HAVE_PATHS_H 1

/* Define to 1 if you have the <pcreposix.h> header file. */
/* #undef HAVE_PCREPOSIX_H */

/* Define to 1 if you have the `pipe' function. */
#define HAVE_PIPE 1

/* Define to 1 if you have the `poll' function. */
#define HAVE_POLL 1

/* Define to 1 if you have the <poll.h> header file. */
#define HAVE_POLL_H 1

/* Define to 1 if you have the `posix_spawnp' function. */
#define HAVE_POSIX_SPAWNP 1

/* Define to 1 if you have the <process.h> header file. */
/* #undef HAVE_PROCESS_H */

/* Define to 1 if you have the <pwd.h> header file. */
#define HAVE_PWD_H 1

/* Define to 1 if you have the `readdir_r' function. */
#define HAVE_READDIR_R 1

/* Define to 1 if you have the `readlink' function. */
#define HAVE_READLINK 1

/* Define to 1 if you have the `readlinkat' function. */
#define HAVE_READLINKAT 1

/* Define to 1 if you have the <regex.h> header file. */
#define HAVE_REGEX_H 1

/* Define to 1 if you have the `select' function. */
#define HAVE_SELECT 1

/* Define to 1 if you have the `setenv' function. */
#define HAVE_SETENV 1

/* Define to 1 if you have the `setlocale' function. */
#define HAVE_SETLOCALE 1

/* Define to 1 if you have the `sigaction' function. */
#define HAVE_SIGACTION 1

/* Define to 1 if you have the <signal.h> header file. */
#define HAVE_SIGNAL_H 1

/* Define to 1 if you have the <spawn.h> header file. */
#define HAVE_SPAWN_H 1

/* Define to 1 if you have the `statfs' function. */
#define HAVE_STATFS 1

/* Define to 1 if you have the `statvfs' function. */
#define HAVE_STATVFS 1

/* Define to 1 if `stat' has the bug that it succeeds when given the
   zero-length file name argument. */
/* #undef HAVE_STAT_EMPTY_STRING_BUG */

/* Define to 1 if you have the <stdarg.h> header file. */
#define HAVE_STDARG_H 1

/* Define to 1 if you have the <stdint.h> header file. */
#define HAVE_STDINT_H 1

/* Define to 1 if you have the <stdlib.h> header file. */
#define HAVE_STDLIB_H 1

/* Define to 1 if you have the `strchr' function. */
#define HAVE_STRCHR 1

/* Define to 1 if you have the `strdup' function. */
#define HAVE_STRDUP 1

/* Define to 1 if you have the `strerror' function. */
#define HAVE_STRERROR 1

/* Define to 1 if you have the `strerror_r' function. */
#define HAVE_STRERROR_R 1

/* Define to 1 if you have the `strftime' function. */
#define HAVE_STRFTIME 1

/* Define to 1 if you have the <strings.h> header file. */
#define HAVE_STRINGS_H 1

/* Define to 1 if you have the <string.h> header file. */
#define HAVE_STRING_H 1

/* Define to 1 if you have the `strrchr' function. */
#define HAVE_STRRCHR 1

/* Define to 1 if `f_namemax' is a member of `struct statfs'. */
/* #undef HAVE_STRUCT_STATFS_F_NAMEMAX */

/* Define to 1 if `f_iosize' is a member of `struct statvfs'. */
/* #undef HAVE_STRUCT_STATVFS_F_IOSIZE */

/* Define to 1 if `st_birthtime' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIME */

/* Define to 1 if `st_birthtimespec.tv_nsec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC_TV_NSEC */

/* Define to 1 if `st_blksize' is a member of `struct stat'. */
#define HAVE_STRUCT_STAT_ST_BLKSIZE 1

/* Define to 1 if `st_flags' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_FLAGS */

/* Define to 1 if `st_mtimespec.tv_nsec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC */

/* Define to 1 if `st_mtime_n' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIME_N */

/* Define to 1 if `st_mtime_usec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIME_USEC */

/* Define to 1 if `st_mtim.tv_nsec' is a member of `struct stat'. */
#define HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC 1

/* Define to 1 if `st_umtime' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_UMTIME */

/* Define to 1 if `tm_gmtoff' is a member of `struct tm'. */
#define HAVE_STRUCT_TM_TM_GMTOFF 1

/* Define to 1 if `__tm_gmtoff' is a member of `struct tm'. */
/* #undef HAVE_STRUCT_TM___TM_GMTOFF */

/* Define to 1 if you have the `symlink' function. */
#define HAVE_SYMLINK 1

/* Define to 1 if you have the <sys/acl.h> header file. */
/* #undef HAVE_SYS_ACL_H */

/* Define to 1 if you have the <sys/cdefs.h> header file. */
#define HAVE_SYS_CDEFS_H 1

/* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.
   */
/* #undef HAVE_SYS_DIR_H */

/* Define to 1 if you have the <sys/ea.h> header file. */
/* #undef HAVE_SYS_EA_H */

/* Define to 1 if you have the <sys/extattr.h> header file. */
/* #undef HAVE_SYS_EXTATTR_H */

/* Define to 1 if you have the <sys/ioctl.h> header file. */
#define HAVE_SYS_IOCTL_H 1

/* Define to 1 if you have the <sys/mkdev.h> header file. */
/* #undef HAVE_SYS_MKDEV_H */

/* Define to 1 if you have the <sys/mount.h> header file. */
/* #undef HAVE_SYS_MOUNT_H */

/* Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.
   */
/* #undef HAVE_SYS_NDIR_H */

/* Define to 1 if you have the <sys/param.h> header file. */
#define HAVE_SYS_PARAM_H 1

/* Define to 1 if you have the <sys/poll.h> header file. */
#define HAVE_SYS_POLL_H 1

/* Define to 1 if you have the <sys/select.h> header file. */
#define HAVE_SYS_SELECT_H 1

/* Define to 1 if you have the <sys/statfs.h> header file. */
#define HAVE_SYS_STATFS_H 1

/* Define to 1 if you have the <sys/statvfs.h> header file. */
#define HAVE_SYS_STATVFS_H 1

/* Define to 1 if you have the <sys/stat.h> header file. */
#define HAVE_SYS_STAT_H 1

/* Define to 1 if you have the <sys/time.h> header file. */
#define HAVE_SYS_TIME_H 1

/* Define to 1 if you have the <sys/types.h> header file. */
#define HAVE_SYS_TYPES_H 1

/* Define to 1 if you have the <sys/utime.h> header file. */
/* #undef HAVE_SYS_UTIME_H */

/* Define to 1 if you have the <sys/utsname.h> header file. */
#define HAVE_SYS_UTSNAME_H 1

/* Define to 1 if you have the <sys/vfs.h> header file. */
#define HAVE_SYS_VFS_H 1

/* Define to 1 if you have <sys/wait.h> that is POSIX.1 compatible. */
#define HAVE_SYS_WAIT_H 1

/* Define to 1 if you have the <sys/xattr.h> header file. */
/* #undef HAVE_SYS_XATTR_H */

/* Define to 1 if you have the `timegm' function. */
#define HAVE_TIMEGM 1

/* Define to 1 if you have the <time.h> header file. */
#define HAVE_TIME_H 1

/* Define to 1 if you have the `tzset' function. */
#define HAVE_TZSET 1

/* Define to 1 if you have the <unistd.h> header file. */
#define HAVE_UNISTD_H 1

/* Define to 1 if you have the `unsetenv' function. */
#define HAVE_UNSETENV 1

/* Define to 1 if the system has the type `unsigned long long'. */
/* #undef HAVE_UNSIGNED_LONG_LONG */

/* Define to 1 if the system has the type `unsigned long long int'. */
/* #undef HAVE_UNSIGNED_LONG_LONG_INT */

/* Define to 1 if you have the `utime' function. */
#define HAVE_UTIME 1

/* Define to 1 if you have the `utimensat' function. */
#define HAVE_UTIMENSAT 1

/* Define to 1 if you have the `utimes' function. */
#define HAVE_UTIMES 1

/* Define to 1 if you have the <utime.h> header file. */
#define HAVE_UTIME_H 1

/* Define to 1 if you have the `vfork' function. */
#define HAVE_VFORK 1

/* Define to 1 if you have the `vprintf' function. */
#define HAVE_VPRINTF 1

/* Define to 1 if you have the <wchar.h> header file. */
#define HAVE_WCHAR_H 1

/* Define to 1 if the system has the type `wchar_t'. */
#define HAVE_WCHAR_T 1

/* Define to 1 if you have the `wcrtomb' function. */
#define HAVE_WCRTOMB 1

/* Define to 1 if you have the `wcscmp' function. */
#define HAVE_WCSCMP 1

/* Define to 1 if you have the `wcscpy' function. */
#define HAVE_WCSCPY 1

/* Define to 1 if you have the `wcslen' function. */
#define HAVE_WCSLEN 1

/* Define to 1 if you have the `wctomb' function. */
#define HAVE_WCTOMB 1

/* Define to 1 if you have the <wctype.h> header file. */
#define HAVE_WCTYPE_H 1

/* Define to 1 if you have the <wincrypt.h> header file. */
/* #undef HAVE_WINCRYPT_H */

/* Define to 1 if you have the <windows.h> header file. */
/* #undef HAVE_WINDOWS_H */

/* Define to 1 if you have the <winioctl.h> header file. */
/* #undef HAVE_WINIOCTL_H */

/* Define to 1 if you have _CrtSetReportMode in <crtdbg.h>  */
/* #undef HAVE__CrtSetReportMode */

/* Define to 1 if you have the `wmemcmp' function. */
#define HAVE_WMEMCMP 1

/* Define to 1 if you have the `wmemcpy' function. */
#define HAVE_WMEMCPY 1

/* Define to 1 if you have a working EXT2_IOC_GETFLAGS */
/* #undef HAVE_WORKING_EXT2_IOC_GETFLAGS */

/* Define to 1 if you have the <zlib.h> header file. */
#define HAVE_ZLIB_H 1

/* Define to 1 if you have the `_ctime64_s' function. */
/* #undef HAVE__CTIME64_S */

/* Define to 1 if you have the `_fseeki64' function. */
/* #undef HAVE__FSEEKI64 */

/* Define to 1 if you have the `_get_timezone' function. */
/* #undef HAVE__GET_TIMEZONE */

/* Define to 1 if you have the `_localtime64_s' function. */
/* #undef HAVE__LOCALTIME64_S */

/* Define to 1 if you have the `_mkgmtime64' function. */
/* #undef HAVE__MKGMTIME64 */

/* Define as const if the declaration of iconv() needs const. */
#define ICONV_CONST 

/* Version number of libarchive as a single integer */
#define LIBARCHIVE_VERSION_NUMBER "3001002"

/* Version number of libarchive */
#define LIBARCHIVE_VERSION_STRING "3.1.2"

/* Define to 1 if `lstat' dereferences a symlink specified with a trailing
   slash. */
/* #undef LSTAT_FOLLOWS_SLASHED_SYMLINK */

/* Define to 1 if `major', `minor', and `makedev' are declared in <mkdev.h>.
   */
/* #undef MAJOR_IN_MKDEV */

/* Define to 1 if `major', `minor', and `makedev' are declared in
   <sysmacros.h>. */
#define MAJOR_IN_SYSMACROS 1

/* Define to 1 if your C compiler doesn't accept -c and -o together. */
/* #undef NO_MINUS_C_MINUS_O */

/* The size of `wchar_t', as computed by sizeof. */
#define SIZEOF_WCHAR_T 4

/* Define to 1 if strerror_r returns char *. */
/* #undef STRERROR_R_CHAR_P */

/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
#define TIME_WITH_SYS_TIME 1

/*
 * Some platform requires a macro to use extension functions.
 */
#define SAFE_TO_DEFINE_EXTENSIONS 1
#ifdef SAFE_TO_DEFINE_EXTENSIONS
/* Enable extensions on AIX 3, Interix.  */
#ifndef _ALL_SOURCE
# define _ALL_SOURCE 1
#endif
/* Enable GNU extensions on systems that have them.  */
#ifndef _GNU_SOURCE
# define _GNU_SOURCE 1
#endif
/* Enable threading extensions on Solaris.  */
#ifndef _POSIX_PTHREAD_SEMANTICS
# define _POSIX_PTHREAD_SEMANTICS 1
#endif
/* Enable extensions on HP NonStop.  */
#ifndef _TANDEM_SOURCE
# define _TANDEM_SOURCE 1
#endif
/* Enable general extensions on Solaris.  */
#ifndef __EXTENSIONS__
# define __EXTENSIONS__ 1
#endif
#endif /* SAFE_TO_DEFINE_EXTENSIONS */

/* Version number of package */
#define VERSION "3.1.2"

/* Number of bits in a file offset, on hosts where this is settable. */
/* #undef _FILE_OFFSET_BITS */

/* Define to 1 to make fseeko visible on some hosts (e.g. glibc 2.2). */
/* #undef _LARGEFILE_SOURCE */

/* Define for large files, on AIX-style hosts. */
/* #undef _LARGE_FILES */

/* Define for Windows to use Windows 2000+ APIs. */
/* #undef _WIN32_WINNT */
/* #undef WINVER */

/* Define to empty if `const' does not conform to ANSI C. */
/* #undef const */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef gid_t */

/* Define to `unsigned long' if <sys/types.h> does not define. */
/* #undef id_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef mode_t */

/* Define to `long long' if <sys/types.h> does not define. */
/* #undef off_t */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef pid_t */

/* Define to `unsigned int' if <sys/types.h> does not define. */
/* #undef size_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef ssize_t */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef uid_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef intptr_t */

/* Define to `unsigned int' if <sys/types.h> does not define. */
/* #undef uintptr_t */


#define ARCHIVE_SHA1_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA1_LIBSYSTEM
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = (DWORD)bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. Nettle
 * 6. OpenSSL
 * 7. libmd
 * 8. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive_sha1_ctx ctx;
  archive_sha1_init(&ctx);
  archive_sha1_update(&ctx, *argv, argc);
  archive_sha1_final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA256_LIBSYSTEM failed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3144256106/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3144256106.dir/build.make CMakeFiles/cmTryCompileExec3144256106.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3144256106.dir/check_crypto_md.c.o
/usr/bin/gcc   -w  -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2 -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmlibarchive/libarchive -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec3144256106.dir/check_crypto_md.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1186:0:
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:112:39: fatal error: CommonCrypto/CommonDigest.h: No such file or directory
 #include <CommonCrypto/CommonDigest.h>
                                       ^
compilation terminated.
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec3144256106.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec3144256106/fast] Error 2

Source file was:
/* config.h.  Generated from build/cmake/config.h.in by cmake configure */
#if defined(__osf__)
# define _OSF_SOURCE
#endif

/*
 * Ensure we have C99-style int64_t, etc, all defined.
 */

/* First, we need to know if the system has already defined them. */
#define HAVE_INT16_T
#define HAVE_INT32_T
#define HAVE_INT64_T
#define HAVE_INTMAX_T

#define HAVE_UINT8_T
#define HAVE_UINT16_T
#define HAVE_UINT32_T
#define HAVE_UINT64_T
#define HAVE_UINTMAX_T

/* We might have the types we want under other spellings. */
/* #undef HAVE___INT64 */
/* #undef HAVE_U_INT64_T */
/* #undef HAVE_UNSIGNED___INT64 */

/* The sizes of various standard integer types. */
#define SIZE_OF_SHORT 2
#define SIZE_OF_INT 4
#define SIZE_OF_LONG 8
#define SIZE_OF_LONG_LONG 8
#define SIZE_OF_UNSIGNED_SHORT 2
#define SIZE_OF_UNSIGNED 4
#define SIZE_OF_UNSIGNED_LONG 8
#define SIZE_OF_UNSIGNED_LONG_LONG 8

/*
 * If we lack int64_t, define it to the first of __int64, int, long, and long long
 * that exists and is the right size.
 */
#if !defined(HAVE_INT64_T) && defined(HAVE___INT64)
typedef __int64 int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_INT == 8
typedef int int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_LONG == 8
typedef long int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_LONG_LONG == 8
typedef long long int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T)
#error No 64-bit integer type was found.
#endif

/*
 * Similarly for int32_t
 */
#if !defined(HAVE_INT32_T) && SIZE_OF_INT == 4
typedef long int32_t;
#define HAVE_INT32_T
#endif

#if !defined(HAVE_INT32_T) && SIZE_OF_LONG == 4
typedef long int32_t;
#define HAVE_INT32_T
#endif

#if !defined(HAVE_INT32_T)
#error No 32-bit integer type was found.
#endif

/*
 * Similarly for int16_t
 */
#if !defined(HAVE_INT16_T) && SIZE_OF_INT == 2
typedef int int16_t;
#define HAVE_INT16_T
#endif

#if !defined(HAVE_INT16_T) && SIZE_OF_SHORT == 2
typedef short int16_t;
#define HAVE_INT16_T
#endif

#if !defined(HAVE_INT16_T)
#error No 16-bit integer type was found.
#endif

/*
 * Similarly for uint64_t
 */
#if !defined(HAVE_UINT64_T) && defined(HAVE_UNSIGNED___INT64)
typedef unsigned __int64 uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED == 8
typedef unsigned uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED_LONG == 8
typedef unsigned long uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED_LONG_LONG == 8
typedef unsigned long long uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T)
#error No 64-bit unsigned integer type was found.
#endif


/*
 * Similarly for uint32_t
 */
#if !defined(HAVE_UINT32_T) && SIZE_OF_UNSIGNED == 4
typedef unsigned uint32_t;
#define HAVE_UINT32_T
#endif

#if !defined(HAVE_UINT32_T) && SIZE_OF_UNSIGNED_LONG == 4
typedef unsigned long uint32_t;
#define HAVE_UINT32_T
#endif

#if !defined(HAVE_UINT32_T)
#error No 32-bit unsigned integer type was found.
#endif

/*
 * Similarly for uint16_t
 */
#if !defined(HAVE_UINT16_T) && SIZE_OF_UNSIGNED == 2
typedef unsigned uint16_t;
#define HAVE_UINT16_T
#endif

#if !defined(HAVE_UINT16_T) && SIZE_OF_UNSIGNED_SHORT == 2
typedef unsigned short uint16_t;
#define HAVE_UINT16_T
#endif

#if !defined(HAVE_UINT16_T)
#error No 16-bit unsigned integer type was found.
#endif

/*
 * Similarly for uint8_t
 */
#if !defined(HAVE_UINT8_T)
typedef unsigned char uint8_t;
#define HAVE_UINT8_T
#endif

#if !defined(HAVE_UINT16_T)
#error No 8-bit unsigned integer type was found.
#endif

/* Define intmax_t and uintmax_t if they are not already defined. */
#if !defined(HAVE_INTMAX_T)
typedef int64_t intmax_t;
#define INTMAX_MIN INT64_MIN
#define INTMAX_MAX INT64_MAX
#endif

#if !defined(HAVE_UINTMAX_T)
typedef uint64_t uintmax_t;
#endif

/* Define ZLIB_WINAPI if zlib was built on Visual Studio. */
/* #undef ZLIB_WINAPI */

/* MD5 via ARCHIVE_CRYPTO_MD5_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_MD5_LIBC */

/* MD5 via ARCHIVE_CRYPTO_MD5_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_MD5_LIBSYSTEM */

/* MD5 via ARCHIVE_CRYPTO_MD5_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_MD5_NETTLE */

/* MD5 via ARCHIVE_CRYPTO_MD5_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_MD5_OPENSSL */

/* MD5 via ARCHIVE_CRYPTO_MD5_WIN supported. */
/* #undef ARCHIVE_CRYPTO_MD5_WIN */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_LIBC */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_NETTLE */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_OPENSSL */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_LIBC */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_LIBSYSTEM */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_NETTLE */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_OPENSSL */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_WIN */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC2 */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC3 */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBSYSTEM */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_NETTLE */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_OPENSSL */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_WIN */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC2 */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC3 */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBSYSTEM */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_NETTLE */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_OPENSSL */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_WIN */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC2 */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC3 */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBSYSTEM */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_NETTLE */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_OPENSSL */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_WIN */

/* Version number of bsdcpio */
#define BSDCPIO_VERSION_STRING "3.1.2"

/* Version number of bsdtar */
#define BSDTAR_VERSION_STRING "3.1.2"

/* Define to 1 if you have the `acl_create_entry' function. */
/* #undef HAVE_ACL_CREATE_ENTRY */

/* Define to 1 if you have the `acl_get_link' function. */
/* #undef HAVE_ACL_GET_LINK */

/* Define to 1 if you have the `acl_get_link_np' function. */
/* #undef HAVE_ACL_GET_LINK_NP */

/* Define to 1 if you have the `acl_get_perm' function. */
/* #undef HAVE_ACL_GET_PERM */

/* Define to 1 if you have the `acl_get_perm_np' function. */
/* #undef HAVE_ACL_GET_PERM_NP */

/* Define to 1 if you have the `acl_init' function. */
/* #undef HAVE_ACL_INIT */

/* Define to 1 if you have the <acl/libacl.h> header file. */
/* #undef HAVE_ACL_LIBACL_H */

/* Define to 1 if the system has the type `acl_permset_t'. */
/* #undef HAVE_ACL_PERMSET_T */

/* Define to 1 if you have the `acl_set_fd' function. */
/* #undef HAVE_ACL_SET_FD */

/* Define to 1 if you have the `acl_set_fd_np' function. */
/* #undef HAVE_ACL_SET_FD_NP */

/* Define to 1 if you have the `acl_set_file' function. */
/* #undef HAVE_ACL_SET_FILE */

/* True for systems with POSIX ACL support */
/* #undef HAVE_ACL_USER */

/* Define to 1 if you have the <attr/xattr.h> header file. */
/* #undef HAVE_ATTR_XATTR_H */

/* Define to 1 if you have the <bsdxml.h> header file. */
/* #undef HAVE_BSDXML_H */

/* Define to 1 if you have the <bzlib.h> header file. */
#define HAVE_BZLIB_H 1

/* Define to 1 if you have the `chflags' function. */
/* #undef HAVE_CHFLAGS */

/* Define to 1 if you have the `chown' function. */
#define HAVE_CHOWN 1

/* Define to 1 if you have the `chroot' function. */
#define HAVE_CHROOT 1

/* Define to 1 if you have the <copyfile.h> header file. */
/* #undef HAVE_COPYFILE_H */

/* Define to 1 if you have the `ctime_r' function. */
#define HAVE_CTIME_R 1

/* Define to 1 if you have the <ctype.h> header file. */
#define HAVE_CTYPE_H 1

/* Define to 1 if you have the `cygwin_conv_path' function. */
/* #undef HAVE_CYGWIN_CONV_PATH */

/* Define to 1 if you have the declaration of `INT64_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_INT64_MAX 1

/* Define to 1 if you have the declaration of `INT64_MIN', and to 0 if you
   don't. */
#define HAVE_DECL_INT64_MIN 1

/* Define to 1 if you have the declaration of `SIZE_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_SIZE_MAX 1

/* Define to 1 if you have the declaration of `SSIZE_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_SSIZE_MAX 1

/* Define to 1 if you have the declaration of `strerror_r', and to 0 if you
   don't. */
#define HAVE_DECL_STRERROR_R 1

/* Define to 1 if you have the declaration of `UINT32_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_UINT32_MAX 1

/* Define to 1 if you have the declaration of `UINT64_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_UINT64_MAX 1

/* Define to 1 if you have the <direct.h> header file. */
/* #undef HAVE_DIRECT_H */

/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.
   */
#define HAVE_DIRENT_H 1

/* Define to 1 if you have the `dirfd' function. */
#define HAVE_DIRFD 1

/* Define to 1 if you have the <dlfcn.h> header file. */
#define HAVE_DLFCN_H 1

/* Define to 1 if you don't have `vprintf' but do have `_doprnt.' */
/* #undef HAVE_DOPRNT */

/* Define to 1 if nl_langinfo supports D_MD_ORDER */
/* #undef HAVE_D_MD_ORDER */

/* A possible errno value for invalid file format errors */
/* #undef HAVE_EFTYPE */

/* A possible errno value for invalid file format errors */
#define HAVE_EILSEQ 1

/* Define to 1 if you have the <errno.h> header file. */
#define HAVE_ERRNO_H 1

/* Define to 1 if you have the <expat.h> header file. */
/* #undef HAVE_EXPAT_H */

/* Define to 1 if you have the <ext2fs/ext2_fs.h> header file. */
/* #undef HAVE_EXT2FS_EXT2_FS_H */

/* Define to 1 if you have the `extattr_get_file' function. */
/* #undef HAVE_EXTATTR_GET_FILE */

/* Define to 1 if you have the `extattr_list_file' function. */
/* #undef HAVE_EXTATTR_LIST_FILE */

/* Define to 1 if you have the `extattr_set_fd' function. */
/* #undef HAVE_EXTATTR_SET_FD */

/* Define to 1 if you have the `extattr_set_file' function. */
/* #undef HAVE_EXTATTR_SET_FILE */

/* Define to 1 if EXTATTR_NAMESPACE_USER is defined in sys/extattr.h. */
/* #undef HAVE_DECL_EXTATTR_NAMESPACE_USER */

/* Define to 1 if you have the `fchdir' function. */
#define HAVE_FCHDIR 1

/* Define to 1 if you have the `fchflags' function. */
/* #undef HAVE_FCHFLAGS */

/* Define to 1 if you have the `fchmod' function. */
#define HAVE_FCHMOD 1

/* Define to 1 if you have the `fchown' function. */
#define HAVE_FCHOWN 1

/* Define to 1 if you have the `fcntl' function. */
#define HAVE_FCNTL 1

/* Define to 1 if you have the <fcntl.h> header file. */
#define HAVE_FCNTL_H 1

/* Define to 1 if you have the `fdopendir' function. */
#define HAVE_FDOPENDIR 1

/* Define to 1 if you have the `fgetea' function. */
/* #undef HAVE_FGETEA */

/* Define to 1 if you have the `fgetxattr' function. */
/* #undef HAVE_FGETXATTR */

/* Define to 1 if you have the `flistea' function. */
/* #undef HAVE_FLISTEA */

/* Define to 1 if you have the `flistxattr' function. */
/* #undef HAVE_FLISTXATTR */

/* Define to 1 if you have the `fork' function. */
#define HAVE_FORK 1

/* Define to 1 if fseeko (and presumably ftello) exists and is declared. */
#define HAVE_FSEEKO 1

/* Define to 1 if you have the `fsetea' function. */
/* #undef HAVE_FSETEA */

/* Define to 1 if you have the `fsetxattr' function. */
/* #undef HAVE_FSETXATTR */

/* Define to 1 if you have the `fstat' function. */
#define HAVE_FSTAT 1

/* Define to 1 if you have the `fstatat' function. */
#define HAVE_FSTATAT 1

/* Define to 1 if you have the `fstatfs' function. */
#define HAVE_FSTATFS 1

/* Define to 1 if you have the `fstatvfs' function. */
#define HAVE_FSTATVFS 1

/* Define to 1 if you have the `ftruncate' function. */
#define HAVE_FTRUNCATE 1

/* Define to 1 if you have the `futimens' function. */
#define HAVE_FUTIMENS 1

/* Define to 1 if you have the `futimes' function. */
#define HAVE_FUTIMES 1

/* Define to 1 if you have the `futimesat' function. */
#define HAVE_FUTIMESAT 1

/* Define to 1 if you have the `getea' function. */
/* #undef HAVE_GETEA */

/* Define to 1 if you have the `geteuid' function. */
#define HAVE_GETEUID 1

/* Define to 1 if you have the `getgrgid_r' function. */
#define HAVE_GETGRGID_R 1

/* Define to 1 if you have the `getgrnam_r' function. */
#define HAVE_GETGRNAM_R 1

/* Define to 1 if you have the `getpid' function. */
#define HAVE_GETPID 1

/* Define to 1 if you have the `getpwnam_r' function. */
#define HAVE_GETPWNAM_R 1

/* Define to 1 if you have the `getpwuid_r' function. */
#define HAVE_GETPWUID_R 1

/* Define to 1 if you have the `getvfsbyname' function. */
/* #undef HAVE_GETVFSBYNAME */

/* Define to 1 if you have the `getxattr' function. */
/* #undef HAVE_GETXATTR */

/* Define to 1 if you have the `gmtime_r' function. */
#define HAVE_GMTIME_R 1

/* Define to 1 if you have the <grp.h> header file. */
#define HAVE_GRP_H 1

/* Define to 1 if you have the `iconv' function. */
/* #undef HAVE_ICONV */

/* Define to 1 if you have the <iconv.h> header file. */
/* #undef HAVE_ICONV_H */

/* Define to 1 if you have the <inttypes.h> header file. */
#define HAVE_INTTYPES_H 1

/* Define to 1 if you have the <io.h> header file. */
/* #undef HAVE_IO_H */

/* Define to 1 if you have the <langinfo.h> header file. */
#define HAVE_LANGINFO_H 1

/* Define to 1 if you have the `lchflags' function. */
/* #undef HAVE_LCHFLAGS */

/* Define to 1 if you have the `lchmod' function. */
/* #undef HAVE_LCHMOD */

/* Define to 1 if you have the `lchown' function. */
#define HAVE_LCHOWN 1

/* Define to 1 if you have the `lgetea' function. */
/* #undef HAVE_LGETEA */

/* Define to 1 if you have the `lgetxattr' function. */
/* #undef HAVE_LGETXATTR */

/* Define to 1 if you have the `acl' library (-lacl). */
/* #undef HAVE_LIBACL */

/* Define to 1 if you have the `attr' library (-lattr). */
/* #undef HAVE_LIBATTR */

/* Define to 1 if you have the `bsdxml' library (-lbsdxml). */
/* #undef HAVE_LIBBSDXML */

/* Define to 1 if you have the `bz2' library (-lbz2). */
#define HAVE_LIBBZ2 1

/* Define to 1 if you have the `expat' library (-lexpat). */
/* #undef HAVE_LIBEXPAT */

/* Define to 1 if you have the `gcc' library (-lgcc). */
/* #undef HAVE_LIBGCC */

/* Define to 1 if you have the `lzma' library (-llzma). */
/* #undef HAVE_LIBLZMA */

/* Define to 1 if you have the `lzmadec' library (-llzmadec). */
/* #undef HAVE_LIBLZMADEC */

/* Define to 1 if you have the `lzo2' library (-llzo2). */
/* #undef HAVE_LIBLZO2 */

/* Define to 1 if you have the `nettle' library (-lnettle). */
/* #undef HAVE_LIBNETTLE */

/* Define to 1 if you have the `pcre' library (-lpcre). */
/* #undef HAVE_LIBPCRE */

/* Define to 1 if you have the `pcreposix' library (-lpcreposix). */
/* #undef HAVE_LIBPCREPOSIX */

/* Define to 1 if you have the `xml2' library (-lxml2). */
/* #undef HAVE_LIBXML2 */

/* Define to 1 if you have the <libxml/xmlreader.h> header file. */
/* #undef HAVE_LIBXML_XMLREADER_H */

/* Define to 1 if you have the <libxml/xmlwriter.h> header file. */
/* #undef HAVE_LIBXML_XMLWRITER_H */

/* Define to 1 if you have the `z' library (-lz). */
#define HAVE_LIBZ 1

/* Define to 1 if you have the <limits.h> header file. */
#define HAVE_LIMITS_H 1

/* Define to 1 if you have the `link' function. */
#define HAVE_LINK 1

/* Define to 1 if you have the <linux/types.h> header file. */
#define HAVE_LINUX_TYPES_H 1

/* Define to 1 if you have the <linux/fiemap.h> header file. */
#define HAVE_LINUX_FIEMAP_H 1

/* Define to 1 if you have the <linux/fs.h> header file. */
#define HAVE_LINUX_FS_H 1

/* Define to 1 if you have the <linux/magic.h> header file. */
#define HAVE_LINUX_MAGIC_H 1

/* Define to 1 if you have the <linux/types.h> header file. */
#define HAVE_LINUX_TYPES_H 1

/* Define to 1 if you have the `listea' function. */
/* #undef HAVE_LISTEA */

/* Define to 1 if you have the `listxattr' function. */
/* #undef HAVE_LISTXATTR */

/* Define to 1 if you have the `llistea' function. */
/* #undef HAVE_LLISTEA */

/* Define to 1 if you have the `llistxattr' function. */
/* #undef HAVE_LLISTXATTR */

/* Define to 1 if you have the <localcharset.h> header file. */
/* #undef HAVE_LOCALCHARSET_H */

/* Define to 1 if you have the `locale_charset' function. */
/* #undef HAVE_LOCALE_CHARSET */

/* Define to 1 if you have the <locale.h> header file. */
#define HAVE_LOCALE_H 1

/* Define to 1 if you have the `localtime_r' function. */
#define HAVE_LOCALTIME_R 1

/* Define to 1 if the system has the type `long long int'. */
/* #undef HAVE_LONG_LONG_INT */

/* Define to 1 if you have the `lsetea' function. */
/* #undef HAVE_LSETEA */

/* Define to 1 if you have the `lsetxattr' function. */
/* #undef HAVE_LSETXATTR */

/* Define to 1 if you have the `lstat' function. */
#define HAVE_LSTAT 1

/* Define to 1 if `lstat' has the bug that it succeeds when given the
   zero-length file name argument. */
/* #undef HAVE_LSTAT_EMPTY_STRING_BUG */

/* Define to 1 if you have the `lutimes' function. */
#define HAVE_LUTIMES 1

/* Define to 1 if you have the <lzmadec.h> header file. */
/* #undef HAVE_LZMADEC_H */

/* Define to 1 if you have the <lzma.h> header file. */
/* #undef HAVE_LZMA_H */

/* Define to 1 if you have the <lzo/lzo1x.h> header file. */
/* #undef HAVE_LZO_LZO1X_H */

/* Define to 1 if you have the <lzo/lzoconf.h> header file. */
/* #undef HAVE_LZO_LZOCONF_H */

/* Define to 1 if you have the `mbrtowc' function. */
#define HAVE_MBRTOWC 1

/* Define to 1 if you have the `memmove' function. */
#define HAVE_MEMMOVE 1

/* Define to 1 if you have the <memory.h> header file. */
#define HAVE_MEMORY_H 1

/* Define to 1 if you have the `mkdir' function. */
#define HAVE_MKDIR 1

/* Define to 1 if you have the `mkfifo' function. */
#define HAVE_MKFIFO 1

/* Define to 1 if you have the `mknod' function. */
#define HAVE_MKNOD 1

/* Define to 1 if you have the `mkstemp' function. */
#define HAVE_MKSTEMP 1

/* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */
/* #undef HAVE_NDIR_H */

/* Define to 1 if you have the <nettle/md5.h> header file. */
/* #undef HAVE_NETTLE_MD5_H */

/* Define to 1 if you have the <nettle/ripemd160.h> header file. */
/* #undef HAVE_NETTLE_RIPEMD160_H */

/* Define to 1 if you have the <nettle/sha.h> header file. */
/* #undef HAVE_NETTLE_SHA_H */

/* Define to 1 if you have the `nl_langinfo' function. */
#define HAVE_NL_LANGINFO 1

/* Define to 1 if you have the `openat' function. */
#define HAVE_OPENAT 1

/* Define to 1 if you have the <paths.h> header file. */
#define HAVE_PATHS_H 1

/* Define to 1 if you have the <pcreposix.h> header file. */
/* #undef HAVE_PCREPOSIX_H */

/* Define to 1 if you have the `pipe' function. */
#define HAVE_PIPE 1

/* Define to 1 if you have the `poll' function. */
#define HAVE_POLL 1

/* Define to 1 if you have the <poll.h> header file. */
#define HAVE_POLL_H 1

/* Define to 1 if you have the `posix_spawnp' function. */
#define HAVE_POSIX_SPAWNP 1

/* Define to 1 if you have the <process.h> header file. */
/* #undef HAVE_PROCESS_H */

/* Define to 1 if you have the <pwd.h> header file. */
#define HAVE_PWD_H 1

/* Define to 1 if you have the `readdir_r' function. */
#define HAVE_READDIR_R 1

/* Define to 1 if you have the `readlink' function. */
#define HAVE_READLINK 1

/* Define to 1 if you have the `readlinkat' function. */
#define HAVE_READLINKAT 1

/* Define to 1 if you have the <regex.h> header file. */
#define HAVE_REGEX_H 1

/* Define to 1 if you have the `select' function. */
#define HAVE_SELECT 1

/* Define to 1 if you have the `setenv' function. */
#define HAVE_SETENV 1

/* Define to 1 if you have the `setlocale' function. */
#define HAVE_SETLOCALE 1

/* Define to 1 if you have the `sigaction' function. */
#define HAVE_SIGACTION 1

/* Define to 1 if you have the <signal.h> header file. */
#define HAVE_SIGNAL_H 1

/* Define to 1 if you have the <spawn.h> header file. */
#define HAVE_SPAWN_H 1

/* Define to 1 if you have the `statfs' function. */
#define HAVE_STATFS 1

/* Define to 1 if you have the `statvfs' function. */
#define HAVE_STATVFS 1

/* Define to 1 if `stat' has the bug that it succeeds when given the
   zero-length file name argument. */
/* #undef HAVE_STAT_EMPTY_STRING_BUG */

/* Define to 1 if you have the <stdarg.h> header file. */
#define HAVE_STDARG_H 1

/* Define to 1 if you have the <stdint.h> header file. */
#define HAVE_STDINT_H 1

/* Define to 1 if you have the <stdlib.h> header file. */
#define HAVE_STDLIB_H 1

/* Define to 1 if you have the `strchr' function. */
#define HAVE_STRCHR 1

/* Define to 1 if you have the `strdup' function. */
#define HAVE_STRDUP 1

/* Define to 1 if you have the `strerror' function. */
#define HAVE_STRERROR 1

/* Define to 1 if you have the `strerror_r' function. */
#define HAVE_STRERROR_R 1

/* Define to 1 if you have the `strftime' function. */
#define HAVE_STRFTIME 1

/* Define to 1 if you have the <strings.h> header file. */
#define HAVE_STRINGS_H 1

/* Define to 1 if you have the <string.h> header file. */
#define HAVE_STRING_H 1

/* Define to 1 if you have the `strrchr' function. */
#define HAVE_STRRCHR 1

/* Define to 1 if `f_namemax' is a member of `struct statfs'. */
/* #undef HAVE_STRUCT_STATFS_F_NAMEMAX */

/* Define to 1 if `f_iosize' is a member of `struct statvfs'. */
/* #undef HAVE_STRUCT_STATVFS_F_IOSIZE */

/* Define to 1 if `st_birthtime' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIME */

/* Define to 1 if `st_birthtimespec.tv_nsec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC_TV_NSEC */

/* Define to 1 if `st_blksize' is a member of `struct stat'. */
#define HAVE_STRUCT_STAT_ST_BLKSIZE 1

/* Define to 1 if `st_flags' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_FLAGS */

/* Define to 1 if `st_mtimespec.tv_nsec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC */

/* Define to 1 if `st_mtime_n' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIME_N */

/* Define to 1 if `st_mtime_usec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIME_USEC */

/* Define to 1 if `st_mtim.tv_nsec' is a member of `struct stat'. */
#define HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC 1

/* Define to 1 if `st_umtime' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_UMTIME */

/* Define to 1 if `tm_gmtoff' is a member of `struct tm'. */
#define HAVE_STRUCT_TM_TM_GMTOFF 1

/* Define to 1 if `__tm_gmtoff' is a member of `struct tm'. */
/* #undef HAVE_STRUCT_TM___TM_GMTOFF */

/* Define to 1 if you have the `symlink' function. */
#define HAVE_SYMLINK 1

/* Define to 1 if you have the <sys/acl.h> header file. */
/* #undef HAVE_SYS_ACL_H */

/* Define to 1 if you have the <sys/cdefs.h> header file. */
#define HAVE_SYS_CDEFS_H 1

/* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.
   */
/* #undef HAVE_SYS_DIR_H */

/* Define to 1 if you have the <sys/ea.h> header file. */
/* #undef HAVE_SYS_EA_H */

/* Define to 1 if you have the <sys/extattr.h> header file. */
/* #undef HAVE_SYS_EXTATTR_H */

/* Define to 1 if you have the <sys/ioctl.h> header file. */
#define HAVE_SYS_IOCTL_H 1

/* Define to 1 if you have the <sys/mkdev.h> header file. */
/* #undef HAVE_SYS_MKDEV_H */

/* Define to 1 if you have the <sys/mount.h> header file. */
/* #undef HAVE_SYS_MOUNT_H */

/* Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.
   */
/* #undef HAVE_SYS_NDIR_H */

/* Define to 1 if you have the <sys/param.h> header file. */
#define HAVE_SYS_PARAM_H 1

/* Define to 1 if you have the <sys/poll.h> header file. */
#define HAVE_SYS_POLL_H 1

/* Define to 1 if you have the <sys/select.h> header file. */
#define HAVE_SYS_SELECT_H 1

/* Define to 1 if you have the <sys/statfs.h> header file. */
#define HAVE_SYS_STATFS_H 1

/* Define to 1 if you have the <sys/statvfs.h> header file. */
#define HAVE_SYS_STATVFS_H 1

/* Define to 1 if you have the <sys/stat.h> header file. */
#define HAVE_SYS_STAT_H 1

/* Define to 1 if you have the <sys/time.h> header file. */
#define HAVE_SYS_TIME_H 1

/* Define to 1 if you have the <sys/types.h> header file. */
#define HAVE_SYS_TYPES_H 1

/* Define to 1 if you have the <sys/utime.h> header file. */
/* #undef HAVE_SYS_UTIME_H */

/* Define to 1 if you have the <sys/utsname.h> header file. */
#define HAVE_SYS_UTSNAME_H 1

/* Define to 1 if you have the <sys/vfs.h> header file. */
#define HAVE_SYS_VFS_H 1

/* Define to 1 if you have <sys/wait.h> that is POSIX.1 compatible. */
#define HAVE_SYS_WAIT_H 1

/* Define to 1 if you have the <sys/xattr.h> header file. */
/* #undef HAVE_SYS_XATTR_H */

/* Define to 1 if you have the `timegm' function. */
#define HAVE_TIMEGM 1

/* Define to 1 if you have the <time.h> header file. */
#define HAVE_TIME_H 1

/* Define to 1 if you have the `tzset' function. */
#define HAVE_TZSET 1

/* Define to 1 if you have the <unistd.h> header file. */
#define HAVE_UNISTD_H 1

/* Define to 1 if you have the `unsetenv' function. */
#define HAVE_UNSETENV 1

/* Define to 1 if the system has the type `unsigned long long'. */
/* #undef HAVE_UNSIGNED_LONG_LONG */

/* Define to 1 if the system has the type `unsigned long long int'. */
/* #undef HAVE_UNSIGNED_LONG_LONG_INT */

/* Define to 1 if you have the `utime' function. */
#define HAVE_UTIME 1

/* Define to 1 if you have the `utimensat' function. */
#define HAVE_UTIMENSAT 1

/* Define to 1 if you have the `utimes' function. */
#define HAVE_UTIMES 1

/* Define to 1 if you have the <utime.h> header file. */
#define HAVE_UTIME_H 1

/* Define to 1 if you have the `vfork' function. */
#define HAVE_VFORK 1

/* Define to 1 if you have the `vprintf' function. */
#define HAVE_VPRINTF 1

/* Define to 1 if you have the <wchar.h> header file. */
#define HAVE_WCHAR_H 1

/* Define to 1 if the system has the type `wchar_t'. */
#define HAVE_WCHAR_T 1

/* Define to 1 if you have the `wcrtomb' function. */
#define HAVE_WCRTOMB 1

/* Define to 1 if you have the `wcscmp' function. */
#define HAVE_WCSCMP 1

/* Define to 1 if you have the `wcscpy' function. */
#define HAVE_WCSCPY 1

/* Define to 1 if you have the `wcslen' function. */
#define HAVE_WCSLEN 1

/* Define to 1 if you have the `wctomb' function. */
#define HAVE_WCTOMB 1

/* Define to 1 if you have the <wctype.h> header file. */
#define HAVE_WCTYPE_H 1

/* Define to 1 if you have the <wincrypt.h> header file. */
/* #undef HAVE_WINCRYPT_H */

/* Define to 1 if you have the <windows.h> header file. */
/* #undef HAVE_WINDOWS_H */

/* Define to 1 if you have the <winioctl.h> header file. */
/* #undef HAVE_WINIOCTL_H */

/* Define to 1 if you have _CrtSetReportMode in <crtdbg.h>  */
/* #undef HAVE__CrtSetReportMode */

/* Define to 1 if you have the `wmemcmp' function. */
#define HAVE_WMEMCMP 1

/* Define to 1 if you have the `wmemcpy' function. */
#define HAVE_WMEMCPY 1

/* Define to 1 if you have a working EXT2_IOC_GETFLAGS */
/* #undef HAVE_WORKING_EXT2_IOC_GETFLAGS */

/* Define to 1 if you have the <zlib.h> header file. */
#define HAVE_ZLIB_H 1

/* Define to 1 if you have the `_ctime64_s' function. */
/* #undef HAVE__CTIME64_S */

/* Define to 1 if you have the `_fseeki64' function. */
/* #undef HAVE__FSEEKI64 */

/* Define to 1 if you have the `_get_timezone' function. */
/* #undef HAVE__GET_TIMEZONE */

/* Define to 1 if you have the `_localtime64_s' function. */
/* #undef HAVE__LOCALTIME64_S */

/* Define to 1 if you have the `_mkgmtime64' function. */
/* #undef HAVE__MKGMTIME64 */

/* Define as const if the declaration of iconv() needs const. */
#define ICONV_CONST 

/* Version number of libarchive as a single integer */
#define LIBARCHIVE_VERSION_NUMBER "3001002"

/* Version number of libarchive */
#define LIBARCHIVE_VERSION_STRING "3.1.2"

/* Define to 1 if `lstat' dereferences a symlink specified with a trailing
   slash. */
/* #undef LSTAT_FOLLOWS_SLASHED_SYMLINK */

/* Define to 1 if `major', `minor', and `makedev' are declared in <mkdev.h>.
   */
/* #undef MAJOR_IN_MKDEV */

/* Define to 1 if `major', `minor', and `makedev' are declared in
   <sysmacros.h>. */
#define MAJOR_IN_SYSMACROS 1

/* Define to 1 if your C compiler doesn't accept -c and -o together. */
/* #undef NO_MINUS_C_MINUS_O */

/* The size of `wchar_t', as computed by sizeof. */
#define SIZEOF_WCHAR_T 4

/* Define to 1 if strerror_r returns char *. */
/* #undef STRERROR_R_CHAR_P */

/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
#define TIME_WITH_SYS_TIME 1

/*
 * Some platform requires a macro to use extension functions.
 */
#define SAFE_TO_DEFINE_EXTENSIONS 1
#ifdef SAFE_TO_DEFINE_EXTENSIONS
/* Enable extensions on AIX 3, Interix.  */
#ifndef _ALL_SOURCE
# define _ALL_SOURCE 1
#endif
/* Enable GNU extensions on systems that have them.  */
#ifndef _GNU_SOURCE
# define _GNU_SOURCE 1
#endif
/* Enable threading extensions on Solaris.  */
#ifndef _POSIX_PTHREAD_SEMANTICS
# define _POSIX_PTHREAD_SEMANTICS 1
#endif
/* Enable extensions on HP NonStop.  */
#ifndef _TANDEM_SOURCE
# define _TANDEM_SOURCE 1
#endif
/* Enable general extensions on Solaris.  */
#ifndef __EXTENSIONS__
# define __EXTENSIONS__ 1
#endif
#endif /* SAFE_TO_DEFINE_EXTENSIONS */

/* Version number of package */
#define VERSION "3.1.2"

/* Number of bits in a file offset, on hosts where this is settable. */
/* #undef _FILE_OFFSET_BITS */

/* Define to 1 to make fseeko visible on some hosts (e.g. glibc 2.2). */
/* #undef _LARGEFILE_SOURCE */

/* Define for large files, on AIX-style hosts. */
/* #undef _LARGE_FILES */

/* Define for Windows to use Windows 2000+ APIs. */
/* #undef _WIN32_WINNT */
/* #undef WINVER */

/* Define to empty if `const' does not conform to ANSI C. */
/* #undef const */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef gid_t */

/* Define to `unsigned long' if <sys/types.h> does not define. */
/* #undef id_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef mode_t */

/* Define to `long long' if <sys/types.h> does not define. */
/* #undef off_t */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef pid_t */

/* Define to `unsigned int' if <sys/types.h> does not define. */
/* #undef size_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef ssize_t */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef uid_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef intptr_t */

/* Define to `unsigned int' if <sys/types.h> does not define. */
/* #undef uintptr_t */


#define ARCHIVE_SHA256_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA256_LIBSYSTEM
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = (DWORD)bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. Nettle
 * 6. OpenSSL
 * 7. libmd
 * 8. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive_sha256_ctx ctx;
  archive_sha256_init(&ctx);
  archive_sha256_update(&ctx, *argv, argc);
  archive_sha256_final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA384_LIBSYSTEM failed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec389555975/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec389555975.dir/build.make CMakeFiles/cmTryCompileExec389555975.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec389555975.dir/check_crypto_md.c.o
/usr/bin/gcc   -w  -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2 -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmlibarchive/libarchive -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec389555975.dir/check_crypto_md.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1186:0:
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:112:39: fatal error: CommonCrypto/CommonDigest.h: No such file or directory
 #include <CommonCrypto/CommonDigest.h>
                                       ^
compilation terminated.
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec389555975.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec389555975/fast] Error 2

Source file was:
/* config.h.  Generated from build/cmake/config.h.in by cmake configure */
#if defined(__osf__)
# define _OSF_SOURCE
#endif

/*
 * Ensure we have C99-style int64_t, etc, all defined.
 */

/* First, we need to know if the system has already defined them. */
#define HAVE_INT16_T
#define HAVE_INT32_T
#define HAVE_INT64_T
#define HAVE_INTMAX_T

#define HAVE_UINT8_T
#define HAVE_UINT16_T
#define HAVE_UINT32_T
#define HAVE_UINT64_T
#define HAVE_UINTMAX_T

/* We might have the types we want under other spellings. */
/* #undef HAVE___INT64 */
/* #undef HAVE_U_INT64_T */
/* #undef HAVE_UNSIGNED___INT64 */

/* The sizes of various standard integer types. */
#define SIZE_OF_SHORT 2
#define SIZE_OF_INT 4
#define SIZE_OF_LONG 8
#define SIZE_OF_LONG_LONG 8
#define SIZE_OF_UNSIGNED_SHORT 2
#define SIZE_OF_UNSIGNED 4
#define SIZE_OF_UNSIGNED_LONG 8
#define SIZE_OF_UNSIGNED_LONG_LONG 8

/*
 * If we lack int64_t, define it to the first of __int64, int, long, and long long
 * that exists and is the right size.
 */
#if !defined(HAVE_INT64_T) && defined(HAVE___INT64)
typedef __int64 int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_INT == 8
typedef int int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_LONG == 8
typedef long int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_LONG_LONG == 8
typedef long long int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T)
#error No 64-bit integer type was found.
#endif

/*
 * Similarly for int32_t
 */
#if !defined(HAVE_INT32_T) && SIZE_OF_INT == 4
typedef long int32_t;
#define HAVE_INT32_T
#endif

#if !defined(HAVE_INT32_T) && SIZE_OF_LONG == 4
typedef long int32_t;
#define HAVE_INT32_T
#endif

#if !defined(HAVE_INT32_T)
#error No 32-bit integer type was found.
#endif

/*
 * Similarly for int16_t
 */
#if !defined(HAVE_INT16_T) && SIZE_OF_INT == 2
typedef int int16_t;
#define HAVE_INT16_T
#endif

#if !defined(HAVE_INT16_T) && SIZE_OF_SHORT == 2
typedef short int16_t;
#define HAVE_INT16_T
#endif

#if !defined(HAVE_INT16_T)
#error No 16-bit integer type was found.
#endif

/*
 * Similarly for uint64_t
 */
#if !defined(HAVE_UINT64_T) && defined(HAVE_UNSIGNED___INT64)
typedef unsigned __int64 uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED == 8
typedef unsigned uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED_LONG == 8
typedef unsigned long uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED_LONG_LONG == 8
typedef unsigned long long uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T)
#error No 64-bit unsigned integer type was found.
#endif


/*
 * Similarly for uint32_t
 */
#if !defined(HAVE_UINT32_T) && SIZE_OF_UNSIGNED == 4
typedef unsigned uint32_t;
#define HAVE_UINT32_T
#endif

#if !defined(HAVE_UINT32_T) && SIZE_OF_UNSIGNED_LONG == 4
typedef unsigned long uint32_t;
#define HAVE_UINT32_T
#endif

#if !defined(HAVE_UINT32_T)
#error No 32-bit unsigned integer type was found.
#endif

/*
 * Similarly for uint16_t
 */
#if !defined(HAVE_UINT16_T) && SIZE_OF_UNSIGNED == 2
typedef unsigned uint16_t;
#define HAVE_UINT16_T
#endif

#if !defined(HAVE_UINT16_T) && SIZE_OF_UNSIGNED_SHORT == 2
typedef unsigned short uint16_t;
#define HAVE_UINT16_T
#endif

#if !defined(HAVE_UINT16_T)
#error No 16-bit unsigned integer type was found.
#endif

/*
 * Similarly for uint8_t
 */
#if !defined(HAVE_UINT8_T)
typedef unsigned char uint8_t;
#define HAVE_UINT8_T
#endif

#if !defined(HAVE_UINT16_T)
#error No 8-bit unsigned integer type was found.
#endif

/* Define intmax_t and uintmax_t if they are not already defined. */
#if !defined(HAVE_INTMAX_T)
typedef int64_t intmax_t;
#define INTMAX_MIN INT64_MIN
#define INTMAX_MAX INT64_MAX
#endif

#if !defined(HAVE_UINTMAX_T)
typedef uint64_t uintmax_t;
#endif

/* Define ZLIB_WINAPI if zlib was built on Visual Studio. */
/* #undef ZLIB_WINAPI */

/* MD5 via ARCHIVE_CRYPTO_MD5_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_MD5_LIBC */

/* MD5 via ARCHIVE_CRYPTO_MD5_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_MD5_LIBSYSTEM */

/* MD5 via ARCHIVE_CRYPTO_MD5_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_MD5_NETTLE */

/* MD5 via ARCHIVE_CRYPTO_MD5_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_MD5_OPENSSL */

/* MD5 via ARCHIVE_CRYPTO_MD5_WIN supported. */
/* #undef ARCHIVE_CRYPTO_MD5_WIN */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_LIBC */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_NETTLE */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_OPENSSL */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_LIBC */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_LIBSYSTEM */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_NETTLE */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_OPENSSL */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_WIN */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC2 */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC3 */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBSYSTEM */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_NETTLE */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_OPENSSL */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_WIN */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC2 */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC3 */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBSYSTEM */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_NETTLE */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_OPENSSL */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_WIN */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC2 */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC3 */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBSYSTEM */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_NETTLE */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_OPENSSL */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_WIN */

/* Version number of bsdcpio */
#define BSDCPIO_VERSION_STRING "3.1.2"

/* Version number of bsdtar */
#define BSDTAR_VERSION_STRING "3.1.2"

/* Define to 1 if you have the `acl_create_entry' function. */
/* #undef HAVE_ACL_CREATE_ENTRY */

/* Define to 1 if you have the `acl_get_link' function. */
/* #undef HAVE_ACL_GET_LINK */

/* Define to 1 if you have the `acl_get_link_np' function. */
/* #undef HAVE_ACL_GET_LINK_NP */

/* Define to 1 if you have the `acl_get_perm' function. */
/* #undef HAVE_ACL_GET_PERM */

/* Define to 1 if you have the `acl_get_perm_np' function. */
/* #undef HAVE_ACL_GET_PERM_NP */

/* Define to 1 if you have the `acl_init' function. */
/* #undef HAVE_ACL_INIT */

/* Define to 1 if you have the <acl/libacl.h> header file. */
/* #undef HAVE_ACL_LIBACL_H */

/* Define to 1 if the system has the type `acl_permset_t'. */
/* #undef HAVE_ACL_PERMSET_T */

/* Define to 1 if you have the `acl_set_fd' function. */
/* #undef HAVE_ACL_SET_FD */

/* Define to 1 if you have the `acl_set_fd_np' function. */
/* #undef HAVE_ACL_SET_FD_NP */

/* Define to 1 if you have the `acl_set_file' function. */
/* #undef HAVE_ACL_SET_FILE */

/* True for systems with POSIX ACL support */
/* #undef HAVE_ACL_USER */

/* Define to 1 if you have the <attr/xattr.h> header file. */
/* #undef HAVE_ATTR_XATTR_H */

/* Define to 1 if you have the <bsdxml.h> header file. */
/* #undef HAVE_BSDXML_H */

/* Define to 1 if you have the <bzlib.h> header file. */
#define HAVE_BZLIB_H 1

/* Define to 1 if you have the `chflags' function. */
/* #undef HAVE_CHFLAGS */

/* Define to 1 if you have the `chown' function. */
#define HAVE_CHOWN 1

/* Define to 1 if you have the `chroot' function. */
#define HAVE_CHROOT 1

/* Define to 1 if you have the <copyfile.h> header file. */
/* #undef HAVE_COPYFILE_H */

/* Define to 1 if you have the `ctime_r' function. */
#define HAVE_CTIME_R 1

/* Define to 1 if you have the <ctype.h> header file. */
#define HAVE_CTYPE_H 1

/* Define to 1 if you have the `cygwin_conv_path' function. */
/* #undef HAVE_CYGWIN_CONV_PATH */

/* Define to 1 if you have the declaration of `INT64_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_INT64_MAX 1

/* Define to 1 if you have the declaration of `INT64_MIN', and to 0 if you
   don't. */
#define HAVE_DECL_INT64_MIN 1

/* Define to 1 if you have the declaration of `SIZE_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_SIZE_MAX 1

/* Define to 1 if you have the declaration of `SSIZE_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_SSIZE_MAX 1

/* Define to 1 if you have the declaration of `strerror_r', and to 0 if you
   don't. */
#define HAVE_DECL_STRERROR_R 1

/* Define to 1 if you have the declaration of `UINT32_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_UINT32_MAX 1

/* Define to 1 if you have the declaration of `UINT64_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_UINT64_MAX 1

/* Define to 1 if you have the <direct.h> header file. */
/* #undef HAVE_DIRECT_H */

/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.
   */
#define HAVE_DIRENT_H 1

/* Define to 1 if you have the `dirfd' function. */
#define HAVE_DIRFD 1

/* Define to 1 if you have the <dlfcn.h> header file. */
#define HAVE_DLFCN_H 1

/* Define to 1 if you don't have `vprintf' but do have `_doprnt.' */
/* #undef HAVE_DOPRNT */

/* Define to 1 if nl_langinfo supports D_MD_ORDER */
/* #undef HAVE_D_MD_ORDER */

/* A possible errno value for invalid file format errors */
/* #undef HAVE_EFTYPE */

/* A possible errno value for invalid file format errors */
#define HAVE_EILSEQ 1

/* Define to 1 if you have the <errno.h> header file. */
#define HAVE_ERRNO_H 1

/* Define to 1 if you have the <expat.h> header file. */
/* #undef HAVE_EXPAT_H */

/* Define to 1 if you have the <ext2fs/ext2_fs.h> header file. */
/* #undef HAVE_EXT2FS_EXT2_FS_H */

/* Define to 1 if you have the `extattr_get_file' function. */
/* #undef HAVE_EXTATTR_GET_FILE */

/* Define to 1 if you have the `extattr_list_file' function. */
/* #undef HAVE_EXTATTR_LIST_FILE */

/* Define to 1 if you have the `extattr_set_fd' function. */
/* #undef HAVE_EXTATTR_SET_FD */

/* Define to 1 if you have the `extattr_set_file' function. */
/* #undef HAVE_EXTATTR_SET_FILE */

/* Define to 1 if EXTATTR_NAMESPACE_USER is defined in sys/extattr.h. */
/* #undef HAVE_DECL_EXTATTR_NAMESPACE_USER */

/* Define to 1 if you have the `fchdir' function. */
#define HAVE_FCHDIR 1

/* Define to 1 if you have the `fchflags' function. */
/* #undef HAVE_FCHFLAGS */

/* Define to 1 if you have the `fchmod' function. */
#define HAVE_FCHMOD 1

/* Define to 1 if you have the `fchown' function. */
#define HAVE_FCHOWN 1

/* Define to 1 if you have the `fcntl' function. */
#define HAVE_FCNTL 1

/* Define to 1 if you have the <fcntl.h> header file. */
#define HAVE_FCNTL_H 1

/* Define to 1 if you have the `fdopendir' function. */
#define HAVE_FDOPENDIR 1

/* Define to 1 if you have the `fgetea' function. */
/* #undef HAVE_FGETEA */

/* Define to 1 if you have the `fgetxattr' function. */
/* #undef HAVE_FGETXATTR */

/* Define to 1 if you have the `flistea' function. */
/* #undef HAVE_FLISTEA */

/* Define to 1 if you have the `flistxattr' function. */
/* #undef HAVE_FLISTXATTR */

/* Define to 1 if you have the `fork' function. */
#define HAVE_FORK 1

/* Define to 1 if fseeko (and presumably ftello) exists and is declared. */
#define HAVE_FSEEKO 1

/* Define to 1 if you have the `fsetea' function. */
/* #undef HAVE_FSETEA */

/* Define to 1 if you have the `fsetxattr' function. */
/* #undef HAVE_FSETXATTR */

/* Define to 1 if you have the `fstat' function. */
#define HAVE_FSTAT 1

/* Define to 1 if you have the `fstatat' function. */
#define HAVE_FSTATAT 1

/* Define to 1 if you have the `fstatfs' function. */
#define HAVE_FSTATFS 1

/* Define to 1 if you have the `fstatvfs' function. */
#define HAVE_FSTATVFS 1

/* Define to 1 if you have the `ftruncate' function. */
#define HAVE_FTRUNCATE 1

/* Define to 1 if you have the `futimens' function. */
#define HAVE_FUTIMENS 1

/* Define to 1 if you have the `futimes' function. */
#define HAVE_FUTIMES 1

/* Define to 1 if you have the `futimesat' function. */
#define HAVE_FUTIMESAT 1

/* Define to 1 if you have the `getea' function. */
/* #undef HAVE_GETEA */

/* Define to 1 if you have the `geteuid' function. */
#define HAVE_GETEUID 1

/* Define to 1 if you have the `getgrgid_r' function. */
#define HAVE_GETGRGID_R 1

/* Define to 1 if you have the `getgrnam_r' function. */
#define HAVE_GETGRNAM_R 1

/* Define to 1 if you have the `getpid' function. */
#define HAVE_GETPID 1

/* Define to 1 if you have the `getpwnam_r' function. */
#define HAVE_GETPWNAM_R 1

/* Define to 1 if you have the `getpwuid_r' function. */
#define HAVE_GETPWUID_R 1

/* Define to 1 if you have the `getvfsbyname' function. */
/* #undef HAVE_GETVFSBYNAME */

/* Define to 1 if you have the `getxattr' function. */
/* #undef HAVE_GETXATTR */

/* Define to 1 if you have the `gmtime_r' function. */
#define HAVE_GMTIME_R 1

/* Define to 1 if you have the <grp.h> header file. */
#define HAVE_GRP_H 1

/* Define to 1 if you have the `iconv' function. */
/* #undef HAVE_ICONV */

/* Define to 1 if you have the <iconv.h> header file. */
/* #undef HAVE_ICONV_H */

/* Define to 1 if you have the <inttypes.h> header file. */
#define HAVE_INTTYPES_H 1

/* Define to 1 if you have the <io.h> header file. */
/* #undef HAVE_IO_H */

/* Define to 1 if you have the <langinfo.h> header file. */
#define HAVE_LANGINFO_H 1

/* Define to 1 if you have the `lchflags' function. */
/* #undef HAVE_LCHFLAGS */

/* Define to 1 if you have the `lchmod' function. */
/* #undef HAVE_LCHMOD */

/* Define to 1 if you have the `lchown' function. */
#define HAVE_LCHOWN 1

/* Define to 1 if you have the `lgetea' function. */
/* #undef HAVE_LGETEA */

/* Define to 1 if you have the `lgetxattr' function. */
/* #undef HAVE_LGETXATTR */

/* Define to 1 if you have the `acl' library (-lacl). */
/* #undef HAVE_LIBACL */

/* Define to 1 if you have the `attr' library (-lattr). */
/* #undef HAVE_LIBATTR */

/* Define to 1 if you have the `bsdxml' library (-lbsdxml). */
/* #undef HAVE_LIBBSDXML */

/* Define to 1 if you have the `bz2' library (-lbz2). */
#define HAVE_LIBBZ2 1

/* Define to 1 if you have the `expat' library (-lexpat). */
/* #undef HAVE_LIBEXPAT */

/* Define to 1 if you have the `gcc' library (-lgcc). */
/* #undef HAVE_LIBGCC */

/* Define to 1 if you have the `lzma' library (-llzma). */
/* #undef HAVE_LIBLZMA */

/* Define to 1 if you have the `lzmadec' library (-llzmadec). */
/* #undef HAVE_LIBLZMADEC */

/* Define to 1 if you have the `lzo2' library (-llzo2). */
/* #undef HAVE_LIBLZO2 */

/* Define to 1 if you have the `nettle' library (-lnettle). */
/* #undef HAVE_LIBNETTLE */

/* Define to 1 if you have the `pcre' library (-lpcre). */
/* #undef HAVE_LIBPCRE */

/* Define to 1 if you have the `pcreposix' library (-lpcreposix). */
/* #undef HAVE_LIBPCREPOSIX */

/* Define to 1 if you have the `xml2' library (-lxml2). */
/* #undef HAVE_LIBXML2 */

/* Define to 1 if you have the <libxml/xmlreader.h> header file. */
/* #undef HAVE_LIBXML_XMLREADER_H */

/* Define to 1 if you have the <libxml/xmlwriter.h> header file. */
/* #undef HAVE_LIBXML_XMLWRITER_H */

/* Define to 1 if you have the `z' library (-lz). */
#define HAVE_LIBZ 1

/* Define to 1 if you have the <limits.h> header file. */
#define HAVE_LIMITS_H 1

/* Define to 1 if you have the `link' function. */
#define HAVE_LINK 1

/* Define to 1 if you have the <linux/types.h> header file. */
#define HAVE_LINUX_TYPES_H 1

/* Define to 1 if you have the <linux/fiemap.h> header file. */
#define HAVE_LINUX_FIEMAP_H 1

/* Define to 1 if you have the <linux/fs.h> header file. */
#define HAVE_LINUX_FS_H 1

/* Define to 1 if you have the <linux/magic.h> header file. */
#define HAVE_LINUX_MAGIC_H 1

/* Define to 1 if you have the <linux/types.h> header file. */
#define HAVE_LINUX_TYPES_H 1

/* Define to 1 if you have the `listea' function. */
/* #undef HAVE_LISTEA */

/* Define to 1 if you have the `listxattr' function. */
/* #undef HAVE_LISTXATTR */

/* Define to 1 if you have the `llistea' function. */
/* #undef HAVE_LLISTEA */

/* Define to 1 if you have the `llistxattr' function. */
/* #undef HAVE_LLISTXATTR */

/* Define to 1 if you have the <localcharset.h> header file. */
/* #undef HAVE_LOCALCHARSET_H */

/* Define to 1 if you have the `locale_charset' function. */
/* #undef HAVE_LOCALE_CHARSET */

/* Define to 1 if you have the <locale.h> header file. */
#define HAVE_LOCALE_H 1

/* Define to 1 if you have the `localtime_r' function. */
#define HAVE_LOCALTIME_R 1

/* Define to 1 if the system has the type `long long int'. */
/* #undef HAVE_LONG_LONG_INT */

/* Define to 1 if you have the `lsetea' function. */
/* #undef HAVE_LSETEA */

/* Define to 1 if you have the `lsetxattr' function. */
/* #undef HAVE_LSETXATTR */

/* Define to 1 if you have the `lstat' function. */
#define HAVE_LSTAT 1

/* Define to 1 if `lstat' has the bug that it succeeds when given the
   zero-length file name argument. */
/* #undef HAVE_LSTAT_EMPTY_STRING_BUG */

/* Define to 1 if you have the `lutimes' function. */
#define HAVE_LUTIMES 1

/* Define to 1 if you have the <lzmadec.h> header file. */
/* #undef HAVE_LZMADEC_H */

/* Define to 1 if you have the <lzma.h> header file. */
/* #undef HAVE_LZMA_H */

/* Define to 1 if you have the <lzo/lzo1x.h> header file. */
/* #undef HAVE_LZO_LZO1X_H */

/* Define to 1 if you have the <lzo/lzoconf.h> header file. */
/* #undef HAVE_LZO_LZOCONF_H */

/* Define to 1 if you have the `mbrtowc' function. */
#define HAVE_MBRTOWC 1

/* Define to 1 if you have the `memmove' function. */
#define HAVE_MEMMOVE 1

/* Define to 1 if you have the <memory.h> header file. */
#define HAVE_MEMORY_H 1

/* Define to 1 if you have the `mkdir' function. */
#define HAVE_MKDIR 1

/* Define to 1 if you have the `mkfifo' function. */
#define HAVE_MKFIFO 1

/* Define to 1 if you have the `mknod' function. */
#define HAVE_MKNOD 1

/* Define to 1 if you have the `mkstemp' function. */
#define HAVE_MKSTEMP 1

/* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */
/* #undef HAVE_NDIR_H */

/* Define to 1 if you have the <nettle/md5.h> header file. */
/* #undef HAVE_NETTLE_MD5_H */

/* Define to 1 if you have the <nettle/ripemd160.h> header file. */
/* #undef HAVE_NETTLE_RIPEMD160_H */

/* Define to 1 if you have the <nettle/sha.h> header file. */
/* #undef HAVE_NETTLE_SHA_H */

/* Define to 1 if you have the `nl_langinfo' function. */
#define HAVE_NL_LANGINFO 1

/* Define to 1 if you have the `openat' function. */
#define HAVE_OPENAT 1

/* Define to 1 if you have the <paths.h> header file. */
#define HAVE_PATHS_H 1

/* Define to 1 if you have the <pcreposix.h> header file. */
/* #undef HAVE_PCREPOSIX_H */

/* Define to 1 if you have the `pipe' function. */
#define HAVE_PIPE 1

/* Define to 1 if you have the `poll' function. */
#define HAVE_POLL 1

/* Define to 1 if you have the <poll.h> header file. */
#define HAVE_POLL_H 1

/* Define to 1 if you have the `posix_spawnp' function. */
#define HAVE_POSIX_SPAWNP 1

/* Define to 1 if you have the <process.h> header file. */
/* #undef HAVE_PROCESS_H */

/* Define to 1 if you have the <pwd.h> header file. */
#define HAVE_PWD_H 1

/* Define to 1 if you have the `readdir_r' function. */
#define HAVE_READDIR_R 1

/* Define to 1 if you have the `readlink' function. */
#define HAVE_READLINK 1

/* Define to 1 if you have the `readlinkat' function. */
#define HAVE_READLINKAT 1

/* Define to 1 if you have the <regex.h> header file. */
#define HAVE_REGEX_H 1

/* Define to 1 if you have the `select' function. */
#define HAVE_SELECT 1

/* Define to 1 if you have the `setenv' function. */
#define HAVE_SETENV 1

/* Define to 1 if you have the `setlocale' function. */
#define HAVE_SETLOCALE 1

/* Define to 1 if you have the `sigaction' function. */
#define HAVE_SIGACTION 1

/* Define to 1 if you have the <signal.h> header file. */
#define HAVE_SIGNAL_H 1

/* Define to 1 if you have the <spawn.h> header file. */
#define HAVE_SPAWN_H 1

/* Define to 1 if you have the `statfs' function. */
#define HAVE_STATFS 1

/* Define to 1 if you have the `statvfs' function. */
#define HAVE_STATVFS 1

/* Define to 1 if `stat' has the bug that it succeeds when given the
   zero-length file name argument. */
/* #undef HAVE_STAT_EMPTY_STRING_BUG */

/* Define to 1 if you have the <stdarg.h> header file. */
#define HAVE_STDARG_H 1

/* Define to 1 if you have the <stdint.h> header file. */
#define HAVE_STDINT_H 1

/* Define to 1 if you have the <stdlib.h> header file. */
#define HAVE_STDLIB_H 1

/* Define to 1 if you have the `strchr' function. */
#define HAVE_STRCHR 1

/* Define to 1 if you have the `strdup' function. */
#define HAVE_STRDUP 1

/* Define to 1 if you have the `strerror' function. */
#define HAVE_STRERROR 1

/* Define to 1 if you have the `strerror_r' function. */
#define HAVE_STRERROR_R 1

/* Define to 1 if you have the `strftime' function. */
#define HAVE_STRFTIME 1

/* Define to 1 if you have the <strings.h> header file. */
#define HAVE_STRINGS_H 1

/* Define to 1 if you have the <string.h> header file. */
#define HAVE_STRING_H 1

/* Define to 1 if you have the `strrchr' function. */
#define HAVE_STRRCHR 1

/* Define to 1 if `f_namemax' is a member of `struct statfs'. */
/* #undef HAVE_STRUCT_STATFS_F_NAMEMAX */

/* Define to 1 if `f_iosize' is a member of `struct statvfs'. */
/* #undef HAVE_STRUCT_STATVFS_F_IOSIZE */

/* Define to 1 if `st_birthtime' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIME */

/* Define to 1 if `st_birthtimespec.tv_nsec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC_TV_NSEC */

/* Define to 1 if `st_blksize' is a member of `struct stat'. */
#define HAVE_STRUCT_STAT_ST_BLKSIZE 1

/* Define to 1 if `st_flags' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_FLAGS */

/* Define to 1 if `st_mtimespec.tv_nsec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC */

/* Define to 1 if `st_mtime_n' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIME_N */

/* Define to 1 if `st_mtime_usec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIME_USEC */

/* Define to 1 if `st_mtim.tv_nsec' is a member of `struct stat'. */
#define HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC 1

/* Define to 1 if `st_umtime' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_UMTIME */

/* Define to 1 if `tm_gmtoff' is a member of `struct tm'. */
#define HAVE_STRUCT_TM_TM_GMTOFF 1

/* Define to 1 if `__tm_gmtoff' is a member of `struct tm'. */
/* #undef HAVE_STRUCT_TM___TM_GMTOFF */

/* Define to 1 if you have the `symlink' function. */
#define HAVE_SYMLINK 1

/* Define to 1 if you have the <sys/acl.h> header file. */
/* #undef HAVE_SYS_ACL_H */

/* Define to 1 if you have the <sys/cdefs.h> header file. */
#define HAVE_SYS_CDEFS_H 1

/* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.
   */
/* #undef HAVE_SYS_DIR_H */

/* Define to 1 if you have the <sys/ea.h> header file. */
/* #undef HAVE_SYS_EA_H */

/* Define to 1 if you have the <sys/extattr.h> header file. */
/* #undef HAVE_SYS_EXTATTR_H */

/* Define to 1 if you have the <sys/ioctl.h> header file. */
#define HAVE_SYS_IOCTL_H 1

/* Define to 1 if you have the <sys/mkdev.h> header file. */
/* #undef HAVE_SYS_MKDEV_H */

/* Define to 1 if you have the <sys/mount.h> header file. */
/* #undef HAVE_SYS_MOUNT_H */

/* Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.
   */
/* #undef HAVE_SYS_NDIR_H */

/* Define to 1 if you have the <sys/param.h> header file. */
#define HAVE_SYS_PARAM_H 1

/* Define to 1 if you have the <sys/poll.h> header file. */
#define HAVE_SYS_POLL_H 1

/* Define to 1 if you have the <sys/select.h> header file. */
#define HAVE_SYS_SELECT_H 1

/* Define to 1 if you have the <sys/statfs.h> header file. */
#define HAVE_SYS_STATFS_H 1

/* Define to 1 if you have the <sys/statvfs.h> header file. */
#define HAVE_SYS_STATVFS_H 1

/* Define to 1 if you have the <sys/stat.h> header file. */
#define HAVE_SYS_STAT_H 1

/* Define to 1 if you have the <sys/time.h> header file. */
#define HAVE_SYS_TIME_H 1

/* Define to 1 if you have the <sys/types.h> header file. */
#define HAVE_SYS_TYPES_H 1

/* Define to 1 if you have the <sys/utime.h> header file. */
/* #undef HAVE_SYS_UTIME_H */

/* Define to 1 if you have the <sys/utsname.h> header file. */
#define HAVE_SYS_UTSNAME_H 1

/* Define to 1 if you have the <sys/vfs.h> header file. */
#define HAVE_SYS_VFS_H 1

/* Define to 1 if you have <sys/wait.h> that is POSIX.1 compatible. */
#define HAVE_SYS_WAIT_H 1

/* Define to 1 if you have the <sys/xattr.h> header file. */
/* #undef HAVE_SYS_XATTR_H */

/* Define to 1 if you have the `timegm' function. */
#define HAVE_TIMEGM 1

/* Define to 1 if you have the <time.h> header file. */
#define HAVE_TIME_H 1

/* Define to 1 if you have the `tzset' function. */
#define HAVE_TZSET 1

/* Define to 1 if you have the <unistd.h> header file. */
#define HAVE_UNISTD_H 1

/* Define to 1 if you have the `unsetenv' function. */
#define HAVE_UNSETENV 1

/* Define to 1 if the system has the type `unsigned long long'. */
/* #undef HAVE_UNSIGNED_LONG_LONG */

/* Define to 1 if the system has the type `unsigned long long int'. */
/* #undef HAVE_UNSIGNED_LONG_LONG_INT */

/* Define to 1 if you have the `utime' function. */
#define HAVE_UTIME 1

/* Define to 1 if you have the `utimensat' function. */
#define HAVE_UTIMENSAT 1

/* Define to 1 if you have the `utimes' function. */
#define HAVE_UTIMES 1

/* Define to 1 if you have the <utime.h> header file. */
#define HAVE_UTIME_H 1

/* Define to 1 if you have the `vfork' function. */
#define HAVE_VFORK 1

/* Define to 1 if you have the `vprintf' function. */
#define HAVE_VPRINTF 1

/* Define to 1 if you have the <wchar.h> header file. */
#define HAVE_WCHAR_H 1

/* Define to 1 if the system has the type `wchar_t'. */
#define HAVE_WCHAR_T 1

/* Define to 1 if you have the `wcrtomb' function. */
#define HAVE_WCRTOMB 1

/* Define to 1 if you have the `wcscmp' function. */
#define HAVE_WCSCMP 1

/* Define to 1 if you have the `wcscpy' function. */
#define HAVE_WCSCPY 1

/* Define to 1 if you have the `wcslen' function. */
#define HAVE_WCSLEN 1

/* Define to 1 if you have the `wctomb' function. */
#define HAVE_WCTOMB 1

/* Define to 1 if you have the <wctype.h> header file. */
#define HAVE_WCTYPE_H 1

/* Define to 1 if you have the <wincrypt.h> header file. */
/* #undef HAVE_WINCRYPT_H */

/* Define to 1 if you have the <windows.h> header file. */
/* #undef HAVE_WINDOWS_H */

/* Define to 1 if you have the <winioctl.h> header file. */
/* #undef HAVE_WINIOCTL_H */

/* Define to 1 if you have _CrtSetReportMode in <crtdbg.h>  */
/* #undef HAVE__CrtSetReportMode */

/* Define to 1 if you have the `wmemcmp' function. */
#define HAVE_WMEMCMP 1

/* Define to 1 if you have the `wmemcpy' function. */
#define HAVE_WMEMCPY 1

/* Define to 1 if you have a working EXT2_IOC_GETFLAGS */
/* #undef HAVE_WORKING_EXT2_IOC_GETFLAGS */

/* Define to 1 if you have the <zlib.h> header file. */
#define HAVE_ZLIB_H 1

/* Define to 1 if you have the `_ctime64_s' function. */
/* #undef HAVE__CTIME64_S */

/* Define to 1 if you have the `_fseeki64' function. */
/* #undef HAVE__FSEEKI64 */

/* Define to 1 if you have the `_get_timezone' function. */
/* #undef HAVE__GET_TIMEZONE */

/* Define to 1 if you have the `_localtime64_s' function. */
/* #undef HAVE__LOCALTIME64_S */

/* Define to 1 if you have the `_mkgmtime64' function. */
/* #undef HAVE__MKGMTIME64 */

/* Define as const if the declaration of iconv() needs const. */
#define ICONV_CONST 

/* Version number of libarchive as a single integer */
#define LIBARCHIVE_VERSION_NUMBER "3001002"

/* Version number of libarchive */
#define LIBARCHIVE_VERSION_STRING "3.1.2"

/* Define to 1 if `lstat' dereferences a symlink specified with a trailing
   slash. */
/* #undef LSTAT_FOLLOWS_SLASHED_SYMLINK */

/* Define to 1 if `major', `minor', and `makedev' are declared in <mkdev.h>.
   */
/* #undef MAJOR_IN_MKDEV */

/* Define to 1 if `major', `minor', and `makedev' are declared in
   <sysmacros.h>. */
#define MAJOR_IN_SYSMACROS 1

/* Define to 1 if your C compiler doesn't accept -c and -o together. */
/* #undef NO_MINUS_C_MINUS_O */

/* The size of `wchar_t', as computed by sizeof. */
#define SIZEOF_WCHAR_T 4

/* Define to 1 if strerror_r returns char *. */
/* #undef STRERROR_R_CHAR_P */

/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
#define TIME_WITH_SYS_TIME 1

/*
 * Some platform requires a macro to use extension functions.
 */
#define SAFE_TO_DEFINE_EXTENSIONS 1
#ifdef SAFE_TO_DEFINE_EXTENSIONS
/* Enable extensions on AIX 3, Interix.  */
#ifndef _ALL_SOURCE
# define _ALL_SOURCE 1
#endif
/* Enable GNU extensions on systems that have them.  */
#ifndef _GNU_SOURCE
# define _GNU_SOURCE 1
#endif
/* Enable threading extensions on Solaris.  */
#ifndef _POSIX_PTHREAD_SEMANTICS
# define _POSIX_PTHREAD_SEMANTICS 1
#endif
/* Enable extensions on HP NonStop.  */
#ifndef _TANDEM_SOURCE
# define _TANDEM_SOURCE 1
#endif
/* Enable general extensions on Solaris.  */
#ifndef __EXTENSIONS__
# define __EXTENSIONS__ 1
#endif
#endif /* SAFE_TO_DEFINE_EXTENSIONS */

/* Version number of package */
#define VERSION "3.1.2"

/* Number of bits in a file offset, on hosts where this is settable. */
/* #undef _FILE_OFFSET_BITS */

/* Define to 1 to make fseeko visible on some hosts (e.g. glibc 2.2). */
/* #undef _LARGEFILE_SOURCE */

/* Define for large files, on AIX-style hosts. */
/* #undef _LARGE_FILES */

/* Define for Windows to use Windows 2000+ APIs. */
/* #undef _WIN32_WINNT */
/* #undef WINVER */

/* Define to empty if `const' does not conform to ANSI C. */
/* #undef const */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef gid_t */

/* Define to `unsigned long' if <sys/types.h> does not define. */
/* #undef id_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef mode_t */

/* Define to `long long' if <sys/types.h> does not define. */
/* #undef off_t */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef pid_t */

/* Define to `unsigned int' if <sys/types.h> does not define. */
/* #undef size_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef ssize_t */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef uid_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef intptr_t */

/* Define to `unsigned int' if <sys/types.h> does not define. */
/* #undef uintptr_t */


#define ARCHIVE_SHA384_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA384_LIBSYSTEM
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = (DWORD)bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. Nettle
 * 6. OpenSSL
 * 7. libmd
 * 8. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive_sha384_ctx ctx;
  archive_sha384_init(&ctx);
  archive_sha384_update(&ctx, *argv, argc);
  archive_sha384_final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA512_LIBSYSTEM failed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2126027722/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2126027722.dir/build.make CMakeFiles/cmTryCompileExec2126027722.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2126027722.dir/check_crypto_md.c.o
/usr/bin/gcc   -w  -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2 -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmlibarchive/libarchive -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec2126027722.dir/check_crypto_md.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1186:0:
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:112:39: fatal error: CommonCrypto/CommonDigest.h: No such file or directory
 #include <CommonCrypto/CommonDigest.h>
                                       ^
compilation terminated.
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec2126027722.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec2126027722/fast] Error 2

Source file was:
/* config.h.  Generated from build/cmake/config.h.in by cmake configure */
#if defined(__osf__)
# define _OSF_SOURCE
#endif

/*
 * Ensure we have C99-style int64_t, etc, all defined.
 */

/* First, we need to know if the system has already defined them. */
#define HAVE_INT16_T
#define HAVE_INT32_T
#define HAVE_INT64_T
#define HAVE_INTMAX_T

#define HAVE_UINT8_T
#define HAVE_UINT16_T
#define HAVE_UINT32_T
#define HAVE_UINT64_T
#define HAVE_UINTMAX_T

/* We might have the types we want under other spellings. */
/* #undef HAVE___INT64 */
/* #undef HAVE_U_INT64_T */
/* #undef HAVE_UNSIGNED___INT64 */

/* The sizes of various standard integer types. */
#define SIZE_OF_SHORT 2
#define SIZE_OF_INT 4
#define SIZE_OF_LONG 8
#define SIZE_OF_LONG_LONG 8
#define SIZE_OF_UNSIGNED_SHORT 2
#define SIZE_OF_UNSIGNED 4
#define SIZE_OF_UNSIGNED_LONG 8
#define SIZE_OF_UNSIGNED_LONG_LONG 8

/*
 * If we lack int64_t, define it to the first of __int64, int, long, and long long
 * that exists and is the right size.
 */
#if !defined(HAVE_INT64_T) && defined(HAVE___INT64)
typedef __int64 int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_INT == 8
typedef int int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_LONG == 8
typedef long int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_LONG_LONG == 8
typedef long long int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T)
#error No 64-bit integer type was found.
#endif

/*
 * Similarly for int32_t
 */
#if !defined(HAVE_INT32_T) && SIZE_OF_INT == 4
typedef long int32_t;
#define HAVE_INT32_T
#endif

#if !defined(HAVE_INT32_T) && SIZE_OF_LONG == 4
typedef long int32_t;
#define HAVE_INT32_T
#endif

#if !defined(HAVE_INT32_T)
#error No 32-bit integer type was found.
#endif

/*
 * Similarly for int16_t
 */
#if !defined(HAVE_INT16_T) && SIZE_OF_INT == 2
typedef int int16_t;
#define HAVE_INT16_T
#endif

#if !defined(HAVE_INT16_T) && SIZE_OF_SHORT == 2
typedef short int16_t;
#define HAVE_INT16_T
#endif

#if !defined(HAVE_INT16_T)
#error No 16-bit integer type was found.
#endif

/*
 * Similarly for uint64_t
 */
#if !defined(HAVE_UINT64_T) && defined(HAVE_UNSIGNED___INT64)
typedef unsigned __int64 uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED == 8
typedef unsigned uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED_LONG == 8
typedef unsigned long uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED_LONG_LONG == 8
typedef unsigned long long uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T)
#error No 64-bit unsigned integer type was found.
#endif


/*
 * Similarly for uint32_t
 */
#if !defined(HAVE_UINT32_T) && SIZE_OF_UNSIGNED == 4
typedef unsigned uint32_t;
#define HAVE_UINT32_T
#endif

#if !defined(HAVE_UINT32_T) && SIZE_OF_UNSIGNED_LONG == 4
typedef unsigned long uint32_t;
#define HAVE_UINT32_T
#endif

#if !defined(HAVE_UINT32_T)
#error No 32-bit unsigned integer type was found.
#endif

/*
 * Similarly for uint16_t
 */
#if !defined(HAVE_UINT16_T) && SIZE_OF_UNSIGNED == 2
typedef unsigned uint16_t;
#define HAVE_UINT16_T
#endif

#if !defined(HAVE_UINT16_T) && SIZE_OF_UNSIGNED_SHORT == 2
typedef unsigned short uint16_t;
#define HAVE_UINT16_T
#endif

#if !defined(HAVE_UINT16_T)
#error No 16-bit unsigned integer type was found.
#endif

/*
 * Similarly for uint8_t
 */
#if !defined(HAVE_UINT8_T)
typedef unsigned char uint8_t;
#define HAVE_UINT8_T
#endif

#if !defined(HAVE_UINT16_T)
#error No 8-bit unsigned integer type was found.
#endif

/* Define intmax_t and uintmax_t if they are not already defined. */
#if !defined(HAVE_INTMAX_T)
typedef int64_t intmax_t;
#define INTMAX_MIN INT64_MIN
#define INTMAX_MAX INT64_MAX
#endif

#if !defined(HAVE_UINTMAX_T)
typedef uint64_t uintmax_t;
#endif

/* Define ZLIB_WINAPI if zlib was built on Visual Studio. */
/* #undef ZLIB_WINAPI */

/* MD5 via ARCHIVE_CRYPTO_MD5_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_MD5_LIBC */

/* MD5 via ARCHIVE_CRYPTO_MD5_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_MD5_LIBSYSTEM */

/* MD5 via ARCHIVE_CRYPTO_MD5_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_MD5_NETTLE */

/* MD5 via ARCHIVE_CRYPTO_MD5_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_MD5_OPENSSL */

/* MD5 via ARCHIVE_CRYPTO_MD5_WIN supported. */
/* #undef ARCHIVE_CRYPTO_MD5_WIN */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_LIBC */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_NETTLE */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_OPENSSL */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_LIBC */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_LIBSYSTEM */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_NETTLE */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_OPENSSL */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_WIN */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC2 */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC3 */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBSYSTEM */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_NETTLE */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_OPENSSL */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_WIN */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC2 */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC3 */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBSYSTEM */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_NETTLE */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_OPENSSL */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_WIN */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC2 */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC3 */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBSYSTEM */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_NETTLE */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_OPENSSL */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_WIN */

/* Version number of bsdcpio */
#define BSDCPIO_VERSION_STRING "3.1.2"

/* Version number of bsdtar */
#define BSDTAR_VERSION_STRING "3.1.2"

/* Define to 1 if you have the `acl_create_entry' function. */
/* #undef HAVE_ACL_CREATE_ENTRY */

/* Define to 1 if you have the `acl_get_link' function. */
/* #undef HAVE_ACL_GET_LINK */

/* Define to 1 if you have the `acl_get_link_np' function. */
/* #undef HAVE_ACL_GET_LINK_NP */

/* Define to 1 if you have the `acl_get_perm' function. */
/* #undef HAVE_ACL_GET_PERM */

/* Define to 1 if you have the `acl_get_perm_np' function. */
/* #undef HAVE_ACL_GET_PERM_NP */

/* Define to 1 if you have the `acl_init' function. */
/* #undef HAVE_ACL_INIT */

/* Define to 1 if you have the <acl/libacl.h> header file. */
/* #undef HAVE_ACL_LIBACL_H */

/* Define to 1 if the system has the type `acl_permset_t'. */
/* #undef HAVE_ACL_PERMSET_T */

/* Define to 1 if you have the `acl_set_fd' function. */
/* #undef HAVE_ACL_SET_FD */

/* Define to 1 if you have the `acl_set_fd_np' function. */
/* #undef HAVE_ACL_SET_FD_NP */

/* Define to 1 if you have the `acl_set_file' function. */
/* #undef HAVE_ACL_SET_FILE */

/* True for systems with POSIX ACL support */
/* #undef HAVE_ACL_USER */

/* Define to 1 if you have the <attr/xattr.h> header file. */
/* #undef HAVE_ATTR_XATTR_H */

/* Define to 1 if you have the <bsdxml.h> header file. */
/* #undef HAVE_BSDXML_H */

/* Define to 1 if you have the <bzlib.h> header file. */
#define HAVE_BZLIB_H 1

/* Define to 1 if you have the `chflags' function. */
/* #undef HAVE_CHFLAGS */

/* Define to 1 if you have the `chown' function. */
#define HAVE_CHOWN 1

/* Define to 1 if you have the `chroot' function. */
#define HAVE_CHROOT 1

/* Define to 1 if you have the <copyfile.h> header file. */
/* #undef HAVE_COPYFILE_H */

/* Define to 1 if you have the `ctime_r' function. */
#define HAVE_CTIME_R 1

/* Define to 1 if you have the <ctype.h> header file. */
#define HAVE_CTYPE_H 1

/* Define to 1 if you have the `cygwin_conv_path' function. */
/* #undef HAVE_CYGWIN_CONV_PATH */

/* Define to 1 if you have the declaration of `INT64_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_INT64_MAX 1

/* Define to 1 if you have the declaration of `INT64_MIN', and to 0 if you
   don't. */
#define HAVE_DECL_INT64_MIN 1

/* Define to 1 if you have the declaration of `SIZE_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_SIZE_MAX 1

/* Define to 1 if you have the declaration of `SSIZE_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_SSIZE_MAX 1

/* Define to 1 if you have the declaration of `strerror_r', and to 0 if you
   don't. */
#define HAVE_DECL_STRERROR_R 1

/* Define to 1 if you have the declaration of `UINT32_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_UINT32_MAX 1

/* Define to 1 if you have the declaration of `UINT64_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_UINT64_MAX 1

/* Define to 1 if you have the <direct.h> header file. */
/* #undef HAVE_DIRECT_H */

/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.
   */
#define HAVE_DIRENT_H 1

/* Define to 1 if you have the `dirfd' function. */
#define HAVE_DIRFD 1

/* Define to 1 if you have the <dlfcn.h> header file. */
#define HAVE_DLFCN_H 1

/* Define to 1 if you don't have `vprintf' but do have `_doprnt.' */
/* #undef HAVE_DOPRNT */

/* Define to 1 if nl_langinfo supports D_MD_ORDER */
/* #undef HAVE_D_MD_ORDER */

/* A possible errno value for invalid file format errors */
/* #undef HAVE_EFTYPE */

/* A possible errno value for invalid file format errors */
#define HAVE_EILSEQ 1

/* Define to 1 if you have the <errno.h> header file. */
#define HAVE_ERRNO_H 1

/* Define to 1 if you have the <expat.h> header file. */
/* #undef HAVE_EXPAT_H */

/* Define to 1 if you have the <ext2fs/ext2_fs.h> header file. */
/* #undef HAVE_EXT2FS_EXT2_FS_H */

/* Define to 1 if you have the `extattr_get_file' function. */
/* #undef HAVE_EXTATTR_GET_FILE */

/* Define to 1 if you have the `extattr_list_file' function. */
/* #undef HAVE_EXTATTR_LIST_FILE */

/* Define to 1 if you have the `extattr_set_fd' function. */
/* #undef HAVE_EXTATTR_SET_FD */

/* Define to 1 if you have the `extattr_set_file' function. */
/* #undef HAVE_EXTATTR_SET_FILE */

/* Define to 1 if EXTATTR_NAMESPACE_USER is defined in sys/extattr.h. */
/* #undef HAVE_DECL_EXTATTR_NAMESPACE_USER */

/* Define to 1 if you have the `fchdir' function. */
#define HAVE_FCHDIR 1

/* Define to 1 if you have the `fchflags' function. */
/* #undef HAVE_FCHFLAGS */

/* Define to 1 if you have the `fchmod' function. */
#define HAVE_FCHMOD 1

/* Define to 1 if you have the `fchown' function. */
#define HAVE_FCHOWN 1

/* Define to 1 if you have the `fcntl' function. */
#define HAVE_FCNTL 1

/* Define to 1 if you have the <fcntl.h> header file. */
#define HAVE_FCNTL_H 1

/* Define to 1 if you have the `fdopendir' function. */
#define HAVE_FDOPENDIR 1

/* Define to 1 if you have the `fgetea' function. */
/* #undef HAVE_FGETEA */

/* Define to 1 if you have the `fgetxattr' function. */
/* #undef HAVE_FGETXATTR */

/* Define to 1 if you have the `flistea' function. */
/* #undef HAVE_FLISTEA */

/* Define to 1 if you have the `flistxattr' function. */
/* #undef HAVE_FLISTXATTR */

/* Define to 1 if you have the `fork' function. */
#define HAVE_FORK 1

/* Define to 1 if fseeko (and presumably ftello) exists and is declared. */
#define HAVE_FSEEKO 1

/* Define to 1 if you have the `fsetea' function. */
/* #undef HAVE_FSETEA */

/* Define to 1 if you have the `fsetxattr' function. */
/* #undef HAVE_FSETXATTR */

/* Define to 1 if you have the `fstat' function. */
#define HAVE_FSTAT 1

/* Define to 1 if you have the `fstatat' function. */
#define HAVE_FSTATAT 1

/* Define to 1 if you have the `fstatfs' function. */
#define HAVE_FSTATFS 1

/* Define to 1 if you have the `fstatvfs' function. */
#define HAVE_FSTATVFS 1

/* Define to 1 if you have the `ftruncate' function. */
#define HAVE_FTRUNCATE 1

/* Define to 1 if you have the `futimens' function. */
#define HAVE_FUTIMENS 1

/* Define to 1 if you have the `futimes' function. */
#define HAVE_FUTIMES 1

/* Define to 1 if you have the `futimesat' function. */
#define HAVE_FUTIMESAT 1

/* Define to 1 if you have the `getea' function. */
/* #undef HAVE_GETEA */

/* Define to 1 if you have the `geteuid' function. */
#define HAVE_GETEUID 1

/* Define to 1 if you have the `getgrgid_r' function. */
#define HAVE_GETGRGID_R 1

/* Define to 1 if you have the `getgrnam_r' function. */
#define HAVE_GETGRNAM_R 1

/* Define to 1 if you have the `getpid' function. */
#define HAVE_GETPID 1

/* Define to 1 if you have the `getpwnam_r' function. */
#define HAVE_GETPWNAM_R 1

/* Define to 1 if you have the `getpwuid_r' function. */
#define HAVE_GETPWUID_R 1

/* Define to 1 if you have the `getvfsbyname' function. */
/* #undef HAVE_GETVFSBYNAME */

/* Define to 1 if you have the `getxattr' function. */
/* #undef HAVE_GETXATTR */

/* Define to 1 if you have the `gmtime_r' function. */
#define HAVE_GMTIME_R 1

/* Define to 1 if you have the <grp.h> header file. */
#define HAVE_GRP_H 1

/* Define to 1 if you have the `iconv' function. */
/* #undef HAVE_ICONV */

/* Define to 1 if you have the <iconv.h> header file. */
/* #undef HAVE_ICONV_H */

/* Define to 1 if you have the <inttypes.h> header file. */
#define HAVE_INTTYPES_H 1

/* Define to 1 if you have the <io.h> header file. */
/* #undef HAVE_IO_H */

/* Define to 1 if you have the <langinfo.h> header file. */
#define HAVE_LANGINFO_H 1

/* Define to 1 if you have the `lchflags' function. */
/* #undef HAVE_LCHFLAGS */

/* Define to 1 if you have the `lchmod' function. */
/* #undef HAVE_LCHMOD */

/* Define to 1 if you have the `lchown' function. */
#define HAVE_LCHOWN 1

/* Define to 1 if you have the `lgetea' function. */
/* #undef HAVE_LGETEA */

/* Define to 1 if you have the `lgetxattr' function. */
/* #undef HAVE_LGETXATTR */

/* Define to 1 if you have the `acl' library (-lacl). */
/* #undef HAVE_LIBACL */

/* Define to 1 if you have the `attr' library (-lattr). */
/* #undef HAVE_LIBATTR */

/* Define to 1 if you have the `bsdxml' library (-lbsdxml). */
/* #undef HAVE_LIBBSDXML */

/* Define to 1 if you have the `bz2' library (-lbz2). */
#define HAVE_LIBBZ2 1

/* Define to 1 if you have the `expat' library (-lexpat). */
/* #undef HAVE_LIBEXPAT */

/* Define to 1 if you have the `gcc' library (-lgcc). */
/* #undef HAVE_LIBGCC */

/* Define to 1 if you have the `lzma' library (-llzma). */
/* #undef HAVE_LIBLZMA */

/* Define to 1 if you have the `lzmadec' library (-llzmadec). */
/* #undef HAVE_LIBLZMADEC */

/* Define to 1 if you have the `lzo2' library (-llzo2). */
/* #undef HAVE_LIBLZO2 */

/* Define to 1 if you have the `nettle' library (-lnettle). */
/* #undef HAVE_LIBNETTLE */

/* Define to 1 if you have the `pcre' library (-lpcre). */
/* #undef HAVE_LIBPCRE */

/* Define to 1 if you have the `pcreposix' library (-lpcreposix). */
/* #undef HAVE_LIBPCREPOSIX */

/* Define to 1 if you have the `xml2' library (-lxml2). */
/* #undef HAVE_LIBXML2 */

/* Define to 1 if you have the <libxml/xmlreader.h> header file. */
/* #undef HAVE_LIBXML_XMLREADER_H */

/* Define to 1 if you have the <libxml/xmlwriter.h> header file. */
/* #undef HAVE_LIBXML_XMLWRITER_H */

/* Define to 1 if you have the `z' library (-lz). */
#define HAVE_LIBZ 1

/* Define to 1 if you have the <limits.h> header file. */
#define HAVE_LIMITS_H 1

/* Define to 1 if you have the `link' function. */
#define HAVE_LINK 1

/* Define to 1 if you have the <linux/types.h> header file. */
#define HAVE_LINUX_TYPES_H 1

/* Define to 1 if you have the <linux/fiemap.h> header file. */
#define HAVE_LINUX_FIEMAP_H 1

/* Define to 1 if you have the <linux/fs.h> header file. */
#define HAVE_LINUX_FS_H 1

/* Define to 1 if you have the <linux/magic.h> header file. */
#define HAVE_LINUX_MAGIC_H 1

/* Define to 1 if you have the <linux/types.h> header file. */
#define HAVE_LINUX_TYPES_H 1

/* Define to 1 if you have the `listea' function. */
/* #undef HAVE_LISTEA */

/* Define to 1 if you have the `listxattr' function. */
/* #undef HAVE_LISTXATTR */

/* Define to 1 if you have the `llistea' function. */
/* #undef HAVE_LLISTEA */

/* Define to 1 if you have the `llistxattr' function. */
/* #undef HAVE_LLISTXATTR */

/* Define to 1 if you have the <localcharset.h> header file. */
/* #undef HAVE_LOCALCHARSET_H */

/* Define to 1 if you have the `locale_charset' function. */
/* #undef HAVE_LOCALE_CHARSET */

/* Define to 1 if you have the <locale.h> header file. */
#define HAVE_LOCALE_H 1

/* Define to 1 if you have the `localtime_r' function. */
#define HAVE_LOCALTIME_R 1

/* Define to 1 if the system has the type `long long int'. */
/* #undef HAVE_LONG_LONG_INT */

/* Define to 1 if you have the `lsetea' function. */
/* #undef HAVE_LSETEA */

/* Define to 1 if you have the `lsetxattr' function. */
/* #undef HAVE_LSETXATTR */

/* Define to 1 if you have the `lstat' function. */
#define HAVE_LSTAT 1

/* Define to 1 if `lstat' has the bug that it succeeds when given the
   zero-length file name argument. */
/* #undef HAVE_LSTAT_EMPTY_STRING_BUG */

/* Define to 1 if you have the `lutimes' function. */
#define HAVE_LUTIMES 1

/* Define to 1 if you have the <lzmadec.h> header file. */
/* #undef HAVE_LZMADEC_H */

/* Define to 1 if you have the <lzma.h> header file. */
/* #undef HAVE_LZMA_H */

/* Define to 1 if you have the <lzo/lzo1x.h> header file. */
/* #undef HAVE_LZO_LZO1X_H */

/* Define to 1 if you have the <lzo/lzoconf.h> header file. */
/* #undef HAVE_LZO_LZOCONF_H */

/* Define to 1 if you have the `mbrtowc' function. */
#define HAVE_MBRTOWC 1

/* Define to 1 if you have the `memmove' function. */
#define HAVE_MEMMOVE 1

/* Define to 1 if you have the <memory.h> header file. */
#define HAVE_MEMORY_H 1

/* Define to 1 if you have the `mkdir' function. */
#define HAVE_MKDIR 1

/* Define to 1 if you have the `mkfifo' function. */
#define HAVE_MKFIFO 1

/* Define to 1 if you have the `mknod' function. */
#define HAVE_MKNOD 1

/* Define to 1 if you have the `mkstemp' function. */
#define HAVE_MKSTEMP 1

/* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */
/* #undef HAVE_NDIR_H */

/* Define to 1 if you have the <nettle/md5.h> header file. */
/* #undef HAVE_NETTLE_MD5_H */

/* Define to 1 if you have the <nettle/ripemd160.h> header file. */
/* #undef HAVE_NETTLE_RIPEMD160_H */

/* Define to 1 if you have the <nettle/sha.h> header file. */
/* #undef HAVE_NETTLE_SHA_H */

/* Define to 1 if you have the `nl_langinfo' function. */
#define HAVE_NL_LANGINFO 1

/* Define to 1 if you have the `openat' function. */
#define HAVE_OPENAT 1

/* Define to 1 if you have the <paths.h> header file. */
#define HAVE_PATHS_H 1

/* Define to 1 if you have the <pcreposix.h> header file. */
/* #undef HAVE_PCREPOSIX_H */

/* Define to 1 if you have the `pipe' function. */
#define HAVE_PIPE 1

/* Define to 1 if you have the `poll' function. */
#define HAVE_POLL 1

/* Define to 1 if you have the <poll.h> header file. */
#define HAVE_POLL_H 1

/* Define to 1 if you have the `posix_spawnp' function. */
#define HAVE_POSIX_SPAWNP 1

/* Define to 1 if you have the <process.h> header file. */
/* #undef HAVE_PROCESS_H */

/* Define to 1 if you have the <pwd.h> header file. */
#define HAVE_PWD_H 1

/* Define to 1 if you have the `readdir_r' function. */
#define HAVE_READDIR_R 1

/* Define to 1 if you have the `readlink' function. */
#define HAVE_READLINK 1

/* Define to 1 if you have the `readlinkat' function. */
#define HAVE_READLINKAT 1

/* Define to 1 if you have the <regex.h> header file. */
#define HAVE_REGEX_H 1

/* Define to 1 if you have the `select' function. */
#define HAVE_SELECT 1

/* Define to 1 if you have the `setenv' function. */
#define HAVE_SETENV 1

/* Define to 1 if you have the `setlocale' function. */
#define HAVE_SETLOCALE 1

/* Define to 1 if you have the `sigaction' function. */
#define HAVE_SIGACTION 1

/* Define to 1 if you have the <signal.h> header file. */
#define HAVE_SIGNAL_H 1

/* Define to 1 if you have the <spawn.h> header file. */
#define HAVE_SPAWN_H 1

/* Define to 1 if you have the `statfs' function. */
#define HAVE_STATFS 1

/* Define to 1 if you have the `statvfs' function. */
#define HAVE_STATVFS 1

/* Define to 1 if `stat' has the bug that it succeeds when given the
   zero-length file name argument. */
/* #undef HAVE_STAT_EMPTY_STRING_BUG */

/* Define to 1 if you have the <stdarg.h> header file. */
#define HAVE_STDARG_H 1

/* Define to 1 if you have the <stdint.h> header file. */
#define HAVE_STDINT_H 1

/* Define to 1 if you have the <stdlib.h> header file. */
#define HAVE_STDLIB_H 1

/* Define to 1 if you have the `strchr' function. */
#define HAVE_STRCHR 1

/* Define to 1 if you have the `strdup' function. */
#define HAVE_STRDUP 1

/* Define to 1 if you have the `strerror' function. */
#define HAVE_STRERROR 1

/* Define to 1 if you have the `strerror_r' function. */
#define HAVE_STRERROR_R 1

/* Define to 1 if you have the `strftime' function. */
#define HAVE_STRFTIME 1

/* Define to 1 if you have the <strings.h> header file. */
#define HAVE_STRINGS_H 1

/* Define to 1 if you have the <string.h> header file. */
#define HAVE_STRING_H 1

/* Define to 1 if you have the `strrchr' function. */
#define HAVE_STRRCHR 1

/* Define to 1 if `f_namemax' is a member of `struct statfs'. */
/* #undef HAVE_STRUCT_STATFS_F_NAMEMAX */

/* Define to 1 if `f_iosize' is a member of `struct statvfs'. */
/* #undef HAVE_STRUCT_STATVFS_F_IOSIZE */

/* Define to 1 if `st_birthtime' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIME */

/* Define to 1 if `st_birthtimespec.tv_nsec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC_TV_NSEC */

/* Define to 1 if `st_blksize' is a member of `struct stat'. */
#define HAVE_STRUCT_STAT_ST_BLKSIZE 1

/* Define to 1 if `st_flags' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_FLAGS */

/* Define to 1 if `st_mtimespec.tv_nsec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC */

/* Define to 1 if `st_mtime_n' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIME_N */

/* Define to 1 if `st_mtime_usec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIME_USEC */

/* Define to 1 if `st_mtim.tv_nsec' is a member of `struct stat'. */
#define HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC 1

/* Define to 1 if `st_umtime' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_UMTIME */

/* Define to 1 if `tm_gmtoff' is a member of `struct tm'. */
#define HAVE_STRUCT_TM_TM_GMTOFF 1

/* Define to 1 if `__tm_gmtoff' is a member of `struct tm'. */
/* #undef HAVE_STRUCT_TM___TM_GMTOFF */

/* Define to 1 if you have the `symlink' function. */
#define HAVE_SYMLINK 1

/* Define to 1 if you have the <sys/acl.h> header file. */
/* #undef HAVE_SYS_ACL_H */

/* Define to 1 if you have the <sys/cdefs.h> header file. */
#define HAVE_SYS_CDEFS_H 1

/* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.
   */
/* #undef HAVE_SYS_DIR_H */

/* Define to 1 if you have the <sys/ea.h> header file. */
/* #undef HAVE_SYS_EA_H */

/* Define to 1 if you have the <sys/extattr.h> header file. */
/* #undef HAVE_SYS_EXTATTR_H */

/* Define to 1 if you have the <sys/ioctl.h> header file. */
#define HAVE_SYS_IOCTL_H 1

/* Define to 1 if you have the <sys/mkdev.h> header file. */
/* #undef HAVE_SYS_MKDEV_H */

/* Define to 1 if you have the <sys/mount.h> header file. */
/* #undef HAVE_SYS_MOUNT_H */

/* Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.
   */
/* #undef HAVE_SYS_NDIR_H */

/* Define to 1 if you have the <sys/param.h> header file. */
#define HAVE_SYS_PARAM_H 1

/* Define to 1 if you have the <sys/poll.h> header file. */
#define HAVE_SYS_POLL_H 1

/* Define to 1 if you have the <sys/select.h> header file. */
#define HAVE_SYS_SELECT_H 1

/* Define to 1 if you have the <sys/statfs.h> header file. */
#define HAVE_SYS_STATFS_H 1

/* Define to 1 if you have the <sys/statvfs.h> header file. */
#define HAVE_SYS_STATVFS_H 1

/* Define to 1 if you have the <sys/stat.h> header file. */
#define HAVE_SYS_STAT_H 1

/* Define to 1 if you have the <sys/time.h> header file. */
#define HAVE_SYS_TIME_H 1

/* Define to 1 if you have the <sys/types.h> header file. */
#define HAVE_SYS_TYPES_H 1

/* Define to 1 if you have the <sys/utime.h> header file. */
/* #undef HAVE_SYS_UTIME_H */

/* Define to 1 if you have the <sys/utsname.h> header file. */
#define HAVE_SYS_UTSNAME_H 1

/* Define to 1 if you have the <sys/vfs.h> header file. */
#define HAVE_SYS_VFS_H 1

/* Define to 1 if you have <sys/wait.h> that is POSIX.1 compatible. */
#define HAVE_SYS_WAIT_H 1

/* Define to 1 if you have the <sys/xattr.h> header file. */
/* #undef HAVE_SYS_XATTR_H */

/* Define to 1 if you have the `timegm' function. */
#define HAVE_TIMEGM 1

/* Define to 1 if you have the <time.h> header file. */
#define HAVE_TIME_H 1

/* Define to 1 if you have the `tzset' function. */
#define HAVE_TZSET 1

/* Define to 1 if you have the <unistd.h> header file. */
#define HAVE_UNISTD_H 1

/* Define to 1 if you have the `unsetenv' function. */
#define HAVE_UNSETENV 1

/* Define to 1 if the system has the type `unsigned long long'. */
/* #undef HAVE_UNSIGNED_LONG_LONG */

/* Define to 1 if the system has the type `unsigned long long int'. */
/* #undef HAVE_UNSIGNED_LONG_LONG_INT */

/* Define to 1 if you have the `utime' function. */
#define HAVE_UTIME 1

/* Define to 1 if you have the `utimensat' function. */
#define HAVE_UTIMENSAT 1

/* Define to 1 if you have the `utimes' function. */
#define HAVE_UTIMES 1

/* Define to 1 if you have the <utime.h> header file. */
#define HAVE_UTIME_H 1

/* Define to 1 if you have the `vfork' function. */
#define HAVE_VFORK 1

/* Define to 1 if you have the `vprintf' function. */
#define HAVE_VPRINTF 1

/* Define to 1 if you have the <wchar.h> header file. */
#define HAVE_WCHAR_H 1

/* Define to 1 if the system has the type `wchar_t'. */
#define HAVE_WCHAR_T 1

/* Define to 1 if you have the `wcrtomb' function. */
#define HAVE_WCRTOMB 1

/* Define to 1 if you have the `wcscmp' function. */
#define HAVE_WCSCMP 1

/* Define to 1 if you have the `wcscpy' function. */
#define HAVE_WCSCPY 1

/* Define to 1 if you have the `wcslen' function. */
#define HAVE_WCSLEN 1

/* Define to 1 if you have the `wctomb' function. */
#define HAVE_WCTOMB 1

/* Define to 1 if you have the <wctype.h> header file. */
#define HAVE_WCTYPE_H 1

/* Define to 1 if you have the <wincrypt.h> header file. */
/* #undef HAVE_WINCRYPT_H */

/* Define to 1 if you have the <windows.h> header file. */
/* #undef HAVE_WINDOWS_H */

/* Define to 1 if you have the <winioctl.h> header file. */
/* #undef HAVE_WINIOCTL_H */

/* Define to 1 if you have _CrtSetReportMode in <crtdbg.h>  */
/* #undef HAVE__CrtSetReportMode */

/* Define to 1 if you have the `wmemcmp' function. */
#define HAVE_WMEMCMP 1

/* Define to 1 if you have the `wmemcpy' function. */
#define HAVE_WMEMCPY 1

/* Define to 1 if you have a working EXT2_IOC_GETFLAGS */
/* #undef HAVE_WORKING_EXT2_IOC_GETFLAGS */

/* Define to 1 if you have the <zlib.h> header file. */
#define HAVE_ZLIB_H 1

/* Define to 1 if you have the `_ctime64_s' function. */
/* #undef HAVE__CTIME64_S */

/* Define to 1 if you have the `_fseeki64' function. */
/* #undef HAVE__FSEEKI64 */

/* Define to 1 if you have the `_get_timezone' function. */
/* #undef HAVE__GET_TIMEZONE */

/* Define to 1 if you have the `_localtime64_s' function. */
/* #undef HAVE__LOCALTIME64_S */

/* Define to 1 if you have the `_mkgmtime64' function. */
/* #undef HAVE__MKGMTIME64 */

/* Define as const if the declaration of iconv() needs const. */
#define ICONV_CONST 

/* Version number of libarchive as a single integer */
#define LIBARCHIVE_VERSION_NUMBER "3001002"

/* Version number of libarchive */
#define LIBARCHIVE_VERSION_STRING "3.1.2"

/* Define to 1 if `lstat' dereferences a symlink specified with a trailing
   slash. */
/* #undef LSTAT_FOLLOWS_SLASHED_SYMLINK */

/* Define to 1 if `major', `minor', and `makedev' are declared in <mkdev.h>.
   */
/* #undef MAJOR_IN_MKDEV */

/* Define to 1 if `major', `minor', and `makedev' are declared in
   <sysmacros.h>. */
#define MAJOR_IN_SYSMACROS 1

/* Define to 1 if your C compiler doesn't accept -c and -o together. */
/* #undef NO_MINUS_C_MINUS_O */

/* The size of `wchar_t', as computed by sizeof. */
#define SIZEOF_WCHAR_T 4

/* Define to 1 if strerror_r returns char *. */
/* #undef STRERROR_R_CHAR_P */

/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
#define TIME_WITH_SYS_TIME 1

/*
 * Some platform requires a macro to use extension functions.
 */
#define SAFE_TO_DEFINE_EXTENSIONS 1
#ifdef SAFE_TO_DEFINE_EXTENSIONS
/* Enable extensions on AIX 3, Interix.  */
#ifndef _ALL_SOURCE
# define _ALL_SOURCE 1
#endif
/* Enable GNU extensions on systems that have them.  */
#ifndef _GNU_SOURCE
# define _GNU_SOURCE 1
#endif
/* Enable threading extensions on Solaris.  */
#ifndef _POSIX_PTHREAD_SEMANTICS
# define _POSIX_PTHREAD_SEMANTICS 1
#endif
/* Enable extensions on HP NonStop.  */
#ifndef _TANDEM_SOURCE
# define _TANDEM_SOURCE 1
#endif
/* Enable general extensions on Solaris.  */
#ifndef __EXTENSIONS__
# define __EXTENSIONS__ 1
#endif
#endif /* SAFE_TO_DEFINE_EXTENSIONS */

/* Version number of package */
#define VERSION "3.1.2"

/* Number of bits in a file offset, on hosts where this is settable. */
/* #undef _FILE_OFFSET_BITS */

/* Define to 1 to make fseeko visible on some hosts (e.g. glibc 2.2). */
/* #undef _LARGEFILE_SOURCE */

/* Define for large files, on AIX-style hosts. */
/* #undef _LARGE_FILES */

/* Define for Windows to use Windows 2000+ APIs. */
/* #undef _WIN32_WINNT */
/* #undef WINVER */

/* Define to empty if `const' does not conform to ANSI C. */
/* #undef const */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef gid_t */

/* Define to `unsigned long' if <sys/types.h> does not define. */
/* #undef id_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef mode_t */

/* Define to `long long' if <sys/types.h> does not define. */
/* #undef off_t */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef pid_t */

/* Define to `unsigned int' if <sys/types.h> does not define. */
/* #undef size_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef ssize_t */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef uid_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef intptr_t */

/* Define to `unsigned int' if <sys/types.h> does not define. */
/* #undef uintptr_t */


#define ARCHIVE_SHA512_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA512_LIBSYSTEM
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = (DWORD)bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. Nettle
 * 6. OpenSSL
 * 7. libmd
 * 8. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive_sha512_ctx ctx;
  archive_sha512_init(&ctx);
  archive_sha512_update(&ctx, *argv, argc);
  archive_sha512_final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_MD5_LIBMD failed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec651744742/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec651744742.dir/build.make CMakeFiles/cmTryCompileExec651744742.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec651744742.dir/check_crypto_md.c.o
/usr/bin/gcc   -w  -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2 -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmlibarchive/libarchive -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec651744742.dir/check_crypto_md.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1186:0:
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:91:17: fatal error: md5.h: No such file or directory
 #include <md5.h>
                 ^
compilation terminated.
make[5]: *** [CMakeFiles/cmTryCompileExec651744742.dir/check_crypto_md.c.o] Error 1
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec651744742/fast] Error 2

Source file was:
/* config.h.  Generated from build/cmake/config.h.in by cmake configure */
#if defined(__osf__)
# define _OSF_SOURCE
#endif

/*
 * Ensure we have C99-style int64_t, etc, all defined.
 */

/* First, we need to know if the system has already defined them. */
#define HAVE_INT16_T
#define HAVE_INT32_T
#define HAVE_INT64_T
#define HAVE_INTMAX_T

#define HAVE_UINT8_T
#define HAVE_UINT16_T
#define HAVE_UINT32_T
#define HAVE_UINT64_T
#define HAVE_UINTMAX_T

/* We might have the types we want under other spellings. */
/* #undef HAVE___INT64 */
/* #undef HAVE_U_INT64_T */
/* #undef HAVE_UNSIGNED___INT64 */

/* The sizes of various standard integer types. */
#define SIZE_OF_SHORT 2
#define SIZE_OF_INT 4
#define SIZE_OF_LONG 8
#define SIZE_OF_LONG_LONG 8
#define SIZE_OF_UNSIGNED_SHORT 2
#define SIZE_OF_UNSIGNED 4
#define SIZE_OF_UNSIGNED_LONG 8
#define SIZE_OF_UNSIGNED_LONG_LONG 8

/*
 * If we lack int64_t, define it to the first of __int64, int, long, and long long
 * that exists and is the right size.
 */
#if !defined(HAVE_INT64_T) && defined(HAVE___INT64)
typedef __int64 int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_INT == 8
typedef int int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_LONG == 8
typedef long int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_LONG_LONG == 8
typedef long long int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T)
#error No 64-bit integer type was found.
#endif

/*
 * Similarly for int32_t
 */
#if !defined(HAVE_INT32_T) && SIZE_OF_INT == 4
typedef long int32_t;
#define HAVE_INT32_T
#endif

#if !defined(HAVE_INT32_T) && SIZE_OF_LONG == 4
typedef long int32_t;
#define HAVE_INT32_T
#endif

#if !defined(HAVE_INT32_T)
#error No 32-bit integer type was found.
#endif

/*
 * Similarly for int16_t
 */
#if !defined(HAVE_INT16_T) && SIZE_OF_INT == 2
typedef int int16_t;
#define HAVE_INT16_T
#endif

#if !defined(HAVE_INT16_T) && SIZE_OF_SHORT == 2
typedef short int16_t;
#define HAVE_INT16_T
#endif

#if !defined(HAVE_INT16_T)
#error No 16-bit integer type was found.
#endif

/*
 * Similarly for uint64_t
 */
#if !defined(HAVE_UINT64_T) && defined(HAVE_UNSIGNED___INT64)
typedef unsigned __int64 uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED == 8
typedef unsigned uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED_LONG == 8
typedef unsigned long uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED_LONG_LONG == 8
typedef unsigned long long uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T)
#error No 64-bit unsigned integer type was found.
#endif


/*
 * Similarly for uint32_t
 */
#if !defined(HAVE_UINT32_T) && SIZE_OF_UNSIGNED == 4
typedef unsigned uint32_t;
#define HAVE_UINT32_T
#endif

#if !defined(HAVE_UINT32_T) && SIZE_OF_UNSIGNED_LONG == 4
typedef unsigned long uint32_t;
#define HAVE_UINT32_T
#endif

#if !defined(HAVE_UINT32_T)
#error No 32-bit unsigned integer type was found.
#endif

/*
 * Similarly for uint16_t
 */
#if !defined(HAVE_UINT16_T) && SIZE_OF_UNSIGNED == 2
typedef unsigned uint16_t;
#define HAVE_UINT16_T
#endif

#if !defined(HAVE_UINT16_T) && SIZE_OF_UNSIGNED_SHORT == 2
typedef unsigned short uint16_t;
#define HAVE_UINT16_T
#endif

#if !defined(HAVE_UINT16_T)
#error No 16-bit unsigned integer type was found.
#endif

/*
 * Similarly for uint8_t
 */
#if !defined(HAVE_UINT8_T)
typedef unsigned char uint8_t;
#define HAVE_UINT8_T
#endif

#if !defined(HAVE_UINT16_T)
#error No 8-bit unsigned integer type was found.
#endif

/* Define intmax_t and uintmax_t if they are not already defined. */
#if !defined(HAVE_INTMAX_T)
typedef int64_t intmax_t;
#define INTMAX_MIN INT64_MIN
#define INTMAX_MAX INT64_MAX
#endif

#if !defined(HAVE_UINTMAX_T)
typedef uint64_t uintmax_t;
#endif

/* Define ZLIB_WINAPI if zlib was built on Visual Studio. */
/* #undef ZLIB_WINAPI */

/* MD5 via ARCHIVE_CRYPTO_MD5_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_MD5_LIBC */

/* MD5 via ARCHIVE_CRYPTO_MD5_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_MD5_LIBSYSTEM */

/* MD5 via ARCHIVE_CRYPTO_MD5_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_MD5_NETTLE */

/* MD5 via ARCHIVE_CRYPTO_MD5_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_MD5_OPENSSL */

/* MD5 via ARCHIVE_CRYPTO_MD5_WIN supported. */
/* #undef ARCHIVE_CRYPTO_MD5_WIN */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_LIBC */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_NETTLE */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_OPENSSL */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_LIBC */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_LIBSYSTEM */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_NETTLE */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_OPENSSL */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_WIN */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC2 */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC3 */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBSYSTEM */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_NETTLE */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_OPENSSL */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_WIN */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC2 */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC3 */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBSYSTEM */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_NETTLE */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_OPENSSL */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_WIN */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC2 */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC3 */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBSYSTEM */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_NETTLE */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_OPENSSL */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_WIN */

/* Version number of bsdcpio */
#define BSDCPIO_VERSION_STRING "3.1.2"

/* Version number of bsdtar */
#define BSDTAR_VERSION_STRING "3.1.2"

/* Define to 1 if you have the `acl_create_entry' function. */
/* #undef HAVE_ACL_CREATE_ENTRY */

/* Define to 1 if you have the `acl_get_link' function. */
/* #undef HAVE_ACL_GET_LINK */

/* Define to 1 if you have the `acl_get_link_np' function. */
/* #undef HAVE_ACL_GET_LINK_NP */

/* Define to 1 if you have the `acl_get_perm' function. */
/* #undef HAVE_ACL_GET_PERM */

/* Define to 1 if you have the `acl_get_perm_np' function. */
/* #undef HAVE_ACL_GET_PERM_NP */

/* Define to 1 if you have the `acl_init' function. */
/* #undef HAVE_ACL_INIT */

/* Define to 1 if you have the <acl/libacl.h> header file. */
/* #undef HAVE_ACL_LIBACL_H */

/* Define to 1 if the system has the type `acl_permset_t'. */
/* #undef HAVE_ACL_PERMSET_T */

/* Define to 1 if you have the `acl_set_fd' function. */
/* #undef HAVE_ACL_SET_FD */

/* Define to 1 if you have the `acl_set_fd_np' function. */
/* #undef HAVE_ACL_SET_FD_NP */

/* Define to 1 if you have the `acl_set_file' function. */
/* #undef HAVE_ACL_SET_FILE */

/* True for systems with POSIX ACL support */
/* #undef HAVE_ACL_USER */

/* Define to 1 if you have the <attr/xattr.h> header file. */
/* #undef HAVE_ATTR_XATTR_H */

/* Define to 1 if you have the <bsdxml.h> header file. */
/* #undef HAVE_BSDXML_H */

/* Define to 1 if you have the <bzlib.h> header file. */
#define HAVE_BZLIB_H 1

/* Define to 1 if you have the `chflags' function. */
/* #undef HAVE_CHFLAGS */

/* Define to 1 if you have the `chown' function. */
#define HAVE_CHOWN 1

/* Define to 1 if you have the `chroot' function. */
#define HAVE_CHROOT 1

/* Define to 1 if you have the <copyfile.h> header file. */
/* #undef HAVE_COPYFILE_H */

/* Define to 1 if you have the `ctime_r' function. */
#define HAVE_CTIME_R 1

/* Define to 1 if you have the <ctype.h> header file. */
#define HAVE_CTYPE_H 1

/* Define to 1 if you have the `cygwin_conv_path' function. */
/* #undef HAVE_CYGWIN_CONV_PATH */

/* Define to 1 if you have the declaration of `INT64_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_INT64_MAX 1

/* Define to 1 if you have the declaration of `INT64_MIN', and to 0 if you
   don't. */
#define HAVE_DECL_INT64_MIN 1

/* Define to 1 if you have the declaration of `SIZE_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_SIZE_MAX 1

/* Define to 1 if you have the declaration of `SSIZE_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_SSIZE_MAX 1

/* Define to 1 if you have the declaration of `strerror_r', and to 0 if you
   don't. */
#define HAVE_DECL_STRERROR_R 1

/* Define to 1 if you have the declaration of `UINT32_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_UINT32_MAX 1

/* Define to 1 if you have the declaration of `UINT64_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_UINT64_MAX 1

/* Define to 1 if you have the <direct.h> header file. */
/* #undef HAVE_DIRECT_H */

/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.
   */
#define HAVE_DIRENT_H 1

/* Define to 1 if you have the `dirfd' function. */
#define HAVE_DIRFD 1

/* Define to 1 if you have the <dlfcn.h> header file. */
#define HAVE_DLFCN_H 1

/* Define to 1 if you don't have `vprintf' but do have `_doprnt.' */
/* #undef HAVE_DOPRNT */

/* Define to 1 if nl_langinfo supports D_MD_ORDER */
/* #undef HAVE_D_MD_ORDER */

/* A possible errno value for invalid file format errors */
/* #undef HAVE_EFTYPE */

/* A possible errno value for invalid file format errors */
#define HAVE_EILSEQ 1

/* Define to 1 if you have the <errno.h> header file. */
#define HAVE_ERRNO_H 1

/* Define to 1 if you have the <expat.h> header file. */
/* #undef HAVE_EXPAT_H */

/* Define to 1 if you have the <ext2fs/ext2_fs.h> header file. */
/* #undef HAVE_EXT2FS_EXT2_FS_H */

/* Define to 1 if you have the `extattr_get_file' function. */
/* #undef HAVE_EXTATTR_GET_FILE */

/* Define to 1 if you have the `extattr_list_file' function. */
/* #undef HAVE_EXTATTR_LIST_FILE */

/* Define to 1 if you have the `extattr_set_fd' function. */
/* #undef HAVE_EXTATTR_SET_FD */

/* Define to 1 if you have the `extattr_set_file' function. */
/* #undef HAVE_EXTATTR_SET_FILE */

/* Define to 1 if EXTATTR_NAMESPACE_USER is defined in sys/extattr.h. */
/* #undef HAVE_DECL_EXTATTR_NAMESPACE_USER */

/* Define to 1 if you have the `fchdir' function. */
#define HAVE_FCHDIR 1

/* Define to 1 if you have the `fchflags' function. */
/* #undef HAVE_FCHFLAGS */

/* Define to 1 if you have the `fchmod' function. */
#define HAVE_FCHMOD 1

/* Define to 1 if you have the `fchown' function. */
#define HAVE_FCHOWN 1

/* Define to 1 if you have the `fcntl' function. */
#define HAVE_FCNTL 1

/* Define to 1 if you have the <fcntl.h> header file. */
#define HAVE_FCNTL_H 1

/* Define to 1 if you have the `fdopendir' function. */
#define HAVE_FDOPENDIR 1

/* Define to 1 if you have the `fgetea' function. */
/* #undef HAVE_FGETEA */

/* Define to 1 if you have the `fgetxattr' function. */
/* #undef HAVE_FGETXATTR */

/* Define to 1 if you have the `flistea' function. */
/* #undef HAVE_FLISTEA */

/* Define to 1 if you have the `flistxattr' function. */
/* #undef HAVE_FLISTXATTR */

/* Define to 1 if you have the `fork' function. */
#define HAVE_FORK 1

/* Define to 1 if fseeko (and presumably ftello) exists and is declared. */
#define HAVE_FSEEKO 1

/* Define to 1 if you have the `fsetea' function. */
/* #undef HAVE_FSETEA */

/* Define to 1 if you have the `fsetxattr' function. */
/* #undef HAVE_FSETXATTR */

/* Define to 1 if you have the `fstat' function. */
#define HAVE_FSTAT 1

/* Define to 1 if you have the `fstatat' function. */
#define HAVE_FSTATAT 1

/* Define to 1 if you have the `fstatfs' function. */
#define HAVE_FSTATFS 1

/* Define to 1 if you have the `fstatvfs' function. */
#define HAVE_FSTATVFS 1

/* Define to 1 if you have the `ftruncate' function. */
#define HAVE_FTRUNCATE 1

/* Define to 1 if you have the `futimens' function. */
#define HAVE_FUTIMENS 1

/* Define to 1 if you have the `futimes' function. */
#define HAVE_FUTIMES 1

/* Define to 1 if you have the `futimesat' function. */
#define HAVE_FUTIMESAT 1

/* Define to 1 if you have the `getea' function. */
/* #undef HAVE_GETEA */

/* Define to 1 if you have the `geteuid' function. */
#define HAVE_GETEUID 1

/* Define to 1 if you have the `getgrgid_r' function. */
#define HAVE_GETGRGID_R 1

/* Define to 1 if you have the `getgrnam_r' function. */
#define HAVE_GETGRNAM_R 1

/* Define to 1 if you have the `getpid' function. */
#define HAVE_GETPID 1

/* Define to 1 if you have the `getpwnam_r' function. */
#define HAVE_GETPWNAM_R 1

/* Define to 1 if you have the `getpwuid_r' function. */
#define HAVE_GETPWUID_R 1

/* Define to 1 if you have the `getvfsbyname' function. */
/* #undef HAVE_GETVFSBYNAME */

/* Define to 1 if you have the `getxattr' function. */
/* #undef HAVE_GETXATTR */

/* Define to 1 if you have the `gmtime_r' function. */
#define HAVE_GMTIME_R 1

/* Define to 1 if you have the <grp.h> header file. */
#define HAVE_GRP_H 1

/* Define to 1 if you have the `iconv' function. */
/* #undef HAVE_ICONV */

/* Define to 1 if you have the <iconv.h> header file. */
/* #undef HAVE_ICONV_H */

/* Define to 1 if you have the <inttypes.h> header file. */
#define HAVE_INTTYPES_H 1

/* Define to 1 if you have the <io.h> header file. */
/* #undef HAVE_IO_H */

/* Define to 1 if you have the <langinfo.h> header file. */
#define HAVE_LANGINFO_H 1

/* Define to 1 if you have the `lchflags' function. */
/* #undef HAVE_LCHFLAGS */

/* Define to 1 if you have the `lchmod' function. */
/* #undef HAVE_LCHMOD */

/* Define to 1 if you have the `lchown' function. */
#define HAVE_LCHOWN 1

/* Define to 1 if you have the `lgetea' function. */
/* #undef HAVE_LGETEA */

/* Define to 1 if you have the `lgetxattr' function. */
/* #undef HAVE_LGETXATTR */

/* Define to 1 if you have the `acl' library (-lacl). */
/* #undef HAVE_LIBACL */

/* Define to 1 if you have the `attr' library (-lattr). */
/* #undef HAVE_LIBATTR */

/* Define to 1 if you have the `bsdxml' library (-lbsdxml). */
/* #undef HAVE_LIBBSDXML */

/* Define to 1 if you have the `bz2' library (-lbz2). */
#define HAVE_LIBBZ2 1

/* Define to 1 if you have the `expat' library (-lexpat). */
/* #undef HAVE_LIBEXPAT */

/* Define to 1 if you have the `gcc' library (-lgcc). */
/* #undef HAVE_LIBGCC */

/* Define to 1 if you have the `lzma' library (-llzma). */
/* #undef HAVE_LIBLZMA */

/* Define to 1 if you have the `lzmadec' library (-llzmadec). */
/* #undef HAVE_LIBLZMADEC */

/* Define to 1 if you have the `lzo2' library (-llzo2). */
/* #undef HAVE_LIBLZO2 */

/* Define to 1 if you have the `nettle' library (-lnettle). */
/* #undef HAVE_LIBNETTLE */

/* Define to 1 if you have the `pcre' library (-lpcre). */
/* #undef HAVE_LIBPCRE */

/* Define to 1 if you have the `pcreposix' library (-lpcreposix). */
/* #undef HAVE_LIBPCREPOSIX */

/* Define to 1 if you have the `xml2' library (-lxml2). */
/* #undef HAVE_LIBXML2 */

/* Define to 1 if you have the <libxml/xmlreader.h> header file. */
/* #undef HAVE_LIBXML_XMLREADER_H */

/* Define to 1 if you have the <libxml/xmlwriter.h> header file. */
/* #undef HAVE_LIBXML_XMLWRITER_H */

/* Define to 1 if you have the `z' library (-lz). */
#define HAVE_LIBZ 1

/* Define to 1 if you have the <limits.h> header file. */
#define HAVE_LIMITS_H 1

/* Define to 1 if you have the `link' function. */
#define HAVE_LINK 1

/* Define to 1 if you have the <linux/types.h> header file. */
#define HAVE_LINUX_TYPES_H 1

/* Define to 1 if you have the <linux/fiemap.h> header file. */
#define HAVE_LINUX_FIEMAP_H 1

/* Define to 1 if you have the <linux/fs.h> header file. */
#define HAVE_LINUX_FS_H 1

/* Define to 1 if you have the <linux/magic.h> header file. */
#define HAVE_LINUX_MAGIC_H 1

/* Define to 1 if you have the <linux/types.h> header file. */
#define HAVE_LINUX_TYPES_H 1

/* Define to 1 if you have the `listea' function. */
/* #undef HAVE_LISTEA */

/* Define to 1 if you have the `listxattr' function. */
/* #undef HAVE_LISTXATTR */

/* Define to 1 if you have the `llistea' function. */
/* #undef HAVE_LLISTEA */

/* Define to 1 if you have the `llistxattr' function. */
/* #undef HAVE_LLISTXATTR */

/* Define to 1 if you have the <localcharset.h> header file. */
/* #undef HAVE_LOCALCHARSET_H */

/* Define to 1 if you have the `locale_charset' function. */
/* #undef HAVE_LOCALE_CHARSET */

/* Define to 1 if you have the <locale.h> header file. */
#define HAVE_LOCALE_H 1

/* Define to 1 if you have the `localtime_r' function. */
#define HAVE_LOCALTIME_R 1

/* Define to 1 if the system has the type `long long int'. */
/* #undef HAVE_LONG_LONG_INT */

/* Define to 1 if you have the `lsetea' function. */
/* #undef HAVE_LSETEA */

/* Define to 1 if you have the `lsetxattr' function. */
/* #undef HAVE_LSETXATTR */

/* Define to 1 if you have the `lstat' function. */
#define HAVE_LSTAT 1

/* Define to 1 if `lstat' has the bug that it succeeds when given the
   zero-length file name argument. */
/* #undef HAVE_LSTAT_EMPTY_STRING_BUG */

/* Define to 1 if you have the `lutimes' function. */
#define HAVE_LUTIMES 1

/* Define to 1 if you have the <lzmadec.h> header file. */
/* #undef HAVE_LZMADEC_H */

/* Define to 1 if you have the <lzma.h> header file. */
/* #undef HAVE_LZMA_H */

/* Define to 1 if you have the <lzo/lzo1x.h> header file. */
/* #undef HAVE_LZO_LZO1X_H */

/* Define to 1 if you have the <lzo/lzoconf.h> header file. */
/* #undef HAVE_LZO_LZOCONF_H */

/* Define to 1 if you have the `mbrtowc' function. */
#define HAVE_MBRTOWC 1

/* Define to 1 if you have the `memmove' function. */
#define HAVE_MEMMOVE 1

/* Define to 1 if you have the <memory.h> header file. */
#define HAVE_MEMORY_H 1

/* Define to 1 if you have the `mkdir' function. */
#define HAVE_MKDIR 1

/* Define to 1 if you have the `mkfifo' function. */
#define HAVE_MKFIFO 1

/* Define to 1 if you have the `mknod' function. */
#define HAVE_MKNOD 1

/* Define to 1 if you have the `mkstemp' function. */
#define HAVE_MKSTEMP 1

/* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */
/* #undef HAVE_NDIR_H */

/* Define to 1 if you have the <nettle/md5.h> header file. */
/* #undef HAVE_NETTLE_MD5_H */

/* Define to 1 if you have the <nettle/ripemd160.h> header file. */
/* #undef HAVE_NETTLE_RIPEMD160_H */

/* Define to 1 if you have the <nettle/sha.h> header file. */
/* #undef HAVE_NETTLE_SHA_H */

/* Define to 1 if you have the `nl_langinfo' function. */
#define HAVE_NL_LANGINFO 1

/* Define to 1 if you have the `openat' function. */
#define HAVE_OPENAT 1

/* Define to 1 if you have the <paths.h> header file. */
#define HAVE_PATHS_H 1

/* Define to 1 if you have the <pcreposix.h> header file. */
/* #undef HAVE_PCREPOSIX_H */

/* Define to 1 if you have the `pipe' function. */
#define HAVE_PIPE 1

/* Define to 1 if you have the `poll' function. */
#define HAVE_POLL 1

/* Define to 1 if you have the <poll.h> header file. */
#define HAVE_POLL_H 1

/* Define to 1 if you have the `posix_spawnp' function. */
#define HAVE_POSIX_SPAWNP 1

/* Define to 1 if you have the <process.h> header file. */
/* #undef HAVE_PROCESS_H */

/* Define to 1 if you have the <pwd.h> header file. */
#define HAVE_PWD_H 1

/* Define to 1 if you have the `readdir_r' function. */
#define HAVE_READDIR_R 1

/* Define to 1 if you have the `readlink' function. */
#define HAVE_READLINK 1

/* Define to 1 if you have the `readlinkat' function. */
#define HAVE_READLINKAT 1

/* Define to 1 if you have the <regex.h> header file. */
#define HAVE_REGEX_H 1

/* Define to 1 if you have the `select' function. */
#define HAVE_SELECT 1

/* Define to 1 if you have the `setenv' function. */
#define HAVE_SETENV 1

/* Define to 1 if you have the `setlocale' function. */
#define HAVE_SETLOCALE 1

/* Define to 1 if you have the `sigaction' function. */
#define HAVE_SIGACTION 1

/* Define to 1 if you have the <signal.h> header file. */
#define HAVE_SIGNAL_H 1

/* Define to 1 if you have the <spawn.h> header file. */
#define HAVE_SPAWN_H 1

/* Define to 1 if you have the `statfs' function. */
#define HAVE_STATFS 1

/* Define to 1 if you have the `statvfs' function. */
#define HAVE_STATVFS 1

/* Define to 1 if `stat' has the bug that it succeeds when given the
   zero-length file name argument. */
/* #undef HAVE_STAT_EMPTY_STRING_BUG */

/* Define to 1 if you have the <stdarg.h> header file. */
#define HAVE_STDARG_H 1

/* Define to 1 if you have the <stdint.h> header file. */
#define HAVE_STDINT_H 1

/* Define to 1 if you have the <stdlib.h> header file. */
#define HAVE_STDLIB_H 1

/* Define to 1 if you have the `strchr' function. */
#define HAVE_STRCHR 1

/* Define to 1 if you have the `strdup' function. */
#define HAVE_STRDUP 1

/* Define to 1 if you have the `strerror' function. */
#define HAVE_STRERROR 1

/* Define to 1 if you have the `strerror_r' function. */
#define HAVE_STRERROR_R 1

/* Define to 1 if you have the `strftime' function. */
#define HAVE_STRFTIME 1

/* Define to 1 if you have the <strings.h> header file. */
#define HAVE_STRINGS_H 1

/* Define to 1 if you have the <string.h> header file. */
#define HAVE_STRING_H 1

/* Define to 1 if you have the `strrchr' function. */
#define HAVE_STRRCHR 1

/* Define to 1 if `f_namemax' is a member of `struct statfs'. */
/* #undef HAVE_STRUCT_STATFS_F_NAMEMAX */

/* Define to 1 if `f_iosize' is a member of `struct statvfs'. */
/* #undef HAVE_STRUCT_STATVFS_F_IOSIZE */

/* Define to 1 if `st_birthtime' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIME */

/* Define to 1 if `st_birthtimespec.tv_nsec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC_TV_NSEC */

/* Define to 1 if `st_blksize' is a member of `struct stat'. */
#define HAVE_STRUCT_STAT_ST_BLKSIZE 1

/* Define to 1 if `st_flags' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_FLAGS */

/* Define to 1 if `st_mtimespec.tv_nsec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC */

/* Define to 1 if `st_mtime_n' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIME_N */

/* Define to 1 if `st_mtime_usec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIME_USEC */

/* Define to 1 if `st_mtim.tv_nsec' is a member of `struct stat'. */
#define HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC 1

/* Define to 1 if `st_umtime' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_UMTIME */

/* Define to 1 if `tm_gmtoff' is a member of `struct tm'. */
#define HAVE_STRUCT_TM_TM_GMTOFF 1

/* Define to 1 if `__tm_gmtoff' is a member of `struct tm'. */
/* #undef HAVE_STRUCT_TM___TM_GMTOFF */

/* Define to 1 if you have the `symlink' function. */
#define HAVE_SYMLINK 1

/* Define to 1 if you have the <sys/acl.h> header file. */
/* #undef HAVE_SYS_ACL_H */

/* Define to 1 if you have the <sys/cdefs.h> header file. */
#define HAVE_SYS_CDEFS_H 1

/* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.
   */
/* #undef HAVE_SYS_DIR_H */

/* Define to 1 if you have the <sys/ea.h> header file. */
/* #undef HAVE_SYS_EA_H */

/* Define to 1 if you have the <sys/extattr.h> header file. */
/* #undef HAVE_SYS_EXTATTR_H */

/* Define to 1 if you have the <sys/ioctl.h> header file. */
#define HAVE_SYS_IOCTL_H 1

/* Define to 1 if you have the <sys/mkdev.h> header file. */
/* #undef HAVE_SYS_MKDEV_H */

/* Define to 1 if you have the <sys/mount.h> header file. */
/* #undef HAVE_SYS_MOUNT_H */

/* Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.
   */
/* #undef HAVE_SYS_NDIR_H */

/* Define to 1 if you have the <sys/param.h> header file. */
#define HAVE_SYS_PARAM_H 1

/* Define to 1 if you have the <sys/poll.h> header file. */
#define HAVE_SYS_POLL_H 1

/* Define to 1 if you have the <sys/select.h> header file. */
#define HAVE_SYS_SELECT_H 1

/* Define to 1 if you have the <sys/statfs.h> header file. */
#define HAVE_SYS_STATFS_H 1

/* Define to 1 if you have the <sys/statvfs.h> header file. */
#define HAVE_SYS_STATVFS_H 1

/* Define to 1 if you have the <sys/stat.h> header file. */
#define HAVE_SYS_STAT_H 1

/* Define to 1 if you have the <sys/time.h> header file. */
#define HAVE_SYS_TIME_H 1

/* Define to 1 if you have the <sys/types.h> header file. */
#define HAVE_SYS_TYPES_H 1

/* Define to 1 if you have the <sys/utime.h> header file. */
/* #undef HAVE_SYS_UTIME_H */

/* Define to 1 if you have the <sys/utsname.h> header file. */
#define HAVE_SYS_UTSNAME_H 1

/* Define to 1 if you have the <sys/vfs.h> header file. */
#define HAVE_SYS_VFS_H 1

/* Define to 1 if you have <sys/wait.h> that is POSIX.1 compatible. */
#define HAVE_SYS_WAIT_H 1

/* Define to 1 if you have the <sys/xattr.h> header file. */
/* #undef HAVE_SYS_XATTR_H */

/* Define to 1 if you have the `timegm' function. */
#define HAVE_TIMEGM 1

/* Define to 1 if you have the <time.h> header file. */
#define HAVE_TIME_H 1

/* Define to 1 if you have the `tzset' function. */
#define HAVE_TZSET 1

/* Define to 1 if you have the <unistd.h> header file. */
#define HAVE_UNISTD_H 1

/* Define to 1 if you have the `unsetenv' function. */
#define HAVE_UNSETENV 1

/* Define to 1 if the system has the type `unsigned long long'. */
/* #undef HAVE_UNSIGNED_LONG_LONG */

/* Define to 1 if the system has the type `unsigned long long int'. */
/* #undef HAVE_UNSIGNED_LONG_LONG_INT */

/* Define to 1 if you have the `utime' function. */
#define HAVE_UTIME 1

/* Define to 1 if you have the `utimensat' function. */
#define HAVE_UTIMENSAT 1

/* Define to 1 if you have the `utimes' function. */
#define HAVE_UTIMES 1

/* Define to 1 if you have the <utime.h> header file. */
#define HAVE_UTIME_H 1

/* Define to 1 if you have the `vfork' function. */
#define HAVE_VFORK 1

/* Define to 1 if you have the `vprintf' function. */
#define HAVE_VPRINTF 1

/* Define to 1 if you have the <wchar.h> header file. */
#define HAVE_WCHAR_H 1

/* Define to 1 if the system has the type `wchar_t'. */
#define HAVE_WCHAR_T 1

/* Define to 1 if you have the `wcrtomb' function. */
#define HAVE_WCRTOMB 1

/* Define to 1 if you have the `wcscmp' function. */
#define HAVE_WCSCMP 1

/* Define to 1 if you have the `wcscpy' function. */
#define HAVE_WCSCPY 1

/* Define to 1 if you have the `wcslen' function. */
#define HAVE_WCSLEN 1

/* Define to 1 if you have the `wctomb' function. */
#define HAVE_WCTOMB 1

/* Define to 1 if you have the <wctype.h> header file. */
#define HAVE_WCTYPE_H 1

/* Define to 1 if you have the <wincrypt.h> header file. */
/* #undef HAVE_WINCRYPT_H */

/* Define to 1 if you have the <windows.h> header file. */
/* #undef HAVE_WINDOWS_H */

/* Define to 1 if you have the <winioctl.h> header file. */
/* #undef HAVE_WINIOCTL_H */

/* Define to 1 if you have _CrtSetReportMode in <crtdbg.h>  */
/* #undef HAVE__CrtSetReportMode */

/* Define to 1 if you have the `wmemcmp' function. */
#define HAVE_WMEMCMP 1

/* Define to 1 if you have the `wmemcpy' function. */
#define HAVE_WMEMCPY 1

/* Define to 1 if you have a working EXT2_IOC_GETFLAGS */
/* #undef HAVE_WORKING_EXT2_IOC_GETFLAGS */

/* Define to 1 if you have the <zlib.h> header file. */
#define HAVE_ZLIB_H 1

/* Define to 1 if you have the `_ctime64_s' function. */
/* #undef HAVE__CTIME64_S */

/* Define to 1 if you have the `_fseeki64' function. */
/* #undef HAVE__FSEEKI64 */

/* Define to 1 if you have the `_get_timezone' function. */
/* #undef HAVE__GET_TIMEZONE */

/* Define to 1 if you have the `_localtime64_s' function. */
/* #undef HAVE__LOCALTIME64_S */

/* Define to 1 if you have the `_mkgmtime64' function. */
/* #undef HAVE__MKGMTIME64 */

/* Define as const if the declaration of iconv() needs const. */
#define ICONV_CONST 

/* Version number of libarchive as a single integer */
#define LIBARCHIVE_VERSION_NUMBER "3001002"

/* Version number of libarchive */
#define LIBARCHIVE_VERSION_STRING "3.1.2"

/* Define to 1 if `lstat' dereferences a symlink specified with a trailing
   slash. */
/* #undef LSTAT_FOLLOWS_SLASHED_SYMLINK */

/* Define to 1 if `major', `minor', and `makedev' are declared in <mkdev.h>.
   */
/* #undef MAJOR_IN_MKDEV */

/* Define to 1 if `major', `minor', and `makedev' are declared in
   <sysmacros.h>. */
#define MAJOR_IN_SYSMACROS 1

/* Define to 1 if your C compiler doesn't accept -c and -o together. */
/* #undef NO_MINUS_C_MINUS_O */

/* The size of `wchar_t', as computed by sizeof. */
#define SIZEOF_WCHAR_T 4

/* Define to 1 if strerror_r returns char *. */
/* #undef STRERROR_R_CHAR_P */

/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
#define TIME_WITH_SYS_TIME 1

/*
 * Some platform requires a macro to use extension functions.
 */
#define SAFE_TO_DEFINE_EXTENSIONS 1
#ifdef SAFE_TO_DEFINE_EXTENSIONS
/* Enable extensions on AIX 3, Interix.  */
#ifndef _ALL_SOURCE
# define _ALL_SOURCE 1
#endif
/* Enable GNU extensions on systems that have them.  */
#ifndef _GNU_SOURCE
# define _GNU_SOURCE 1
#endif
/* Enable threading extensions on Solaris.  */
#ifndef _POSIX_PTHREAD_SEMANTICS
# define _POSIX_PTHREAD_SEMANTICS 1
#endif
/* Enable extensions on HP NonStop.  */
#ifndef _TANDEM_SOURCE
# define _TANDEM_SOURCE 1
#endif
/* Enable general extensions on Solaris.  */
#ifndef __EXTENSIONS__
# define __EXTENSIONS__ 1
#endif
#endif /* SAFE_TO_DEFINE_EXTENSIONS */

/* Version number of package */
#define VERSION "3.1.2"

/* Number of bits in a file offset, on hosts where this is settable. */
/* #undef _FILE_OFFSET_BITS */

/* Define to 1 to make fseeko visible on some hosts (e.g. glibc 2.2). */
/* #undef _LARGEFILE_SOURCE */

/* Define for large files, on AIX-style hosts. */
/* #undef _LARGE_FILES */

/* Define for Windows to use Windows 2000+ APIs. */
/* #undef _WIN32_WINNT */
/* #undef WINVER */

/* Define to empty if `const' does not conform to ANSI C. */
/* #undef const */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef gid_t */

/* Define to `unsigned long' if <sys/types.h> does not define. */
/* #undef id_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef mode_t */

/* Define to `long long' if <sys/types.h> does not define. */
/* #undef off_t */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef pid_t */

/* Define to `unsigned int' if <sys/types.h> does not define. */
/* #undef size_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef ssize_t */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef uid_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef intptr_t */

/* Define to `unsigned int' if <sys/types.h> does not define. */
/* #undef uintptr_t */


#define ARCHIVE_MD5_COMPILE_TEST
#define ARCHIVE_CRYPTO_MD5_LIBMD
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = (DWORD)bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. Nettle
 * 6. OpenSSL
 * 7. libmd
 * 8. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive_md5_ctx ctx;
  archive_md5_init(&ctx);
  archive_md5_update(&ctx, *argv, argc);
  archive_md5_final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_RMD160_LIBMD failed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec737006722/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec737006722.dir/build.make CMakeFiles/cmTryCompileExec737006722.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec737006722.dir/check_crypto_md.c.o
/usr/bin/gcc   -w  -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2 -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmlibarchive/libarchive -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec737006722.dir/check_crypto_md.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1186:0:
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:94:20: fatal error: ripemd.h: No such file or directory
 #include <ripemd.h>
                    ^
compilation terminated.
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec737006722.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec737006722/fast] Error 2

Source file was:
/* config.h.  Generated from build/cmake/config.h.in by cmake configure */
#if defined(__osf__)
# define _OSF_SOURCE
#endif

/*
 * Ensure we have C99-style int64_t, etc, all defined.
 */

/* First, we need to know if the system has already defined them. */
#define HAVE_INT16_T
#define HAVE_INT32_T
#define HAVE_INT64_T
#define HAVE_INTMAX_T

#define HAVE_UINT8_T
#define HAVE_UINT16_T
#define HAVE_UINT32_T
#define HAVE_UINT64_T
#define HAVE_UINTMAX_T

/* We might have the types we want under other spellings. */
/* #undef HAVE___INT64 */
/* #undef HAVE_U_INT64_T */
/* #undef HAVE_UNSIGNED___INT64 */

/* The sizes of various standard integer types. */
#define SIZE_OF_SHORT 2
#define SIZE_OF_INT 4
#define SIZE_OF_LONG 8
#define SIZE_OF_LONG_LONG 8
#define SIZE_OF_UNSIGNED_SHORT 2
#define SIZE_OF_UNSIGNED 4
#define SIZE_OF_UNSIGNED_LONG 8
#define SIZE_OF_UNSIGNED_LONG_LONG 8

/*
 * If we lack int64_t, define it to the first of __int64, int, long, and long long
 * that exists and is the right size.
 */
#if !defined(HAVE_INT64_T) && defined(HAVE___INT64)
typedef __int64 int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_INT == 8
typedef int int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_LONG == 8
typedef long int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_LONG_LONG == 8
typedef long long int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T)
#error No 64-bit integer type was found.
#endif

/*
 * Similarly for int32_t
 */
#if !defined(HAVE_INT32_T) && SIZE_OF_INT == 4
typedef long int32_t;
#define HAVE_INT32_T
#endif

#if !defined(HAVE_INT32_T) && SIZE_OF_LONG == 4
typedef long int32_t;
#define HAVE_INT32_T
#endif

#if !defined(HAVE_INT32_T)
#error No 32-bit integer type was found.
#endif

/*
 * Similarly for int16_t
 */
#if !defined(HAVE_INT16_T) && SIZE_OF_INT == 2
typedef int int16_t;
#define HAVE_INT16_T
#endif

#if !defined(HAVE_INT16_T) && SIZE_OF_SHORT == 2
typedef short int16_t;
#define HAVE_INT16_T
#endif

#if !defined(HAVE_INT16_T)
#error No 16-bit integer type was found.
#endif

/*
 * Similarly for uint64_t
 */
#if !defined(HAVE_UINT64_T) && defined(HAVE_UNSIGNED___INT64)
typedef unsigned __int64 uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED == 8
typedef unsigned uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED_LONG == 8
typedef unsigned long uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED_LONG_LONG == 8
typedef unsigned long long uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T)
#error No 64-bit unsigned integer type was found.
#endif


/*
 * Similarly for uint32_t
 */
#if !defined(HAVE_UINT32_T) && SIZE_OF_UNSIGNED == 4
typedef unsigned uint32_t;
#define HAVE_UINT32_T
#endif

#if !defined(HAVE_UINT32_T) && SIZE_OF_UNSIGNED_LONG == 4
typedef unsigned long uint32_t;
#define HAVE_UINT32_T
#endif

#if !defined(HAVE_UINT32_T)
#error No 32-bit unsigned integer type was found.
#endif

/*
 * Similarly for uint16_t
 */
#if !defined(HAVE_UINT16_T) && SIZE_OF_UNSIGNED == 2
typedef unsigned uint16_t;
#define HAVE_UINT16_T
#endif

#if !defined(HAVE_UINT16_T) && SIZE_OF_UNSIGNED_SHORT == 2
typedef unsigned short uint16_t;
#define HAVE_UINT16_T
#endif

#if !defined(HAVE_UINT16_T)
#error No 16-bit unsigned integer type was found.
#endif

/*
 * Similarly for uint8_t
 */
#if !defined(HAVE_UINT8_T)
typedef unsigned char uint8_t;
#define HAVE_UINT8_T
#endif

#if !defined(HAVE_UINT16_T)
#error No 8-bit unsigned integer type was found.
#endif

/* Define intmax_t and uintmax_t if they are not already defined. */
#if !defined(HAVE_INTMAX_T)
typedef int64_t intmax_t;
#define INTMAX_MIN INT64_MIN
#define INTMAX_MAX INT64_MAX
#endif

#if !defined(HAVE_UINTMAX_T)
typedef uint64_t uintmax_t;
#endif

/* Define ZLIB_WINAPI if zlib was built on Visual Studio. */
/* #undef ZLIB_WINAPI */

/* MD5 via ARCHIVE_CRYPTO_MD5_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_MD5_LIBC */

/* MD5 via ARCHIVE_CRYPTO_MD5_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_MD5_LIBSYSTEM */

/* MD5 via ARCHIVE_CRYPTO_MD5_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_MD5_NETTLE */

/* MD5 via ARCHIVE_CRYPTO_MD5_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_MD5_OPENSSL */

/* MD5 via ARCHIVE_CRYPTO_MD5_WIN supported. */
/* #undef ARCHIVE_CRYPTO_MD5_WIN */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_LIBC */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_NETTLE */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_OPENSSL */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_LIBC */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_LIBSYSTEM */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_NETTLE */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_OPENSSL */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_WIN */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC2 */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC3 */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBSYSTEM */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_NETTLE */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_OPENSSL */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_WIN */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC2 */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC3 */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBSYSTEM */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_NETTLE */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_OPENSSL */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_WIN */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC2 */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC3 */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBSYSTEM */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_NETTLE */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_OPENSSL */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_WIN */

/* Version number of bsdcpio */
#define BSDCPIO_VERSION_STRING "3.1.2"

/* Version number of bsdtar */
#define BSDTAR_VERSION_STRING "3.1.2"

/* Define to 1 if you have the `acl_create_entry' function. */
/* #undef HAVE_ACL_CREATE_ENTRY */

/* Define to 1 if you have the `acl_get_link' function. */
/* #undef HAVE_ACL_GET_LINK */

/* Define to 1 if you have the `acl_get_link_np' function. */
/* #undef HAVE_ACL_GET_LINK_NP */

/* Define to 1 if you have the `acl_get_perm' function. */
/* #undef HAVE_ACL_GET_PERM */

/* Define to 1 if you have the `acl_get_perm_np' function. */
/* #undef HAVE_ACL_GET_PERM_NP */

/* Define to 1 if you have the `acl_init' function. */
/* #undef HAVE_ACL_INIT */

/* Define to 1 if you have the <acl/libacl.h> header file. */
/* #undef HAVE_ACL_LIBACL_H */

/* Define to 1 if the system has the type `acl_permset_t'. */
/* #undef HAVE_ACL_PERMSET_T */

/* Define to 1 if you have the `acl_set_fd' function. */
/* #undef HAVE_ACL_SET_FD */

/* Define to 1 if you have the `acl_set_fd_np' function. */
/* #undef HAVE_ACL_SET_FD_NP */

/* Define to 1 if you have the `acl_set_file' function. */
/* #undef HAVE_ACL_SET_FILE */

/* True for systems with POSIX ACL support */
/* #undef HAVE_ACL_USER */

/* Define to 1 if you have the <attr/xattr.h> header file. */
/* #undef HAVE_ATTR_XATTR_H */

/* Define to 1 if you have the <bsdxml.h> header file. */
/* #undef HAVE_BSDXML_H */

/* Define to 1 if you have the <bzlib.h> header file. */
#define HAVE_BZLIB_H 1

/* Define to 1 if you have the `chflags' function. */
/* #undef HAVE_CHFLAGS */

/* Define to 1 if you have the `chown' function. */
#define HAVE_CHOWN 1

/* Define to 1 if you have the `chroot' function. */
#define HAVE_CHROOT 1

/* Define to 1 if you have the <copyfile.h> header file. */
/* #undef HAVE_COPYFILE_H */

/* Define to 1 if you have the `ctime_r' function. */
#define HAVE_CTIME_R 1

/* Define to 1 if you have the <ctype.h> header file. */
#define HAVE_CTYPE_H 1

/* Define to 1 if you have the `cygwin_conv_path' function. */
/* #undef HAVE_CYGWIN_CONV_PATH */

/* Define to 1 if you have the declaration of `INT64_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_INT64_MAX 1

/* Define to 1 if you have the declaration of `INT64_MIN', and to 0 if you
   don't. */
#define HAVE_DECL_INT64_MIN 1

/* Define to 1 if you have the declaration of `SIZE_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_SIZE_MAX 1

/* Define to 1 if you have the declaration of `SSIZE_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_SSIZE_MAX 1

/* Define to 1 if you have the declaration of `strerror_r', and to 0 if you
   don't. */
#define HAVE_DECL_STRERROR_R 1

/* Define to 1 if you have the declaration of `UINT32_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_UINT32_MAX 1

/* Define to 1 if you have the declaration of `UINT64_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_UINT64_MAX 1

/* Define to 1 if you have the <direct.h> header file. */
/* #undef HAVE_DIRECT_H */

/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.
   */
#define HAVE_DIRENT_H 1

/* Define to 1 if you have the `dirfd' function. */
#define HAVE_DIRFD 1

/* Define to 1 if you have the <dlfcn.h> header file. */
#define HAVE_DLFCN_H 1

/* Define to 1 if you don't have `vprintf' but do have `_doprnt.' */
/* #undef HAVE_DOPRNT */

/* Define to 1 if nl_langinfo supports D_MD_ORDER */
/* #undef HAVE_D_MD_ORDER */

/* A possible errno value for invalid file format errors */
/* #undef HAVE_EFTYPE */

/* A possible errno value for invalid file format errors */
#define HAVE_EILSEQ 1

/* Define to 1 if you have the <errno.h> header file. */
#define HAVE_ERRNO_H 1

/* Define to 1 if you have the <expat.h> header file. */
/* #undef HAVE_EXPAT_H */

/* Define to 1 if you have the <ext2fs/ext2_fs.h> header file. */
/* #undef HAVE_EXT2FS_EXT2_FS_H */

/* Define to 1 if you have the `extattr_get_file' function. */
/* #undef HAVE_EXTATTR_GET_FILE */

/* Define to 1 if you have the `extattr_list_file' function. */
/* #undef HAVE_EXTATTR_LIST_FILE */

/* Define to 1 if you have the `extattr_set_fd' function. */
/* #undef HAVE_EXTATTR_SET_FD */

/* Define to 1 if you have the `extattr_set_file' function. */
/* #undef HAVE_EXTATTR_SET_FILE */

/* Define to 1 if EXTATTR_NAMESPACE_USER is defined in sys/extattr.h. */
/* #undef HAVE_DECL_EXTATTR_NAMESPACE_USER */

/* Define to 1 if you have the `fchdir' function. */
#define HAVE_FCHDIR 1

/* Define to 1 if you have the `fchflags' function. */
/* #undef HAVE_FCHFLAGS */

/* Define to 1 if you have the `fchmod' function. */
#define HAVE_FCHMOD 1

/* Define to 1 if you have the `fchown' function. */
#define HAVE_FCHOWN 1

/* Define to 1 if you have the `fcntl' function. */
#define HAVE_FCNTL 1

/* Define to 1 if you have the <fcntl.h> header file. */
#define HAVE_FCNTL_H 1

/* Define to 1 if you have the `fdopendir' function. */
#define HAVE_FDOPENDIR 1

/* Define to 1 if you have the `fgetea' function. */
/* #undef HAVE_FGETEA */

/* Define to 1 if you have the `fgetxattr' function. */
/* #undef HAVE_FGETXATTR */

/* Define to 1 if you have the `flistea' function. */
/* #undef HAVE_FLISTEA */

/* Define to 1 if you have the `flistxattr' function. */
/* #undef HAVE_FLISTXATTR */

/* Define to 1 if you have the `fork' function. */
#define HAVE_FORK 1

/* Define to 1 if fseeko (and presumably ftello) exists and is declared. */
#define HAVE_FSEEKO 1

/* Define to 1 if you have the `fsetea' function. */
/* #undef HAVE_FSETEA */

/* Define to 1 if you have the `fsetxattr' function. */
/* #undef HAVE_FSETXATTR */

/* Define to 1 if you have the `fstat' function. */
#define HAVE_FSTAT 1

/* Define to 1 if you have the `fstatat' function. */
#define HAVE_FSTATAT 1

/* Define to 1 if you have the `fstatfs' function. */
#define HAVE_FSTATFS 1

/* Define to 1 if you have the `fstatvfs' function. */
#define HAVE_FSTATVFS 1

/* Define to 1 if you have the `ftruncate' function. */
#define HAVE_FTRUNCATE 1

/* Define to 1 if you have the `futimens' function. */
#define HAVE_FUTIMENS 1

/* Define to 1 if you have the `futimes' function. */
#define HAVE_FUTIMES 1

/* Define to 1 if you have the `futimesat' function. */
#define HAVE_FUTIMESAT 1

/* Define to 1 if you have the `getea' function. */
/* #undef HAVE_GETEA */

/* Define to 1 if you have the `geteuid' function. */
#define HAVE_GETEUID 1

/* Define to 1 if you have the `getgrgid_r' function. */
#define HAVE_GETGRGID_R 1

/* Define to 1 if you have the `getgrnam_r' function. */
#define HAVE_GETGRNAM_R 1

/* Define to 1 if you have the `getpid' function. */
#define HAVE_GETPID 1

/* Define to 1 if you have the `getpwnam_r' function. */
#define HAVE_GETPWNAM_R 1

/* Define to 1 if you have the `getpwuid_r' function. */
#define HAVE_GETPWUID_R 1

/* Define to 1 if you have the `getvfsbyname' function. */
/* #undef HAVE_GETVFSBYNAME */

/* Define to 1 if you have the `getxattr' function. */
/* #undef HAVE_GETXATTR */

/* Define to 1 if you have the `gmtime_r' function. */
#define HAVE_GMTIME_R 1

/* Define to 1 if you have the <grp.h> header file. */
#define HAVE_GRP_H 1

/* Define to 1 if you have the `iconv' function. */
/* #undef HAVE_ICONV */

/* Define to 1 if you have the <iconv.h> header file. */
/* #undef HAVE_ICONV_H */

/* Define to 1 if you have the <inttypes.h> header file. */
#define HAVE_INTTYPES_H 1

/* Define to 1 if you have the <io.h> header file. */
/* #undef HAVE_IO_H */

/* Define to 1 if you have the <langinfo.h> header file. */
#define HAVE_LANGINFO_H 1

/* Define to 1 if you have the `lchflags' function. */
/* #undef HAVE_LCHFLAGS */

/* Define to 1 if you have the `lchmod' function. */
/* #undef HAVE_LCHMOD */

/* Define to 1 if you have the `lchown' function. */
#define HAVE_LCHOWN 1

/* Define to 1 if you have the `lgetea' function. */
/* #undef HAVE_LGETEA */

/* Define to 1 if you have the `lgetxattr' function. */
/* #undef HAVE_LGETXATTR */

/* Define to 1 if you have the `acl' library (-lacl). */
/* #undef HAVE_LIBACL */

/* Define to 1 if you have the `attr' library (-lattr). */
/* #undef HAVE_LIBATTR */

/* Define to 1 if you have the `bsdxml' library (-lbsdxml). */
/* #undef HAVE_LIBBSDXML */

/* Define to 1 if you have the `bz2' library (-lbz2). */
#define HAVE_LIBBZ2 1

/* Define to 1 if you have the `expat' library (-lexpat). */
/* #undef HAVE_LIBEXPAT */

/* Define to 1 if you have the `gcc' library (-lgcc). */
/* #undef HAVE_LIBGCC */

/* Define to 1 if you have the `lzma' library (-llzma). */
/* #undef HAVE_LIBLZMA */

/* Define to 1 if you have the `lzmadec' library (-llzmadec). */
/* #undef HAVE_LIBLZMADEC */

/* Define to 1 if you have the `lzo2' library (-llzo2). */
/* #undef HAVE_LIBLZO2 */

/* Define to 1 if you have the `nettle' library (-lnettle). */
/* #undef HAVE_LIBNETTLE */

/* Define to 1 if you have the `pcre' library (-lpcre). */
/* #undef HAVE_LIBPCRE */

/* Define to 1 if you have the `pcreposix' library (-lpcreposix). */
/* #undef HAVE_LIBPCREPOSIX */

/* Define to 1 if you have the `xml2' library (-lxml2). */
/* #undef HAVE_LIBXML2 */

/* Define to 1 if you have the <libxml/xmlreader.h> header file. */
/* #undef HAVE_LIBXML_XMLREADER_H */

/* Define to 1 if you have the <libxml/xmlwriter.h> header file. */
/* #undef HAVE_LIBXML_XMLWRITER_H */

/* Define to 1 if you have the `z' library (-lz). */
#define HAVE_LIBZ 1

/* Define to 1 if you have the <limits.h> header file. */
#define HAVE_LIMITS_H 1

/* Define to 1 if you have the `link' function. */
#define HAVE_LINK 1

/* Define to 1 if you have the <linux/types.h> header file. */
#define HAVE_LINUX_TYPES_H 1

/* Define to 1 if you have the <linux/fiemap.h> header file. */
#define HAVE_LINUX_FIEMAP_H 1

/* Define to 1 if you have the <linux/fs.h> header file. */
#define HAVE_LINUX_FS_H 1

/* Define to 1 if you have the <linux/magic.h> header file. */
#define HAVE_LINUX_MAGIC_H 1

/* Define to 1 if you have the <linux/types.h> header file. */
#define HAVE_LINUX_TYPES_H 1

/* Define to 1 if you have the `listea' function. */
/* #undef HAVE_LISTEA */

/* Define to 1 if you have the `listxattr' function. */
/* #undef HAVE_LISTXATTR */

/* Define to 1 if you have the `llistea' function. */
/* #undef HAVE_LLISTEA */

/* Define to 1 if you have the `llistxattr' function. */
/* #undef HAVE_LLISTXATTR */

/* Define to 1 if you have the <localcharset.h> header file. */
/* #undef HAVE_LOCALCHARSET_H */

/* Define to 1 if you have the `locale_charset' function. */
/* #undef HAVE_LOCALE_CHARSET */

/* Define to 1 if you have the <locale.h> header file. */
#define HAVE_LOCALE_H 1

/* Define to 1 if you have the `localtime_r' function. */
#define HAVE_LOCALTIME_R 1

/* Define to 1 if the system has the type `long long int'. */
/* #undef HAVE_LONG_LONG_INT */

/* Define to 1 if you have the `lsetea' function. */
/* #undef HAVE_LSETEA */

/* Define to 1 if you have the `lsetxattr' function. */
/* #undef HAVE_LSETXATTR */

/* Define to 1 if you have the `lstat' function. */
#define HAVE_LSTAT 1

/* Define to 1 if `lstat' has the bug that it succeeds when given the
   zero-length file name argument. */
/* #undef HAVE_LSTAT_EMPTY_STRING_BUG */

/* Define to 1 if you have the `lutimes' function. */
#define HAVE_LUTIMES 1

/* Define to 1 if you have the <lzmadec.h> header file. */
/* #undef HAVE_LZMADEC_H */

/* Define to 1 if you have the <lzma.h> header file. */
/* #undef HAVE_LZMA_H */

/* Define to 1 if you have the <lzo/lzo1x.h> header file. */
/* #undef HAVE_LZO_LZO1X_H */

/* Define to 1 if you have the <lzo/lzoconf.h> header file. */
/* #undef HAVE_LZO_LZOCONF_H */

/* Define to 1 if you have the `mbrtowc' function. */
#define HAVE_MBRTOWC 1

/* Define to 1 if you have the `memmove' function. */
#define HAVE_MEMMOVE 1

/* Define to 1 if you have the <memory.h> header file. */
#define HAVE_MEMORY_H 1

/* Define to 1 if you have the `mkdir' function. */
#define HAVE_MKDIR 1

/* Define to 1 if you have the `mkfifo' function. */
#define HAVE_MKFIFO 1

/* Define to 1 if you have the `mknod' function. */
#define HAVE_MKNOD 1

/* Define to 1 if you have the `mkstemp' function. */
#define HAVE_MKSTEMP 1

/* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */
/* #undef HAVE_NDIR_H */

/* Define to 1 if you have the <nettle/md5.h> header file. */
/* #undef HAVE_NETTLE_MD5_H */

/* Define to 1 if you have the <nettle/ripemd160.h> header file. */
/* #undef HAVE_NETTLE_RIPEMD160_H */

/* Define to 1 if you have the <nettle/sha.h> header file. */
/* #undef HAVE_NETTLE_SHA_H */

/* Define to 1 if you have the `nl_langinfo' function. */
#define HAVE_NL_LANGINFO 1

/* Define to 1 if you have the `openat' function. */
#define HAVE_OPENAT 1

/* Define to 1 if you have the <paths.h> header file. */
#define HAVE_PATHS_H 1

/* Define to 1 if you have the <pcreposix.h> header file. */
/* #undef HAVE_PCREPOSIX_H */

/* Define to 1 if you have the `pipe' function. */
#define HAVE_PIPE 1

/* Define to 1 if you have the `poll' function. */
#define HAVE_POLL 1

/* Define to 1 if you have the <poll.h> header file. */
#define HAVE_POLL_H 1

/* Define to 1 if you have the `posix_spawnp' function. */
#define HAVE_POSIX_SPAWNP 1

/* Define to 1 if you have the <process.h> header file. */
/* #undef HAVE_PROCESS_H */

/* Define to 1 if you have the <pwd.h> header file. */
#define HAVE_PWD_H 1

/* Define to 1 if you have the `readdir_r' function. */
#define HAVE_READDIR_R 1

/* Define to 1 if you have the `readlink' function. */
#define HAVE_READLINK 1

/* Define to 1 if you have the `readlinkat' function. */
#define HAVE_READLINKAT 1

/* Define to 1 if you have the <regex.h> header file. */
#define HAVE_REGEX_H 1

/* Define to 1 if you have the `select' function. */
#define HAVE_SELECT 1

/* Define to 1 if you have the `setenv' function. */
#define HAVE_SETENV 1

/* Define to 1 if you have the `setlocale' function. */
#define HAVE_SETLOCALE 1

/* Define to 1 if you have the `sigaction' function. */
#define HAVE_SIGACTION 1

/* Define to 1 if you have the <signal.h> header file. */
#define HAVE_SIGNAL_H 1

/* Define to 1 if you have the <spawn.h> header file. */
#define HAVE_SPAWN_H 1

/* Define to 1 if you have the `statfs' function. */
#define HAVE_STATFS 1

/* Define to 1 if you have the `statvfs' function. */
#define HAVE_STATVFS 1

/* Define to 1 if `stat' has the bug that it succeeds when given the
   zero-length file name argument. */
/* #undef HAVE_STAT_EMPTY_STRING_BUG */

/* Define to 1 if you have the <stdarg.h> header file. */
#define HAVE_STDARG_H 1

/* Define to 1 if you have the <stdint.h> header file. */
#define HAVE_STDINT_H 1

/* Define to 1 if you have the <stdlib.h> header file. */
#define HAVE_STDLIB_H 1

/* Define to 1 if you have the `strchr' function. */
#define HAVE_STRCHR 1

/* Define to 1 if you have the `strdup' function. */
#define HAVE_STRDUP 1

/* Define to 1 if you have the `strerror' function. */
#define HAVE_STRERROR 1

/* Define to 1 if you have the `strerror_r' function. */
#define HAVE_STRERROR_R 1

/* Define to 1 if you have the `strftime' function. */
#define HAVE_STRFTIME 1

/* Define to 1 if you have the <strings.h> header file. */
#define HAVE_STRINGS_H 1

/* Define to 1 if you have the <string.h> header file. */
#define HAVE_STRING_H 1

/* Define to 1 if you have the `strrchr' function. */
#define HAVE_STRRCHR 1

/* Define to 1 if `f_namemax' is a member of `struct statfs'. */
/* #undef HAVE_STRUCT_STATFS_F_NAMEMAX */

/* Define to 1 if `f_iosize' is a member of `struct statvfs'. */
/* #undef HAVE_STRUCT_STATVFS_F_IOSIZE */

/* Define to 1 if `st_birthtime' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIME */

/* Define to 1 if `st_birthtimespec.tv_nsec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC_TV_NSEC */

/* Define to 1 if `st_blksize' is a member of `struct stat'. */
#define HAVE_STRUCT_STAT_ST_BLKSIZE 1

/* Define to 1 if `st_flags' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_FLAGS */

/* Define to 1 if `st_mtimespec.tv_nsec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC */

/* Define to 1 if `st_mtime_n' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIME_N */

/* Define to 1 if `st_mtime_usec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIME_USEC */

/* Define to 1 if `st_mtim.tv_nsec' is a member of `struct stat'. */
#define HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC 1

/* Define to 1 if `st_umtime' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_UMTIME */

/* Define to 1 if `tm_gmtoff' is a member of `struct tm'. */
#define HAVE_STRUCT_TM_TM_GMTOFF 1

/* Define to 1 if `__tm_gmtoff' is a member of `struct tm'. */
/* #undef HAVE_STRUCT_TM___TM_GMTOFF */

/* Define to 1 if you have the `symlink' function. */
#define HAVE_SYMLINK 1

/* Define to 1 if you have the <sys/acl.h> header file. */
/* #undef HAVE_SYS_ACL_H */

/* Define to 1 if you have the <sys/cdefs.h> header file. */
#define HAVE_SYS_CDEFS_H 1

/* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.
   */
/* #undef HAVE_SYS_DIR_H */

/* Define to 1 if you have the <sys/ea.h> header file. */
/* #undef HAVE_SYS_EA_H */

/* Define to 1 if you have the <sys/extattr.h> header file. */
/* #undef HAVE_SYS_EXTATTR_H */

/* Define to 1 if you have the <sys/ioctl.h> header file. */
#define HAVE_SYS_IOCTL_H 1

/* Define to 1 if you have the <sys/mkdev.h> header file. */
/* #undef HAVE_SYS_MKDEV_H */

/* Define to 1 if you have the <sys/mount.h> header file. */
/* #undef HAVE_SYS_MOUNT_H */

/* Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.
   */
/* #undef HAVE_SYS_NDIR_H */

/* Define to 1 if you have the <sys/param.h> header file. */
#define HAVE_SYS_PARAM_H 1

/* Define to 1 if you have the <sys/poll.h> header file. */
#define HAVE_SYS_POLL_H 1

/* Define to 1 if you have the <sys/select.h> header file. */
#define HAVE_SYS_SELECT_H 1

/* Define to 1 if you have the <sys/statfs.h> header file. */
#define HAVE_SYS_STATFS_H 1

/* Define to 1 if you have the <sys/statvfs.h> header file. */
#define HAVE_SYS_STATVFS_H 1

/* Define to 1 if you have the <sys/stat.h> header file. */
#define HAVE_SYS_STAT_H 1

/* Define to 1 if you have the <sys/time.h> header file. */
#define HAVE_SYS_TIME_H 1

/* Define to 1 if you have the <sys/types.h> header file. */
#define HAVE_SYS_TYPES_H 1

/* Define to 1 if you have the <sys/utime.h> header file. */
/* #undef HAVE_SYS_UTIME_H */

/* Define to 1 if you have the <sys/utsname.h> header file. */
#define HAVE_SYS_UTSNAME_H 1

/* Define to 1 if you have the <sys/vfs.h> header file. */
#define HAVE_SYS_VFS_H 1

/* Define to 1 if you have <sys/wait.h> that is POSIX.1 compatible. */
#define HAVE_SYS_WAIT_H 1

/* Define to 1 if you have the <sys/xattr.h> header file. */
/* #undef HAVE_SYS_XATTR_H */

/* Define to 1 if you have the `timegm' function. */
#define HAVE_TIMEGM 1

/* Define to 1 if you have the <time.h> header file. */
#define HAVE_TIME_H 1

/* Define to 1 if you have the `tzset' function. */
#define HAVE_TZSET 1

/* Define to 1 if you have the <unistd.h> header file. */
#define HAVE_UNISTD_H 1

/* Define to 1 if you have the `unsetenv' function. */
#define HAVE_UNSETENV 1

/* Define to 1 if the system has the type `unsigned long long'. */
/* #undef HAVE_UNSIGNED_LONG_LONG */

/* Define to 1 if the system has the type `unsigned long long int'. */
/* #undef HAVE_UNSIGNED_LONG_LONG_INT */

/* Define to 1 if you have the `utime' function. */
#define HAVE_UTIME 1

/* Define to 1 if you have the `utimensat' function. */
#define HAVE_UTIMENSAT 1

/* Define to 1 if you have the `utimes' function. */
#define HAVE_UTIMES 1

/* Define to 1 if you have the <utime.h> header file. */
#define HAVE_UTIME_H 1

/* Define to 1 if you have the `vfork' function. */
#define HAVE_VFORK 1

/* Define to 1 if you have the `vprintf' function. */
#define HAVE_VPRINTF 1

/* Define to 1 if you have the <wchar.h> header file. */
#define HAVE_WCHAR_H 1

/* Define to 1 if the system has the type `wchar_t'. */
#define HAVE_WCHAR_T 1

/* Define to 1 if you have the `wcrtomb' function. */
#define HAVE_WCRTOMB 1

/* Define to 1 if you have the `wcscmp' function. */
#define HAVE_WCSCMP 1

/* Define to 1 if you have the `wcscpy' function. */
#define HAVE_WCSCPY 1

/* Define to 1 if you have the `wcslen' function. */
#define HAVE_WCSLEN 1

/* Define to 1 if you have the `wctomb' function. */
#define HAVE_WCTOMB 1

/* Define to 1 if you have the <wctype.h> header file. */
#define HAVE_WCTYPE_H 1

/* Define to 1 if you have the <wincrypt.h> header file. */
/* #undef HAVE_WINCRYPT_H */

/* Define to 1 if you have the <windows.h> header file. */
/* #undef HAVE_WINDOWS_H */

/* Define to 1 if you have the <winioctl.h> header file. */
/* #undef HAVE_WINIOCTL_H */

/* Define to 1 if you have _CrtSetReportMode in <crtdbg.h>  */
/* #undef HAVE__CrtSetReportMode */

/* Define to 1 if you have the `wmemcmp' function. */
#define HAVE_WMEMCMP 1

/* Define to 1 if you have the `wmemcpy' function. */
#define HAVE_WMEMCPY 1

/* Define to 1 if you have a working EXT2_IOC_GETFLAGS */
/* #undef HAVE_WORKING_EXT2_IOC_GETFLAGS */

/* Define to 1 if you have the <zlib.h> header file. */
#define HAVE_ZLIB_H 1

/* Define to 1 if you have the `_ctime64_s' function. */
/* #undef HAVE__CTIME64_S */

/* Define to 1 if you have the `_fseeki64' function. */
/* #undef HAVE__FSEEKI64 */

/* Define to 1 if you have the `_get_timezone' function. */
/* #undef HAVE__GET_TIMEZONE */

/* Define to 1 if you have the `_localtime64_s' function. */
/* #undef HAVE__LOCALTIME64_S */

/* Define to 1 if you have the `_mkgmtime64' function. */
/* #undef HAVE__MKGMTIME64 */

/* Define as const if the declaration of iconv() needs const. */
#define ICONV_CONST 

/* Version number of libarchive as a single integer */
#define LIBARCHIVE_VERSION_NUMBER "3001002"

/* Version number of libarchive */
#define LIBARCHIVE_VERSION_STRING "3.1.2"

/* Define to 1 if `lstat' dereferences a symlink specified with a trailing
   slash. */
/* #undef LSTAT_FOLLOWS_SLASHED_SYMLINK */

/* Define to 1 if `major', `minor', and `makedev' are declared in <mkdev.h>.
   */
/* #undef MAJOR_IN_MKDEV */

/* Define to 1 if `major', `minor', and `makedev' are declared in
   <sysmacros.h>. */
#define MAJOR_IN_SYSMACROS 1

/* Define to 1 if your C compiler doesn't accept -c and -o together. */
/* #undef NO_MINUS_C_MINUS_O */

/* The size of `wchar_t', as computed by sizeof. */
#define SIZEOF_WCHAR_T 4

/* Define to 1 if strerror_r returns char *. */
/* #undef STRERROR_R_CHAR_P */

/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
#define TIME_WITH_SYS_TIME 1

/*
 * Some platform requires a macro to use extension functions.
 */
#define SAFE_TO_DEFINE_EXTENSIONS 1
#ifdef SAFE_TO_DEFINE_EXTENSIONS
/* Enable extensions on AIX 3, Interix.  */
#ifndef _ALL_SOURCE
# define _ALL_SOURCE 1
#endif
/* Enable GNU extensions on systems that have them.  */
#ifndef _GNU_SOURCE
# define _GNU_SOURCE 1
#endif
/* Enable threading extensions on Solaris.  */
#ifndef _POSIX_PTHREAD_SEMANTICS
# define _POSIX_PTHREAD_SEMANTICS 1
#endif
/* Enable extensions on HP NonStop.  */
#ifndef _TANDEM_SOURCE
# define _TANDEM_SOURCE 1
#endif
/* Enable general extensions on Solaris.  */
#ifndef __EXTENSIONS__
# define __EXTENSIONS__ 1
#endif
#endif /* SAFE_TO_DEFINE_EXTENSIONS */

/* Version number of package */
#define VERSION "3.1.2"

/* Number of bits in a file offset, on hosts where this is settable. */
/* #undef _FILE_OFFSET_BITS */

/* Define to 1 to make fseeko visible on some hosts (e.g. glibc 2.2). */
/* #undef _LARGEFILE_SOURCE */

/* Define for large files, on AIX-style hosts. */
/* #undef _LARGE_FILES */

/* Define for Windows to use Windows 2000+ APIs. */
/* #undef _WIN32_WINNT */
/* #undef WINVER */

/* Define to empty if `const' does not conform to ANSI C. */
/* #undef const */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef gid_t */

/* Define to `unsigned long' if <sys/types.h> does not define. */
/* #undef id_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef mode_t */

/* Define to `long long' if <sys/types.h> does not define. */
/* #undef off_t */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef pid_t */

/* Define to `unsigned int' if <sys/types.h> does not define. */
/* #undef size_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef ssize_t */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef uid_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef intptr_t */

/* Define to `unsigned int' if <sys/types.h> does not define. */
/* #undef uintptr_t */


#define ARCHIVE_RMD160_COMPILE_TEST
#define ARCHIVE_CRYPTO_RMD160_LIBMD
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = (DWORD)bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. Nettle
 * 6. OpenSSL
 * 7. libmd
 * 8. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive_rmd160_ctx ctx;
  archive_rmd160_init(&ctx);
  archive_rmd160_update(&ctx, *argv, argc);
  archive_rmd160_final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA1_LIBMD failed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2870864766/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2870864766.dir/build.make CMakeFiles/cmTryCompileExec2870864766.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2870864766.dir/check_crypto_md.c.o
/usr/bin/gcc   -w  -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2 -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmlibarchive/libarchive -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec2870864766.dir/check_crypto_md.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1186:0:
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:97:17: fatal error: sha.h: No such file or directory
 #include <sha.h>
                 ^
compilation terminated.
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec2870864766.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec2870864766/fast] Error 2

Source file was:
/* config.h.  Generated from build/cmake/config.h.in by cmake configure */
#if defined(__osf__)
# define _OSF_SOURCE
#endif

/*
 * Ensure we have C99-style int64_t, etc, all defined.
 */

/* First, we need to know if the system has already defined them. */
#define HAVE_INT16_T
#define HAVE_INT32_T
#define HAVE_INT64_T
#define HAVE_INTMAX_T

#define HAVE_UINT8_T
#define HAVE_UINT16_T
#define HAVE_UINT32_T
#define HAVE_UINT64_T
#define HAVE_UINTMAX_T

/* We might have the types we want under other spellings. */
/* #undef HAVE___INT64 */
/* #undef HAVE_U_INT64_T */
/* #undef HAVE_UNSIGNED___INT64 */

/* The sizes of various standard integer types. */
#define SIZE_OF_SHORT 2
#define SIZE_OF_INT 4
#define SIZE_OF_LONG 8
#define SIZE_OF_LONG_LONG 8
#define SIZE_OF_UNSIGNED_SHORT 2
#define SIZE_OF_UNSIGNED 4
#define SIZE_OF_UNSIGNED_LONG 8
#define SIZE_OF_UNSIGNED_LONG_LONG 8

/*
 * If we lack int64_t, define it to the first of __int64, int, long, and long long
 * that exists and is the right size.
 */
#if !defined(HAVE_INT64_T) && defined(HAVE___INT64)
typedef __int64 int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_INT == 8
typedef int int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_LONG == 8
typedef long int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_LONG_LONG == 8
typedef long long int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T)
#error No 64-bit integer type was found.
#endif

/*
 * Similarly for int32_t
 */
#if !defined(HAVE_INT32_T) && SIZE_OF_INT == 4
typedef long int32_t;
#define HAVE_INT32_T
#endif

#if !defined(HAVE_INT32_T) && SIZE_OF_LONG == 4
typedef long int32_t;
#define HAVE_INT32_T
#endif

#if !defined(HAVE_INT32_T)
#error No 32-bit integer type was found.
#endif

/*
 * Similarly for int16_t
 */
#if !defined(HAVE_INT16_T) && SIZE_OF_INT == 2
typedef int int16_t;
#define HAVE_INT16_T
#endif

#if !defined(HAVE_INT16_T) && SIZE_OF_SHORT == 2
typedef short int16_t;
#define HAVE_INT16_T
#endif

#if !defined(HAVE_INT16_T)
#error No 16-bit integer type was found.
#endif

/*
 * Similarly for uint64_t
 */
#if !defined(HAVE_UINT64_T) && defined(HAVE_UNSIGNED___INT64)
typedef unsigned __int64 uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED == 8
typedef unsigned uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED_LONG == 8
typedef unsigned long uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED_LONG_LONG == 8
typedef unsigned long long uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T)
#error No 64-bit unsigned integer type was found.
#endif


/*
 * Similarly for uint32_t
 */
#if !defined(HAVE_UINT32_T) && SIZE_OF_UNSIGNED == 4
typedef unsigned uint32_t;
#define HAVE_UINT32_T
#endif

#if !defined(HAVE_UINT32_T) && SIZE_OF_UNSIGNED_LONG == 4
typedef unsigned long uint32_t;
#define HAVE_UINT32_T
#endif

#if !defined(HAVE_UINT32_T)
#error No 32-bit unsigned integer type was found.
#endif

/*
 * Similarly for uint16_t
 */
#if !defined(HAVE_UINT16_T) && SIZE_OF_UNSIGNED == 2
typedef unsigned uint16_t;
#define HAVE_UINT16_T
#endif

#if !defined(HAVE_UINT16_T) && SIZE_OF_UNSIGNED_SHORT == 2
typedef unsigned short uint16_t;
#define HAVE_UINT16_T
#endif

#if !defined(HAVE_UINT16_T)
#error No 16-bit unsigned integer type was found.
#endif

/*
 * Similarly for uint8_t
 */
#if !defined(HAVE_UINT8_T)
typedef unsigned char uint8_t;
#define HAVE_UINT8_T
#endif

#if !defined(HAVE_UINT16_T)
#error No 8-bit unsigned integer type was found.
#endif

/* Define intmax_t and uintmax_t if they are not already defined. */
#if !defined(HAVE_INTMAX_T)
typedef int64_t intmax_t;
#define INTMAX_MIN INT64_MIN
#define INTMAX_MAX INT64_MAX
#endif

#if !defined(HAVE_UINTMAX_T)
typedef uint64_t uintmax_t;
#endif

/* Define ZLIB_WINAPI if zlib was built on Visual Studio. */
/* #undef ZLIB_WINAPI */

/* MD5 via ARCHIVE_CRYPTO_MD5_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_MD5_LIBC */

/* MD5 via ARCHIVE_CRYPTO_MD5_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_MD5_LIBSYSTEM */

/* MD5 via ARCHIVE_CRYPTO_MD5_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_MD5_NETTLE */

/* MD5 via ARCHIVE_CRYPTO_MD5_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_MD5_OPENSSL */

/* MD5 via ARCHIVE_CRYPTO_MD5_WIN supported. */
/* #undef ARCHIVE_CRYPTO_MD5_WIN */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_LIBC */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_NETTLE */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_OPENSSL */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_LIBC */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_LIBSYSTEM */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_NETTLE */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_OPENSSL */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_WIN */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC2 */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC3 */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBSYSTEM */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_NETTLE */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_OPENSSL */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_WIN */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC2 */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC3 */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBSYSTEM */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_NETTLE */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_OPENSSL */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_WIN */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC2 */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC3 */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBSYSTEM */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_NETTLE */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_OPENSSL */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_WIN */

/* Version number of bsdcpio */
#define BSDCPIO_VERSION_STRING "3.1.2"

/* Version number of bsdtar */
#define BSDTAR_VERSION_STRING "3.1.2"

/* Define to 1 if you have the `acl_create_entry' function. */
/* #undef HAVE_ACL_CREATE_ENTRY */

/* Define to 1 if you have the `acl_get_link' function. */
/* #undef HAVE_ACL_GET_LINK */

/* Define to 1 if you have the `acl_get_link_np' function. */
/* #undef HAVE_ACL_GET_LINK_NP */

/* Define to 1 if you have the `acl_get_perm' function. */
/* #undef HAVE_ACL_GET_PERM */

/* Define to 1 if you have the `acl_get_perm_np' function. */
/* #undef HAVE_ACL_GET_PERM_NP */

/* Define to 1 if you have the `acl_init' function. */
/* #undef HAVE_ACL_INIT */

/* Define to 1 if you have the <acl/libacl.h> header file. */
/* #undef HAVE_ACL_LIBACL_H */

/* Define to 1 if the system has the type `acl_permset_t'. */
/* #undef HAVE_ACL_PERMSET_T */

/* Define to 1 if you have the `acl_set_fd' function. */
/* #undef HAVE_ACL_SET_FD */

/* Define to 1 if you have the `acl_set_fd_np' function. */
/* #undef HAVE_ACL_SET_FD_NP */

/* Define to 1 if you have the `acl_set_file' function. */
/* #undef HAVE_ACL_SET_FILE */

/* True for systems with POSIX ACL support */
/* #undef HAVE_ACL_USER */

/* Define to 1 if you have the <attr/xattr.h> header file. */
/* #undef HAVE_ATTR_XATTR_H */

/* Define to 1 if you have the <bsdxml.h> header file. */
/* #undef HAVE_BSDXML_H */

/* Define to 1 if you have the <bzlib.h> header file. */
#define HAVE_BZLIB_H 1

/* Define to 1 if you have the `chflags' function. */
/* #undef HAVE_CHFLAGS */

/* Define to 1 if you have the `chown' function. */
#define HAVE_CHOWN 1

/* Define to 1 if you have the `chroot' function. */
#define HAVE_CHROOT 1

/* Define to 1 if you have the <copyfile.h> header file. */
/* #undef HAVE_COPYFILE_H */

/* Define to 1 if you have the `ctime_r' function. */
#define HAVE_CTIME_R 1

/* Define to 1 if you have the <ctype.h> header file. */
#define HAVE_CTYPE_H 1

/* Define to 1 if you have the `cygwin_conv_path' function. */
/* #undef HAVE_CYGWIN_CONV_PATH */

/* Define to 1 if you have the declaration of `INT64_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_INT64_MAX 1

/* Define to 1 if you have the declaration of `INT64_MIN', and to 0 if you
   don't. */
#define HAVE_DECL_INT64_MIN 1

/* Define to 1 if you have the declaration of `SIZE_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_SIZE_MAX 1

/* Define to 1 if you have the declaration of `SSIZE_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_SSIZE_MAX 1

/* Define to 1 if you have the declaration of `strerror_r', and to 0 if you
   don't. */
#define HAVE_DECL_STRERROR_R 1

/* Define to 1 if you have the declaration of `UINT32_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_UINT32_MAX 1

/* Define to 1 if you have the declaration of `UINT64_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_UINT64_MAX 1

/* Define to 1 if you have the <direct.h> header file. */
/* #undef HAVE_DIRECT_H */

/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.
   */
#define HAVE_DIRENT_H 1

/* Define to 1 if you have the `dirfd' function. */
#define HAVE_DIRFD 1

/* Define to 1 if you have the <dlfcn.h> header file. */
#define HAVE_DLFCN_H 1

/* Define to 1 if you don't have `vprintf' but do have `_doprnt.' */
/* #undef HAVE_DOPRNT */

/* Define to 1 if nl_langinfo supports D_MD_ORDER */
/* #undef HAVE_D_MD_ORDER */

/* A possible errno value for invalid file format errors */
/* #undef HAVE_EFTYPE */

/* A possible errno value for invalid file format errors */
#define HAVE_EILSEQ 1

/* Define to 1 if you have the <errno.h> header file. */
#define HAVE_ERRNO_H 1

/* Define to 1 if you have the <expat.h> header file. */
/* #undef HAVE_EXPAT_H */

/* Define to 1 if you have the <ext2fs/ext2_fs.h> header file. */
/* #undef HAVE_EXT2FS_EXT2_FS_H */

/* Define to 1 if you have the `extattr_get_file' function. */
/* #undef HAVE_EXTATTR_GET_FILE */

/* Define to 1 if you have the `extattr_list_file' function. */
/* #undef HAVE_EXTATTR_LIST_FILE */

/* Define to 1 if you have the `extattr_set_fd' function. */
/* #undef HAVE_EXTATTR_SET_FD */

/* Define to 1 if you have the `extattr_set_file' function. */
/* #undef HAVE_EXTATTR_SET_FILE */

/* Define to 1 if EXTATTR_NAMESPACE_USER is defined in sys/extattr.h. */
/* #undef HAVE_DECL_EXTATTR_NAMESPACE_USER */

/* Define to 1 if you have the `fchdir' function. */
#define HAVE_FCHDIR 1

/* Define to 1 if you have the `fchflags' function. */
/* #undef HAVE_FCHFLAGS */

/* Define to 1 if you have the `fchmod' function. */
#define HAVE_FCHMOD 1

/* Define to 1 if you have the `fchown' function. */
#define HAVE_FCHOWN 1

/* Define to 1 if you have the `fcntl' function. */
#define HAVE_FCNTL 1

/* Define to 1 if you have the <fcntl.h> header file. */
#define HAVE_FCNTL_H 1

/* Define to 1 if you have the `fdopendir' function. */
#define HAVE_FDOPENDIR 1

/* Define to 1 if you have the `fgetea' function. */
/* #undef HAVE_FGETEA */

/* Define to 1 if you have the `fgetxattr' function. */
/* #undef HAVE_FGETXATTR */

/* Define to 1 if you have the `flistea' function. */
/* #undef HAVE_FLISTEA */

/* Define to 1 if you have the `flistxattr' function. */
/* #undef HAVE_FLISTXATTR */

/* Define to 1 if you have the `fork' function. */
#define HAVE_FORK 1

/* Define to 1 if fseeko (and presumably ftello) exists and is declared. */
#define HAVE_FSEEKO 1

/* Define to 1 if you have the `fsetea' function. */
/* #undef HAVE_FSETEA */

/* Define to 1 if you have the `fsetxattr' function. */
/* #undef HAVE_FSETXATTR */

/* Define to 1 if you have the `fstat' function. */
#define HAVE_FSTAT 1

/* Define to 1 if you have the `fstatat' function. */
#define HAVE_FSTATAT 1

/* Define to 1 if you have the `fstatfs' function. */
#define HAVE_FSTATFS 1

/* Define to 1 if you have the `fstatvfs' function. */
#define HAVE_FSTATVFS 1

/* Define to 1 if you have the `ftruncate' function. */
#define HAVE_FTRUNCATE 1

/* Define to 1 if you have the `futimens' function. */
#define HAVE_FUTIMENS 1

/* Define to 1 if you have the `futimes' function. */
#define HAVE_FUTIMES 1

/* Define to 1 if you have the `futimesat' function. */
#define HAVE_FUTIMESAT 1

/* Define to 1 if you have the `getea' function. */
/* #undef HAVE_GETEA */

/* Define to 1 if you have the `geteuid' function. */
#define HAVE_GETEUID 1

/* Define to 1 if you have the `getgrgid_r' function. */
#define HAVE_GETGRGID_R 1

/* Define to 1 if you have the `getgrnam_r' function. */
#define HAVE_GETGRNAM_R 1

/* Define to 1 if you have the `getpid' function. */
#define HAVE_GETPID 1

/* Define to 1 if you have the `getpwnam_r' function. */
#define HAVE_GETPWNAM_R 1

/* Define to 1 if you have the `getpwuid_r' function. */
#define HAVE_GETPWUID_R 1

/* Define to 1 if you have the `getvfsbyname' function. */
/* #undef HAVE_GETVFSBYNAME */

/* Define to 1 if you have the `getxattr' function. */
/* #undef HAVE_GETXATTR */

/* Define to 1 if you have the `gmtime_r' function. */
#define HAVE_GMTIME_R 1

/* Define to 1 if you have the <grp.h> header file. */
#define HAVE_GRP_H 1

/* Define to 1 if you have the `iconv' function. */
/* #undef HAVE_ICONV */

/* Define to 1 if you have the <iconv.h> header file. */
/* #undef HAVE_ICONV_H */

/* Define to 1 if you have the <inttypes.h> header file. */
#define HAVE_INTTYPES_H 1

/* Define to 1 if you have the <io.h> header file. */
/* #undef HAVE_IO_H */

/* Define to 1 if you have the <langinfo.h> header file. */
#define HAVE_LANGINFO_H 1

/* Define to 1 if you have the `lchflags' function. */
/* #undef HAVE_LCHFLAGS */

/* Define to 1 if you have the `lchmod' function. */
/* #undef HAVE_LCHMOD */

/* Define to 1 if you have the `lchown' function. */
#define HAVE_LCHOWN 1

/* Define to 1 if you have the `lgetea' function. */
/* #undef HAVE_LGETEA */

/* Define to 1 if you have the `lgetxattr' function. */
/* #undef HAVE_LGETXATTR */

/* Define to 1 if you have the `acl' library (-lacl). */
/* #undef HAVE_LIBACL */

/* Define to 1 if you have the `attr' library (-lattr). */
/* #undef HAVE_LIBATTR */

/* Define to 1 if you have the `bsdxml' library (-lbsdxml). */
/* #undef HAVE_LIBBSDXML */

/* Define to 1 if you have the `bz2' library (-lbz2). */
#define HAVE_LIBBZ2 1

/* Define to 1 if you have the `expat' library (-lexpat). */
/* #undef HAVE_LIBEXPAT */

/* Define to 1 if you have the `gcc' library (-lgcc). */
/* #undef HAVE_LIBGCC */

/* Define to 1 if you have the `lzma' library (-llzma). */
/* #undef HAVE_LIBLZMA */

/* Define to 1 if you have the `lzmadec' library (-llzmadec). */
/* #undef HAVE_LIBLZMADEC */

/* Define to 1 if you have the `lzo2' library (-llzo2). */
/* #undef HAVE_LIBLZO2 */

/* Define to 1 if you have the `nettle' library (-lnettle). */
/* #undef HAVE_LIBNETTLE */

/* Define to 1 if you have the `pcre' library (-lpcre). */
/* #undef HAVE_LIBPCRE */

/* Define to 1 if you have the `pcreposix' library (-lpcreposix). */
/* #undef HAVE_LIBPCREPOSIX */

/* Define to 1 if you have the `xml2' library (-lxml2). */
/* #undef HAVE_LIBXML2 */

/* Define to 1 if you have the <libxml/xmlreader.h> header file. */
/* #undef HAVE_LIBXML_XMLREADER_H */

/* Define to 1 if you have the <libxml/xmlwriter.h> header file. */
/* #undef HAVE_LIBXML_XMLWRITER_H */

/* Define to 1 if you have the `z' library (-lz). */
#define HAVE_LIBZ 1

/* Define to 1 if you have the <limits.h> header file. */
#define HAVE_LIMITS_H 1

/* Define to 1 if you have the `link' function. */
#define HAVE_LINK 1

/* Define to 1 if you have the <linux/types.h> header file. */
#define HAVE_LINUX_TYPES_H 1

/* Define to 1 if you have the <linux/fiemap.h> header file. */
#define HAVE_LINUX_FIEMAP_H 1

/* Define to 1 if you have the <linux/fs.h> header file. */
#define HAVE_LINUX_FS_H 1

/* Define to 1 if you have the <linux/magic.h> header file. */
#define HAVE_LINUX_MAGIC_H 1

/* Define to 1 if you have the <linux/types.h> header file. */
#define HAVE_LINUX_TYPES_H 1

/* Define to 1 if you have the `listea' function. */
/* #undef HAVE_LISTEA */

/* Define to 1 if you have the `listxattr' function. */
/* #undef HAVE_LISTXATTR */

/* Define to 1 if you have the `llistea' function. */
/* #undef HAVE_LLISTEA */

/* Define to 1 if you have the `llistxattr' function. */
/* #undef HAVE_LLISTXATTR */

/* Define to 1 if you have the <localcharset.h> header file. */
/* #undef HAVE_LOCALCHARSET_H */

/* Define to 1 if you have the `locale_charset' function. */
/* #undef HAVE_LOCALE_CHARSET */

/* Define to 1 if you have the <locale.h> header file. */
#define HAVE_LOCALE_H 1

/* Define to 1 if you have the `localtime_r' function. */
#define HAVE_LOCALTIME_R 1

/* Define to 1 if the system has the type `long long int'. */
/* #undef HAVE_LONG_LONG_INT */

/* Define to 1 if you have the `lsetea' function. */
/* #undef HAVE_LSETEA */

/* Define to 1 if you have the `lsetxattr' function. */
/* #undef HAVE_LSETXATTR */

/* Define to 1 if you have the `lstat' function. */
#define HAVE_LSTAT 1

/* Define to 1 if `lstat' has the bug that it succeeds when given the
   zero-length file name argument. */
/* #undef HAVE_LSTAT_EMPTY_STRING_BUG */

/* Define to 1 if you have the `lutimes' function. */
#define HAVE_LUTIMES 1

/* Define to 1 if you have the <lzmadec.h> header file. */
/* #undef HAVE_LZMADEC_H */

/* Define to 1 if you have the <lzma.h> header file. */
/* #undef HAVE_LZMA_H */

/* Define to 1 if you have the <lzo/lzo1x.h> header file. */
/* #undef HAVE_LZO_LZO1X_H */

/* Define to 1 if you have the <lzo/lzoconf.h> header file. */
/* #undef HAVE_LZO_LZOCONF_H */

/* Define to 1 if you have the `mbrtowc' function. */
#define HAVE_MBRTOWC 1

/* Define to 1 if you have the `memmove' function. */
#define HAVE_MEMMOVE 1

/* Define to 1 if you have the <memory.h> header file. */
#define HAVE_MEMORY_H 1

/* Define to 1 if you have the `mkdir' function. */
#define HAVE_MKDIR 1

/* Define to 1 if you have the `mkfifo' function. */
#define HAVE_MKFIFO 1

/* Define to 1 if you have the `mknod' function. */
#define HAVE_MKNOD 1

/* Define to 1 if you have the `mkstemp' function. */
#define HAVE_MKSTEMP 1

/* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */
/* #undef HAVE_NDIR_H */

/* Define to 1 if you have the <nettle/md5.h> header file. */
/* #undef HAVE_NETTLE_MD5_H */

/* Define to 1 if you have the <nettle/ripemd160.h> header file. */
/* #undef HAVE_NETTLE_RIPEMD160_H */

/* Define to 1 if you have the <nettle/sha.h> header file. */
/* #undef HAVE_NETTLE_SHA_H */

/* Define to 1 if you have the `nl_langinfo' function. */
#define HAVE_NL_LANGINFO 1

/* Define to 1 if you have the `openat' function. */
#define HAVE_OPENAT 1

/* Define to 1 if you have the <paths.h> header file. */
#define HAVE_PATHS_H 1

/* Define to 1 if you have the <pcreposix.h> header file. */
/* #undef HAVE_PCREPOSIX_H */

/* Define to 1 if you have the `pipe' function. */
#define HAVE_PIPE 1

/* Define to 1 if you have the `poll' function. */
#define HAVE_POLL 1

/* Define to 1 if you have the <poll.h> header file. */
#define HAVE_POLL_H 1

/* Define to 1 if you have the `posix_spawnp' function. */
#define HAVE_POSIX_SPAWNP 1

/* Define to 1 if you have the <process.h> header file. */
/* #undef HAVE_PROCESS_H */

/* Define to 1 if you have the <pwd.h> header file. */
#define HAVE_PWD_H 1

/* Define to 1 if you have the `readdir_r' function. */
#define HAVE_READDIR_R 1

/* Define to 1 if you have the `readlink' function. */
#define HAVE_READLINK 1

/* Define to 1 if you have the `readlinkat' function. */
#define HAVE_READLINKAT 1

/* Define to 1 if you have the <regex.h> header file. */
#define HAVE_REGEX_H 1

/* Define to 1 if you have the `select' function. */
#define HAVE_SELECT 1

/* Define to 1 if you have the `setenv' function. */
#define HAVE_SETENV 1

/* Define to 1 if you have the `setlocale' function. */
#define HAVE_SETLOCALE 1

/* Define to 1 if you have the `sigaction' function. */
#define HAVE_SIGACTION 1

/* Define to 1 if you have the <signal.h> header file. */
#define HAVE_SIGNAL_H 1

/* Define to 1 if you have the <spawn.h> header file. */
#define HAVE_SPAWN_H 1

/* Define to 1 if you have the `statfs' function. */
#define HAVE_STATFS 1

/* Define to 1 if you have the `statvfs' function. */
#define HAVE_STATVFS 1

/* Define to 1 if `stat' has the bug that it succeeds when given the
   zero-length file name argument. */
/* #undef HAVE_STAT_EMPTY_STRING_BUG */

/* Define to 1 if you have the <stdarg.h> header file. */
#define HAVE_STDARG_H 1

/* Define to 1 if you have the <stdint.h> header file. */
#define HAVE_STDINT_H 1

/* Define to 1 if you have the <stdlib.h> header file. */
#define HAVE_STDLIB_H 1

/* Define to 1 if you have the `strchr' function. */
#define HAVE_STRCHR 1

/* Define to 1 if you have the `strdup' function. */
#define HAVE_STRDUP 1

/* Define to 1 if you have the `strerror' function. */
#define HAVE_STRERROR 1

/* Define to 1 if you have the `strerror_r' function. */
#define HAVE_STRERROR_R 1

/* Define to 1 if you have the `strftime' function. */
#define HAVE_STRFTIME 1

/* Define to 1 if you have the <strings.h> header file. */
#define HAVE_STRINGS_H 1

/* Define to 1 if you have the <string.h> header file. */
#define HAVE_STRING_H 1

/* Define to 1 if you have the `strrchr' function. */
#define HAVE_STRRCHR 1

/* Define to 1 if `f_namemax' is a member of `struct statfs'. */
/* #undef HAVE_STRUCT_STATFS_F_NAMEMAX */

/* Define to 1 if `f_iosize' is a member of `struct statvfs'. */
/* #undef HAVE_STRUCT_STATVFS_F_IOSIZE */

/* Define to 1 if `st_birthtime' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIME */

/* Define to 1 if `st_birthtimespec.tv_nsec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC_TV_NSEC */

/* Define to 1 if `st_blksize' is a member of `struct stat'. */
#define HAVE_STRUCT_STAT_ST_BLKSIZE 1

/* Define to 1 if `st_flags' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_FLAGS */

/* Define to 1 if `st_mtimespec.tv_nsec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC */

/* Define to 1 if `st_mtime_n' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIME_N */

/* Define to 1 if `st_mtime_usec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIME_USEC */

/* Define to 1 if `st_mtim.tv_nsec' is a member of `struct stat'. */
#define HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC 1

/* Define to 1 if `st_umtime' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_UMTIME */

/* Define to 1 if `tm_gmtoff' is a member of `struct tm'. */
#define HAVE_STRUCT_TM_TM_GMTOFF 1

/* Define to 1 if `__tm_gmtoff' is a member of `struct tm'. */
/* #undef HAVE_STRUCT_TM___TM_GMTOFF */

/* Define to 1 if you have the `symlink' function. */
#define HAVE_SYMLINK 1

/* Define to 1 if you have the <sys/acl.h> header file. */
/* #undef HAVE_SYS_ACL_H */

/* Define to 1 if you have the <sys/cdefs.h> header file. */
#define HAVE_SYS_CDEFS_H 1

/* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.
   */
/* #undef HAVE_SYS_DIR_H */

/* Define to 1 if you have the <sys/ea.h> header file. */
/* #undef HAVE_SYS_EA_H */

/* Define to 1 if you have the <sys/extattr.h> header file. */
/* #undef HAVE_SYS_EXTATTR_H */

/* Define to 1 if you have the <sys/ioctl.h> header file. */
#define HAVE_SYS_IOCTL_H 1

/* Define to 1 if you have the <sys/mkdev.h> header file. */
/* #undef HAVE_SYS_MKDEV_H */

/* Define to 1 if you have the <sys/mount.h> header file. */
/* #undef HAVE_SYS_MOUNT_H */

/* Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.
   */
/* #undef HAVE_SYS_NDIR_H */

/* Define to 1 if you have the <sys/param.h> header file. */
#define HAVE_SYS_PARAM_H 1

/* Define to 1 if you have the <sys/poll.h> header file. */
#define HAVE_SYS_POLL_H 1

/* Define to 1 if you have the <sys/select.h> header file. */
#define HAVE_SYS_SELECT_H 1

/* Define to 1 if you have the <sys/statfs.h> header file. */
#define HAVE_SYS_STATFS_H 1

/* Define to 1 if you have the <sys/statvfs.h> header file. */
#define HAVE_SYS_STATVFS_H 1

/* Define to 1 if you have the <sys/stat.h> header file. */
#define HAVE_SYS_STAT_H 1

/* Define to 1 if you have the <sys/time.h> header file. */
#define HAVE_SYS_TIME_H 1

/* Define to 1 if you have the <sys/types.h> header file. */
#define HAVE_SYS_TYPES_H 1

/* Define to 1 if you have the <sys/utime.h> header file. */
/* #undef HAVE_SYS_UTIME_H */

/* Define to 1 if you have the <sys/utsname.h> header file. */
#define HAVE_SYS_UTSNAME_H 1

/* Define to 1 if you have the <sys/vfs.h> header file. */
#define HAVE_SYS_VFS_H 1

/* Define to 1 if you have <sys/wait.h> that is POSIX.1 compatible. */
#define HAVE_SYS_WAIT_H 1

/* Define to 1 if you have the <sys/xattr.h> header file. */
/* #undef HAVE_SYS_XATTR_H */

/* Define to 1 if you have the `timegm' function. */
#define HAVE_TIMEGM 1

/* Define to 1 if you have the <time.h> header file. */
#define HAVE_TIME_H 1

/* Define to 1 if you have the `tzset' function. */
#define HAVE_TZSET 1

/* Define to 1 if you have the <unistd.h> header file. */
#define HAVE_UNISTD_H 1

/* Define to 1 if you have the `unsetenv' function. */
#define HAVE_UNSETENV 1

/* Define to 1 if the system has the type `unsigned long long'. */
/* #undef HAVE_UNSIGNED_LONG_LONG */

/* Define to 1 if the system has the type `unsigned long long int'. */
/* #undef HAVE_UNSIGNED_LONG_LONG_INT */

/* Define to 1 if you have the `utime' function. */
#define HAVE_UTIME 1

/* Define to 1 if you have the `utimensat' function. */
#define HAVE_UTIMENSAT 1

/* Define to 1 if you have the `utimes' function. */
#define HAVE_UTIMES 1

/* Define to 1 if you have the <utime.h> header file. */
#define HAVE_UTIME_H 1

/* Define to 1 if you have the `vfork' function. */
#define HAVE_VFORK 1

/* Define to 1 if you have the `vprintf' function. */
#define HAVE_VPRINTF 1

/* Define to 1 if you have the <wchar.h> header file. */
#define HAVE_WCHAR_H 1

/* Define to 1 if the system has the type `wchar_t'. */
#define HAVE_WCHAR_T 1

/* Define to 1 if you have the `wcrtomb' function. */
#define HAVE_WCRTOMB 1

/* Define to 1 if you have the `wcscmp' function. */
#define HAVE_WCSCMP 1

/* Define to 1 if you have the `wcscpy' function. */
#define HAVE_WCSCPY 1

/* Define to 1 if you have the `wcslen' function. */
#define HAVE_WCSLEN 1

/* Define to 1 if you have the `wctomb' function. */
#define HAVE_WCTOMB 1

/* Define to 1 if you have the <wctype.h> header file. */
#define HAVE_WCTYPE_H 1

/* Define to 1 if you have the <wincrypt.h> header file. */
/* #undef HAVE_WINCRYPT_H */

/* Define to 1 if you have the <windows.h> header file. */
/* #undef HAVE_WINDOWS_H */

/* Define to 1 if you have the <winioctl.h> header file. */
/* #undef HAVE_WINIOCTL_H */

/* Define to 1 if you have _CrtSetReportMode in <crtdbg.h>  */
/* #undef HAVE__CrtSetReportMode */

/* Define to 1 if you have the `wmemcmp' function. */
#define HAVE_WMEMCMP 1

/* Define to 1 if you have the `wmemcpy' function. */
#define HAVE_WMEMCPY 1

/* Define to 1 if you have a working EXT2_IOC_GETFLAGS */
/* #undef HAVE_WORKING_EXT2_IOC_GETFLAGS */

/* Define to 1 if you have the <zlib.h> header file. */
#define HAVE_ZLIB_H 1

/* Define to 1 if you have the `_ctime64_s' function. */
/* #undef HAVE__CTIME64_S */

/* Define to 1 if you have the `_fseeki64' function. */
/* #undef HAVE__FSEEKI64 */

/* Define to 1 if you have the `_get_timezone' function. */
/* #undef HAVE__GET_TIMEZONE */

/* Define to 1 if you have the `_localtime64_s' function. */
/* #undef HAVE__LOCALTIME64_S */

/* Define to 1 if you have the `_mkgmtime64' function. */
/* #undef HAVE__MKGMTIME64 */

/* Define as const if the declaration of iconv() needs const. */
#define ICONV_CONST 

/* Version number of libarchive as a single integer */
#define LIBARCHIVE_VERSION_NUMBER "3001002"

/* Version number of libarchive */
#define LIBARCHIVE_VERSION_STRING "3.1.2"

/* Define to 1 if `lstat' dereferences a symlink specified with a trailing
   slash. */
/* #undef LSTAT_FOLLOWS_SLASHED_SYMLINK */

/* Define to 1 if `major', `minor', and `makedev' are declared in <mkdev.h>.
   */
/* #undef MAJOR_IN_MKDEV */

/* Define to 1 if `major', `minor', and `makedev' are declared in
   <sysmacros.h>. */
#define MAJOR_IN_SYSMACROS 1

/* Define to 1 if your C compiler doesn't accept -c and -o together. */
/* #undef NO_MINUS_C_MINUS_O */

/* The size of `wchar_t', as computed by sizeof. */
#define SIZEOF_WCHAR_T 4

/* Define to 1 if strerror_r returns char *. */
/* #undef STRERROR_R_CHAR_P */

/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
#define TIME_WITH_SYS_TIME 1

/*
 * Some platform requires a macro to use extension functions.
 */
#define SAFE_TO_DEFINE_EXTENSIONS 1
#ifdef SAFE_TO_DEFINE_EXTENSIONS
/* Enable extensions on AIX 3, Interix.  */
#ifndef _ALL_SOURCE
# define _ALL_SOURCE 1
#endif
/* Enable GNU extensions on systems that have them.  */
#ifndef _GNU_SOURCE
# define _GNU_SOURCE 1
#endif
/* Enable threading extensions on Solaris.  */
#ifndef _POSIX_PTHREAD_SEMANTICS
# define _POSIX_PTHREAD_SEMANTICS 1
#endif
/* Enable extensions on HP NonStop.  */
#ifndef _TANDEM_SOURCE
# define _TANDEM_SOURCE 1
#endif
/* Enable general extensions on Solaris.  */
#ifndef __EXTENSIONS__
# define __EXTENSIONS__ 1
#endif
#endif /* SAFE_TO_DEFINE_EXTENSIONS */

/* Version number of package */
#define VERSION "3.1.2"

/* Number of bits in a file offset, on hosts where this is settable. */
/* #undef _FILE_OFFSET_BITS */

/* Define to 1 to make fseeko visible on some hosts (e.g. glibc 2.2). */
/* #undef _LARGEFILE_SOURCE */

/* Define for large files, on AIX-style hosts. */
/* #undef _LARGE_FILES */

/* Define for Windows to use Windows 2000+ APIs. */
/* #undef _WIN32_WINNT */
/* #undef WINVER */

/* Define to empty if `const' does not conform to ANSI C. */
/* #undef const */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef gid_t */

/* Define to `unsigned long' if <sys/types.h> does not define. */
/* #undef id_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef mode_t */

/* Define to `long long' if <sys/types.h> does not define. */
/* #undef off_t */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef pid_t */

/* Define to `unsigned int' if <sys/types.h> does not define. */
/* #undef size_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef ssize_t */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef uid_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef intptr_t */

/* Define to `unsigned int' if <sys/types.h> does not define. */
/* #undef uintptr_t */


#define ARCHIVE_SHA1_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA1_LIBMD
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = (DWORD)bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. Nettle
 * 6. OpenSSL
 * 7. libmd
 * 8. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive_sha1_ctx ctx;
  archive_sha1_init(&ctx);
  archive_sha1_update(&ctx, *argv, argc);
  archive_sha1_final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA256_LIBMD failed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2648799827/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2648799827.dir/build.make CMakeFiles/cmTryCompileExec2648799827.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2648799827.dir/check_crypto_md.c.o
/usr/bin/gcc   -w  -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2 -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmlibarchive/libarchive -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec2648799827.dir/check_crypto_md.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1186:0:
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:100:20: fatal error: sha256.h: No such file or directory
 #include <sha256.h>
                    ^
compilation terminated.
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec2648799827.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec2648799827/fast] Error 2

Source file was:
/* config.h.  Generated from build/cmake/config.h.in by cmake configure */
#if defined(__osf__)
# define _OSF_SOURCE
#endif

/*
 * Ensure we have C99-style int64_t, etc, all defined.
 */

/* First, we need to know if the system has already defined them. */
#define HAVE_INT16_T
#define HAVE_INT32_T
#define HAVE_INT64_T
#define HAVE_INTMAX_T

#define HAVE_UINT8_T
#define HAVE_UINT16_T
#define HAVE_UINT32_T
#define HAVE_UINT64_T
#define HAVE_UINTMAX_T

/* We might have the types we want under other spellings. */
/* #undef HAVE___INT64 */
/* #undef HAVE_U_INT64_T */
/* #undef HAVE_UNSIGNED___INT64 */

/* The sizes of various standard integer types. */
#define SIZE_OF_SHORT 2
#define SIZE_OF_INT 4
#define SIZE_OF_LONG 8
#define SIZE_OF_LONG_LONG 8
#define SIZE_OF_UNSIGNED_SHORT 2
#define SIZE_OF_UNSIGNED 4
#define SIZE_OF_UNSIGNED_LONG 8
#define SIZE_OF_UNSIGNED_LONG_LONG 8

/*
 * If we lack int64_t, define it to the first of __int64, int, long, and long long
 * that exists and is the right size.
 */
#if !defined(HAVE_INT64_T) && defined(HAVE___INT64)
typedef __int64 int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_INT == 8
typedef int int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_LONG == 8
typedef long int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_LONG_LONG == 8
typedef long long int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T)
#error No 64-bit integer type was found.
#endif

/*
 * Similarly for int32_t
 */
#if !defined(HAVE_INT32_T) && SIZE_OF_INT == 4
typedef long int32_t;
#define HAVE_INT32_T
#endif

#if !defined(HAVE_INT32_T) && SIZE_OF_LONG == 4
typedef long int32_t;
#define HAVE_INT32_T
#endif

#if !defined(HAVE_INT32_T)
#error No 32-bit integer type was found.
#endif

/*
 * Similarly for int16_t
 */
#if !defined(HAVE_INT16_T) && SIZE_OF_INT == 2
typedef int int16_t;
#define HAVE_INT16_T
#endif

#if !defined(HAVE_INT16_T) && SIZE_OF_SHORT == 2
typedef short int16_t;
#define HAVE_INT16_T
#endif

#if !defined(HAVE_INT16_T)
#error No 16-bit integer type was found.
#endif

/*
 * Similarly for uint64_t
 */
#if !defined(HAVE_UINT64_T) && defined(HAVE_UNSIGNED___INT64)
typedef unsigned __int64 uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED == 8
typedef unsigned uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED_LONG == 8
typedef unsigned long uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED_LONG_LONG == 8
typedef unsigned long long uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T)
#error No 64-bit unsigned integer type was found.
#endif


/*
 * Similarly for uint32_t
 */
#if !defined(HAVE_UINT32_T) && SIZE_OF_UNSIGNED == 4
typedef unsigned uint32_t;
#define HAVE_UINT32_T
#endif

#if !defined(HAVE_UINT32_T) && SIZE_OF_UNSIGNED_LONG == 4
typedef unsigned long uint32_t;
#define HAVE_UINT32_T
#endif

#if !defined(HAVE_UINT32_T)
#error No 32-bit unsigned integer type was found.
#endif

/*
 * Similarly for uint16_t
 */
#if !defined(HAVE_UINT16_T) && SIZE_OF_UNSIGNED == 2
typedef unsigned uint16_t;
#define HAVE_UINT16_T
#endif

#if !defined(HAVE_UINT16_T) && SIZE_OF_UNSIGNED_SHORT == 2
typedef unsigned short uint16_t;
#define HAVE_UINT16_T
#endif

#if !defined(HAVE_UINT16_T)
#error No 16-bit unsigned integer type was found.
#endif

/*
 * Similarly for uint8_t
 */
#if !defined(HAVE_UINT8_T)
typedef unsigned char uint8_t;
#define HAVE_UINT8_T
#endif

#if !defined(HAVE_UINT16_T)
#error No 8-bit unsigned integer type was found.
#endif

/* Define intmax_t and uintmax_t if they are not already defined. */
#if !defined(HAVE_INTMAX_T)
typedef int64_t intmax_t;
#define INTMAX_MIN INT64_MIN
#define INTMAX_MAX INT64_MAX
#endif

#if !defined(HAVE_UINTMAX_T)
typedef uint64_t uintmax_t;
#endif

/* Define ZLIB_WINAPI if zlib was built on Visual Studio. */
/* #undef ZLIB_WINAPI */

/* MD5 via ARCHIVE_CRYPTO_MD5_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_MD5_LIBC */

/* MD5 via ARCHIVE_CRYPTO_MD5_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_MD5_LIBSYSTEM */

/* MD5 via ARCHIVE_CRYPTO_MD5_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_MD5_NETTLE */

/* MD5 via ARCHIVE_CRYPTO_MD5_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_MD5_OPENSSL */

/* MD5 via ARCHIVE_CRYPTO_MD5_WIN supported. */
/* #undef ARCHIVE_CRYPTO_MD5_WIN */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_LIBC */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_NETTLE */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_OPENSSL */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_LIBC */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_LIBSYSTEM */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_NETTLE */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_OPENSSL */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_WIN */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC2 */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC3 */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBSYSTEM */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_NETTLE */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_OPENSSL */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_WIN */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC2 */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC3 */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBSYSTEM */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_NETTLE */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_OPENSSL */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_WIN */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC2 */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC3 */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBSYSTEM */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_NETTLE */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_OPENSSL */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_WIN */

/* Version number of bsdcpio */
#define BSDCPIO_VERSION_STRING "3.1.2"

/* Version number of bsdtar */
#define BSDTAR_VERSION_STRING "3.1.2"

/* Define to 1 if you have the `acl_create_entry' function. */
/* #undef HAVE_ACL_CREATE_ENTRY */

/* Define to 1 if you have the `acl_get_link' function. */
/* #undef HAVE_ACL_GET_LINK */

/* Define to 1 if you have the `acl_get_link_np' function. */
/* #undef HAVE_ACL_GET_LINK_NP */

/* Define to 1 if you have the `acl_get_perm' function. */
/* #undef HAVE_ACL_GET_PERM */

/* Define to 1 if you have the `acl_get_perm_np' function. */
/* #undef HAVE_ACL_GET_PERM_NP */

/* Define to 1 if you have the `acl_init' function. */
/* #undef HAVE_ACL_INIT */

/* Define to 1 if you have the <acl/libacl.h> header file. */
/* #undef HAVE_ACL_LIBACL_H */

/* Define to 1 if the system has the type `acl_permset_t'. */
/* #undef HAVE_ACL_PERMSET_T */

/* Define to 1 if you have the `acl_set_fd' function. */
/* #undef HAVE_ACL_SET_FD */

/* Define to 1 if you have the `acl_set_fd_np' function. */
/* #undef HAVE_ACL_SET_FD_NP */

/* Define to 1 if you have the `acl_set_file' function. */
/* #undef HAVE_ACL_SET_FILE */

/* True for systems with POSIX ACL support */
/* #undef HAVE_ACL_USER */

/* Define to 1 if you have the <attr/xattr.h> header file. */
/* #undef HAVE_ATTR_XATTR_H */

/* Define to 1 if you have the <bsdxml.h> header file. */
/* #undef HAVE_BSDXML_H */

/* Define to 1 if you have the <bzlib.h> header file. */
#define HAVE_BZLIB_H 1

/* Define to 1 if you have the `chflags' function. */
/* #undef HAVE_CHFLAGS */

/* Define to 1 if you have the `chown' function. */
#define HAVE_CHOWN 1

/* Define to 1 if you have the `chroot' function. */
#define HAVE_CHROOT 1

/* Define to 1 if you have the <copyfile.h> header file. */
/* #undef HAVE_COPYFILE_H */

/* Define to 1 if you have the `ctime_r' function. */
#define HAVE_CTIME_R 1

/* Define to 1 if you have the <ctype.h> header file. */
#define HAVE_CTYPE_H 1

/* Define to 1 if you have the `cygwin_conv_path' function. */
/* #undef HAVE_CYGWIN_CONV_PATH */

/* Define to 1 if you have the declaration of `INT64_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_INT64_MAX 1

/* Define to 1 if you have the declaration of `INT64_MIN', and to 0 if you
   don't. */
#define HAVE_DECL_INT64_MIN 1

/* Define to 1 if you have the declaration of `SIZE_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_SIZE_MAX 1

/* Define to 1 if you have the declaration of `SSIZE_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_SSIZE_MAX 1

/* Define to 1 if you have the declaration of `strerror_r', and to 0 if you
   don't. */
#define HAVE_DECL_STRERROR_R 1

/* Define to 1 if you have the declaration of `UINT32_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_UINT32_MAX 1

/* Define to 1 if you have the declaration of `UINT64_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_UINT64_MAX 1

/* Define to 1 if you have the <direct.h> header file. */
/* #undef HAVE_DIRECT_H */

/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.
   */
#define HAVE_DIRENT_H 1

/* Define to 1 if you have the `dirfd' function. */
#define HAVE_DIRFD 1

/* Define to 1 if you have the <dlfcn.h> header file. */
#define HAVE_DLFCN_H 1

/* Define to 1 if you don't have `vprintf' but do have `_doprnt.' */
/* #undef HAVE_DOPRNT */

/* Define to 1 if nl_langinfo supports D_MD_ORDER */
/* #undef HAVE_D_MD_ORDER */

/* A possible errno value for invalid file format errors */
/* #undef HAVE_EFTYPE */

/* A possible errno value for invalid file format errors */
#define HAVE_EILSEQ 1

/* Define to 1 if you have the <errno.h> header file. */
#define HAVE_ERRNO_H 1

/* Define to 1 if you have the <expat.h> header file. */
/* #undef HAVE_EXPAT_H */

/* Define to 1 if you have the <ext2fs/ext2_fs.h> header file. */
/* #undef HAVE_EXT2FS_EXT2_FS_H */

/* Define to 1 if you have the `extattr_get_file' function. */
/* #undef HAVE_EXTATTR_GET_FILE */

/* Define to 1 if you have the `extattr_list_file' function. */
/* #undef HAVE_EXTATTR_LIST_FILE */

/* Define to 1 if you have the `extattr_set_fd' function. */
/* #undef HAVE_EXTATTR_SET_FD */

/* Define to 1 if you have the `extattr_set_file' function. */
/* #undef HAVE_EXTATTR_SET_FILE */

/* Define to 1 if EXTATTR_NAMESPACE_USER is defined in sys/extattr.h. */
/* #undef HAVE_DECL_EXTATTR_NAMESPACE_USER */

/* Define to 1 if you have the `fchdir' function. */
#define HAVE_FCHDIR 1

/* Define to 1 if you have the `fchflags' function. */
/* #undef HAVE_FCHFLAGS */

/* Define to 1 if you have the `fchmod' function. */
#define HAVE_FCHMOD 1

/* Define to 1 if you have the `fchown' function. */
#define HAVE_FCHOWN 1

/* Define to 1 if you have the `fcntl' function. */
#define HAVE_FCNTL 1

/* Define to 1 if you have the <fcntl.h> header file. */
#define HAVE_FCNTL_H 1

/* Define to 1 if you have the `fdopendir' function. */
#define HAVE_FDOPENDIR 1

/* Define to 1 if you have the `fgetea' function. */
/* #undef HAVE_FGETEA */

/* Define to 1 if you have the `fgetxattr' function. */
/* #undef HAVE_FGETXATTR */

/* Define to 1 if you have the `flistea' function. */
/* #undef HAVE_FLISTEA */

/* Define to 1 if you have the `flistxattr' function. */
/* #undef HAVE_FLISTXATTR */

/* Define to 1 if you have the `fork' function. */
#define HAVE_FORK 1

/* Define to 1 if fseeko (and presumably ftello) exists and is declared. */
#define HAVE_FSEEKO 1

/* Define to 1 if you have the `fsetea' function. */
/* #undef HAVE_FSETEA */

/* Define to 1 if you have the `fsetxattr' function. */
/* #undef HAVE_FSETXATTR */

/* Define to 1 if you have the `fstat' function. */
#define HAVE_FSTAT 1

/* Define to 1 if you have the `fstatat' function. */
#define HAVE_FSTATAT 1

/* Define to 1 if you have the `fstatfs' function. */
#define HAVE_FSTATFS 1

/* Define to 1 if you have the `fstatvfs' function. */
#define HAVE_FSTATVFS 1

/* Define to 1 if you have the `ftruncate' function. */
#define HAVE_FTRUNCATE 1

/* Define to 1 if you have the `futimens' function. */
#define HAVE_FUTIMENS 1

/* Define to 1 if you have the `futimes' function. */
#define HAVE_FUTIMES 1

/* Define to 1 if you have the `futimesat' function. */
#define HAVE_FUTIMESAT 1

/* Define to 1 if you have the `getea' function. */
/* #undef HAVE_GETEA */

/* Define to 1 if you have the `geteuid' function. */
#define HAVE_GETEUID 1

/* Define to 1 if you have the `getgrgid_r' function. */
#define HAVE_GETGRGID_R 1

/* Define to 1 if you have the `getgrnam_r' function. */
#define HAVE_GETGRNAM_R 1

/* Define to 1 if you have the `getpid' function. */
#define HAVE_GETPID 1

/* Define to 1 if you have the `getpwnam_r' function. */
#define HAVE_GETPWNAM_R 1

/* Define to 1 if you have the `getpwuid_r' function. */
#define HAVE_GETPWUID_R 1

/* Define to 1 if you have the `getvfsbyname' function. */
/* #undef HAVE_GETVFSBYNAME */

/* Define to 1 if you have the `getxattr' function. */
/* #undef HAVE_GETXATTR */

/* Define to 1 if you have the `gmtime_r' function. */
#define HAVE_GMTIME_R 1

/* Define to 1 if you have the <grp.h> header file. */
#define HAVE_GRP_H 1

/* Define to 1 if you have the `iconv' function. */
/* #undef HAVE_ICONV */

/* Define to 1 if you have the <iconv.h> header file. */
/* #undef HAVE_ICONV_H */

/* Define to 1 if you have the <inttypes.h> header file. */
#define HAVE_INTTYPES_H 1

/* Define to 1 if you have the <io.h> header file. */
/* #undef HAVE_IO_H */

/* Define to 1 if you have the <langinfo.h> header file. */
#define HAVE_LANGINFO_H 1

/* Define to 1 if you have the `lchflags' function. */
/* #undef HAVE_LCHFLAGS */

/* Define to 1 if you have the `lchmod' function. */
/* #undef HAVE_LCHMOD */

/* Define to 1 if you have the `lchown' function. */
#define HAVE_LCHOWN 1

/* Define to 1 if you have the `lgetea' function. */
/* #undef HAVE_LGETEA */

/* Define to 1 if you have the `lgetxattr' function. */
/* #undef HAVE_LGETXATTR */

/* Define to 1 if you have the `acl' library (-lacl). */
/* #undef HAVE_LIBACL */

/* Define to 1 if you have the `attr' library (-lattr). */
/* #undef HAVE_LIBATTR */

/* Define to 1 if you have the `bsdxml' library (-lbsdxml). */
/* #undef HAVE_LIBBSDXML */

/* Define to 1 if you have the `bz2' library (-lbz2). */
#define HAVE_LIBBZ2 1

/* Define to 1 if you have the `expat' library (-lexpat). */
/* #undef HAVE_LIBEXPAT */

/* Define to 1 if you have the `gcc' library (-lgcc). */
/* #undef HAVE_LIBGCC */

/* Define to 1 if you have the `lzma' library (-llzma). */
/* #undef HAVE_LIBLZMA */

/* Define to 1 if you have the `lzmadec' library (-llzmadec). */
/* #undef HAVE_LIBLZMADEC */

/* Define to 1 if you have the `lzo2' library (-llzo2). */
/* #undef HAVE_LIBLZO2 */

/* Define to 1 if you have the `nettle' library (-lnettle). */
/* #undef HAVE_LIBNETTLE */

/* Define to 1 if you have the `pcre' library (-lpcre). */
/* #undef HAVE_LIBPCRE */

/* Define to 1 if you have the `pcreposix' library (-lpcreposix). */
/* #undef HAVE_LIBPCREPOSIX */

/* Define to 1 if you have the `xml2' library (-lxml2). */
/* #undef HAVE_LIBXML2 */

/* Define to 1 if you have the <libxml/xmlreader.h> header file. */
/* #undef HAVE_LIBXML_XMLREADER_H */

/* Define to 1 if you have the <libxml/xmlwriter.h> header file. */
/* #undef HAVE_LIBXML_XMLWRITER_H */

/* Define to 1 if you have the `z' library (-lz). */
#define HAVE_LIBZ 1

/* Define to 1 if you have the <limits.h> header file. */
#define HAVE_LIMITS_H 1

/* Define to 1 if you have the `link' function. */
#define HAVE_LINK 1

/* Define to 1 if you have the <linux/types.h> header file. */
#define HAVE_LINUX_TYPES_H 1

/* Define to 1 if you have the <linux/fiemap.h> header file. */
#define HAVE_LINUX_FIEMAP_H 1

/* Define to 1 if you have the <linux/fs.h> header file. */
#define HAVE_LINUX_FS_H 1

/* Define to 1 if you have the <linux/magic.h> header file. */
#define HAVE_LINUX_MAGIC_H 1

/* Define to 1 if you have the <linux/types.h> header file. */
#define HAVE_LINUX_TYPES_H 1

/* Define to 1 if you have the `listea' function. */
/* #undef HAVE_LISTEA */

/* Define to 1 if you have the `listxattr' function. */
/* #undef HAVE_LISTXATTR */

/* Define to 1 if you have the `llistea' function. */
/* #undef HAVE_LLISTEA */

/* Define to 1 if you have the `llistxattr' function. */
/* #undef HAVE_LLISTXATTR */

/* Define to 1 if you have the <localcharset.h> header file. */
/* #undef HAVE_LOCALCHARSET_H */

/* Define to 1 if you have the `locale_charset' function. */
/* #undef HAVE_LOCALE_CHARSET */

/* Define to 1 if you have the <locale.h> header file. */
#define HAVE_LOCALE_H 1

/* Define to 1 if you have the `localtime_r' function. */
#define HAVE_LOCALTIME_R 1

/* Define to 1 if the system has the type `long long int'. */
/* #undef HAVE_LONG_LONG_INT */

/* Define to 1 if you have the `lsetea' function. */
/* #undef HAVE_LSETEA */

/* Define to 1 if you have the `lsetxattr' function. */
/* #undef HAVE_LSETXATTR */

/* Define to 1 if you have the `lstat' function. */
#define HAVE_LSTAT 1

/* Define to 1 if `lstat' has the bug that it succeeds when given the
   zero-length file name argument. */
/* #undef HAVE_LSTAT_EMPTY_STRING_BUG */

/* Define to 1 if you have the `lutimes' function. */
#define HAVE_LUTIMES 1

/* Define to 1 if you have the <lzmadec.h> header file. */
/* #undef HAVE_LZMADEC_H */

/* Define to 1 if you have the <lzma.h> header file. */
/* #undef HAVE_LZMA_H */

/* Define to 1 if you have the <lzo/lzo1x.h> header file. */
/* #undef HAVE_LZO_LZO1X_H */

/* Define to 1 if you have the <lzo/lzoconf.h> header file. */
/* #undef HAVE_LZO_LZOCONF_H */

/* Define to 1 if you have the `mbrtowc' function. */
#define HAVE_MBRTOWC 1

/* Define to 1 if you have the `memmove' function. */
#define HAVE_MEMMOVE 1

/* Define to 1 if you have the <memory.h> header file. */
#define HAVE_MEMORY_H 1

/* Define to 1 if you have the `mkdir' function. */
#define HAVE_MKDIR 1

/* Define to 1 if you have the `mkfifo' function. */
#define HAVE_MKFIFO 1

/* Define to 1 if you have the `mknod' function. */
#define HAVE_MKNOD 1

/* Define to 1 if you have the `mkstemp' function. */
#define HAVE_MKSTEMP 1

/* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */
/* #undef HAVE_NDIR_H */

/* Define to 1 if you have the <nettle/md5.h> header file. */
/* #undef HAVE_NETTLE_MD5_H */

/* Define to 1 if you have the <nettle/ripemd160.h> header file. */
/* #undef HAVE_NETTLE_RIPEMD160_H */

/* Define to 1 if you have the <nettle/sha.h> header file. */
/* #undef HAVE_NETTLE_SHA_H */

/* Define to 1 if you have the `nl_langinfo' function. */
#define HAVE_NL_LANGINFO 1

/* Define to 1 if you have the `openat' function. */
#define HAVE_OPENAT 1

/* Define to 1 if you have the <paths.h> header file. */
#define HAVE_PATHS_H 1

/* Define to 1 if you have the <pcreposix.h> header file. */
/* #undef HAVE_PCREPOSIX_H */

/* Define to 1 if you have the `pipe' function. */
#define HAVE_PIPE 1

/* Define to 1 if you have the `poll' function. */
#define HAVE_POLL 1

/* Define to 1 if you have the <poll.h> header file. */
#define HAVE_POLL_H 1

/* Define to 1 if you have the `posix_spawnp' function. */
#define HAVE_POSIX_SPAWNP 1

/* Define to 1 if you have the <process.h> header file. */
/* #undef HAVE_PROCESS_H */

/* Define to 1 if you have the <pwd.h> header file. */
#define HAVE_PWD_H 1

/* Define to 1 if you have the `readdir_r' function. */
#define HAVE_READDIR_R 1

/* Define to 1 if you have the `readlink' function. */
#define HAVE_READLINK 1

/* Define to 1 if you have the `readlinkat' function. */
#define HAVE_READLINKAT 1

/* Define to 1 if you have the <regex.h> header file. */
#define HAVE_REGEX_H 1

/* Define to 1 if you have the `select' function. */
#define HAVE_SELECT 1

/* Define to 1 if you have the `setenv' function. */
#define HAVE_SETENV 1

/* Define to 1 if you have the `setlocale' function. */
#define HAVE_SETLOCALE 1

/* Define to 1 if you have the `sigaction' function. */
#define HAVE_SIGACTION 1

/* Define to 1 if you have the <signal.h> header file. */
#define HAVE_SIGNAL_H 1

/* Define to 1 if you have the <spawn.h> header file. */
#define HAVE_SPAWN_H 1

/* Define to 1 if you have the `statfs' function. */
#define HAVE_STATFS 1

/* Define to 1 if you have the `statvfs' function. */
#define HAVE_STATVFS 1

/* Define to 1 if `stat' has the bug that it succeeds when given the
   zero-length file name argument. */
/* #undef HAVE_STAT_EMPTY_STRING_BUG */

/* Define to 1 if you have the <stdarg.h> header file. */
#define HAVE_STDARG_H 1

/* Define to 1 if you have the <stdint.h> header file. */
#define HAVE_STDINT_H 1

/* Define to 1 if you have the <stdlib.h> header file. */
#define HAVE_STDLIB_H 1

/* Define to 1 if you have the `strchr' function. */
#define HAVE_STRCHR 1

/* Define to 1 if you have the `strdup' function. */
#define HAVE_STRDUP 1

/* Define to 1 if you have the `strerror' function. */
#define HAVE_STRERROR 1

/* Define to 1 if you have the `strerror_r' function. */
#define HAVE_STRERROR_R 1

/* Define to 1 if you have the `strftime' function. */
#define HAVE_STRFTIME 1

/* Define to 1 if you have the <strings.h> header file. */
#define HAVE_STRINGS_H 1

/* Define to 1 if you have the <string.h> header file. */
#define HAVE_STRING_H 1

/* Define to 1 if you have the `strrchr' function. */
#define HAVE_STRRCHR 1

/* Define to 1 if `f_namemax' is a member of `struct statfs'. */
/* #undef HAVE_STRUCT_STATFS_F_NAMEMAX */

/* Define to 1 if `f_iosize' is a member of `struct statvfs'. */
/* #undef HAVE_STRUCT_STATVFS_F_IOSIZE */

/* Define to 1 if `st_birthtime' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIME */

/* Define to 1 if `st_birthtimespec.tv_nsec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC_TV_NSEC */

/* Define to 1 if `st_blksize' is a member of `struct stat'. */
#define HAVE_STRUCT_STAT_ST_BLKSIZE 1

/* Define to 1 if `st_flags' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_FLAGS */

/* Define to 1 if `st_mtimespec.tv_nsec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC */

/* Define to 1 if `st_mtime_n' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIME_N */

/* Define to 1 if `st_mtime_usec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIME_USEC */

/* Define to 1 if `st_mtim.tv_nsec' is a member of `struct stat'. */
#define HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC 1

/* Define to 1 if `st_umtime' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_UMTIME */

/* Define to 1 if `tm_gmtoff' is a member of `struct tm'. */
#define HAVE_STRUCT_TM_TM_GMTOFF 1

/* Define to 1 if `__tm_gmtoff' is a member of `struct tm'. */
/* #undef HAVE_STRUCT_TM___TM_GMTOFF */

/* Define to 1 if you have the `symlink' function. */
#define HAVE_SYMLINK 1

/* Define to 1 if you have the <sys/acl.h> header file. */
/* #undef HAVE_SYS_ACL_H */

/* Define to 1 if you have the <sys/cdefs.h> header file. */
#define HAVE_SYS_CDEFS_H 1

/* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.
   */
/* #undef HAVE_SYS_DIR_H */

/* Define to 1 if you have the <sys/ea.h> header file. */
/* #undef HAVE_SYS_EA_H */

/* Define to 1 if you have the <sys/extattr.h> header file. */
/* #undef HAVE_SYS_EXTATTR_H */

/* Define to 1 if you have the <sys/ioctl.h> header file. */
#define HAVE_SYS_IOCTL_H 1

/* Define to 1 if you have the <sys/mkdev.h> header file. */
/* #undef HAVE_SYS_MKDEV_H */

/* Define to 1 if you have the <sys/mount.h> header file. */
/* #undef HAVE_SYS_MOUNT_H */

/* Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.
   */
/* #undef HAVE_SYS_NDIR_H */

/* Define to 1 if you have the <sys/param.h> header file. */
#define HAVE_SYS_PARAM_H 1

/* Define to 1 if you have the <sys/poll.h> header file. */
#define HAVE_SYS_POLL_H 1

/* Define to 1 if you have the <sys/select.h> header file. */
#define HAVE_SYS_SELECT_H 1

/* Define to 1 if you have the <sys/statfs.h> header file. */
#define HAVE_SYS_STATFS_H 1

/* Define to 1 if you have the <sys/statvfs.h> header file. */
#define HAVE_SYS_STATVFS_H 1

/* Define to 1 if you have the <sys/stat.h> header file. */
#define HAVE_SYS_STAT_H 1

/* Define to 1 if you have the <sys/time.h> header file. */
#define HAVE_SYS_TIME_H 1

/* Define to 1 if you have the <sys/types.h> header file. */
#define HAVE_SYS_TYPES_H 1

/* Define to 1 if you have the <sys/utime.h> header file. */
/* #undef HAVE_SYS_UTIME_H */

/* Define to 1 if you have the <sys/utsname.h> header file. */
#define HAVE_SYS_UTSNAME_H 1

/* Define to 1 if you have the <sys/vfs.h> header file. */
#define HAVE_SYS_VFS_H 1

/* Define to 1 if you have <sys/wait.h> that is POSIX.1 compatible. */
#define HAVE_SYS_WAIT_H 1

/* Define to 1 if you have the <sys/xattr.h> header file. */
/* #undef HAVE_SYS_XATTR_H */

/* Define to 1 if you have the `timegm' function. */
#define HAVE_TIMEGM 1

/* Define to 1 if you have the <time.h> header file. */
#define HAVE_TIME_H 1

/* Define to 1 if you have the `tzset' function. */
#define HAVE_TZSET 1

/* Define to 1 if you have the <unistd.h> header file. */
#define HAVE_UNISTD_H 1

/* Define to 1 if you have the `unsetenv' function. */
#define HAVE_UNSETENV 1

/* Define to 1 if the system has the type `unsigned long long'. */
/* #undef HAVE_UNSIGNED_LONG_LONG */

/* Define to 1 if the system has the type `unsigned long long int'. */
/* #undef HAVE_UNSIGNED_LONG_LONG_INT */

/* Define to 1 if you have the `utime' function. */
#define HAVE_UTIME 1

/* Define to 1 if you have the `utimensat' function. */
#define HAVE_UTIMENSAT 1

/* Define to 1 if you have the `utimes' function. */
#define HAVE_UTIMES 1

/* Define to 1 if you have the <utime.h> header file. */
#define HAVE_UTIME_H 1

/* Define to 1 if you have the `vfork' function. */
#define HAVE_VFORK 1

/* Define to 1 if you have the `vprintf' function. */
#define HAVE_VPRINTF 1

/* Define to 1 if you have the <wchar.h> header file. */
#define HAVE_WCHAR_H 1

/* Define to 1 if the system has the type `wchar_t'. */
#define HAVE_WCHAR_T 1

/* Define to 1 if you have the `wcrtomb' function. */
#define HAVE_WCRTOMB 1

/* Define to 1 if you have the `wcscmp' function. */
#define HAVE_WCSCMP 1

/* Define to 1 if you have the `wcscpy' function. */
#define HAVE_WCSCPY 1

/* Define to 1 if you have the `wcslen' function. */
#define HAVE_WCSLEN 1

/* Define to 1 if you have the `wctomb' function. */
#define HAVE_WCTOMB 1

/* Define to 1 if you have the <wctype.h> header file. */
#define HAVE_WCTYPE_H 1

/* Define to 1 if you have the <wincrypt.h> header file. */
/* #undef HAVE_WINCRYPT_H */

/* Define to 1 if you have the <windows.h> header file. */
/* #undef HAVE_WINDOWS_H */

/* Define to 1 if you have the <winioctl.h> header file. */
/* #undef HAVE_WINIOCTL_H */

/* Define to 1 if you have _CrtSetReportMode in <crtdbg.h>  */
/* #undef HAVE__CrtSetReportMode */

/* Define to 1 if you have the `wmemcmp' function. */
#define HAVE_WMEMCMP 1

/* Define to 1 if you have the `wmemcpy' function. */
#define HAVE_WMEMCPY 1

/* Define to 1 if you have a working EXT2_IOC_GETFLAGS */
/* #undef HAVE_WORKING_EXT2_IOC_GETFLAGS */

/* Define to 1 if you have the <zlib.h> header file. */
#define HAVE_ZLIB_H 1

/* Define to 1 if you have the `_ctime64_s' function. */
/* #undef HAVE__CTIME64_S */

/* Define to 1 if you have the `_fseeki64' function. */
/* #undef HAVE__FSEEKI64 */

/* Define to 1 if you have the `_get_timezone' function. */
/* #undef HAVE__GET_TIMEZONE */

/* Define to 1 if you have the `_localtime64_s' function. */
/* #undef HAVE__LOCALTIME64_S */

/* Define to 1 if you have the `_mkgmtime64' function. */
/* #undef HAVE__MKGMTIME64 */

/* Define as const if the declaration of iconv() needs const. */
#define ICONV_CONST 

/* Version number of libarchive as a single integer */
#define LIBARCHIVE_VERSION_NUMBER "3001002"

/* Version number of libarchive */
#define LIBARCHIVE_VERSION_STRING "3.1.2"

/* Define to 1 if `lstat' dereferences a symlink specified with a trailing
   slash. */
/* #undef LSTAT_FOLLOWS_SLASHED_SYMLINK */

/* Define to 1 if `major', `minor', and `makedev' are declared in <mkdev.h>.
   */
/* #undef MAJOR_IN_MKDEV */

/* Define to 1 if `major', `minor', and `makedev' are declared in
   <sysmacros.h>. */
#define MAJOR_IN_SYSMACROS 1

/* Define to 1 if your C compiler doesn't accept -c and -o together. */
/* #undef NO_MINUS_C_MINUS_O */

/* The size of `wchar_t', as computed by sizeof. */
#define SIZEOF_WCHAR_T 4

/* Define to 1 if strerror_r returns char *. */
/* #undef STRERROR_R_CHAR_P */

/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
#define TIME_WITH_SYS_TIME 1

/*
 * Some platform requires a macro to use extension functions.
 */
#define SAFE_TO_DEFINE_EXTENSIONS 1
#ifdef SAFE_TO_DEFINE_EXTENSIONS
/* Enable extensions on AIX 3, Interix.  */
#ifndef _ALL_SOURCE
# define _ALL_SOURCE 1
#endif
/* Enable GNU extensions on systems that have them.  */
#ifndef _GNU_SOURCE
# define _GNU_SOURCE 1
#endif
/* Enable threading extensions on Solaris.  */
#ifndef _POSIX_PTHREAD_SEMANTICS
# define _POSIX_PTHREAD_SEMANTICS 1
#endif
/* Enable extensions on HP NonStop.  */
#ifndef _TANDEM_SOURCE
# define _TANDEM_SOURCE 1
#endif
/* Enable general extensions on Solaris.  */
#ifndef __EXTENSIONS__
# define __EXTENSIONS__ 1
#endif
#endif /* SAFE_TO_DEFINE_EXTENSIONS */

/* Version number of package */
#define VERSION "3.1.2"

/* Number of bits in a file offset, on hosts where this is settable. */
/* #undef _FILE_OFFSET_BITS */

/* Define to 1 to make fseeko visible on some hosts (e.g. glibc 2.2). */
/* #undef _LARGEFILE_SOURCE */

/* Define for large files, on AIX-style hosts. */
/* #undef _LARGE_FILES */

/* Define for Windows to use Windows 2000+ APIs. */
/* #undef _WIN32_WINNT */
/* #undef WINVER */

/* Define to empty if `const' does not conform to ANSI C. */
/* #undef const */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef gid_t */

/* Define to `unsigned long' if <sys/types.h> does not define. */
/* #undef id_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef mode_t */

/* Define to `long long' if <sys/types.h> does not define. */
/* #undef off_t */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef pid_t */

/* Define to `unsigned int' if <sys/types.h> does not define. */
/* #undef size_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef ssize_t */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef uid_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef intptr_t */

/* Define to `unsigned int' if <sys/types.h> does not define. */
/* #undef uintptr_t */


#define ARCHIVE_SHA256_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA256_LIBMD
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = (DWORD)bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. Nettle
 * 6. OpenSSL
 * 7. libmd
 * 8. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive_sha256_ctx ctx;
  archive_sha256_init(&ctx);
  archive_sha256_update(&ctx, *argv, argc);
  archive_sha256_final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA512_LIBMD failed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3297811323/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3297811323.dir/build.make CMakeFiles/cmTryCompileExec3297811323.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3297811323.dir/check_crypto_md.c.o
/usr/bin/gcc   -w  -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2 -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmlibarchive/libarchive -I/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec3297811323.dir/check_crypto_md.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/check_crypto_md.c:1186:0:
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:103:20: fatal error: sha512.h: No such file or directory
 #include <sha512.h>
                    ^
compilation terminated.
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec3297811323.dir/check_crypto_md.c.o] Error 1
make[4]: *** [cmTryCompileExec3297811323/fast] Error 2
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

Source file was:
/* config.h.  Generated from build/cmake/config.h.in by cmake configure */
#if defined(__osf__)
# define _OSF_SOURCE
#endif

/*
 * Ensure we have C99-style int64_t, etc, all defined.
 */

/* First, we need to know if the system has already defined them. */
#define HAVE_INT16_T
#define HAVE_INT32_T
#define HAVE_INT64_T
#define HAVE_INTMAX_T

#define HAVE_UINT8_T
#define HAVE_UINT16_T
#define HAVE_UINT32_T
#define HAVE_UINT64_T
#define HAVE_UINTMAX_T

/* We might have the types we want under other spellings. */
/* #undef HAVE___INT64 */
/* #undef HAVE_U_INT64_T */
/* #undef HAVE_UNSIGNED___INT64 */

/* The sizes of various standard integer types. */
#define SIZE_OF_SHORT 2
#define SIZE_OF_INT 4
#define SIZE_OF_LONG 8
#define SIZE_OF_LONG_LONG 8
#define SIZE_OF_UNSIGNED_SHORT 2
#define SIZE_OF_UNSIGNED 4
#define SIZE_OF_UNSIGNED_LONG 8
#define SIZE_OF_UNSIGNED_LONG_LONG 8

/*
 * If we lack int64_t, define it to the first of __int64, int, long, and long long
 * that exists and is the right size.
 */
#if !defined(HAVE_INT64_T) && defined(HAVE___INT64)
typedef __int64 int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_INT == 8
typedef int int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_LONG == 8
typedef long int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T) && SIZE_OF_LONG_LONG == 8
typedef long long int64_t;
#define HAVE_INT64_T
#endif

#if !defined(HAVE_INT64_T)
#error No 64-bit integer type was found.
#endif

/*
 * Similarly for int32_t
 */
#if !defined(HAVE_INT32_T) && SIZE_OF_INT == 4
typedef long int32_t;
#define HAVE_INT32_T
#endif

#if !defined(HAVE_INT32_T) && SIZE_OF_LONG == 4
typedef long int32_t;
#define HAVE_INT32_T
#endif

#if !defined(HAVE_INT32_T)
#error No 32-bit integer type was found.
#endif

/*
 * Similarly for int16_t
 */
#if !defined(HAVE_INT16_T) && SIZE_OF_INT == 2
typedef int int16_t;
#define HAVE_INT16_T
#endif

#if !defined(HAVE_INT16_T) && SIZE_OF_SHORT == 2
typedef short int16_t;
#define HAVE_INT16_T
#endif

#if !defined(HAVE_INT16_T)
#error No 16-bit integer type was found.
#endif

/*
 * Similarly for uint64_t
 */
#if !defined(HAVE_UINT64_T) && defined(HAVE_UNSIGNED___INT64)
typedef unsigned __int64 uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED == 8
typedef unsigned uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED_LONG == 8
typedef unsigned long uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED_LONG_LONG == 8
typedef unsigned long long uint64_t;
#define HAVE_UINT64_T
#endif

#if !defined(HAVE_UINT64_T)
#error No 64-bit unsigned integer type was found.
#endif


/*
 * Similarly for uint32_t
 */
#if !defined(HAVE_UINT32_T) && SIZE_OF_UNSIGNED == 4
typedef unsigned uint32_t;
#define HAVE_UINT32_T
#endif

#if !defined(HAVE_UINT32_T) && SIZE_OF_UNSIGNED_LONG == 4
typedef unsigned long uint32_t;
#define HAVE_UINT32_T
#endif

#if !defined(HAVE_UINT32_T)
#error No 32-bit unsigned integer type was found.
#endif

/*
 * Similarly for uint16_t
 */
#if !defined(HAVE_UINT16_T) && SIZE_OF_UNSIGNED == 2
typedef unsigned uint16_t;
#define HAVE_UINT16_T
#endif

#if !defined(HAVE_UINT16_T) && SIZE_OF_UNSIGNED_SHORT == 2
typedef unsigned short uint16_t;
#define HAVE_UINT16_T
#endif

#if !defined(HAVE_UINT16_T)
#error No 16-bit unsigned integer type was found.
#endif

/*
 * Similarly for uint8_t
 */
#if !defined(HAVE_UINT8_T)
typedef unsigned char uint8_t;
#define HAVE_UINT8_T
#endif

#if !defined(HAVE_UINT16_T)
#error No 8-bit unsigned integer type was found.
#endif

/* Define intmax_t and uintmax_t if they are not already defined. */
#if !defined(HAVE_INTMAX_T)
typedef int64_t intmax_t;
#define INTMAX_MIN INT64_MIN
#define INTMAX_MAX INT64_MAX
#endif

#if !defined(HAVE_UINTMAX_T)
typedef uint64_t uintmax_t;
#endif

/* Define ZLIB_WINAPI if zlib was built on Visual Studio. */
/* #undef ZLIB_WINAPI */

/* MD5 via ARCHIVE_CRYPTO_MD5_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_MD5_LIBC */

/* MD5 via ARCHIVE_CRYPTO_MD5_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_MD5_LIBSYSTEM */

/* MD5 via ARCHIVE_CRYPTO_MD5_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_MD5_NETTLE */

/* MD5 via ARCHIVE_CRYPTO_MD5_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_MD5_OPENSSL */

/* MD5 via ARCHIVE_CRYPTO_MD5_WIN supported. */
/* #undef ARCHIVE_CRYPTO_MD5_WIN */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_LIBC */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_NETTLE */

/* RMD160 via ARCHIVE_CRYPTO_RMD160_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_RMD160_OPENSSL */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_LIBC */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_LIBSYSTEM */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_NETTLE */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_OPENSSL */

/* SHA1 via ARCHIVE_CRYPTO_SHA1_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA1_WIN */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC2 */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBC3 */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_LIBSYSTEM */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_NETTLE */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_OPENSSL */

/* SHA256 via ARCHIVE_CRYPTO_SHA256_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA256_WIN */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC2 */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBC3 */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_LIBSYSTEM */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_NETTLE */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_OPENSSL */

/* SHA384 via ARCHIVE_CRYPTO_SHA384_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA384_WIN */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC2 supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC2 */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC3 supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBC3 */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBSYSTEM supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_LIBSYSTEM */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_NETTLE supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_NETTLE */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_OPENSSL supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_OPENSSL */

/* SHA512 via ARCHIVE_CRYPTO_SHA512_WIN supported. */
/* #undef ARCHIVE_CRYPTO_SHA512_WIN */

/* Version number of bsdcpio */
#define BSDCPIO_VERSION_STRING "3.1.2"

/* Version number of bsdtar */
#define BSDTAR_VERSION_STRING "3.1.2"

/* Define to 1 if you have the `acl_create_entry' function. */
/* #undef HAVE_ACL_CREATE_ENTRY */

/* Define to 1 if you have the `acl_get_link' function. */
/* #undef HAVE_ACL_GET_LINK */

/* Define to 1 if you have the `acl_get_link_np' function. */
/* #undef HAVE_ACL_GET_LINK_NP */

/* Define to 1 if you have the `acl_get_perm' function. */
/* #undef HAVE_ACL_GET_PERM */

/* Define to 1 if you have the `acl_get_perm_np' function. */
/* #undef HAVE_ACL_GET_PERM_NP */

/* Define to 1 if you have the `acl_init' function. */
/* #undef HAVE_ACL_INIT */

/* Define to 1 if you have the <acl/libacl.h> header file. */
/* #undef HAVE_ACL_LIBACL_H */

/* Define to 1 if the system has the type `acl_permset_t'. */
/* #undef HAVE_ACL_PERMSET_T */

/* Define to 1 if you have the `acl_set_fd' function. */
/* #undef HAVE_ACL_SET_FD */

/* Define to 1 if you have the `acl_set_fd_np' function. */
/* #undef HAVE_ACL_SET_FD_NP */

/* Define to 1 if you have the `acl_set_file' function. */
/* #undef HAVE_ACL_SET_FILE */

/* True for systems with POSIX ACL support */
/* #undef HAVE_ACL_USER */

/* Define to 1 if you have the <attr/xattr.h> header file. */
/* #undef HAVE_ATTR_XATTR_H */

/* Define to 1 if you have the <bsdxml.h> header file. */
/* #undef HAVE_BSDXML_H */

/* Define to 1 if you have the <bzlib.h> header file. */
#define HAVE_BZLIB_H 1

/* Define to 1 if you have the `chflags' function. */
/* #undef HAVE_CHFLAGS */

/* Define to 1 if you have the `chown' function. */
#define HAVE_CHOWN 1

/* Define to 1 if you have the `chroot' function. */
#define HAVE_CHROOT 1

/* Define to 1 if you have the <copyfile.h> header file. */
/* #undef HAVE_COPYFILE_H */

/* Define to 1 if you have the `ctime_r' function. */
#define HAVE_CTIME_R 1

/* Define to 1 if you have the <ctype.h> header file. */
#define HAVE_CTYPE_H 1

/* Define to 1 if you have the `cygwin_conv_path' function. */
/* #undef HAVE_CYGWIN_CONV_PATH */

/* Define to 1 if you have the declaration of `INT64_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_INT64_MAX 1

/* Define to 1 if you have the declaration of `INT64_MIN', and to 0 if you
   don't. */
#define HAVE_DECL_INT64_MIN 1

/* Define to 1 if you have the declaration of `SIZE_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_SIZE_MAX 1

/* Define to 1 if you have the declaration of `SSIZE_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_SSIZE_MAX 1

/* Define to 1 if you have the declaration of `strerror_r', and to 0 if you
   don't. */
#define HAVE_DECL_STRERROR_R 1

/* Define to 1 if you have the declaration of `UINT32_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_UINT32_MAX 1

/* Define to 1 if you have the declaration of `UINT64_MAX', and to 0 if you
   don't. */
#define HAVE_DECL_UINT64_MAX 1

/* Define to 1 if you have the <direct.h> header file. */
/* #undef HAVE_DIRECT_H */

/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.
   */
#define HAVE_DIRENT_H 1

/* Define to 1 if you have the `dirfd' function. */
#define HAVE_DIRFD 1

/* Define to 1 if you have the <dlfcn.h> header file. */
#define HAVE_DLFCN_H 1

/* Define to 1 if you don't have `vprintf' but do have `_doprnt.' */
/* #undef HAVE_DOPRNT */

/* Define to 1 if nl_langinfo supports D_MD_ORDER */
/* #undef HAVE_D_MD_ORDER */

/* A possible errno value for invalid file format errors */
/* #undef HAVE_EFTYPE */

/* A possible errno value for invalid file format errors */
#define HAVE_EILSEQ 1

/* Define to 1 if you have the <errno.h> header file. */
#define HAVE_ERRNO_H 1

/* Define to 1 if you have the <expat.h> header file. */
/* #undef HAVE_EXPAT_H */

/* Define to 1 if you have the <ext2fs/ext2_fs.h> header file. */
/* #undef HAVE_EXT2FS_EXT2_FS_H */

/* Define to 1 if you have the `extattr_get_file' function. */
/* #undef HAVE_EXTATTR_GET_FILE */

/* Define to 1 if you have the `extattr_list_file' function. */
/* #undef HAVE_EXTATTR_LIST_FILE */

/* Define to 1 if you have the `extattr_set_fd' function. */
/* #undef HAVE_EXTATTR_SET_FD */

/* Define to 1 if you have the `extattr_set_file' function. */
/* #undef HAVE_EXTATTR_SET_FILE */

/* Define to 1 if EXTATTR_NAMESPACE_USER is defined in sys/extattr.h. */
/* #undef HAVE_DECL_EXTATTR_NAMESPACE_USER */

/* Define to 1 if you have the `fchdir' function. */
#define HAVE_FCHDIR 1

/* Define to 1 if you have the `fchflags' function. */
/* #undef HAVE_FCHFLAGS */

/* Define to 1 if you have the `fchmod' function. */
#define HAVE_FCHMOD 1

/* Define to 1 if you have the `fchown' function. */
#define HAVE_FCHOWN 1

/* Define to 1 if you have the `fcntl' function. */
#define HAVE_FCNTL 1

/* Define to 1 if you have the <fcntl.h> header file. */
#define HAVE_FCNTL_H 1

/* Define to 1 if you have the `fdopendir' function. */
#define HAVE_FDOPENDIR 1

/* Define to 1 if you have the `fgetea' function. */
/* #undef HAVE_FGETEA */

/* Define to 1 if you have the `fgetxattr' function. */
/* #undef HAVE_FGETXATTR */

/* Define to 1 if you have the `flistea' function. */
/* #undef HAVE_FLISTEA */

/* Define to 1 if you have the `flistxattr' function. */
/* #undef HAVE_FLISTXATTR */

/* Define to 1 if you have the `fork' function. */
#define HAVE_FORK 1

/* Define to 1 if fseeko (and presumably ftello) exists and is declared. */
#define HAVE_FSEEKO 1

/* Define to 1 if you have the `fsetea' function. */
/* #undef HAVE_FSETEA */

/* Define to 1 if you have the `fsetxattr' function. */
/* #undef HAVE_FSETXATTR */

/* Define to 1 if you have the `fstat' function. */
#define HAVE_FSTAT 1

/* Define to 1 if you have the `fstatat' function. */
#define HAVE_FSTATAT 1

/* Define to 1 if you have the `fstatfs' function. */
#define HAVE_FSTATFS 1

/* Define to 1 if you have the `fstatvfs' function. */
#define HAVE_FSTATVFS 1

/* Define to 1 if you have the `ftruncate' function. */
#define HAVE_FTRUNCATE 1

/* Define to 1 if you have the `futimens' function. */
#define HAVE_FUTIMENS 1

/* Define to 1 if you have the `futimes' function. */
#define HAVE_FUTIMES 1

/* Define to 1 if you have the `futimesat' function. */
#define HAVE_FUTIMESAT 1

/* Define to 1 if you have the `getea' function. */
/* #undef HAVE_GETEA */

/* Define to 1 if you have the `geteuid' function. */
#define HAVE_GETEUID 1

/* Define to 1 if you have the `getgrgid_r' function. */
#define HAVE_GETGRGID_R 1

/* Define to 1 if you have the `getgrnam_r' function. */
#define HAVE_GETGRNAM_R 1

/* Define to 1 if you have the `getpid' function. */
#define HAVE_GETPID 1

/* Define to 1 if you have the `getpwnam_r' function. */
#define HAVE_GETPWNAM_R 1

/* Define to 1 if you have the `getpwuid_r' function. */
#define HAVE_GETPWUID_R 1

/* Define to 1 if you have the `getvfsbyname' function. */
/* #undef HAVE_GETVFSBYNAME */

/* Define to 1 if you have the `getxattr' function. */
/* #undef HAVE_GETXATTR */

/* Define to 1 if you have the `gmtime_r' function. */
#define HAVE_GMTIME_R 1

/* Define to 1 if you have the <grp.h> header file. */
#define HAVE_GRP_H 1

/* Define to 1 if you have the `iconv' function. */
/* #undef HAVE_ICONV */

/* Define to 1 if you have the <iconv.h> header file. */
/* #undef HAVE_ICONV_H */

/* Define to 1 if you have the <inttypes.h> header file. */
#define HAVE_INTTYPES_H 1

/* Define to 1 if you have the <io.h> header file. */
/* #undef HAVE_IO_H */

/* Define to 1 if you have the <langinfo.h> header file. */
#define HAVE_LANGINFO_H 1

/* Define to 1 if you have the `lchflags' function. */
/* #undef HAVE_LCHFLAGS */

/* Define to 1 if you have the `lchmod' function. */
/* #undef HAVE_LCHMOD */

/* Define to 1 if you have the `lchown' function. */
#define HAVE_LCHOWN 1

/* Define to 1 if you have the `lgetea' function. */
/* #undef HAVE_LGETEA */

/* Define to 1 if you have the `lgetxattr' function. */
/* #undef HAVE_LGETXATTR */

/* Define to 1 if you have the `acl' library (-lacl). */
/* #undef HAVE_LIBACL */

/* Define to 1 if you have the `attr' library (-lattr). */
/* #undef HAVE_LIBATTR */

/* Define to 1 if you have the `bsdxml' library (-lbsdxml). */
/* #undef HAVE_LIBBSDXML */

/* Define to 1 if you have the `bz2' library (-lbz2). */
#define HAVE_LIBBZ2 1

/* Define to 1 if you have the `expat' library (-lexpat). */
/* #undef HAVE_LIBEXPAT */

/* Define to 1 if you have the `gcc' library (-lgcc). */
/* #undef HAVE_LIBGCC */

/* Define to 1 if you have the `lzma' library (-llzma). */
/* #undef HAVE_LIBLZMA */

/* Define to 1 if you have the `lzmadec' library (-llzmadec). */
/* #undef HAVE_LIBLZMADEC */

/* Define to 1 if you have the `lzo2' library (-llzo2). */
/* #undef HAVE_LIBLZO2 */

/* Define to 1 if you have the `nettle' library (-lnettle). */
/* #undef HAVE_LIBNETTLE */

/* Define to 1 if you have the `pcre' library (-lpcre). */
/* #undef HAVE_LIBPCRE */

/* Define to 1 if you have the `pcreposix' library (-lpcreposix). */
/* #undef HAVE_LIBPCREPOSIX */

/* Define to 1 if you have the `xml2' library (-lxml2). */
/* #undef HAVE_LIBXML2 */

/* Define to 1 if you have the <libxml/xmlreader.h> header file. */
/* #undef HAVE_LIBXML_XMLREADER_H */

/* Define to 1 if you have the <libxml/xmlwriter.h> header file. */
/* #undef HAVE_LIBXML_XMLWRITER_H */

/* Define to 1 if you have the `z' library (-lz). */
#define HAVE_LIBZ 1

/* Define to 1 if you have the <limits.h> header file. */
#define HAVE_LIMITS_H 1

/* Define to 1 if you have the `link' function. */
#define HAVE_LINK 1

/* Define to 1 if you have the <linux/types.h> header file. */
#define HAVE_LINUX_TYPES_H 1

/* Define to 1 if you have the <linux/fiemap.h> header file. */
#define HAVE_LINUX_FIEMAP_H 1

/* Define to 1 if you have the <linux/fs.h> header file. */
#define HAVE_LINUX_FS_H 1

/* Define to 1 if you have the <linux/magic.h> header file. */
#define HAVE_LINUX_MAGIC_H 1

/* Define to 1 if you have the <linux/types.h> header file. */
#define HAVE_LINUX_TYPES_H 1

/* Define to 1 if you have the `listea' function. */
/* #undef HAVE_LISTEA */

/* Define to 1 if you have the `listxattr' function. */
/* #undef HAVE_LISTXATTR */

/* Define to 1 if you have the `llistea' function. */
/* #undef HAVE_LLISTEA */

/* Define to 1 if you have the `llistxattr' function. */
/* #undef HAVE_LLISTXATTR */

/* Define to 1 if you have the <localcharset.h> header file. */
/* #undef HAVE_LOCALCHARSET_H */

/* Define to 1 if you have the `locale_charset' function. */
/* #undef HAVE_LOCALE_CHARSET */

/* Define to 1 if you have the <locale.h> header file. */
#define HAVE_LOCALE_H 1

/* Define to 1 if you have the `localtime_r' function. */
#define HAVE_LOCALTIME_R 1

/* Define to 1 if the system has the type `long long int'. */
/* #undef HAVE_LONG_LONG_INT */

/* Define to 1 if you have the `lsetea' function. */
/* #undef HAVE_LSETEA */

/* Define to 1 if you have the `lsetxattr' function. */
/* #undef HAVE_LSETXATTR */

/* Define to 1 if you have the `lstat' function. */
#define HAVE_LSTAT 1

/* Define to 1 if `lstat' has the bug that it succeeds when given the
   zero-length file name argument. */
/* #undef HAVE_LSTAT_EMPTY_STRING_BUG */

/* Define to 1 if you have the `lutimes' function. */
#define HAVE_LUTIMES 1

/* Define to 1 if you have the <lzmadec.h> header file. */
/* #undef HAVE_LZMADEC_H */

/* Define to 1 if you have the <lzma.h> header file. */
/* #undef HAVE_LZMA_H */

/* Define to 1 if you have the <lzo/lzo1x.h> header file. */
/* #undef HAVE_LZO_LZO1X_H */

/* Define to 1 if you have the <lzo/lzoconf.h> header file. */
/* #undef HAVE_LZO_LZOCONF_H */

/* Define to 1 if you have the `mbrtowc' function. */
#define HAVE_MBRTOWC 1

/* Define to 1 if you have the `memmove' function. */
#define HAVE_MEMMOVE 1

/* Define to 1 if you have the <memory.h> header file. */
#define HAVE_MEMORY_H 1

/* Define to 1 if you have the `mkdir' function. */
#define HAVE_MKDIR 1

/* Define to 1 if you have the `mkfifo' function. */
#define HAVE_MKFIFO 1

/* Define to 1 if you have the `mknod' function. */
#define HAVE_MKNOD 1

/* Define to 1 if you have the `mkstemp' function. */
#define HAVE_MKSTEMP 1

/* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */
/* #undef HAVE_NDIR_H */

/* Define to 1 if you have the <nettle/md5.h> header file. */
/* #undef HAVE_NETTLE_MD5_H */

/* Define to 1 if you have the <nettle/ripemd160.h> header file. */
/* #undef HAVE_NETTLE_RIPEMD160_H */

/* Define to 1 if you have the <nettle/sha.h> header file. */
/* #undef HAVE_NETTLE_SHA_H */

/* Define to 1 if you have the `nl_langinfo' function. */
#define HAVE_NL_LANGINFO 1

/* Define to 1 if you have the `openat' function. */
#define HAVE_OPENAT 1

/* Define to 1 if you have the <paths.h> header file. */
#define HAVE_PATHS_H 1

/* Define to 1 if you have the <pcreposix.h> header file. */
/* #undef HAVE_PCREPOSIX_H */

/* Define to 1 if you have the `pipe' function. */
#define HAVE_PIPE 1

/* Define to 1 if you have the `poll' function. */
#define HAVE_POLL 1

/* Define to 1 if you have the <poll.h> header file. */
#define HAVE_POLL_H 1

/* Define to 1 if you have the `posix_spawnp' function. */
#define HAVE_POSIX_SPAWNP 1

/* Define to 1 if you have the <process.h> header file. */
/* #undef HAVE_PROCESS_H */

/* Define to 1 if you have the <pwd.h> header file. */
#define HAVE_PWD_H 1

/* Define to 1 if you have the `readdir_r' function. */
#define HAVE_READDIR_R 1

/* Define to 1 if you have the `readlink' function. */
#define HAVE_READLINK 1

/* Define to 1 if you have the `readlinkat' function. */
#define HAVE_READLINKAT 1

/* Define to 1 if you have the <regex.h> header file. */
#define HAVE_REGEX_H 1

/* Define to 1 if you have the `select' function. */
#define HAVE_SELECT 1

/* Define to 1 if you have the `setenv' function. */
#define HAVE_SETENV 1

/* Define to 1 if you have the `setlocale' function. */
#define HAVE_SETLOCALE 1

/* Define to 1 if you have the `sigaction' function. */
#define HAVE_SIGACTION 1

/* Define to 1 if you have the <signal.h> header file. */
#define HAVE_SIGNAL_H 1

/* Define to 1 if you have the <spawn.h> header file. */
#define HAVE_SPAWN_H 1

/* Define to 1 if you have the `statfs' function. */
#define HAVE_STATFS 1

/* Define to 1 if you have the `statvfs' function. */
#define HAVE_STATVFS 1

/* Define to 1 if `stat' has the bug that it succeeds when given the
   zero-length file name argument. */
/* #undef HAVE_STAT_EMPTY_STRING_BUG */

/* Define to 1 if you have the <stdarg.h> header file. */
#define HAVE_STDARG_H 1

/* Define to 1 if you have the <stdint.h> header file. */
#define HAVE_STDINT_H 1

/* Define to 1 if you have the <stdlib.h> header file. */
#define HAVE_STDLIB_H 1

/* Define to 1 if you have the `strchr' function. */
#define HAVE_STRCHR 1

/* Define to 1 if you have the `strdup' function. */
#define HAVE_STRDUP 1

/* Define to 1 if you have the `strerror' function. */
#define HAVE_STRERROR 1

/* Define to 1 if you have the `strerror_r' function. */
#define HAVE_STRERROR_R 1

/* Define to 1 if you have the `strftime' function. */
#define HAVE_STRFTIME 1

/* Define to 1 if you have the <strings.h> header file. */
#define HAVE_STRINGS_H 1

/* Define to 1 if you have the <string.h> header file. */
#define HAVE_STRING_H 1

/* Define to 1 if you have the `strrchr' function. */
#define HAVE_STRRCHR 1

/* Define to 1 if `f_namemax' is a member of `struct statfs'. */
/* #undef HAVE_STRUCT_STATFS_F_NAMEMAX */

/* Define to 1 if `f_iosize' is a member of `struct statvfs'. */
/* #undef HAVE_STRUCT_STATVFS_F_IOSIZE */

/* Define to 1 if `st_birthtime' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIME */

/* Define to 1 if `st_birthtimespec.tv_nsec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC_TV_NSEC */

/* Define to 1 if `st_blksize' is a member of `struct stat'. */
#define HAVE_STRUCT_STAT_ST_BLKSIZE 1

/* Define to 1 if `st_flags' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_FLAGS */

/* Define to 1 if `st_mtimespec.tv_nsec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC */

/* Define to 1 if `st_mtime_n' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIME_N */

/* Define to 1 if `st_mtime_usec' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_MTIME_USEC */

/* Define to 1 if `st_mtim.tv_nsec' is a member of `struct stat'. */
#define HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC 1

/* Define to 1 if `st_umtime' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_UMTIME */

/* Define to 1 if `tm_gmtoff' is a member of `struct tm'. */
#define HAVE_STRUCT_TM_TM_GMTOFF 1

/* Define to 1 if `__tm_gmtoff' is a member of `struct tm'. */
/* #undef HAVE_STRUCT_TM___TM_GMTOFF */

/* Define to 1 if you have the `symlink' function. */
#define HAVE_SYMLINK 1

/* Define to 1 if you have the <sys/acl.h> header file. */
/* #undef HAVE_SYS_ACL_H */

/* Define to 1 if you have the <sys/cdefs.h> header file. */
#define HAVE_SYS_CDEFS_H 1

/* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.
   */
/* #undef HAVE_SYS_DIR_H */

/* Define to 1 if you have the <sys/ea.h> header file. */
/* #undef HAVE_SYS_EA_H */

/* Define to 1 if you have the <sys/extattr.h> header file. */
/* #undef HAVE_SYS_EXTATTR_H */

/* Define to 1 if you have the <sys/ioctl.h> header file. */
#define HAVE_SYS_IOCTL_H 1

/* Define to 1 if you have the <sys/mkdev.h> header file. */
/* #undef HAVE_SYS_MKDEV_H */

/* Define to 1 if you have the <sys/mount.h> header file. */
/* #undef HAVE_SYS_MOUNT_H */

/* Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.
   */
/* #undef HAVE_SYS_NDIR_H */

/* Define to 1 if you have the <sys/param.h> header file. */
#define HAVE_SYS_PARAM_H 1

/* Define to 1 if you have the <sys/poll.h> header file. */
#define HAVE_SYS_POLL_H 1

/* Define to 1 if you have the <sys/select.h> header file. */
#define HAVE_SYS_SELECT_H 1

/* Define to 1 if you have the <sys/statfs.h> header file. */
#define HAVE_SYS_STATFS_H 1

/* Define to 1 if you have the <sys/statvfs.h> header file. */
#define HAVE_SYS_STATVFS_H 1

/* Define to 1 if you have the <sys/stat.h> header file. */
#define HAVE_SYS_STAT_H 1

/* Define to 1 if you have the <sys/time.h> header file. */
#define HAVE_SYS_TIME_H 1

/* Define to 1 if you have the <sys/types.h> header file. */
#define HAVE_SYS_TYPES_H 1

/* Define to 1 if you have the <sys/utime.h> header file. */
/* #undef HAVE_SYS_UTIME_H */

/* Define to 1 if you have the <sys/utsname.h> header file. */
#define HAVE_SYS_UTSNAME_H 1

/* Define to 1 if you have the <sys/vfs.h> header file. */
#define HAVE_SYS_VFS_H 1

/* Define to 1 if you have <sys/wait.h> that is POSIX.1 compatible. */
#define HAVE_SYS_WAIT_H 1

/* Define to 1 if you have the <sys/xattr.h> header file. */
/* #undef HAVE_SYS_XATTR_H */

/* Define to 1 if you have the `timegm' function. */
#define HAVE_TIMEGM 1

/* Define to 1 if you have the <time.h> header file. */
#define HAVE_TIME_H 1

/* Define to 1 if you have the `tzset' function. */
#define HAVE_TZSET 1

/* Define to 1 if you have the <unistd.h> header file. */
#define HAVE_UNISTD_H 1

/* Define to 1 if you have the `unsetenv' function. */
#define HAVE_UNSETENV 1

/* Define to 1 if the system has the type `unsigned long long'. */
/* #undef HAVE_UNSIGNED_LONG_LONG */

/* Define to 1 if the system has the type `unsigned long long int'. */
/* #undef HAVE_UNSIGNED_LONG_LONG_INT */

/* Define to 1 if you have the `utime' function. */
#define HAVE_UTIME 1

/* Define to 1 if you have the `utimensat' function. */
#define HAVE_UTIMENSAT 1

/* Define to 1 if you have the `utimes' function. */
#define HAVE_UTIMES 1

/* Define to 1 if you have the <utime.h> header file. */
#define HAVE_UTIME_H 1

/* Define to 1 if you have the `vfork' function. */
#define HAVE_VFORK 1

/* Define to 1 if you have the `vprintf' function. */
#define HAVE_VPRINTF 1

/* Define to 1 if you have the <wchar.h> header file. */
#define HAVE_WCHAR_H 1

/* Define to 1 if the system has the type `wchar_t'. */
#define HAVE_WCHAR_T 1

/* Define to 1 if you have the `wcrtomb' function. */
#define HAVE_WCRTOMB 1

/* Define to 1 if you have the `wcscmp' function. */
#define HAVE_WCSCMP 1

/* Define to 1 if you have the `wcscpy' function. */
#define HAVE_WCSCPY 1

/* Define to 1 if you have the `wcslen' function. */
#define HAVE_WCSLEN 1

/* Define to 1 if you have the `wctomb' function. */
#define HAVE_WCTOMB 1

/* Define to 1 if you have the <wctype.h> header file. */
#define HAVE_WCTYPE_H 1

/* Define to 1 if you have the <wincrypt.h> header file. */
/* #undef HAVE_WINCRYPT_H */

/* Define to 1 if you have the <windows.h> header file. */
/* #undef HAVE_WINDOWS_H */

/* Define to 1 if you have the <winioctl.h> header file. */
/* #undef HAVE_WINIOCTL_H */

/* Define to 1 if you have _CrtSetReportMode in <crtdbg.h>  */
/* #undef HAVE__CrtSetReportMode */

/* Define to 1 if you have the `wmemcmp' function. */
#define HAVE_WMEMCMP 1

/* Define to 1 if you have the `wmemcpy' function. */
#define HAVE_WMEMCPY 1

/* Define to 1 if you have a working EXT2_IOC_GETFLAGS */
/* #undef HAVE_WORKING_EXT2_IOC_GETFLAGS */

/* Define to 1 if you have the <zlib.h> header file. */
#define HAVE_ZLIB_H 1

/* Define to 1 if you have the `_ctime64_s' function. */
/* #undef HAVE__CTIME64_S */

/* Define to 1 if you have the `_fseeki64' function. */
/* #undef HAVE__FSEEKI64 */

/* Define to 1 if you have the `_get_timezone' function. */
/* #undef HAVE__GET_TIMEZONE */

/* Define to 1 if you have the `_localtime64_s' function. */
/* #undef HAVE__LOCALTIME64_S */

/* Define to 1 if you have the `_mkgmtime64' function. */
/* #undef HAVE__MKGMTIME64 */

/* Define as const if the declaration of iconv() needs const. */
#define ICONV_CONST 

/* Version number of libarchive as a single integer */
#define LIBARCHIVE_VERSION_NUMBER "3001002"

/* Version number of libarchive */
#define LIBARCHIVE_VERSION_STRING "3.1.2"

/* Define to 1 if `lstat' dereferences a symlink specified with a trailing
   slash. */
/* #undef LSTAT_FOLLOWS_SLASHED_SYMLINK */

/* Define to 1 if `major', `minor', and `makedev' are declared in <mkdev.h>.
   */
/* #undef MAJOR_IN_MKDEV */

/* Define to 1 if `major', `minor', and `makedev' are declared in
   <sysmacros.h>. */
#define MAJOR_IN_SYSMACROS 1

/* Define to 1 if your C compiler doesn't accept -c and -o together. */
/* #undef NO_MINUS_C_MINUS_O */

/* The size of `wchar_t', as computed by sizeof. */
#define SIZEOF_WCHAR_T 4

/* Define to 1 if strerror_r returns char *. */
/* #undef STRERROR_R_CHAR_P */

/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
#define TIME_WITH_SYS_TIME 1

/*
 * Some platform requires a macro to use extension functions.
 */
#define SAFE_TO_DEFINE_EXTENSIONS 1
#ifdef SAFE_TO_DEFINE_EXTENSIONS
/* Enable extensions on AIX 3, Interix.  */
#ifndef _ALL_SOURCE
# define _ALL_SOURCE 1
#endif
/* Enable GNU extensions on systems that have them.  */
#ifndef _GNU_SOURCE
# define _GNU_SOURCE 1
#endif
/* Enable threading extensions on Solaris.  */
#ifndef _POSIX_PTHREAD_SEMANTICS
# define _POSIX_PTHREAD_SEMANTICS 1
#endif
/* Enable extensions on HP NonStop.  */
#ifndef _TANDEM_SOURCE
# define _TANDEM_SOURCE 1
#endif
/* Enable general extensions on Solaris.  */
#ifndef __EXTENSIONS__
# define __EXTENSIONS__ 1
#endif
#endif /* SAFE_TO_DEFINE_EXTENSIONS */

/* Version number of package */
#define VERSION "3.1.2"

/* Number of bits in a file offset, on hosts where this is settable. */
/* #undef _FILE_OFFSET_BITS */

/* Define to 1 to make fseeko visible on some hosts (e.g. glibc 2.2). */
/* #undef _LARGEFILE_SOURCE */

/* Define for large files, on AIX-style hosts. */
/* #undef _LARGE_FILES */

/* Define for Windows to use Windows 2000+ APIs. */
/* #undef _WIN32_WINNT */
/* #undef WINVER */

/* Define to empty if `const' does not conform to ANSI C. */
/* #undef const */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef gid_t */

/* Define to `unsigned long' if <sys/types.h> does not define. */
/* #undef id_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef mode_t */

/* Define to `long long' if <sys/types.h> does not define. */
/* #undef off_t */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef pid_t */

/* Define to `unsigned int' if <sys/types.h> does not define. */
/* #undef size_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef ssize_t */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef uid_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef intptr_t */

/* Define to `unsigned int' if <sys/types.h> does not define. */
/* #undef uintptr_t */


#define ARCHIVE_SHA512_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA512_LIBMD
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = (DWORD)bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. Nettle
 * 6. OpenSSL
 * 7. libmd
 * 8. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive_sha512_ctx ctx;
  archive_sha512_init(&ctx);
  archive_sha512_update(&ctx, *argv, argc);
  archive_sha512_final(&ctx, NULL);
  return 0;
}

Determining size of unsigned short passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1855005101/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1855005101.dir/build.make CMakeFiles/cmTryCompileExec1855005101.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1855005101.dir/CMAKE_SIZEOF_UNSIGNED_SHORT.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1855005101.dir/CMAKE_SIZEOF_UNSIGNED_SHORT.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CheckTypeSize/CMAKE_SIZEOF_UNSIGNED_SHORT.c
Linking C executable cmTryCompileExec1855005101
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1855005101.dir/link.txt --verbose=1
/usr/bin/gcc       CMakeFiles/cmTryCompileExec1855005101.dir/CMAKE_SIZEOF_UNSIGNED_SHORT.c.o  -o cmTryCompileExec1855005101 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the function wsyncup exists in the /usr/lib/x86_64-linux-gnu/libcurses.so passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3252785034/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3252785034.dir/build.make CMakeFiles/cmTryCompileExec3252785034.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3252785034.dir/CheckFunctionExists.c.o
/usr/bin/gcc   -DCHECK_FUNCTION_EXISTS=wsyncup   -o CMakeFiles/cmTryCompileExec3252785034.dir/CheckFunctionExists.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3252785034
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3252785034.dir/link.txt --verbose=1
/usr/bin/gcc   -DCHECK_FUNCTION_EXISTS=wsyncup    CMakeFiles/cmTryCompileExec3252785034.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3252785034 -rdynamic -lcurses 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Determining if the include file elf.h exists passed with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1687057591/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1687057591.dir/build.make CMakeFiles/cmTryCompileExec1687057591.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1687057591.dir/CheckIncludeFile.c.o
/usr/bin/gcc    -o CMakeFiles/cmTryCompileExec1687057591.dir/CheckIncludeFile.c.o   -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CheckIncludeFile.c
Linking C executable cmTryCompileExec1687057591
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1687057591.dir/link.txt --verbose=1
/usr/bin/gcc       CMakeFiles/cmTryCompileExec1687057591.dir/CheckIncludeFile.c.o  -o cmTryCompileExec1687057591 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'


Performing C++ SOURCE FILE Test run_pic_test succeded with the following output:
Change Dir: /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1704654270/fast"
make[4]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1704654270.dir/build.make CMakeFiles/cmTryCompileExec1704654270.dir/build
make[5]: Entering directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_progress_report /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec1704654270.dir/src.cxx.o
/usr/bin/g++    -Drun_pic_test   -fPIE -o CMakeFiles/cmTryCompileExec1704654270.dir/src.cxx.o -c /home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp/src.cxx
Linking CXX executable cmTryCompileExec1704654270
/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1704654270.dir/link.txt --verbose=1
/usr/bin/g++    -Drun_pic_test    CMakeFiles/cmTryCompileExec1704654270.dir/src.cxx.o  -o cmTryCompileExec1704654270 -rdynamic 
make[5]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/ubuntu/tp-link/ER7206_trunk/build_dir/host/cmake-2.8.12.2/CMakeFiles/CMakeTmp'

Source file was:
int main() { return 0;}
