--- a/net/8021q/Kconfig	2017-07-18 17:15:40.361199617 +0800
+++ b/net/8021q/Kconfig	2017-07-18 17:16:39.957199622 +0800
@@ -38,3 +38,14 @@
 	  supersedes GVRP and is not backwards-compatible.
 
 	  If unsure, say N.
+
+config VLAN_MULTICAST_IPTV
+	bool "Multicast IPTV"
+	depends on VLAN_8021Q
+	---help---
+	  If you say Y here, then the IPTV will do with multicast and unicast vlan id
+	  based on VLAN information in the packet.
+
+	  Say N to exclude this support and reduce the binary size.
+
+	  If unsure, say Y.
--- a/net/core/skbuff.c	2017-07-18 17:24:34.036200779 +0800
+++ b/net/core/skbuff.c	2017-07-18 17:25:27.108200085 +0800
@@ -80,6 +80,11 @@
 #include "skbuff_recycle.h"
 #include "skbuff_debug.h"
 
+#ifdef CONFIG_VLAN_MULTICAST_IPTV
+u16 (*iptv_handle_frame_hook)(struct sk_buff *skb, u16 vlan_tci, int flag) __read_mostly;
+EXPORT_SYMBOL_GPL(iptv_handle_frame_hook);
+#endif
+
 struct kmem_cache *skbuff_head_cache __read_mostly;
 static struct kmem_cache *skbuff_fclone_cache __read_mostly;
 
@@ -4100,6 +4105,14 @@
 
 	vhdr = (struct vlan_hdr *)skb->data;
 	vlan_tci = ntohs(vhdr->h_vlan_TCI);
+	#ifdef CONFIG_VLAN_MULTICAST_IPTV
+	if (iptv_handle_frame_hook)
+	{
+		u16 tmp_tci;
+		tmp_tci  = iptv_handle_frame_hook(skb, vlan_tci, 0);
+		vlan_tci = tmp_tci?tmp_tci:vlan_tci;
+	}
+	#endif
 	__vlan_hwaccel_put_tag(skb, skb->protocol, vlan_tci);
 
 	skb_pull_rcsum(skb, VLAN_HLEN);
