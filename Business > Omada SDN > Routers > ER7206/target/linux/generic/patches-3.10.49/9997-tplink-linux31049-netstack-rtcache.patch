--- a/include/net/netfilter/nf_conntrack_extend.h
+++ b/include/net/netfilter/nf_conntrack_extend.h
@@ -26,6 +26,9 @@ enum nf_ct_ext_id {
 #ifdef CONFIG_NF_CONNTRACK_LABELS
 	NF_CT_EXT_LABELS,
 #endif
+#ifdef CONFIG_NF_CONNTRACK_RTCACHE
+    NF_CT_EXT_RTCACHE,
+#endif /* CONFIG_NF_CONNTRACK_RTCACHE */
 	NF_CT_EXT_NUM,
 };
 
@@ -37,6 +40,7 @@ enum nf_ct_ext_id {
 #define NF_CT_EXT_TSTAMP_TYPE struct nf_conn_tstamp
 #define NF_CT_EXT_TIMEOUT_TYPE struct nf_conn_timeout
 #define NF_CT_EXT_LABELS_TYPE struct nf_conn_labels
+#define NF_CT_EXT_RTCACHE_TYPE struct nf_conn_rtcache
 
 /* Extensions: optional stuff which isn't permanently in struct. */
 struct nf_ct_ext {
--- /dev/null
+++ b/include/net/netfilter/nf_conntrack_rtcache.h
@@ -0,0 +1,40 @@
+#include <linux/gfp.h>
+#include <net/netfilter/nf_conntrack.h>
+#include <net/netfilter/nf_conntrack_extend.h>
+
+struct dst_entry;
+
+struct nf_conn_dst_cache {
+    struct dst_entry *dst;
+    int iif;
+#if IS_ENABLED(CONFIG_NF_CONNTRACK_IPV6)
+    u32 cookie;
+#endif
+};
+
+struct nf_conn_rtcache {
+    struct nf_conn_dst_cache cached_dst[IP_CT_DIR_MAX];
+};
+
+static inline
+struct nf_conn_rtcache *nf_ct_rtcache_find(const struct nf_conn *ct)
+{
+#ifdef CONFIG_NF_CONNTRACK_RTCACHE
+    return nf_ct_ext_find(ct, NF_CT_EXT_RTCACHE);
+#else
+    return NULL;
+#endif
+}
+
+static inline int nf_conn_rtcache_iif_get(const struct nf_conn_rtcache *rtc,
+                                          enum ip_conntrack_dir dir)
+{
+    return rtc->cached_dst[dir].iif;
+}
+
+unsigned int
+seq_print_rtcache(struct seq_file *s, const struct nf_conn *ct, int dir);
+
+struct nf_conn_rtcache *
+nf_ct_rtcache_find_usable(struct nf_conn *ct);
+
--- a/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4_compat.c
+++ b/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4_compat.c
@@ -21,6 +21,9 @@
 #include <net/netfilter/nf_conntrack_l4proto.h>
 #include <net/netfilter/nf_conntrack_expect.h>
 #include <net/netfilter/nf_conntrack_acct.h>
+#ifdef CONFIG_NF_CONNTRACK_RTCACHE
+#include <net/netfilter/nf_conntrack_rtcache.h>
+#endif /* CONFIG_NF_CONNTRACK_RTCACHE */
 #include <linux/rculist_nulls.h>
 #include <linux/export.h>
 
@@ -157,6 +160,11 @@ static int ct_seq_show(struct seq_file *
 	if (seq_print_acct(s, ct, IP_CT_DIR_ORIGINAL))
 		goto release;
 
+#ifdef CONFIG_NF_CONNTRACK_RTCACHE
+	if (seq_print_rtcache(s, ct, IP_CT_DIR_ORIGINAL))
+		goto release;
+#endif /* CONFIG_NF_CONNTRACK_RTCACHE */
+
 	if (!(test_bit(IPS_SEEN_REPLY_BIT, &ct->status)))
 		if (seq_printf(s, "[UNREPLIED] "))
 			goto release;
@@ -168,6 +176,11 @@ static int ct_seq_show(struct seq_file *
 	if (seq_print_acct(s, ct, IP_CT_DIR_REPLY))
 		goto release;
 
+#ifdef CONFIG_NF_CONNTRACK_RTCACHE
+	if (seq_print_rtcache(s, ct, IP_CT_DIR_REPLY))
+		goto release;
+#endif /* CONFIG_NF_CONNTRACK_RTCACHE */
+
 	if (test_bit(IPS_ASSURED_BIT, &ct->status))
 		if (seq_printf(s, "[ASSURED] "))
 			goto release;
--- a/net/ipv4/route.c
+++ b/net/ipv4/route.c
@@ -108,6 +108,9 @@
 #include <linux/kmemleak.h>
 #endif
 #include <net/secure_seq.h>
+#ifdef CONFIG_NF_CONNTRACK_RTCACHE
+#include <net/netfilter/nf_conntrack_rtcache.h>
+#endif /* CONFIG_NF_CONNTRACK_RTCACHE */
 
 #define RT_FL_TOS(oldflp4) \
 	((oldflp4)->flowi4_tos & (IPTOS_RT_MASK | RTO_ONLINK))
@@ -1567,7 +1570,7 @@ static int ip_mkroute_input(struct sk_bu
 			    __be32 daddr, __be32 saddr, u32 tos)
 {
 #ifdef CONFIG_IP_ROUTE_MULTIPATH
-	if (res->fi && res->fi->fib_nhs > 1)
+	if (0 == fl4->flowi4_oif && res->fi && res->fi->fib_nhs > 1)
 		fib_select_multipath(res);
 #endif
 
@@ -1638,7 +1641,38 @@ static int ip_route_input_slow(struct sk
 	/*
 	 *	Now we are ready to route packet.
 	 */
+#ifdef CONFIG_NF_CONNTRACK_RTCACHE
+    {
+        struct nf_conn_rtcache *rtc;
+        enum ip_conntrack_info ctinfo;
+        enum ip_conntrack_dir dir;
+        struct nf_conn *ct = NULL;
+        int iif = 0;
+
+        ct = nf_ct_get(skb, &ctinfo);
+        if (!ct)
+        {
+            goto set_oif;
+        }
+
+        dir = CTINFO2DIR(ctinfo);
+
+        rtc = nf_ct_rtcache_find_usable(ct);
+        if (!rtc)
+        {
+            goto set_oif;
+        }
+
+        iif = nf_conn_rtcache_iif_get(rtc, !dir);
+
+        iif = (-1 == iif ? 0 : iif);
+set_oif:
+        fl4.flowi4_oif = iif;
+        //printk(KERN_ERR"\r\nct %p, skb %p : fl4.flowi4_oif = %d\r\n", ct, skb, iif);
+    }
+#else
 	fl4.flowi4_oif = 0;
+#endif /* CONFIG_NF_CONNTRACK_RTCACHE */
 	fl4.flowi4_iif = dev->ifindex;
 	fl4.flowi4_mark = skb->mark;
 	fl4.flowi4_tos = tos;
--- a/net/netfilter/Kconfig
+++ b/net/netfilter/Kconfig
@@ -139,6 +139,17 @@ config NF_CONNTRACK_LABELS
 	  This option enables support for assigning user-defined flag bits
 	  to connection tracking entries.  It selected by the connlabel match.
 
+config NF_CONNTRACK_RTCACHE
+	bool  'Cache route entries in conntrack objects'
+	depends on NETFILTER_ADVANCED
+	depends on NF_CONNTRACK
+	help
+	  If this option is enabled, the connection tracking code will cache
+	  routing information for each connection that is being forwarded, at
+	  a cost of 32 bytes per conntrack object.
+ 	  To compile it as a module, choose M here. If unsure, say N.
+ 	  The module will be called nf_conntrack_rtcache.
+
 config NF_CT_PROTO_DCCP
 	tristate 'DCCP protocol connection tracking support'
 	depends on NETFILTER_ADVANCED
--- a/net/netfilter/Makefile
+++ b/net/netfilter/Makefile
@@ -5,6 +5,7 @@ nf_conntrack-$(CONFIG_NF_CONNTRACK_TIMEO
 nf_conntrack-$(CONFIG_NF_CONNTRACK_TIMESTAMP) += nf_conntrack_timestamp.o
 nf_conntrack-$(CONFIG_NF_CONNTRACK_EVENTS) += nf_conntrack_ecache.o
 nf_conntrack-$(CONFIG_NF_CONNTRACK_LABELS) += nf_conntrack_labels.o
+nf_conntrack-$(CONFIG_NF_CONNTRACK_RTCACHE) += nf_conntrack_rtcache.o
 
 obj-$(CONFIG_NETFILTER) = netfilter.o
 
--- /dev/null
+++ b/net/netfilter/nf_conntrack_rtcache.c
@@ -0,0 +1,539 @@
+/*
+ * route cache
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME": "fmt
+
+#include <linux/types.h>
+#include <linux/netfilter.h>
+#include <linux/skbuff.h>
+#include <linux/stddef.h>
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <linux/export.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <net/dst.h>
+#include <net/route.h>
+#include <net/netfilter/nf_conntrack.h>
+#include <net/netfilter/nf_conntrack_core.h>
+#include <net/netfilter/nf_conntrack_extend.h>
+#include <net/netfilter/nf_conntrack_rtcache.h>
+
+#if IS_ENABLED(CONFIG_NF_CONNTRACK_IPV6)
+#include <net/ip6_fib.h>
+#endif /* IS_ENABLED(CONFIG_NF_CONNTRACK_IPV6) */
+
+unsigned int
+seq_print_rtcache(struct seq_file *s, const struct nf_conn *ct, int dir)
+{
+#ifdef CONFIG_NF_CONNTRACK_RTCACHE
+	struct nf_conn_rtcache *rtc = NULL;
+
+	rtc = nf_ct_rtcache_find(ct);
+	if (!rtc)
+		return 0;
+
+	return seq_printf(s, "dst_entry=%p iif=%d ", rtc->cached_dst[dir].dst, rtc->cached_dst[dir].iif);
+#else
+    return 0;
+#endif
+};
+EXPORT_SYMBOL(seq_print_rtcache);
+
+static void
+__nf_conn_rtcache_destroy(struct nf_conn_rtcache *rtc, enum ip_conntrack_dir dir)
+{
+    struct dst_entry *dst = rtc->cached_dst[dir].dst;
+
+    dst_release(dst);
+}
+
+static void
+nf_conn_rtcache_destroy(struct nf_conn *ct)
+{
+    struct nf_conn_rtcache *rtc = nf_ct_rtcache_find(ct);
+
+    if (!rtc)
+        return;
+
+    __nf_conn_rtcache_destroy(rtc, IP_CT_DIR_ORIGINAL);
+    __nf_conn_rtcache_destroy(rtc, IP_CT_DIR_REPLY);
+}
+
+static void
+nf_ct_rtcache_ext_add(struct nf_conn *ct)
+{
+    struct nf_conn_rtcache *rtc = NULL;
+
+    rtc = nf_ct_ext_add(ct, NF_CT_EXT_RTCACHE, GFP_ATOMIC);
+    if (rtc) {
+        rtc->cached_dst[IP_CT_DIR_ORIGINAL].iif = -1;
+        rtc->cached_dst[IP_CT_DIR_ORIGINAL].dst = NULL;
+        rtc->cached_dst[IP_CT_DIR_REPLY].iif = -1;
+        rtc->cached_dst[IP_CT_DIR_REPLY].dst = NULL;
+    }
+}
+
+struct nf_conn_rtcache *
+nf_ct_rtcache_find_usable(struct nf_conn *ct)
+{
+    if (nf_ct_is_untracked(ct))
+        return NULL;
+    return (struct nf_conn_rtcache *)nf_ct_rtcache_find(ct);
+}
+EXPORT_SYMBOL(nf_ct_rtcache_find_usable);
+
+static struct dst_entry *
+nf_conn_rtcache_dst_get(const struct nf_conn_rtcache *rtc, enum ip_conntrack_dir dir)
+{
+    return rtc->cached_dst[dir].dst;
+}
+
+static u32 nf_rtcache_get_cookie(int pf, const struct dst_entry *dst)
+{
+#if IS_ENABLED(CONFIG_NF_CONNTRACK_IPV6)
+    if (NFPROTO_IPV6 == pf) {
+        const struct rt6_info *rt = (const struct rt6_info *)dst;
+
+        if (rt->rt6i_node)
+            return (u32)rt->rt6i_node->fn_sernum;
+    }
+#endif /* IS_ENABLED(CONFIG_NF_CONNTRACK_IPV6) */
+    return 0;
+}
+
+static void nf_conn_rtcache_dst_set(int pf,
+                                    struct nf_conn_rtcache *rtc,
+                                    struct dst_entry *dst,
+                                    enum ip_conntrack_dir dir,
+                                    int iif)
+{
+    if (rtc->cached_dst[dir].iif != iif)
+        rtc->cached_dst[dir].iif = iif;
+
+    if (rtc->cached_dst[dir].dst != dst) {
+        struct dst_entry *old;
+
+        dst_hold(dst);
+
+        old = xchg(&rtc->cached_dst[dir].dst, dst);
+        dst_release(old);
+
+#if IS_ENABLED(CONFIG_NF_CONNTRACK_IPV6)
+        if (NFPROTO_IPV6 == pf)
+            rtc->cached_dst[dir].cookie = nf_rtcache_get_cookie(pf, dst);
+#endif /* IS_ENABLED(CONFIG_NF_CONNTRACK_IPV6) */
+    }
+}
+
+static void
+nf_conn_rtcache_dst_obsolete(struct nf_conn_rtcache *rtc, enum ip_conntrack_dir dir)
+{
+    struct dst_entry *old;
+
+    pr_debug("Invalidate iif %d for dir %d on cache %p\n",
+             rtc->cached_dst[dir].iif, dir, rtc);
+
+    old = xchg(&rtc->cached_dst[dir].dst, NULL);
+    dst_release(old);
+    rtc->cached_dst[dir].iif = -1;
+}
+
+static unsigned int
+nf_ipv4_rtcache_in(unsigned hooknum,
+                   struct sk_buff *skb,
+                   const struct net_device *in,
+                   const struct net_device *out,
+                   int (*okfn)(struct sk_buff *))
+{
+    struct nf_conn_rtcache *rtc;
+    enum ip_conntrack_info ctinfo;
+    enum ip_conntrack_dir dir;
+    struct dst_entry *dst;
+    struct nf_conn *ct;
+    int iif;
+    u32 cookie;
+
+    if (skb_dst(skb) || skb->sk)
+        return NF_ACCEPT;
+
+    ct = nf_ct_get(skb, &ctinfo);
+    if (!ct)
+        return NF_ACCEPT;
+
+    rtc = nf_ct_rtcache_find_usable(ct);
+    if (!rtc)
+        return NF_ACCEPT;
+
+    /* If iif changes, don't use cache and let ip stack do route lookup.
+     *
+     * If rp_filter is enabled it might toss skb, so we don't want to avoid
+     * these checks.
+     */
+    dir = CTINFO2DIR(ctinfo);
+    iif = nf_conn_rtcache_iif_get(rtc, dir);
+    if (in->ifindex != iif) {
+        pr_debug("ct %p, iif %d, cached iif %d, skip cached entry\n",
+                 ct, iif, in->ifindex);
+        return NF_ACCEPT;
+    }
+
+    dst = nf_conn_rtcache_dst_get(rtc, dir);
+    if (NULL == dst)
+        return NF_ACCEPT;
+
+    cookie = nf_rtcache_get_cookie(NFPROTO_IPV4, dst);
+
+    dst = dst_check(dst, cookie);
+    pr_debug("obtained dst %p for skb %p, cookie %d\n", dst, skb, cookie);
+    if (likely(dst))
+        skb_dst_set_noref_force(skb, dst);
+    else
+        nf_conn_rtcache_dst_obsolete(rtc, dir);
+
+    return NF_ACCEPT;
+}
+
+static unsigned int
+nf_ipv6_rtcache_in(unsigned hooknum,
+                   struct sk_buff *skb,
+                   const struct net_device *in,
+                   const struct net_device *out,
+                   int (*okfn)(struct sk_buff *))
+{
+    struct nf_conn_rtcache *rtc;
+    enum ip_conntrack_info ctinfo;
+    enum ip_conntrack_dir dir;
+    struct dst_entry *dst;
+    struct nf_conn *ct;
+    int iif;
+    u32 cookie;
+
+    if (skb_dst(skb) || skb->sk)
+        return NF_ACCEPT;
+
+    ct = nf_ct_get(skb, &ctinfo);
+    if (!ct)
+        return NF_ACCEPT;
+
+    rtc = nf_ct_rtcache_find_usable(ct);
+    if (!rtc)
+        return NF_ACCEPT;
+
+    /* If iif changes, don't use cache and let ip stack do route lookup.
+     *
+     * If rp_filter is enabled it might toss skb, so we don't want to avoid
+     * these checks.
+     */
+    dir = CTINFO2DIR(ctinfo);
+    iif = nf_conn_rtcache_iif_get(rtc, dir);
+    if (in->ifindex != iif) {
+        pr_debug("ct %p, iif %d, cached iif %d, skip cached entry\n",
+                 ct, iif, in->ifindex);
+        return NF_ACCEPT;
+    }
+
+    dst = nf_conn_rtcache_dst_get(rtc, dir);
+    if (NULL == dst)
+        return NF_ACCEPT;
+
+    cookie = nf_rtcache_get_cookie(NFPROTO_IPV6, dst);
+
+    dst = dst_check(dst, cookie);
+    pr_debug("obtained dst %p for skb %p, cookie %d\n", dst, skb, cookie);
+    if (likely(dst))
+        skb_dst_set_noref_force(skb, dst);
+    else
+        nf_conn_rtcache_dst_obsolete(rtc, dir);
+
+    return NF_ACCEPT;
+}
+
+static unsigned int
+nf_ipv4_rtcache_forward(unsigned int hooknum,
+                        struct sk_buff *skb,
+                        const struct net_device *in,
+                        const struct net_device *out,
+                        int (*okfn)(struct sk_buff *))
+{
+    struct nf_conn_rtcache *rtc;
+    enum ip_conntrack_info ctinfo;
+    enum ip_conntrack_dir dir;
+    enum ip_conntrack_dir redir;
+    struct nf_conn *ct;
+    struct dst_entry *dst = skb_dst(skb);
+    int iif;
+    int oif;
+
+    ct = nf_ct_get(skb, &ctinfo);
+    if (!ct)
+        return NF_ACCEPT;
+
+    if (dst && dst_xfrm(dst))
+        return NF_ACCEPT;
+
+    dir = CTINFO2DIR(ctinfo);
+    redir = IP_CT_DIR_ORIGINAL == dir ? IP_CT_DIR_REPLY : IP_CT_DIR_ORIGINAL;
+
+    if (!nf_ct_is_confirmed(ct)) {
+        if (WARN_ON(nf_ct_rtcache_find(ct)))
+            return NF_ACCEPT;
+
+        nf_ct_rtcache_ext_add(ct);
+
+        /* no need to confirm indev of ORIGINAL, directly save it */
+        if (WARN_ON(IP_CT_DIR_ORIGINAL != dir))
+            return NF_ACCEPT;
+
+        rtc = nf_ct_rtcache_find_usable(ct);
+        if (!rtc)
+            return NF_ACCEPT;
+
+        nf_conn_rtcache_dst_set(NFPROTO_IPV4, rtc, NULL, dir, in->ifindex);
+        return NF_ACCEPT;
+    }
+
+    rtc = nf_ct_rtcache_find_usable(ct);
+    if (!rtc)
+        return NF_ACCEPT;
+
+    iif = nf_conn_rtcache_iif_get(rtc, dir);
+    oif = nf_conn_rtcache_iif_get(rtc, redir);
+    pr_debug("ct %p, skb %p, dir %d, iif %d, cached iif %d\n",
+             ct, skb, dir, iif, in->ifindex);
+#if 0
+    printk(KERN_ERR"\r\nct %p, skb %p : \r\n\t\t%s, iif %d(%s), cached iif %d; \r\n\t\t%s, oif %d(%s), cached oif %d\n",
+             ct, skb, IP_CT_DIR_ORIGINAL == dir ? "ORIG" : "RPLY", in->ifindex, in->name, iif, IP_CT_DIR_ORIGINAL == redir ? "ORIG" : "RPLY", out ? out->ifindex : -1, out ? out->name : "null", oif);
+
+    /* revise output if */
+    if (IP_CT_DIR_REPLY == dir && out && out->ifindex != oif) {
+        struct rtable *rt;
+        struct iphdr *iph = ip_hdr(skb);
+
+        rt = ip_route_output(dev_net(in), iph->daddr, 0, RT_TOS(iph->tos), oif);
+        if (!IS_ERR(rt)) {
+            skb_dst_set_noref_force(skb, &rt->dst);
+        }
+    }
+
+    if (likely(in->ifindex == iif))
+        return NF_ACCEPT;
+#endif /* 0 */
+
+    nf_conn_rtcache_dst_set(NFPROTO_IPV4, rtc, skb_dst(skb), dir, in->ifindex);
+    return NF_ACCEPT;
+}
+
+static unsigned int
+nf_ipv6_rtcache_forward(unsigned int hooknum,
+                        struct sk_buff *skb,
+                        const struct net_device *in,
+                        const struct net_device *out,
+                        int (*okfn)(struct sk_buff *))
+{
+    struct nf_conn_rtcache *rtc;
+    enum ip_conntrack_info ctinfo;
+    enum ip_conntrack_dir dir;
+    struct nf_conn *ct;
+    struct dst_entry *dst = skb_dst(skb);
+    int iif;
+
+    ct = nf_ct_get(skb, &ctinfo);
+    if (!ct)
+        return NF_ACCEPT;
+
+    if (dst && dst_xfrm(dst))
+        return NF_ACCEPT;
+
+    if (!nf_ct_is_confirmed(ct)) {
+        if (WARN_ON(nf_ct_rtcache_find(ct)))
+            return NF_ACCEPT;
+
+        nf_ct_rtcache_ext_add(ct);
+        return NF_ACCEPT;
+    }
+
+    rtc = nf_ct_rtcache_find_usable(ct);
+    if (!rtc)
+        return NF_ACCEPT;
+
+    dir = CTINFO2DIR(ctinfo);
+    iif = nf_conn_rtcache_iif_get(rtc, dir);
+    pr_debug("ct %p, skb %p, dir %d, iif %d, cached iif %d\n",
+             ct, skb, dir, iif, in->ifindex);
+
+    if (likely(in->ifindex == iif))
+        return NF_ACCEPT;
+
+    nf_conn_rtcache_dst_set(NFPROTO_IPV6, rtc, skb_dst(skb), dir, in->ifindex);
+    return NF_ACCEPT;
+}
+
+static int
+nf_rtcache_dst_remove(struct nf_conn *ct, void *data)
+{
+    struct nf_conn_rtcache *rtc = nf_ct_rtcache_find(ct);
+    struct net_device *dev = data;
+
+    if (!rtc)
+        return 0;
+
+    if (dev->ifindex == rtc->cached_dst[IP_CT_DIR_ORIGINAL].iif ||
+        dev->ifindex == rtc->cached_dst[IP_CT_DIR_REPLY].iif) {
+        nf_conn_rtcache_dst_obsolete(rtc, IP_CT_DIR_ORIGINAL);
+        nf_conn_rtcache_dst_obsolete(rtc, IP_CT_DIR_REPLY);
+    }
+
+    return 0;
+}
+
+static int
+nf_rtcache_netdev_event(struct notifier_block *this,
+                        unsigned long event, void *ptr)
+{
+    struct net_device *dev = ptr;
+    struct net *net = dev_net(dev);
+
+    if (NETDEV_DOWN == event)
+        nf_ct_iterate_cleanup(net, nf_rtcache_dst_remove, dev);
+
+    return NOTIFY_DONE;
+}
+
+static struct notifier_block nf_rtcache_notifier = {
+    .notifier_call = nf_rtcache_netdev_event,
+};
+
+static struct nf_hook_ops rtcache_ops[] = {
+    {
+        .hook       = nf_ipv4_rtcache_in,
+        .owner      = THIS_MODULE,
+        .pf         = NFPROTO_IPV4,
+        .hooknum    = NF_INET_PRE_ROUTING,
+        .priority   = NF_IP_PRI_LAST,
+    },
+    {
+        .hook       = nf_ipv4_rtcache_forward,
+        .owner      = THIS_MODULE,
+        .pf         = NFPROTO_IPV4,
+        .hooknum    = NF_INET_FORWARD,
+        .priority   = NF_IP_PRI_LAST,
+    },
+#if IS_ENABLED(CONFIG_NF_CONNTRACK_IPV6)
+    {
+        .hook       = nf_ipv6_rtcache_in,
+        .owner      = THIS_MODULE,
+        .pf         = NFPROTO_IPV6,
+        .hooknum    = NF_INET_PRE_ROUTING,
+        .priority   = NF_IP_PRI_LAST,
+    },
+    {
+        .hook       = nf_ipv6_rtcache_forward,
+        .owner      = THIS_MODULE,
+        .pf         = NFPROTO_IPV6,
+        .hooknum    = NF_INET_FORWARD,
+        .priority   = NF_IP_PRI_LAST,
+    },
+#endif /* IS_ENABLED(CONFIG_NF_CONNTRACK_IPV6) */
+};
+
+static struct nf_ct_ext_type rtcache_ext __read_mostly = {
+    .len        = sizeof(struct nf_conn_rtcache),
+    .align      = __alignof__(struct nf_conn_rtcache),
+    .id         = NF_CT_EXT_RTCACHE,
+    .destroy    = nf_conn_rtcache_destroy,
+};
+
+static int __init
+nf_conntrack_rtcache_init(void)
+{
+    int ret = nf_ct_extend_register(&rtcache_ext);
+
+    if (ret < 0) {
+        pr_err("nf_conntrack_rtcache: unable to register extension\n");
+        return ret;
+    }
+
+    ret = nf_register_hooks(rtcache_ops, ARRAY_SIZE(rtcache_ops));
+    if (ret < 0) {
+        nf_ct_extend_unregister(&rtcache_ext);
+        return ret;
+    }
+
+    ret = register_netdevice_notifier(&nf_rtcache_notifier);
+    if (ret) {
+        nf_unregister_hooks(rtcache_ops, ARRAY_SIZE(rtcache_ops));
+        nf_ct_extend_unregister(&rtcache_ext);
+        return ret;
+    }
+
+    return ret;
+}
+
+static int
+nf_rtcache_ext_remove(struct nf_conn *ct, void *data)
+{
+    struct nf_conn_rtcache *rtc = nf_ct_rtcache_find(ct);
+
+    return rtc != NULL;
+}
+
+static bool __exit
+nf_conntrack_rtcache_wait_for_dying(struct net *net)
+{
+    bool wait = false;
+
+	struct nf_conntrack_tuple_hash *h;
+	struct nf_conn *ct;
+	struct hlist_nulls_node *n;
+
+	spin_lock_bh(&nf_conntrack_lock);
+	hlist_nulls_for_each_entry(h, n, &net->ct.dying, hnnode) {
+		ct = nf_ct_tuplehash_to_ctrack(h);
+        if (nf_ct_rtcache_find(ct) != NULL) {
+            wait = true;
+            break;
+        }
+	}
+	spin_unlock_bh(&nf_conntrack_lock);
+
+    return wait;
+}
+
+static void __exit
+nf_conntrack_rtcache_fini(void)
+{
+    struct net *net;
+    int count = 0;
+
+    /* remove hooks so no new connections get rtcache extension */
+    nf_unregister_hooks(rtcache_ops, ARRAY_SIZE(rtcache_ops));
+
+    synchronize_net();
+
+    unregister_netdevice_notifier(&nf_rtcache_notifier);
+
+    rtnl_lock();
+
+    /* zap all conntracks with rtcache extension */
+    for_each_net(net) {
+        nf_ct_iterate_cleanup(net, nf_rtcache_ext_remove, NULL);
+    }
+
+    for_each_net(net) {
+        /* .. and make sure they're gone from dying list, too */
+        while (nf_conntrack_rtcache_wait_for_dying(net)) {
+            msleep(200);
+            WARN_ONCE(++count > 25, "Waiting for all rtcache conntracks to go away\n");
+        }
+    }
+
+    rtnl_unlock();
+    synchronize_net();
+    nf_ct_extend_unregister(&rtcache_ext);
+}
+
+module_init(nf_conntrack_rtcache_init);
+module_exit(nf_conntrack_rtcache_fini);
+
--- a/net/netfilter/nf_conntrack_standalone.c
+++ b/net/netfilter/nf_conntrack_standalone.c
@@ -32,6 +32,9 @@
 #include <net/netfilter/nf_conntrack_acct.h>
 #include <net/netfilter/nf_conntrack_zones.h>
 #include <net/netfilter/nf_conntrack_timestamp.h>
+#ifdef CONFIG_NF_CONNTRACK_RTCACHE
+#include <net/netfilter/nf_conntrack_rtcache.h>
+#endif /* CONFIG_NF_CONNTRACK_RTCACHE */
 #include <linux/rculist_nulls.h>
 
 MODULE_LICENSE("GPL");
@@ -210,6 +213,11 @@ static int ct_seq_show(struct seq_file *
 	if (seq_print_acct(s, ct, IP_CT_DIR_ORIGINAL))
 		goto release;
 
+#ifdef CONFIG_NF_CONNTRACK_RTCACHE
+	if (seq_print_rtcache(s, ct, IP_CT_DIR_ORIGINAL))
+		goto release;
+#endif /* CONFIG_NF_CONNTRACK_RTCACHE */
+
 	if (!(test_bit(IPS_SEEN_REPLY_BIT, &ct->status)))
 		if (seq_printf(s, "[UNREPLIED] "))
 			goto release;
@@ -221,6 +229,11 @@ static int ct_seq_show(struct seq_file *
 	if (seq_print_acct(s, ct, IP_CT_DIR_REPLY))
 		goto release;
 
+#ifdef CONFIG_NF_CONNTRACK_RTCACHE
+	if (seq_print_rtcache(s, ct, IP_CT_DIR_REPLY))
+		goto release;
+#endif /* CONFIG_NF_CONNTRACK_RTCACHE */
+
 	if (test_bit(IPS_ASSURED_BIT, &ct->status))
 		if (seq_printf(s, "[ASSURED] "))
 			goto release;
