--- a/net/netfilter/xt_connlimit.c
+++ b/net/netfilter/xt_connlimit.c
@@ -23,6 +23,18 @@
 #include <linux/random.h>
 #include <linux/skbuff.h>
 #include <linux/spinlock.h>
+
+#define CONFIG_XT_CONNLIMIT_STATISTICS
+
+#ifdef CONFIG_XT_CONNLIMIT_STATISTICS
+
+#define DOUT(fmt,arg...)  /* printk(KERN_ERR "[connlimit] %s():%d "fmt"\n", __FUNCTION__, __LINE__, ##arg) */
+
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+
+#endif
+
 #include <linux/netfilter/nf_conntrack_tcp.h>
 #include <linux/netfilter/x_tables.h>
 #include <linux/netfilter/xt_connlimit.h>
@@ -31,6 +43,8 @@
 #include <net/netfilter/nf_conntrack_tuple.h>
 #include <net/netfilter/nf_conntrack_zones.h>
 
+#define CONFIG_XT_CONNLIMIT_HASH_MASK (0xFF)
+
 /* we will save the tuples of all connections we care about */
 struct xt_connlimit_conn {
 	struct hlist_node		node;
@@ -39,15 +53,36 @@ struct xt_connlimit_conn {
 };
 
 struct xt_connlimit_data {
-	struct hlist_head	iphash[256];
+#ifdef CONFIG_XT_CONNLIMIT_STATISTICS
+	struct hlist_node		node;
+	int    limit;
+	int    reserved;
+#endif
+	struct hlist_head	iphash[CONFIG_XT_CONNLIMIT_HASH_MASK+1];
 	spinlock_t		lock;
 };
 
 static u_int32_t connlimit_rnd __read_mostly;
 
+#ifdef CONFIG_XT_CONNLIMIT_STATISTICS
+
+struct stat_counter {
+		union nf_inet_addr 	addr;
+		int conn_num;
+};
+
+struct xt_connlimit_statistics {
+	struct hlist_head	rule_list;
+	spinlock_t			lock;
+	struct stat_counter ip_stats[256];
+};
+static struct xt_connlimit_statistics * xt_connlimit_stat_data = NULL;
+#endif
+
+
 static inline unsigned int connlimit_iphash(__be32 addr)
 {
-	return jhash_1word((__force __u32)addr, connlimit_rnd) & 0xFF;
+	return addr & CONFIG_XT_CONNLIMIT_HASH_MASK;
 }
 
 static inline unsigned int
@@ -60,7 +95,7 @@ connlimit_iphash6(const union nf_inet_ad
 	for (i = 0; i < ARRAY_SIZE(addr->ip6); ++i)
 		res.ip6[i] = addr->ip6[i] & mask->ip6[i];
 
-	return jhash2((u32 *)res.ip6, ARRAY_SIZE(res.ip6), connlimit_rnd) & 0xFF;
+	return jhash2((u32 *)res.ip6, ARRAY_SIZE(res.ip6), connlimit_rnd) & CONFIG_XT_CONNLIMIT_HASH_MASK;
 }
 
 static inline bool already_closed(const struct nf_conn *conn)
@@ -251,6 +286,15 @@ static int connlimit_mt_check(const stru
 	for (i = 0; i < ARRAY_SIZE(info->data->iphash); ++i)
 		INIT_HLIST_HEAD(&info->data->iphash[i]);
 
+#ifdef CONFIG_XT_CONNLIMIT_STATISTICS
+
+	info->data->limit = info->limit;
+
+	spin_lock_bh(&xt_connlimit_stat_data->lock);
+	hlist_add_head(&info->data->node, &xt_connlimit_stat_data->rule_list);
+	spin_unlock_bh(&xt_connlimit_stat_data->lock);
+#endif
+
 	return 0;
 }
 
@@ -271,9 +315,124 @@ static void connlimit_mt_destroy(const s
 		}
 	}
 
+#ifdef CONFIG_XT_CONNLIMIT_STATISTICS
+	spin_lock_bh(&xt_connlimit_stat_data->lock);
+	hlist_del(&info->data->node);
+	spin_unlock_bh(&xt_connlimit_stat_data->lock);
+#endif
+
 	kfree(info->data);
 }
 
+#ifdef CONFIG_XT_CONNLIMIT_STATISTICS
+
+static int connlimit_statistics_seq_show(struct seq_file *seq, void *v)
+{
+	struct xt_connlimit_data * rule = NULL;
+	struct hlist_node *n;
+
+	DOUT("in");
+
+	spin_lock_bh(&xt_connlimit_stat_data->lock);
+	hlist_for_each_entry_safe(rule, n, &xt_connlimit_stat_data->rule_list, node)
+	{
+		struct xt_connlimit_conn *conn;
+		struct hlist_node *nn;
+		int hash_index;
+		int ip_stats_cnt;
+		int found;
+		int i;
+
+		DOUT("rule %p ARRAY_SIZE(rule->iphash) %d", rule, ARRAY_SIZE(rule->iphash));
+
+		for (hash_index = 0; hash_index < ARRAY_SIZE(rule->iphash); ++hash_index) {
+
+			memset(&(xt_connlimit_stat_data->ip_stats[0]), 0, sizeof(xt_connlimit_stat_data->ip_stats));
+			ip_stats_cnt = 0;
+
+			hlist_for_each_entry_safe(conn, nn, &rule->iphash[hash_index], node) {
+
+				found = 0;
+
+				for (i = 0; i < ip_stats_cnt; ++ i) {
+
+					if (xt_connlimit_stat_data->ip_stats[i].addr.ip == conn->addr.ip) {
+						xt_connlimit_stat_data->ip_stats[i].conn_num++;
+						found = 1;
+					}
+				}
+
+				if (0 == found) {
+					xt_connlimit_stat_data->ip_stats[ip_stats_cnt].addr.ip = conn->addr.ip;
+					xt_connlimit_stat_data->ip_stats[ip_stats_cnt].conn_num ++;
+					ip_stats_cnt ++;
+					if (ip_stats_cnt >= ARRAY_SIZE(xt_connlimit_stat_data->ip_stats)) {
+						break;
+					}
+				}
+			}
+
+			for (i = 0; i < ip_stats_cnt; ++ i) {
+				seq_printf(seq, "%pI4,%d,%d\n", &(xt_connlimit_stat_data->ip_stats[i].addr.ip), rule->limit, xt_connlimit_stat_data->ip_stats[i].conn_num);
+			}
+		}
+	}
+	spin_unlock_bh(&xt_connlimit_stat_data->lock);
+		
+		
+	DOUT("out");
+	return 0;
+}
+
+static int connlimit_statistics_seq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, connlimit_statistics_seq_show, NULL);
+}
+
+static const struct file_operations connlimit_statistics_seq_fops = {
+	.owner	 = THIS_MODULE,
+	.open	 = connlimit_statistics_seq_open,
+	.read	 = seq_read,
+	.llseek	 = seq_lseek,
+	.release = single_release,
+};
+
+static int __net_init connlimit_statistics_init(void)
+{
+
+	DOUT("in");
+
+	/* init global stat data */
+	xt_connlimit_stat_data = kmalloc(sizeof(struct xt_connlimit_statistics), GFP_KERNEL);
+	if (xt_connlimit_stat_data == NULL) {
+		return -ENOMEM;
+	}
+
+	spin_lock_init(&xt_connlimit_stat_data->lock);
+
+	INIT_HLIST_HEAD(&xt_connlimit_stat_data->rule_list);
+
+	if (!proc_create("connlimit_stat", S_IRUGO, NULL, &connlimit_statistics_seq_fops))
+		return -ENOMEM;
+
+	DOUT("out");
+
+	DOUT("sizeof(struct xt_connlimit_data) = %d", (int)sizeof(struct xt_connlimit_data));
+	DOUT("sizeof(struct xt_connlimit_conn) = %d", (int)sizeof(struct xt_connlimit_conn));
+	return 0;
+}
+
+static void connlimit_statistics_fini(void)
+{
+	DOUT("in");
+	remove_proc_entry("connlimit_stat", NULL);
+	kfree(xt_connlimit_stat_data);
+	xt_connlimit_stat_data = NULL;
+	DOUT("out");
+}
+
+#endif /* CONFIG_XT_CONNLIMIT_STATISTICS */
+
 static struct xt_match connlimit_mt_reg __read_mostly = {
 	.name       = "connlimit",
 	.revision   = 1,
@@ -287,11 +446,19 @@ static struct xt_match connlimit_mt_reg 
 
 static int __init connlimit_mt_init(void)
 {
+#ifdef CONFIG_XT_CONNLIMIT_STATISTICS
+	pr_info("enable /proc/connlimit_stat for per-ip statistics %d.\n", CONFIG_XT_CONNLIMIT_HASH_MASK+1);
+	connlimit_statistics_init();
+#endif
 	return xt_register_match(&connlimit_mt_reg);
 }
 
 static void __exit connlimit_mt_exit(void)
 {
+#ifdef CONFIG_XT_CONNLIMIT_STATISTICS
+	connlimit_statistics_fini();
+#endif
+
 	xt_unregister_match(&connlimit_mt_reg);
 }
 
