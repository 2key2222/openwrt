--- a/net/8021q/Kconfig	2020-06-26 11:01:32.295434456 +0800
+++ b/net/8021q/Kconfig	2020-06-26 11:04:50.364434511 +0800
@@ -49,3 +49,12 @@
 	  Say N to exclude this support and reduce the binary size.
 
 	  If unsure, say Y.
+config VLAN_DEFAULT_DEV
+	bool "DEFAULT VLAN NETDEVICE"
+	depends on VLAN_8021Q
+	---help---
+	  If you say Y here, then untagged packets will be received by a default vlan netdevice.
+
+	  Say N to exclude this support and reduce the binary size.
+
+	  If unsure, say N.
--- a/net/8021q/vlan.c	2020-06-24 13:13:41.825431612 +0800
+++ b/net/8021q/vlan.c	2020-06-26 11:22:04.840370292 +0800
@@ -75,6 +75,24 @@
 	return 0;
 }
 
+#ifdef CONFIG_VLAN_DEFAULT_DEV
+static rx_handler_result_t vlan_handle_frame(struct sk_buff **pskb)
+{
+	struct sk_buff *skb = *pskb;
+	struct net_device *real_dev = skb->dev;
+	struct net_device *vlan_dev = rcu_dereference(real_dev->rx_handler_data);
+
+	/* set pvid of real_dev */
+	if (!vlan_tx_tag_present(skb) && vlan_dev) {
+		__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vlan_dev_vlan_id(vlan_dev));
+		if (vlan_do_receive(pskb))	
+			return RX_HANDLER_ANOTHER;
+	}
+
+	return RX_HANDLER_PASS;
+}
+#endif
+
 void unregister_vlan_dev(struct net_device *dev, struct list_head *head)
 {
 	struct vlan_dev_priv *vlan = vlan_dev_priv(dev);
@@ -82,6 +99,10 @@
 	struct vlan_info *vlan_info;
 	struct vlan_group *grp;
 	u16 vlan_id = vlan->vlan_id;
+#ifdef CONFIG_VLAN_DEFAULT_DEV
+	rx_handler_func_t *rx_handler;
+	void *rx_handler_data;
+#endif
 
 	ASSERT_RTNL();
 
@@ -98,6 +119,14 @@
 		vlan_gvrp_request_leave(dev);
 
 	vlan_group_set_device(grp, vlan->vlan_proto, vlan_id, NULL);
+
+#ifdef CONFIG_VLAN_DEFAULT_DEV
+	rx_handler = rcu_dereference(real_dev->rx_handler);
+	rx_handler_data = rcu_dereference(real_dev->rx_handler_data);
+	if ((rx_handler == vlan_handle_frame) && (rx_handler_data == dev))
+		netdev_rx_handler_unregister(real_dev);
+#endif
+
 	/* Because unregister_netdevice_queue() makes sure at least one rcu
 	 * grace period is respected before device freeing,
 	 * we dont need to call synchronize_net() here.
@@ -145,6 +174,10 @@
 	u16 vlan_id = vlan->vlan_id;
 	struct vlan_info *vlan_info;
 	struct vlan_group *grp;
+#ifdef CONFIG_VLAN_DEFAULT_DEV
+	rx_handler_func_t *rx_handler;
+	void *rx_handler_data;
+#endif
 	int err;
 
 	err = vlan_vid_add(real_dev, vlan->vlan_proto, vlan_id);
@@ -173,6 +206,17 @@
 	if (err)
 		goto out_uninit_mvrp;
 
+#ifdef CONFIG_VLAN_DEFAULT_DEV
+	rx_handler = rcu_dereference(real_dev->rx_handler);
+	rx_handler_data = rcu_dereference(real_dev->rx_handler_data);
+	if (rx_handler && (rx_handler != vlan_handle_frame)) {
+		err = -EBUSY;
+		goto out_upper_dev_unlink;
+	}
+	netdev_rx_handler_unregister(real_dev);
+	netdev_rx_handler_register(real_dev, vlan_handle_frame, dev);
+#endif
+
 	err = register_netdevice(dev);
 	if (err < 0)
 		goto out_upper_dev_unlink;
@@ -192,6 +236,12 @@
 	return 0;
 
 out_upper_dev_unlink:
+#ifdef CONFIG_VLAN_DEFAULT_DEV
+	if (rx_handler == vlan_handle_frame) {
+		netdev_rx_handler_unregister(real_dev);
+		netdev_rx_handler_register(real_dev, vlan_handle_frame, rx_handler_data);
+	}
+#endif
 	netdev_upper_dev_unlink(real_dev, dev);
 out_uninit_mvrp:
 	if (grp->nr_vlan_devs == 0)
