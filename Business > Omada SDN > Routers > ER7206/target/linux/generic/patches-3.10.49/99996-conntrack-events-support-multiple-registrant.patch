diff -uNr a/net/netfilter/Kconfig b/net/netfilter/Kconfig
--- a/net/netfilter/Kconfig	2017-12-15 05:04:05.661849600 -0500
+++ b/net/netfilter/Kconfig	2016-12-12 23:37:25.358821800 -0500
@@ -133,6 +133,14 @@
 
 	  If unsure, say `N'.
 
+config NF_CONNTRACK_CHAIN_EVENTS
+	bool "Register multiple callbacks to ct events"
+	depends on NF_CONNTRACK_EVENTS
+	help
+	  Support multiple registrations.
+
+	  If unsure, say `N'.
+
 config NF_CONNTRACK_TIMEOUT
 	bool  'Connection tracking timeout'
 	depends on NETFILTER_ADVANCED
diff -uNr a/net/netfilter/nf_conntrack_ecache.c b/net/netfilter/nf_conntrack_ecache.c
--- a/net/netfilter/nf_conntrack_ecache.c	2014-09-02 04:43:02.000000000 -0400
+++ b/net/netfilter/nf_conntrack_ecache.c	2016-12-12 23:12:47.985248800 -0500
@@ -18,6 +18,9 @@
 #include <linux/stddef.h>
 #include <linux/err.h>
 #include <linux/percpu.h>
+#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
+#include <linux/notifier.h>
+#endif
 #include <linux/kernel.h>
 #include <linux/netdevice.h>
 #include <linux/slab.h>
@@ -27,6 +30,11 @@
 #include <net/netfilter/nf_conntrack_core.h>
 #include <net/netfilter/nf_conntrack_extend.h>
 
+#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
+ATOMIC_NOTIFIER_HEAD(nf_conntrack_chain);
+EXPORT_SYMBOL_GPL(nf_conntrack_chain);
+#endif
+
 static DEFINE_MUTEX(nf_ct_ecache_mutex);
 
 /* deliver cached events and clear cache entry - must be called with locally
@@ -40,10 +48,12 @@
 	struct nf_ct_event item;
 	int ret;
 
+#ifndef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
 	rcu_read_lock();
 	notify = rcu_dereference(net->ct.nf_conntrack_event_cb);
 	if (notify == NULL)
 		goto out_unlock;
+#endif
 
 	e = nf_ct_ecache_find(ct);
 	if (e == NULL)
@@ -58,14 +68,19 @@
 	 * the lock, thus we may send missed events twice. However,
 	 * this does not harm and it happens very rarely. */
 	missed = e->missed;
-
-	if (!((events | missed) & e->ctmask))
-		goto out_unlock;
-
+	
 	item.ct = ct;
 	item.portid = 0;
 	item.report = 0;
 
+#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
+	atomic_notifier_call_chain(&nf_conntrack_chain,
+                               events | missed,
+                               &item);
+#else
+	if (!((events | missed) & e->ctmask))
+		goto out_unlock;
+
 	ret = notify->fcn(events | missed, &item);
 
 	if (likely(ret >= 0 && !missed))
@@ -77,12 +92,23 @@
 	else
 		e->missed &= ~missed;
 	spin_unlock_bh(&ct->lock);
+#endif
 
 out_unlock:
+#ifndef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
 	rcu_read_unlock();
+#else
+	return;
+#endif
 }
 EXPORT_SYMBOL_GPL(nf_ct_deliver_cached_events);
 
+#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
+int nf_conntrack_register_notifier(struct net *net, struct notifier_block *nb)
+{
+	return atomic_notifier_chain_register(&nf_conntrack_chain, nb);
+}
+#else
 int nf_conntrack_register_notifier(struct net *net,
 				   struct nf_ct_event_notifier *new)
 {
@@ -103,8 +129,15 @@
 	mutex_unlock(&nf_ct_ecache_mutex);
 	return ret;
 }
+#endif
 EXPORT_SYMBOL_GPL(nf_conntrack_register_notifier);
 
+#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
+int nf_conntrack_unregister_notifier(struct net *net, struct notifier_block *nb)
+{
+	return atomic_notifier_chain_unregister(&nf_conntrack_chain, nb);
+}
+#else
 void nf_conntrack_unregister_notifier(struct net *net,
 				      struct nf_ct_event_notifier *new)
 {
@@ -117,6 +150,7 @@
 	RCU_INIT_POINTER(net->ct.nf_conntrack_event_cb, NULL);
 	mutex_unlock(&nf_ct_ecache_mutex);
 }
+#endif
 EXPORT_SYMBOL_GPL(nf_conntrack_unregister_notifier);
 
 int nf_ct_expect_register_notifier(struct net *net,
diff -uNr a/include/net/netfilter/nf_conntrack_ecache.h b/include/net/netfilter/nf_conntrack_ecache.h
--- a/include/net/netfilter/nf_conntrack_ecache.h	2014-09-02 04:42:53.000000000 -0400
+++ b/include/net/netfilter/nf_conntrack_ecache.h	2016-12-12 23:22:31.420131700 -0500
@@ -64,12 +64,18 @@
 	int report;
 };
 
+#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
+extern struct atomic_notifier_head nf_conntrack_chain;
+extern int nf_conntrack_register_notifier(struct net *net, struct notifier_block *nb);
+extern int nf_conntrack_unregister_notifier(struct net *net, struct notifier_block *nb);
+#else
 struct nf_ct_event_notifier {
 	int (*fcn)(unsigned int events, struct nf_ct_event *item);
 };
 
 extern int nf_conntrack_register_notifier(struct net *net, struct nf_ct_event_notifier *nb);
 extern void nf_conntrack_unregister_notifier(struct net *net, struct nf_ct_event_notifier *nb);
+#endif
 
 extern void nf_ct_deliver_cached_events(struct nf_conn *ct);
 
@@ -79,8 +85,10 @@
 	struct net *net = nf_ct_net(ct);
 	struct nf_conntrack_ecache *e;
 
+#ifndef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
 	if (!rcu_access_pointer(net->ct.nf_conntrack_event_cb))
 		return;
+#endif
 
 	e = nf_ct_ecache_find(ct);
 	if (e == NULL)
@@ -100,10 +108,12 @@
 	struct nf_ct_event_notifier *notify;
 	struct nf_conntrack_ecache *e;
 
+#ifndef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
 	rcu_read_lock();
 	notify = rcu_dereference(net->ct.nf_conntrack_event_cb);
 	if (notify == NULL)
 		goto out_unlock;
+#endif
 
 	e = nf_ct_ecache_find(ct);
 	if (e == NULL)
@@ -121,6 +131,10 @@
 		if (!((eventmask | missed) & e->ctmask))
 			goto out_unlock;
 
+#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
+		atomic_notifier_call_chain(&nf_conntrack_chain, eventmask | missed, &item);
+#else
+
 		ret = notify->fcn(eventmask | missed, &item);
 		if (unlikely(ret < 0 || missed)) {
 			spin_lock_bh(&ct->lock);
@@ -137,9 +151,12 @@
 				e->missed &= ~missed;
 			spin_unlock_bh(&ct->lock);
 		}
+#endif
 	}
 out_unlock:
+#ifndef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
 	rcu_read_unlock();
+#endif
 	return ret;
 }
 
diff -uNr a/net/netfilter/nf_conntrack_netlink.c b/net/netfilter/nf_conntrack_netlink.c
--- a/net/netfilter/nf_conntrack_netlink.c	2016-12-12 23:33:27.076389200 -0500
+++ b/net/netfilter/nf_conntrack_netlink.c	2017-12-15 05:04:05.598849600 -0500
@@ -28,6 +28,9 @@
 #include <linux/netlink.h>
 #include <linux/spinlock.h>
 #include <linux/interrupt.h>
+#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
+#include <linux/notifier.h>
+#endif
 #include <linux/slab.h>
 
 #include <linux/netfilter.h>
@@ -611,13 +614,21 @@
 }
 
 #ifdef CONFIG_NF_CONNTRACK_EVENTS
+#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
+static int
+ctnetlink_conntrack_event(struct notifier_block *this, unsigned long events, void *ptr)
+#else
 static int
 ctnetlink_conntrack_event(unsigned int events, struct nf_ct_event *item)
+#endif
 {
 	struct net *net;
 	struct nlmsghdr *nlh;
 	struct nfgenmsg *nfmsg;
 	struct nlattr *nest_parms;
+#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
+	struct nf_ct_event *item = (struct nf_ct_event *)ptr;
+#endif
 	struct nf_conn *ct = item->ct;
 	struct sk_buff *skb;
 	unsigned int type;
@@ -3001,9 +3012,15 @@
 }
 
 #ifdef CONFIG_NF_CONNTRACK_EVENTS
-static struct nf_ct_event_notifier ctnl_notifier = {
-	.fcn = ctnetlink_conntrack_event,
+#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
+static struct notifier_block ctnl_notifier = {
+	.notifier_call = ctnetlink_conntrack_event,
 };
+#else
+ static struct nf_ct_event_notifier ctnl_notifier = {
+ 	.fcn = ctnetlink_conntrack_event,
+ };
+#endif
 
 static struct nf_exp_event_notifier ctnl_notifier_exp = {
 	.fcn = ctnetlink_expect_event,
