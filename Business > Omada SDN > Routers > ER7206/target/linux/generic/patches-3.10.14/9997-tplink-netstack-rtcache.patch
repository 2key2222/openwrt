diff -uprN linux-3.10.14.org/include/net/netfilter/nf_conntrack_extend.h linux-3.10.14/include/net/netfilter/nf_conntrack_extend.h
--- linux-3.10.14.org/include/net/netfilter/nf_conntrack_extend.h	2014-09-02 16:42:53.000000000 +0800
+++ linux-3.10.14/include/net/netfilter/nf_conntrack_extend.h	2016-11-17 23:48:15.640314166 +0800
@@ -20,6 +20,9 @@ enum nf_ct_ext_id {
 #ifdef CONFIG_NF_CONNTRACK_TIMESTAMP
 	NF_CT_EXT_TSTAMP,
 #endif
+#ifdef CONFIG_NF_CONNTRACK_RTCACHE
+    NF_CT_EXT_RTCACHE,
+#endif /* CONFIG_NF_CONNTRACK_RTCACHE */
 #ifdef CONFIG_NF_CONNTRACK_TIMEOUT
 	NF_CT_EXT_TIMEOUT,
 #endif
@@ -35,6 +38,7 @@ enum nf_ct_ext_id {
 #define NF_CT_EXT_ECACHE_TYPE struct nf_conntrack_ecache
 #define NF_CT_EXT_ZONE_TYPE struct nf_conntrack_zone
 #define NF_CT_EXT_TSTAMP_TYPE struct nf_conn_tstamp
+#define NF_CT_EXT_RTCACHE_TYPE struct nf_conn_rtcache
 #define NF_CT_EXT_TIMEOUT_TYPE struct nf_conn_timeout
 #define NF_CT_EXT_LABELS_TYPE struct nf_conn_labels
 
diff -uprN linux-3.10.14.org/include/net/netfilter/nf_conntrack_rtcache.h linux-3.10.14/include/net/netfilter/nf_conntrack_rtcache.h
--- linux-3.10.14.org/include/net/netfilter/nf_conntrack_rtcache.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-3.10.14/include/net/netfilter/nf_conntrack_rtcache.h	2016-11-17 23:49:50.334161195 +0800
@@ -0,0 +1,45 @@
+#include <linux/gfp.h>
+#include <net/netfilter/nf_conntrack.h>
+#include <net/netfilter/nf_conntrack_extend.h>
+
+struct dst_entry;
+
+struct nf_conn_dst_cache {
+    struct dst_entry *dst;
+    int iif;
+#if IS_ENABLED(CONFIG_NF_CONNTRACK_IPV6)
+    u32 cookie;
+#endif
+};
+
+struct nf_conn_rtcache {
+    struct nf_conn_dst_cache cached_dst[IP_CT_DIR_MAX];
+};
+
+static inline
+struct nf_conn_rtcache *nf_ct_rtcache_find(const struct nf_conn *ct)
+{
+#ifdef CONFIG_NF_CONNTRACK_RTCACHE
+    return nf_ct_ext_find(ct, NF_CT_EXT_RTCACHE);
+#else
+    return NULL;
+#endif
+}
+
+static inline int nf_conn_rtcache_iif_get(const struct nf_conn_rtcache *rtc,
+                                          enum ip_conntrack_dir dir)
+{
+    return rtc->cached_dst[dir].iif;
+}
+
+unsigned int
+seq_print_rtcache(struct seq_file *s, const struct nf_conn *ct, int dir);
+
+struct nf_conn_rtcache *
+nf_ct_rtcache_find_usable(struct nf_conn *ct);
+
+int
+nf_conntrack_rtcache_init(void);
+
+void
+nf_conntrack_rtcache_fini(void);
diff -uprN linux-3.10.14.org/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4_compat.c linux-3.10.14/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4_compat.c
--- linux-3.10.14.org/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4_compat.c	2014-09-02 16:43:00.000000000 +0800
+++ linux-3.10.14/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4_compat.c	2016-11-17 23:53:51.748514037 +0800
@@ -21,6 +21,9 @@
 #include <net/netfilter/nf_conntrack_l4proto.h>
 #include <net/netfilter/nf_conntrack_expect.h>
 #include <net/netfilter/nf_conntrack_acct.h>
+#ifdef CONFIG_NF_CONNTRACK_RTCACHE
+#include <net/netfilter/nf_conntrack_rtcache.h>
+#endif /* CONFIG_NF_CONNTRACK_RTCACHE */
 #include <linux/rculist_nulls.h>
 #include <linux/export.h>
 
@@ -156,6 +159,11 @@ static int ct_seq_show(struct seq_file *
 
 	if (seq_print_acct(s, ct, IP_CT_DIR_ORIGINAL))
 		goto release;
+	
+#ifdef CONFIG_NF_CONNTRACK_RTCACHE
+	if (seq_print_rtcache(s, ct, IP_CT_DIR_ORIGINAL))
+		goto release;
+#endif /* CONFIG_NF_CONNTRACK_RTCACHE */
 
 	if (!(test_bit(IPS_SEEN_REPLY_BIT, &ct->status)))
 		if (seq_printf(s, "[UNREPLIED] "))
@@ -167,6 +175,11 @@ static int ct_seq_show(struct seq_file *
 
 	if (seq_print_acct(s, ct, IP_CT_DIR_REPLY))
 		goto release;
+	
+#ifdef CONFIG_NF_CONNTRACK_RTCACHE
+	if (seq_print_rtcache(s, ct, IP_CT_DIR_REPLY))
+		goto release;
+#endif /* CONFIG_NF_CONNTRACK_RTCACHE */
 
 	if (test_bit(IPS_ASSURED_BIT, &ct->status))
 		if (seq_printf(s, "[ASSURED] "))
diff -uprN linux-3.10.14.org/net/ipv4/route.c linux-3.10.14/net/ipv4/route.c
--- linux-3.10.14.org/net/ipv4/route.c	2014-09-02 16:43:01.000000000 +0800
+++ linux-3.10.14/net/ipv4/route.c	2016-11-18 00:03:34.674759010 +0800
@@ -109,6 +109,14 @@
 #endif
 #include <net/secure_seq.h>
 
+#ifdef CONFIG_NF_CONNTRACK_RTCACHE
+#include <net/netfilter/nf_conntrack_rtcache.h>
+
+struct nf_conn_rtcache *(*ip_ct_rtcache_find)(struct nf_conn *ct) = NULL;
+
+EXPORT_SYMBOL(ip_ct_rtcache_find);
+#endif /* CONFIG_NF_CONNTRACK_RTCACHE */
+
 #define RT_FL_TOS(oldflp4) \
 	((oldflp4)->flowi4_tos & (IPTOS_RT_MASK | RTO_ONLINK))
 
@@ -1634,7 +1642,43 @@ static int ip_route_input_slow(struct sk
 	/*
 	 *	Now we are ready to route packet.
 	 */
+	#ifdef CONFIG_NF_CONNTRACK_RTCACHE
+    {
+        struct nf_conn_rtcache *rtc;
+        enum ip_conntrack_info ctinfo;
+        enum ip_conntrack_dir dir;
+        struct nf_conn *ct = NULL;
+        int iif = 0;
+
+        if (!ip_ct_rtcache_find)
+        {
+            goto set_oif;
+        }
+
+        ct = nf_ct_get(skb, &ctinfo);
+        if (!ct)
+        {
+            goto set_oif;
+        }
+
+        dir = CTINFO2DIR(ctinfo);
+
+        rtc = ip_ct_rtcache_find(ct);
+        if (!rtc)
+        {
+            goto set_oif;
+        }
+
+        iif = nf_conn_rtcache_iif_get(rtc, !dir);
+
+        iif = (-1 == iif ? 0 : iif);
+set_oif:
+        fl4.flowi4_oif = iif;
+        //printk(KERN_ERR"\r\nct %p, skb %p : fl4.flowi4_oif = %d\r\n", ct, skb, iif);
+    }
+#else
 	fl4.flowi4_oif = 0;
+#endif /* CONFIG_NF_CONNTRACK_RTCACHE */
 	fl4.flowi4_iif = dev->ifindex;
 	fl4.flowi4_mark = skb->mark;
 	fl4.flowi4_tos = tos;
diff -uprN linux-3.10.14.org/net/netfilter/Kconfig linux-3.10.14/net/netfilter/Kconfig
--- linux-3.10.14.org/net/netfilter/Kconfig	2014-09-02 16:43:02.000000000 +0800
+++ linux-3.10.14/net/netfilter/Kconfig	2016-11-17 23:54:55.971340880 +0800
@@ -151,6 +151,17 @@ config NF_CONNTRACK_LABELS
 	  This option enables support for assigning user-defined flag bits
 	  to connection tracking entries.  It selected by the connlabel match.
 
+config NF_CONNTRACK_RTCACHE
+	bool  'Cache route entries in conntrack objects'
+	depends on NETFILTER_ADVANCED
+	depends on NF_CONNTRACK
+	help
+	  If this option is enabled, the connection tracking code will cache
+	  routing information for each connection that is being forwarded, at
+	  a cost of 32 bytes per conntrack object.
+ 	  To compile it as a module, choose M here. If unsure, say N.
+ 	  The module will be called nf_conntrack_rtcache.
+
 config NF_CT_PROTO_DCCP
 	tristate 'DCCP protocol connection tracking support'
 	depends on NETFILTER_ADVANCED
diff -uprN linux-3.10.14.org/net/netfilter/Makefile linux-3.10.14/net/netfilter/Makefile
--- linux-3.10.14.org/net/netfilter/Makefile	2014-09-02 16:43:02.000000000 +0800
+++ linux-3.10.14/net/netfilter/Makefile	2016-11-17 23:55:30.928343867 +0800
@@ -4,6 +4,7 @@ nf_conntrack-y	:= nf_conntrack_core.o nf
 nf_conntrack-$(CONFIG_NF_CONNTRACK_TIMEOUT) += nf_conntrack_timeout.o
 nf_conntrack-$(CONFIG_NF_CONNTRACK_TIMESTAMP) += nf_conntrack_timestamp.o
 nf_conntrack-$(CONFIG_NF_CONNTRACK_EVENTS) += nf_conntrack_ecache.o
+nf_conntrack-$(CONFIG_NF_CONNTRACK_RTCACHE) += nf_conntrack_rtcache.o
 nf_conntrack-$(CONFIG_NF_CONNTRACK_LABELS) += nf_conntrack_labels.o
 
 obj-$(CONFIG_NETFILTER) = netfilter.o
diff -uprN linux-3.10.14.org/net/netfilter/nf_conntrack_core.c linux-3.10.14/net/netfilter/nf_conntrack_core.c
--- linux-3.10.14.org/net/netfilter/nf_conntrack_core.c	2014-09-02 16:43:02.000000000 +0800
+++ linux-3.10.14/net/netfilter/nf_conntrack_core.c	2016-11-18 00:09:00.401286157 +0800
@@ -49,6 +49,9 @@
 #include <net/netfilter/nf_conntrack_labels.h>
 #include <net/netfilter/nf_nat.h>
 #include <net/netfilter/nf_nat_core.h>
+#ifdef CONFIG_NF_CONNTRACK_RTCACHE
+#include <net/netfilter/nf_conntrack_rtcache.h>
+#endif
 #include <net/netfilter/nf_nat_helper.h>
 
 #if  defined(CONFIG_RA_HW_NAT) || defined(CONFIG_RA_HW_NAT_MODULE)
@@ -1752,6 +1755,13 @@ int nf_conntrack_init_start(void)
 	if (ret < 0)
 		goto err_extend;
 #endif
+
+#ifdef CONFIG_NF_CONNTRACK_RTCACHE
+    ret = nf_conntrack_rtcache_init();
+    if (ret < 0)
+        goto err_rtcache_ext;
+#endif
+
 	ret = nf_conntrack_proto_init();
 	if (ret < 0)
 		goto err_proto;
@@ -1771,6 +1781,10 @@ err_proto:
 	nf_ct_extend_unregister(&nf_ct_zone_extend);
 err_extend:
 #endif
+#ifdef CONFIG_NF_CONNTRACK_RTCACHE
+    nf_conntrack_rtcache_fini();
+err_rtcache_ext:
+#endif
 	nf_conntrack_labels_fini();
 err_labels:
 	nf_conntrack_helper_fini();
diff -uprN linux-3.10.14.org/net/netfilter/nf_conntrack_rtcache.c linux-3.10.14/net/netfilter/nf_conntrack_rtcache.c
--- linux-3.10.14.org/net/netfilter/nf_conntrack_rtcache.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-3.10.14/net/netfilter/nf_conntrack_rtcache.c	2016-11-17 23:56:37.713842055 +0800
@@ -0,0 +1,576 @@
+/*
+ * route cache
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME": "fmt
+
+#include <linux/types.h>
+#include <linux/netfilter.h>
+#include <linux/skbuff.h>
+#include <linux/stddef.h>
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <linux/export.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <net/dst.h>
+#include <net/netfilter/nf_conntrack.h>
+#include <net/netfilter/nf_conntrack_core.h>
+#include <net/netfilter/nf_conntrack_extend.h>
+#include <net/netfilter/nf_conntrack_rtcache.h>
+
+#if IS_ENABLED(CONFIG_NF_CONNTRACK_IPV6)
+#include <net/ip6_fib.h>
+#endif /* IS_ENABLED(CONFIG_NF_CONNTRACK_IPV6) */
+
+#ifdef CONFIG_XFRM
+#define dst_xfrm(dst)   ((dst)->xfrm)
+#else
+#define dst_xfrm(dst)   NULL
+#endif /* CONFIG_XFRM */
+
+extern struct nf_conn_rtcache *(*ip_ct_rtcache_find)(struct nf_conn *ct);
+
+unsigned int
+seq_print_rtcache(struct seq_file *s, const struct nf_conn *ct, int dir)
+{
+#ifdef CONFIG_NF_CONNTRACK_RTCACHE
+	struct nf_conn_rtcache *rtc = NULL;
+
+	rtc = nf_ct_rtcache_find(ct);
+	if (!rtc)
+    {
+		return seq_printf(s, "dst_entry=%p iif=%d ", NULL, -1);
+    }
+
+	return seq_printf(s, "dst_entry=%p iif=%d ", rtc->cached_dst[dir].dst, rtc->cached_dst[dir].iif);
+#else
+    return 0;
+#endif
+};
+EXPORT_SYMBOL(seq_print_rtcache);
+
+static void
+__nf_conn_rtcache_destroy(struct nf_conn_rtcache *rtc, enum ip_conntrack_dir dir)
+{
+    struct dst_entry *dst = rtc->cached_dst[dir].dst;
+
+    dst_release(dst);
+}
+
+static void
+nf_conn_rtcache_destroy(struct nf_conn *ct)
+{
+    struct nf_conn_rtcache *rtc = nf_ct_rtcache_find(ct);
+
+    if (!rtc)
+        return;
+
+    __nf_conn_rtcache_destroy(rtc, IP_CT_DIR_ORIGINAL);
+    __nf_conn_rtcache_destroy(rtc, IP_CT_DIR_REPLY);
+}
+
+static void
+nf_ct_rtcache_ext_add(struct nf_conn *ct)
+{
+    struct nf_conn_rtcache *rtc = NULL;
+
+    rtc = nf_ct_ext_add(ct, NF_CT_EXT_RTCACHE, GFP_ATOMIC);
+    if (rtc) {
+        rtc->cached_dst[IP_CT_DIR_ORIGINAL].iif = -1;
+        rtc->cached_dst[IP_CT_DIR_ORIGINAL].dst = NULL;
+        rtc->cached_dst[IP_CT_DIR_REPLY].iif = -1;
+        rtc->cached_dst[IP_CT_DIR_REPLY].dst = NULL;
+    }
+}
+
+struct nf_conn_rtcache *
+nf_ct_rtcache_find_usable(struct nf_conn *ct)
+{
+    if (nf_ct_is_untracked(ct))
+        return NULL;
+    return (struct nf_conn_rtcache *)nf_ct_rtcache_find(ct);
+}
+EXPORT_SYMBOL(nf_ct_rtcache_find_usable);
+
+static struct dst_entry *
+nf_conn_rtcache_dst_get(const struct nf_conn_rtcache *rtc, enum ip_conntrack_dir dir)
+{
+    return rtc->cached_dst[dir].dst;
+}
+
+static u32 nf_rtcache_get_cookie(int pf, const struct dst_entry *dst)
+{
+#if IS_ENABLED(CONFIG_NF_CONNTRACK_IPV6)
+    if (NFPROTO_IPV6 == pf) {
+        const struct rt6_info *rt = (const struct rt6_info *)dst;
+
+        if (rt->rt6i_node)
+            return (u32)rt->rt6i_node->fn_sernum;
+    }
+#endif /* IS_ENABLED(CONFIG_NF_CONNTRACK_IPV6) */
+    return 0;
+}
+
+static void nf_conn_rtcache_dst_set(int pf,
+                                    struct nf_conn_rtcache *rtc,
+                                    struct dst_entry *dst,
+                                    enum ip_conntrack_dir dir,
+                                    int iif)
+{
+    if (rtc->cached_dst[dir].iif != iif)
+        rtc->cached_dst[dir].iif = iif;
+
+    if (rtc->cached_dst[dir].dst != dst) {
+        struct dst_entry *old;
+
+        dst_hold(dst);
+
+        old = xchg(&rtc->cached_dst[dir].dst, dst);
+        dst_release(old);
+
+#if IS_ENABLED(CONFIG_NF_CONNTRACK_IPV6)
+        if (NFPROTO_IPV6 == pf)
+            rtc->cached_dst[dir].cookie = nf_rtcache_get_cookie(pf, dst);
+#endif /* IS_ENABLED(CONFIG_NF_CONNTRACK_IPV6) */
+    }
+}
+
+static void
+nf_conn_rtcache_dst_obsolete(struct nf_conn_rtcache *rtc, enum ip_conntrack_dir dir)
+{
+    struct dst_entry *old;
+
+    pr_debug("Invalidate iif %d for dir %d on cache %p\n",
+             rtc->cached_dst[dir].iif, dir, rtc);
+
+    old = xchg(&rtc->cached_dst[dir].dst, NULL);
+    dst_release(old);
+    rtc->cached_dst[dir].iif = -1;
+}
+
+static unsigned int
+nf_ipv4_rtcache_in(unsigned hooknum,
+                   struct sk_buff *skb,
+                   const struct net_device *in,
+                   const struct net_device *out,
+                   int (*okfn)(struct sk_buff *))
+{
+    struct nf_conn_rtcache *rtc;
+    enum ip_conntrack_info ctinfo;
+    enum ip_conntrack_dir dir;
+    struct dst_entry *dst;
+    struct nf_conn *ct;
+    int iif;
+    int oif;
+    u32 cookie;
+
+    if (skb_dst(skb) || skb->sk)
+        return NF_ACCEPT;
+
+    ct = nf_ct_get(skb, &ctinfo);
+    if (!ct)
+        return NF_ACCEPT;
+
+    rtc = nf_ct_rtcache_find_usable(ct);
+    if (!rtc)
+        return NF_ACCEPT;
+
+    /* If iif changes, don't use cache and let ip stack do route lookup.
+     *
+     * If rp_filter is enabled it might toss skb, so we don't want to avoid
+     * these checks.
+     */
+    dir = CTINFO2DIR(ctinfo);
+    iif = nf_conn_rtcache_iif_get(rtc, dir);
+    if (in->ifindex != iif) {
+        pr_debug("ct %p, iif %d, cached iif %d, skip cached entry\n",
+                 ct, iif, in->ifindex);
+        return NF_ACCEPT;
+    }
+
+    dst = nf_conn_rtcache_dst_get(rtc, dir);
+    if (NULL == dst)
+        return NF_ACCEPT;
+
+    cookie = nf_rtcache_get_cookie(NFPROTO_IPV4, dst);
+    dst = dst_check(dst, cookie);
+
+    iif = nf_conn_rtcache_iif_get(rtc, dir);
+    oif = nf_conn_rtcache_iif_get(rtc, !dir);
+#if 0
+    printk(KERN_ERR"\r\nct %p, skb %p need check: \r\n\t\t%s, iif %-3d(%-32s), cached iif %-3d dst %p check result %p  DST_NOCACHE %d\r\n\t\t%s, oif %-3d(%-32s), cached oif %-3d dst %p\n",
+            ct, skb,
+            !dir ? "ORIG" : "RPLY", in->ifindex, in->name, iif, rtc->cached_dst[dir].dst, dst, dst ? dst->flags & DST_NOCACHE : -1,
+            dir ? "ORIG" : "RPLY", out ? out->ifindex : -1, out ? out->name : "null", oif, rtc->cached_dst[!dir].dst);
+#endif /* 0 */
+
+    pr_debug("obtained dst %p for skb %p, cookie %d\n", dst, skb, cookie);
+    if (likely(dst))
+		skb->_skb_refdst = (unsigned long)dst | SKB_DST_NOREF;
+    else
+    {
+        //printk(KERN_ERR"dst_check failed, nf_conn_rtcache_dst_obsolete rtc\r\n");
+        nf_conn_rtcache_dst_obsolete(rtc, dir);
+    }
+
+    return NF_ACCEPT;
+}
+
+#if IS_ENABLED(CONFIG_NF_CONNTRACK_IPV6)
+static unsigned int
+nf_ipv6_rtcache_in(unsigned hooknum,
+                   struct sk_buff *skb,
+                   const struct net_device *in,
+                   const struct net_device *out,
+                   int (*okfn)(struct sk_buff *))
+{
+    struct nf_conn_rtcache *rtc;
+    enum ip_conntrack_info ctinfo;
+    enum ip_conntrack_dir dir;
+    struct dst_entry *dst;
+    struct nf_conn *ct;
+    int iif;
+    u32 cookie;
+
+    if (skb_dst(skb) || skb->sk)
+        return NF_ACCEPT;
+
+    ct = nf_ct_get(skb, &ctinfo);
+    if (!ct)
+        return NF_ACCEPT;
+
+    rtc = nf_ct_rtcache_find_usable(ct);
+    if (!rtc)
+        return NF_ACCEPT;
+
+    /* If iif changes, don't use cache and let ip stack do route lookup.
+     *
+     * If rp_filter is enabled it might toss skb, so we don't want to avoid
+     * these checks.
+     */
+    dir = CTINFO2DIR(ctinfo);
+    iif = nf_conn_rtcache_iif_get(rtc, dir);
+    if (in->ifindex != iif) {
+        pr_debug("ct %p, iif %d, cached iif %d, skip cached entry\n",
+                 ct, iif, in->ifindex);
+        return NF_ACCEPT;
+    }
+
+    dst = nf_conn_rtcache_dst_get(rtc, dir);
+    if (NULL == dst)
+        return NF_ACCEPT;
+
+    cookie = nf_rtcache_get_cookie(NFPROTO_IPV6, dst);
+
+    dst = dst_check(dst, cookie);
+    pr_debug("obtained dst %p for skb %p, cookie %d\n", dst, skb, cookie);
+    if (likely(dst))
+        skb_dst_set_noref(skb, dst);
+    else
+        nf_conn_rtcache_dst_obsolete(rtc, dir);
+
+    return NF_ACCEPT;
+}
+#endif /* IS_ENABLED(CONFIG_NF_CONNTRACK_IPV6) */
+
+static unsigned int
+nf_ipv4_rtcache_forward(unsigned int hooknum,
+                        struct sk_buff *skb,
+                        const struct net_device *in,
+                        const struct net_device *out,
+                        int (*okfn)(struct sk_buff *))
+{
+    struct nf_conn_rtcache *rtc;
+    enum ip_conntrack_info ctinfo;
+    enum ip_conntrack_dir dir;
+    struct nf_conn *ct;
+    struct dst_entry *dst = skb_dst(skb);
+    int iif;
+    int oif;
+
+    ct = nf_ct_get(skb, &ctinfo);
+    if (!ct)
+        return NF_ACCEPT;
+
+    if (dst && dst_xfrm(dst))
+        return NF_ACCEPT;
+
+    dir = CTINFO2DIR(ctinfo);
+
+    if (!nf_ct_is_confirmed(ct)) {
+        if (WARN_ON(nf_ct_rtcache_find(ct)))
+            return NF_ACCEPT;
+
+        nf_ct_rtcache_ext_add(ct);
+
+        /* no need to confirm indev of ORIGINAL, directly save it */
+        if (WARN_ON(IP_CT_DIR_ORIGINAL != dir))
+            return NF_ACCEPT;
+
+        rtc = nf_ct_rtcache_find_usable(ct);
+        if (!rtc)
+            return NF_ACCEPT;
+
+        nf_conn_rtcache_dst_set(NFPROTO_IPV4, rtc, NULL, dir, in->ifindex);
+        iif = nf_conn_rtcache_iif_get(rtc, dir);
+        oif = nf_conn_rtcache_iif_get(rtc, !dir);
+#if 0
+        printk(KERN_ERR"\r\nct %p, skb %p not confirmed: \r\n\t\t%s, iif %-3d(%-32s), cached iif %-3d dst %p \r\n\t\t%s, oif %-3d(%-32s), cached oif %-3d dst %p\n",
+                ct, skb,
+                !dir ? "ORIG" : "RPLY", in->ifindex, in->name, iif, rtc->cached_dst[dir].dst,
+                dir ? "ORIG" : "RPLY", out ? out->ifindex : -1, out ? out->name : "null", oif, rtc->cached_dst[!dir].dst);
+#endif /* 0 */
+        return NF_ACCEPT;
+    }
+
+    rtc = nf_ct_rtcache_find_usable(ct);
+    if (!rtc)
+        return NF_ACCEPT;
+
+    iif = nf_conn_rtcache_iif_get(rtc, dir);
+    oif = nf_conn_rtcache_iif_get(rtc, !dir);
+    pr_debug("ct %p, skb %p, dir %d, iif %d, cached iif %d\n",
+             ct, skb, dir, iif, in->ifindex);
+#if 0
+    printk(KERN_ERR"\r\nct %p, skb %p : \r\n\t\t%s, iif %-3d(%-32s), cached iif %-3d dst %p skb_dst %p\r\n\t\t%s, oif %-3d(%-32s), cached oif %-3d dst %p\n",
+           ct, skb,
+           !dir ? "ORIG" : "RPLY", in->ifindex, in->name, iif, rtc->cached_dst[dir].dst, skb_dst(skb),
+           dir ? "ORIG" : "RPLY", out ? out->ifindex : -1, out ? out->name : "null", oif, rtc->cached_dst[!dir].dst);
+#endif /* 0 */
+
+#if 0
+    /* revise output if */
+    if (IP_CT_DIR_REPLY == dir && out && out->ifindex != oif) {
+        struct rtable *rt;
+        struct iphdr *iph = ip_hdr(skb);
+
+        rt = ip_route_output(dev_net(in), iph->daddr, 0, RT_TOS(iph->tos), oif);
+        if (!IS_ERR(rt)) {
+            skb_dst_set_noref_force(skb, &rt->dst);
+        }
+    }
+
+    if (likely(in->ifindex == iif))
+        return NF_ACCEPT;
+#endif /* 0 */
+
+    /*nf_conn_rtcache_dst_set(NFPROTO_IPV4, rtc, skb_dst(skb), dir, in->ifindex);*/
+    return NF_ACCEPT;
+}
+
+#if IS_ENABLED(CONFIG_NF_CONNTRACK_IPV6)
+static unsigned int
+nf_ipv6_rtcache_forward(unsigned int hooknum,
+                        struct sk_buff *skb,
+                        const struct net_device *in,
+                        const struct net_device *out,
+                        int (*okfn)(struct sk_buff *))
+{
+    struct nf_conn_rtcache *rtc;
+    enum ip_conntrack_info ctinfo;
+    enum ip_conntrack_dir dir;
+    struct nf_conn *ct;
+    struct dst_entry *dst = skb_dst(skb);
+    int iif;
+
+    ct = nf_ct_get(skb, &ctinfo);
+    if (!ct)
+        return NF_ACCEPT;
+
+    if (dst && dst_xfrm(dst))
+        return NF_ACCEPT;
+
+    if (!nf_ct_is_confirmed(ct)) {
+        if (WARN_ON(nf_ct_rtcache_find(ct)))
+            return NF_ACCEPT;
+
+        nf_ct_rtcache_ext_add(ct);
+        return NF_ACCEPT;
+    }
+
+    rtc = nf_ct_rtcache_find_usable(ct);
+    if (!rtc)
+        return NF_ACCEPT;
+
+    dir = CTINFO2DIR(ctinfo);
+    iif = nf_conn_rtcache_iif_get(rtc, dir);
+    pr_debug("ct %p, skb %p, dir %d, iif %d, cached iif %d\n",
+             ct, skb, dir, iif, in->ifindex);
+
+    if (likely(in->ifindex == iif))
+        return NF_ACCEPT;
+
+    nf_conn_rtcache_dst_set(NFPROTO_IPV6, rtc, skb_dst(skb), dir, in->ifindex);
+    return NF_ACCEPT;
+}
+#endif /* IS_ENABLED(CONFIG_NF_CONNTRACK_IPV6) */
+
+static int
+nf_rtcache_dst_remove(struct nf_conn *ct, void *data)
+{
+    struct nf_conn_rtcache *rtc = nf_ct_rtcache_find(ct);
+    struct net_device *dev = data;
+
+    if (!rtc)
+        return 0;
+
+    if (dev->ifindex == rtc->cached_dst[IP_CT_DIR_ORIGINAL].iif ||
+        dev->ifindex == rtc->cached_dst[IP_CT_DIR_REPLY].iif) {
+        nf_conn_rtcache_dst_obsolete(rtc, IP_CT_DIR_ORIGINAL);
+        nf_conn_rtcache_dst_obsolete(rtc, IP_CT_DIR_REPLY);
+    }
+
+    return 0;
+}
+
+static int
+nf_rtcache_netdev_event(struct notifier_block *this,
+                        unsigned long event, void *ptr)
+{
+    struct net_device *dev = ptr;
+    struct net *net = dev_net(dev);
+
+    if (NETDEV_DOWN == event)
+        nf_ct_iterate_cleanup(net, nf_rtcache_dst_remove, dev);
+
+    return NOTIFY_DONE;
+}
+
+static struct notifier_block nf_rtcache_notifier = {
+    .notifier_call = nf_rtcache_netdev_event,
+};
+
+static struct nf_hook_ops rtcache_ops[] = {
+    {
+        .hook       = nf_ipv4_rtcache_in,
+        .owner      = THIS_MODULE,
+        .pf         = NFPROTO_IPV4,
+        .hooknum    = NF_INET_PRE_ROUTING,
+        .priority   = NF_IP_PRI_LAST,
+    },
+    {
+        .hook       = nf_ipv4_rtcache_forward,
+        .owner      = THIS_MODULE,
+        .pf         = NFPROTO_IPV4,
+        .hooknum    = NF_INET_FORWARD,
+        .priority   = NF_IP_PRI_LAST,
+    },
+#if IS_ENABLED(CONFIG_NF_CONNTRACK_IPV6)
+    {
+        .hook       = nf_ipv6_rtcache_in,
+        .owner      = THIS_MODULE,
+        .pf         = NFPROTO_IPV6,
+        .hooknum    = NF_INET_PRE_ROUTING,
+        .priority   = NF_IP_PRI_LAST,
+    },
+    {
+        .hook       = nf_ipv6_rtcache_forward,
+        .owner      = THIS_MODULE,
+        .pf         = NFPROTO_IPV6,
+        .hooknum    = NF_INET_FORWARD,
+        .priority   = NF_IP_PRI_LAST,
+    },
+#endif /* IS_ENABLED(CONFIG_NF_CONNTRACK_IPV6) */
+};
+
+static struct nf_ct_ext_type rtcache_ext __read_mostly = {
+    .len        = sizeof(struct nf_conn_rtcache),
+    .align      = __alignof__(struct nf_conn_rtcache),
+    .id         = NF_CT_EXT_RTCACHE,
+    .destroy    = nf_conn_rtcache_destroy,
+};
+
+
+int
+nf_conntrack_rtcache_init(void)
+{
+    int ret = nf_ct_extend_register(&rtcache_ext);
+
+    if (ret < 0) {
+        pr_err("nf_conntrack_rtcache: unable to register extension\n");
+        return ret;
+    }
+
+    ret = nf_register_hooks(rtcache_ops, ARRAY_SIZE(rtcache_ops));
+    if (ret < 0) {
+        nf_ct_extend_unregister(&rtcache_ext);
+        return ret;
+    }
+
+    ret = register_netdevice_notifier(&nf_rtcache_notifier);
+    if (ret) {
+        nf_unregister_hooks(rtcache_ops, ARRAY_SIZE(rtcache_ops));
+        nf_ct_extend_unregister(&rtcache_ext);
+        return ret;
+    }
+
+    ip_ct_rtcache_find = nf_ct_rtcache_find_usable;
+
+    return ret;
+}
+
+static int
+nf_rtcache_ext_remove(struct nf_conn *ct, void *data)
+{
+    struct nf_conn_rtcache *rtc = nf_ct_rtcache_find(ct);
+
+    return rtc != NULL;
+}
+
+static bool
+nf_conntrack_rtcache_wait_for_dying(struct net *net)
+{
+    bool wait = false;
+
+	struct nf_conntrack_tuple_hash *h;
+	struct nf_conn *ct;
+	struct hlist_nulls_node *n;
+
+	spin_lock_bh(&nf_conntrack_lock);
+	hlist_nulls_for_each_entry(h, n, &net->ct.dying, hnnode) {
+		ct = nf_ct_tuplehash_to_ctrack(h);
+        if (nf_ct_rtcache_find(ct) != NULL) {
+            wait = true;
+            break;
+        }
+	}
+	spin_unlock_bh(&nf_conntrack_lock);
+
+    return wait;
+}
+
+void
+nf_conntrack_rtcache_fini(void)
+{
+    struct net *net;
+    int count = 0;
+
+    ip_ct_rtcache_find = NULL;
+
+    /* remove hooks so no new connections get rtcache extension */
+    nf_unregister_hooks(rtcache_ops, ARRAY_SIZE(rtcache_ops));
+
+    synchronize_net();
+
+    unregister_netdevice_notifier(&nf_rtcache_notifier);
+
+    rtnl_lock();
+
+    /* zap all conntracks with rtcache extension */
+    for_each_net(net) {
+        nf_ct_iterate_cleanup(net, nf_rtcache_ext_remove, NULL);
+    }
+
+    for_each_net(net) {
+        /* .. and make sure they're gone from dying list, too */
+        while (nf_conntrack_rtcache_wait_for_dying(net)) {
+            msleep(200);
+            WARN_ONCE(++count > 25, "Waiting for all rtcache conntracks to go away\n");
+        }
+    }
+
+    rtnl_unlock();
+    synchronize_net();
+    nf_ct_extend_unregister(&rtcache_ext);
+}
diff -uprN linux-3.10.14.org/net/netfilter/nf_conntrack_standalone.c linux-3.10.14/net/netfilter/nf_conntrack_standalone.c
--- linux-3.10.14.org/net/netfilter/nf_conntrack_standalone.c	2014-09-02 16:43:02.000000000 +0800
+++ linux-3.10.14/net/netfilter/nf_conntrack_standalone.c	2016-11-17 23:58:18.370312810 +0800
@@ -31,6 +31,9 @@
 #include <net/netfilter/nf_conntrack_acct.h>
 #include <net/netfilter/nf_conntrack_zones.h>
 #include <net/netfilter/nf_conntrack_timestamp.h>
+#ifdef CONFIG_NF_CONNTRACK_RTCACHE
+#include <net/netfilter/nf_conntrack_rtcache.h>
+#endif /* CONFIG_NF_CONNTRACK_RTCACHE */
 #include <linux/rculist_nulls.h>
 
 MODULE_LICENSE("GPL");
@@ -209,6 +212,11 @@ static int ct_seq_show(struct seq_file *
 	if (seq_print_acct(s, ct, IP_CT_DIR_ORIGINAL))
 		goto release;
 
+#ifdef CONFIG_NF_CONNTRACK_RTCACHE
+	if (seq_print_rtcache(s, ct, IP_CT_DIR_ORIGINAL))
+		goto release;
+#endif /* CONFIG_NF_CONNTRACK_RTCACHE */
+
 	if (!(test_bit(IPS_SEEN_REPLY_BIT, &ct->status)))
 		if (seq_printf(s, "[UNREPLIED] "))
 			goto release;
@@ -220,6 +228,11 @@ static int ct_seq_show(struct seq_file *
 	if (seq_print_acct(s, ct, IP_CT_DIR_REPLY))
 		goto release;
 
+#ifdef CONFIG_NF_CONNTRACK_RTCACHE
+	if (seq_print_rtcache(s, ct, IP_CT_DIR_REPLY))
+		goto release;
+#endif /* CONFIG_NF_CONNTRACK_RTCACHE */
+
 	if (test_bit(IPS_ASSURED_BIT, &ct->status))
 		if (seq_printf(s, "[ASSURED] "))
 			goto release;
