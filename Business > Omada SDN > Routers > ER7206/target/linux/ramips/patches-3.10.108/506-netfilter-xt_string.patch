Index: a/include/uapi/linux/netfilter/xt_string.h
===================================================================
--- a/include/uapi/linux/netfilter/xt_string.h	2014-09-02 16:42:55.000000000 +0800
+++ b/include/uapi/linux/netfilter/xt_string.h	2014-10-27 08:12:47.914771182 +0800
@@ -3,6 +3,8 @@
 
 #include <linux/types.h>
 
+#define	XT_STRING_MAX_NUM			16 /*  by liyi, 28Mar14 */
+
 #define XT_STRING_MAX_PATTERN_SIZE 128
 #define XT_STRING_MAX_ALGO_NAME_SIZE 16
 
@@ -15,8 +17,8 @@
 	__u16 from_offset;
 	__u16 to_offset;
 	char	  algo[XT_STRING_MAX_ALGO_NAME_SIZE];
-	char 	  pattern[XT_STRING_MAX_PATTERN_SIZE];
-	__u8  patlen;
+	char 	  pattern[XT_STRING_MAX_NUM][XT_STRING_MAX_PATTERN_SIZE];
+	__u8  patlen[XT_STRING_MAX_NUM];
 	union {
 		struct {
 			__u8  invert;
@@ -28,7 +30,9 @@
 	} u;
 
 	/* Used internally by the kernel */
-	struct ts_config __attribute__((aligned(8))) *config;
+	struct ts_config __attribute__((aligned(8))) *config[XT_STRING_MAX_NUM];
+
+	__u32 string_count;
 };
 
 #endif /*_XT_STRING_H*/
Index: a/net/netfilter/xt_string.c
===================================================================
--- a/net/netfilter/xt_string.c	2014-09-02 16:43:02.000000000 +0800
+++ b/net/netfilter/xt_string.c	2014-10-27 08:16:53.746775625 +0800
@@ -28,47 +28,71 @@
 	const struct xt_string_info *conf = par->matchinfo;
 	struct ts_state state;
 	bool invert;
+	bool second_ret;
+	int i;
 
-	memset(&state, 0, sizeof(struct ts_state));
 	invert = conf->u.v1.flags & XT_STRING_FLAG_INVERT;
+					
+	for (i = 0; i < conf->string_count; ++i)
+	{
+		memset(&state, 0, sizeof(struct ts_state));
+
+		second_ret = (skb_find_text((struct sk_buff *)skb, conf->from_offset,
+			     	  conf->to_offset, conf->config[i], &state) != UINT_MAX);
+
+		if (second_ret == true)
+			break;
+	}
 
-	return (skb_find_text((struct sk_buff *)skb, conf->from_offset,
-			     conf->to_offset, conf->config, &state)
-			     != UINT_MAX) ^ invert;
+	return  second_ret ^ invert;
 }
 
-#define STRING_TEXT_PRIV(m) ((struct xt_string_info *)(m))
-
 static int string_mt_check(const struct xt_mtchk_param *par)
 {
 	struct xt_string_info *conf = par->matchinfo;
 	struct ts_config *ts_conf;
 	int flags = TS_AUTOLOAD;
 
+	int i;
+
 	/* Damn, can't handle this case properly with iptables... */
 	if (conf->from_offset > conf->to_offset)
 		return -EINVAL;
+
 	if (conf->algo[XT_STRING_MAX_ALGO_NAME_SIZE - 1] != '\0')
 		return -EINVAL;
-	if (conf->patlen > XT_STRING_MAX_PATTERN_SIZE)
-		return -EINVAL;
+
 	if (conf->u.v1.flags &
 	    ~(XT_STRING_FLAG_IGNORECASE | XT_STRING_FLAG_INVERT))
 		return -EINVAL;
+
 	if (conf->u.v1.flags & XT_STRING_FLAG_IGNORECASE)
 		flags |= TS_IGNORECASE;
-	ts_conf = textsearch_prepare(conf->algo, conf->pattern, conf->patlen,
-				     GFP_KERNEL, flags);
-	if (IS_ERR(ts_conf))
-		return PTR_ERR(ts_conf);
+	for (i = 0; i < conf->string_count; ++i)
+	{
+		if (conf->patlen[i] > XT_STRING_MAX_PATTERN_SIZE)
+			return -EINVAL;
+			
+		ts_conf = textsearch_prepare(conf->algo, conf->pattern[i], 
+			             conf->patlen[i], GFP_KERNEL, flags);
+		
+		if (IS_ERR(ts_conf))
+			return PTR_ERR(ts_conf);
 
-	conf->config = ts_conf;
+	    conf->config[i] = ts_conf;
+	}
 	return 0;
 }
 
 static void string_mt_destroy(const struct xt_mtdtor_param *par)
 {
-	textsearch_destroy(STRING_TEXT_PRIV(par->matchinfo)->config);
+	int i;
+	struct xt_string_info *conf = par->matchinfo;
+
+	for (i = 0; i < conf->string_count; ++i)
+	{
+		textsearch_destroy(conf->config[i]);
+	}
 }
 
 static struct xt_match xt_string_mt_reg __read_mostly = {
