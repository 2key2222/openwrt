diff -Naru -x .svn linux-3.10.49/include/linux/hardirq.h linux-3.10.49.new/include/linux/hardirq.h
--- linux-3.10.49/include/linux/hardirq.h	2014-07-18 06:58:15.000000000 +0800
+++ linux-3.10.49.new/include/linux/hardirq.h	2015-08-06 14:16:27.108178892 +0800
@@ -61,7 +61,11 @@
 #define HARDIRQ_OFFSET	(1UL << HARDIRQ_SHIFT)
 #define NMI_OFFSET	(1UL << NMI_SHIFT)
 
-#define SOFTIRQ_DISABLE_OFFSET	(2 * SOFTIRQ_OFFSET)
+#ifndef CONFIG_PREEMPT_RT_FULL
+# define SOFTIRQ_DISABLE_OFFSET	(2 * SOFTIRQ_OFFSET)
+#else
+# define SOFTIRQ_DISABLE_OFFSET (0)
+#endif
 
 #ifndef PREEMPT_ACTIVE
 #define PREEMPT_ACTIVE_BITS	1
@@ -74,10 +78,16 @@
 #endif
 
 #define hardirq_count()	(preempt_count() & HARDIRQ_MASK)
-#define softirq_count()	(preempt_count() & SOFTIRQ_MASK)
 #define irq_count()	(preempt_count() & (HARDIRQ_MASK | SOFTIRQ_MASK \
 				 | NMI_MASK))
 
+#ifndef CONFIG_PREEMPT_RT_FULL
+# define softirq_count()	(preempt_count() & SOFTIRQ_MASK)
+# define in_serving_softirq()	(softirq_count() & SOFTIRQ_OFFSET)
+#else
+# define softirq_count()	(0UL)
+extern int in_serving_softirq(void);
+#endif
 /*
  * Are we doing bottom half or hardware interrupt processing?
  * Are we in a softirq context? Interrupt context?
@@ -87,7 +97,6 @@
 #define in_irq()		(hardirq_count())
 #define in_softirq()		(softirq_count())
 #define in_interrupt()		(irq_count())
-#define in_serving_softirq()	(softirq_count() & SOFTIRQ_OFFSET)
 
 /*
  * Are we in NMI context?
diff -Naru -x .svn linux-3.10.49/include/linux/kdb.h linux-3.10.49.new/include/linux/kdb.h
--- linux-3.10.49/include/linux/kdb.h	2014-07-18 06:58:15.000000000 +0800
+++ linux-3.10.49.new/include/linux/kdb.h	2015-08-06 14:16:27.086178892 +0800
@@ -115,7 +115,7 @@
 extern __printf(1, 0) int vkdb_printf(const char *fmt, va_list args);
 extern __printf(1, 2) int kdb_printf(const char *, ...);
 typedef __printf(1, 2) int (*kdb_printf_t)(const char *, ...);
-
+#define in_kdb_printk() (kdb_trap_printk)
 extern void kdb_init(int level);
 
 /* Access to kdb specific polling devices */
@@ -150,6 +150,7 @@
 extern int kdb_unregister(char *);
 #else /* ! CONFIG_KGDB_KDB */
 static inline __printf(1, 2) int kdb_printf(const char *fmt, ...) { return 0; }
+#define in_kdb_printk() (0)
 static inline void kdb_init(int level) {}
 static inline int kdb_register(char *cmd, kdb_func_t func, char *usage,
 			       char *help, short minlen) { return 0; }
diff -Naru -x .svn linux-3.10.49/include/linux/msa.h linux-3.10.49.new/include/linux/msa.h
--- linux-3.10.49/include/linux/msa.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-3.10.49.new/include/linux/msa.h	2015-08-06 14:16:27.077178892 +0800
@@ -0,0 +1,82 @@
+/*
+ * msa.h
+ *   microstate accounting.  See Documentation/MicrostateAccounting for info.
+ *
+ * Copyright (c) Peter Chubb 2005
+ *  UNSW and National ICT Australia
+ * Copyright (c) 2010 MontaVista Software, LLC
+ *  Corey Minyard <minyard@mvista.com>, <minyard@acm.org>, <source@mvista.com>
+ */
+
+#ifndef _LINUX_MSA_H
+#define _LINUX_MSA_H
+
+#include <uapi/linux/msa.h>
+
+#ifdef __KERNEL__
+
+#include <linux/compiler.h> /* For __user */
+
+extern long asmlinkage sys_msa(int ntimers, int which,
+			       msa_time_t __user *timers);
+
+/* Forward definition... */
+struct task_struct;
+
+#ifdef CONFIG_MICROSTATE_ACCT
+
+#include <asm/msa.h>
+
+/*
+ * Times are tracked for the current task in timers[], and for the
+ * current task's children in child_timers[] (accumulated at wait()
+ * time).  One of these structures is added to every struct task_struct.
+ */
+struct microstates {
+	enum msa_thread_state cur_state;
+	enum msa_thread_state next_state;
+	msa_time_t last_change;	/* When the last change happened */
+#ifdef CONFIG_MICROSTATE_ACCT_TIMEPROB_DETECT
+	int last_change_cpu;
+#endif
+	msa_time_t timers[MSA_NR_STATES];
+	msa_time_t child_timers[MSA_NR_STATES];
+};
+
+/* Has to be a macro because microstates is part of task_struct */
+#define msa_next_state(p, s) do { (p)->microstates.next_state = s; } while(0)
+void msa_switch(struct task_struct *prev, struct task_struct *next);
+void msa_update_parent(struct task_struct *parent, struct task_struct *this);
+void msa_init(struct task_struct *p);
+void msa_set_timer(struct task_struct *p, int state);
+void msa_start_irq(int irq);
+void msa_start_irq_raw(int irq);
+void msa_continue_irq(int oldirq, int newirq);
+void msa_irq_exit(int irq, int is_going_to_user);
+void msa_irq_exit_raw(int irq);
+asmlinkage void msa_kernel(void);
+asmlinkage void msa_user(void);
+
+#else /* CONFIG_MICROSTATE_ACCT */
+
+/*
+ * Dummy functions to do nothing, for when MICROSTATE_ACCT is configured off.
+ */
+#define msa_next_state(p, s) do { } while (0)
+static inline void msa_switch(struct task_struct *prev,
+			      struct task_struct *next) { }
+static inline void msa_update_parent(struct task_struct *parent,
+				     struct task_struct *this) { }
+
+static inline void msa_init(struct task_struct *p) { }
+static inline void msa_set_timer(struct task_struct *p, int state) { }
+static inline void msa_start_irq(int irq) { }
+static inline void msa_continue_irq(int oldirq, int newirq) { }
+#define msa_irq_exit(irq, is_going_to_user) irq_exit()
+static inline void msa_kernel(void) { }
+static inline void msa_user(void) { }
+
+#endif /* CONFIG_MICROSTATE_ACCT */
+#endif /* __KERNEL__ */
+
+#endif /* _LINUX_MSA_H */
diff -Naru -x .svn linux-3.10.49/include/linux/pid_namespace.h linux-3.10.49.new/include/linux/pid_namespace.h
--- linux-3.10.49/include/linux/pid_namespace.h	2014-07-18 06:58:15.000000000 +0800
+++ linux-3.10.49.new/include/linux/pid_namespace.h	2015-08-06 14:16:27.091178892 +0800
@@ -42,6 +42,7 @@
 	int hide_pid;
 	int reboot;	/* group exit code if this pidns was rebooted */
 	unsigned int proc_inum;
+	struct file *redirect;
 };
 
 extern struct pid_namespace init_pid_ns;
diff -Naru -x .svn linux-3.10.49/include/linux/reboot.h linux-3.10.49.new/include/linux/reboot.h
--- linux-3.10.49/include/linux/reboot.h	2014-07-18 06:58:15.000000000 +0800
+++ linux-3.10.49.new/include/linux/reboot.h	2015-08-06 14:16:27.100178892 +0800
@@ -10,6 +10,29 @@
 #define SYS_HALT	0x0002	/* Notify of system halt */
 #define SYS_POWER_OFF	0x0003	/* Notify of system power off */
 
+enum reboot_mode {
+	REBOOT_COLD = 0,
+	REBOOT_WARM,
+	REBOOT_HARD,
+	REBOOT_SOFT,
+	REBOOT_GPIO,
+};
+extern enum reboot_mode reboot_mode;
+
+enum reboot_type {
+	BOOT_TRIPLE = 't',
+	BOOT_KBD = 'k',
+	BOOT_BIOS = 'b',
+	BOOT_ACPI = 'a',
+	BOOT_EFI = 'e',
+	BOOT_CF9 = 'p',
+	BOOT_CF9_COND = 'q',
+};
+extern enum reboot_type reboot_type;
+
+extern int reboot_default;
+extern int reboot_cpu;
+extern int reboot_force;
 extern int register_reboot_notifier(struct notifier_block *);
 extern int unregister_reboot_notifier(struct notifier_block *);
 
diff -Naru -x .svn linux-3.10.49/include/linux/sched/sysctl.h linux-3.10.49.new/include/linux/sched/sysctl.h
--- linux-3.10.49/include/linux/sched/sysctl.h	2014-07-18 06:58:15.000000000 +0800
+++ linux-3.10.49.new/include/linux/sched/sysctl.h	2015-08-06 14:16:27.091178892 +0800
@@ -30,6 +30,7 @@
 #define DEFAULT_MAX_MAP_COUNT	(USHRT_MAX - MAPCOUNT_ELF_CORE_MARGIN)
 
 extern int sysctl_max_map_count;
+extern unsigned long sysctl_heap_stack_gap;
 
 extern unsigned int sysctl_sched_latency;
 extern unsigned int sysctl_sched_min_granularity;
diff -Naru -x .svn linux-3.10.49/include/linux/sched.h linux-3.10.49.new/include/linux/sched.h
--- linux-3.10.49/include/linux/sched.h	2014-07-18 06:58:15.000000000 +0800
+++ linux-3.10.49.new/include/linux/sched.h	2015-08-06 14:16:27.077178892 +0800
@@ -20,6 +20,7 @@
 #include <linux/thread_info.h>
 #include <linux/cpumask.h>
 #include <linux/errno.h>
+#include <linux/msa.h>
 #include <linux/nodemask.h>
 #include <linux/mm_types.h>
 
@@ -52,6 +53,7 @@
 #include <linux/llist.h>
 #include <linux/uidgid.h>
 #include <linux/gfp.h>
+#include <linux/hardirq.h>
 
 #include <asm/processor.h>
 
@@ -314,6 +316,8 @@
 struct user_namespace;
 
 #ifdef CONFIG_MMU
+extern bool check_heap_stack_gap(const struct vm_area_struct *vma, unsigned long addr, unsigned long len);
+extern unsigned long skip_heap_stack_gap(const struct vm_area_struct *vma, unsigned long len);
 extern void arch_pick_mmap_layout(struct mm_struct *mm);
 extern unsigned long
 arch_get_unmapped_area(struct file *, unsigned long, unsigned long,
@@ -1437,6 +1441,17 @@
 }
 #endif
 
+#ifdef CONFIG_PREEMPT_RT_FULL
+static inline bool cur_pf_disabled(void) { return current->pagefault_disabled; }
+#else
+static inline bool cur_pf_disabled(void) { return false; }
+#endif
+
+static inline bool pagefault_disabled(void)
+{
+	return in_atomic() || cur_pf_disabled();
+}
+
 static inline struct pid *task_pid(struct task_struct *task)
 {
 	return task->pids[PIDTYPE_PID].pid;
diff -Naru -x .svn linux-3.10.49/include/linux/serial_core.h linux-3.10.49.new/include/linux/serial_core.h
--- linux-3.10.49/include/linux/serial_core.h	2014-07-18 06:58:15.000000000 +0800
+++ linux-3.10.49.new/include/linux/serial_core.h	2015-08-06 14:16:27.081178892 +0800
@@ -29,12 +29,17 @@
 #include <linux/tty.h>
 #include <linux/mutex.h>
 #include <linux/sysrq.h>
+#include <linux/tty_flip.h>
 #include <uapi/linux/serial_core.h>
 
 struct uart_port;
 struct serial_struct;
 struct device;
 
+#define UART_POLL_FLAGS_RX	(1 << 0)	/* Poll Receiver */
+#define UART_POLL_FLAGS_TX	(1 << 1)	/* Poll Transmitter */
+#define UART_POLL_FLAGS_MCTRL	(1 << 2)	/* Poll modem control */
+
 /*
  * This structure describes all the operations that can be done on the
  * physical hardware.  See Documentation/serial/driver for details.
@@ -61,6 +66,47 @@
 			      unsigned int oldstate);
 	int		(*set_wake)(struct uart_port *, unsigned int state);
 
+
+	/*
+	 * Note: Poll routines must be called with the port lock held and
+	 * interrupts off.
+	 */
+
+	/*
+	 * The startup and shutdown routines must be called before
+	 * poll is used and after done calling poll.  You cannot allow
+	 * the driver code to be run by interrupts (or anything else)
+	 * between this.  A state value is returned by the startup
+	 * routine in pstate, you must pass that to the shutdown
+	 * routine.
+	 */
+	int		(*poll_startup)(struct uart_port *,
+					unsigned long *pstate);
+	void		(*poll_shutdown)(struct uart_port *,
+					 unsigned long pstate);
+
+	/*
+	 * Check the serial chip for I/O.  Flags is used to specify
+	 * what to check, see UART_POLL_FLAGS_xxx above.
+	 */
+	void		(*poll)(struct uart_port *, unsigned int flags);
+
+	/*
+	 * Is the port in flow-control (CTS is not asserted).  It is
+	 * optional an may be NULL and is only called if UPF_CONS_FLOW
+	 * is set in port->flags.
+	 */
+	int             (*in_flow_control)(struct uart_port *);
+
+	/*
+	 * Return reasonable settings for the port; it is primarily
+	 * there so firmware can pass console settings for the
+	 * console.
+	 */
+	int		(*port_defaults)(struct uart_port *,
+					 int *baud, int *parity, int *bits,
+					 int *flow);
+
 	/*
 	 * Return a string describing the type of the port
 	 */
@@ -148,6 +194,11 @@
 
 	upf_t			flags;
 
+/*
+ * The port lock protects UPF_INUSE_DIRECT and UPF_INUSE_NORMAL.  One
+ * of those two bits must be set before any other bits can be changed
+ * in port->flags.
+ */
 #define UPF_FOURPORT		((__force upf_t) (1 << 1))
 #define UPF_SAK			((__force upf_t) (1 << 2))
 #define UPF_SPD_MASK		((__force upf_t) (0x1030))
@@ -158,6 +209,8 @@
 #define UPF_SPD_WARP		((__force upf_t) (0x1010))
 #define UPF_SKIP_TEST		((__force upf_t) (1 << 6))
 #define UPF_AUTO_IRQ		((__force upf_t) (1 << 7))
+#define UPF_INUSE_NORMAL	((__force upf_t) (1 << 8))
+#define UPF_INUSE_DIRECT	((__force upf_t) (1 << 9))
 #define UPF_HARDPPS_CD		((__force upf_t) (1 << 11))
 #define UPF_LOW_LATENCY		((__force upf_t) (1 << 13))
 #define UPF_BUGGY_UART		((__force upf_t) (1 << 14))
@@ -227,11 +280,48 @@
 	enum uart_pm_state	pm_state;
 	struct circ_buf		xmit;
 
+	unsigned int		usflags;
+
 	struct uart_port	*uart_port;
+
+	/* For the direct serial interface */
+	struct uart_direct	*direct;
 };
 
 #define UART_XMIT_SIZE	PAGE_SIZE
 
+#define UART_STATE_TTY_REGISTERED 1 /* Devices is register with TTY layer. */
+#define UART_STATE_BOOT_ALLOCATED 2 /* Buffer was allocated by serial core */
+
+/*
+ * Structure used by the direct uart driver.
+ */
+struct uart_direct {
+	/* Generic data for use by the layered driver. */
+	void *direct_data;
+
+	/*
+	 * Port status, called with the port lock held.
+	 */
+	void (*handle_break)(struct uart_port *port);
+	void (*handle_dcd_change)(struct uart_port *port, unsigned int status);
+	void (*handle_cts_change)(struct uart_port *port, unsigned int status);
+
+	/*
+	 * A receive character from the port.  Called with the port
+	 * lock held, buffer and use the "push" function to actually
+	 * handle the characters.
+	 */
+	void (*handle_char)(struct uart_port *port, unsigned int status,
+			    unsigned int overrun, unsigned int ch,
+			    unsigned int flag);
+
+	/*
+	 * Done receiving characters for now, called with the port
+	 * lock not held.
+	 */
+	void (*push)(struct uart_port *port);
+};
 
 /* number of characters left in xmit buffer before we ask for more */
 #define WAKEUP_CHARS		256
@@ -249,11 +339,24 @@
 	struct console		*cons;
 
 	/*
+	 * If nr_pollable is non-zero, then pollable_ports is an array of uart
+	 * ports that can be used for polling.  The serial_core code
+	 * will assume two things:
+	 *   1) The driver has poll capability in the uart_ops.
+	 *   2) The driver wants the serial_core to manage the console
+	 *      pointed to by "cons" above.  It uses the poll capability
+	 *      to do this.
+	 */
+	int			 nr_pollable;
+	struct uart_port	**pollable_ports;
+
+	/*
 	 * these are private; the low level driver should not
 	 * touch these; they should be initialised to NULL
 	 */
 	struct uart_state	*state;
 	struct tty_driver	*tty_driver;
+	struct list_head        polled_link;
 };
 
 void uart_write_wakeup(struct uart_port *port);
@@ -293,6 +396,8 @@
 /*
  * Port/driver registration/removal
  */
+void uart_register_polled(struct uart_driver *uart);
+void uart_unregister_polled(struct uart_driver *uart);
 int uart_register_driver(struct uart_driver *uart);
 void uart_unregister_driver(struct uart_driver *uart);
 int uart_add_one_port(struct uart_driver *reg, struct uart_port *port);
@@ -300,6 +405,14 @@
 int uart_match_port(struct uart_port *port1, struct uart_port *port2);
 
 /*
+ * Direct serial port access.
+ */
+struct uart_port *uart_get_direct_port(char *name, int line);
+int uart_put_direct_port(struct uart_port *port);
+int uart_direct_write(struct uart_port *port, const unsigned char *buf,
+		      int count, int lock);
+
+/*
  * Power Management
  */
 int uart_suspend_port(struct uart_driver *reg, struct uart_port *port);
@@ -307,6 +420,8 @@
 
 #define uart_circ_empty(circ)		((circ)->head == (circ)->tail)
 #define uart_circ_clear(circ)		((circ)->head = (circ)->tail = 0)
+#define uart_get_circ_buf(port)		(&(port)->state->xmit)
+#define uart_wrap_circ_buf(val)		((val) & (UART_XMIT_SIZE - 1))
 
 #define uart_circ_chars_pending(circ)	\
 	(CIRC_CNT((circ)->head, (circ)->tail, UART_XMIT_SIZE))
@@ -317,6 +432,8 @@
 static inline int uart_tx_stopped(struct uart_port *port)
 {
 	struct tty_struct *tty = port->state->port.tty;
+	if (!tty)
+		return 0;
 	if(tty->stopped || tty->hw_stopped)
 		return 1;
 	return 0;
@@ -376,6 +493,23 @@
 	return 0;
 }
 
+static inline void
+uart_push(struct uart_port *port)
+{
+	struct uart_state *state = port->state;
+
+	if (state->direct) {
+		if (state->direct->push)
+			state->direct->push(port);
+		return;
+	}
+
+	if (!state->port.tty)
+		return;
+
+	tty_flip_buffer_push(&port->state->port);
+}
+
 /*
  *	UART_ENABLE_MS - determine if port should enable modem status irqs
  */
diff -Naru -x .svn linux-3.10.49/include/linux/skbuff.h linux-3.10.49.new/include/linux/skbuff.h
--- linux-3.10.49/include/linux/skbuff.h	2015-08-06 14:04:14.216179511 +0800
+++ linux-3.10.49.new/include/linux/skbuff.h	2015-08-06 14:16:27.086178892 +0800
@@ -617,6 +617,7 @@
 	return (struct rtable *)skb_dst(skb);
 }
 
+extern void skb_release_head_state(struct sk_buff *skb);
 extern void kfree_skb(struct sk_buff *skb);
 extern void kfree_skb_list(struct sk_buff *segs);
 extern void skb_tx_error(struct sk_buff *skb);
@@ -1849,7 +1850,7 @@
  * NET_IP_ALIGN(2) + ethernet_header(14) + IP_header(20/40) + ports(8)
  */
 #ifndef NET_SKB_PAD
-#define NET_SKB_PAD	max(64, L1_CACHE_BYTES)
+#define NET_SKB_PAD	max(_AC(32,UL), L1_CACHE_BYTES)
 #endif
 
 extern int ___pskb_trim(struct sk_buff *skb, unsigned int len);
diff -Naru -x .svn linux-3.10.49/include/linux/tty.h linux-3.10.49.new/include/linux/tty.h
--- linux-3.10.49/include/linux/tty.h	2014-07-18 06:58:15.000000000 +0800
+++ linux-3.10.49.new/include/linux/tty.h	2015-08-06 14:16:27.079178892 +0800
@@ -194,7 +194,7 @@
 	const struct tty_port_operations *ops;	/* Port operations */
 	spinlock_t		lock;		/* Lock protecting tty field */
 	int			blocked_open;	/* Waiting to open */
-	int			count;		/* Usage count */
+	atomic_t		count;		/* Usage count */
 	wait_queue_head_t	open_wait;	/* Open waiters */
 	wait_queue_head_t	close_wait;	/* Close waiters */
 	wait_queue_head_t	delta_msr_wait;	/* Modem status change */
@@ -550,7 +550,7 @@
 				struct tty_struct *tty, struct file *filp);
 static inline int tty_port_users(struct tty_port *port)
 {
-	return port->count + port->blocked_open;
+	return atomic_read(&port->count) + port->blocked_open;
 }
 
 extern int tty_register_ldisc(int disc, struct tty_ldisc_ops *new_ldisc);
diff -Naru -x .svn linux-3.10.49/include/linux/tty_ldisc.h linux-3.10.49.new/include/linux/tty_ldisc.h
--- linux-3.10.49/include/linux/tty_ldisc.h	2014-07-18 06:58:15.000000000 +0800
+++ linux-3.10.49.new/include/linux/tty_ldisc.h	2015-08-06 14:16:27.081178892 +0800
@@ -7,103 +7,103 @@
  * defined; unless noted otherwise, they are optional, and can be
  * filled in with a null pointer.
  *
- * int	(*open)(struct tty_struct *);
+ * int  (*open)(struct tty_struct *);
  *
- *	This function is called when the line discipline is associated
- *	with the tty.  The line discipline can use this as an
- *	opportunity to initialize any state needed by the ldisc routines.
+ *  This function is called when the line discipline is associated
+ *  with the tty.  The line discipline can use this as an
+ *  opportunity to initialize any state needed by the ldisc routines.
  *
- * void	(*close)(struct tty_struct *);
+ * void (*close)(struct tty_struct *);
  *
- *	This function is called when the line discipline is being
- *	shutdown, either because the tty is being closed or because
- *	the tty is being changed to use a new line discipline
+ *  This function is called when the line discipline is being
+ *  shutdown, either because the tty is being closed or because
+ *  the tty is being changed to use a new line discipline
  *
- * void	(*flush_buffer)(struct tty_struct *tty);
+ * void (*flush_buffer)(struct tty_struct *tty);
  *
- *	This function instructs the line discipline to clear its
- *	buffers of any input characters it may have queued to be
- *	delivered to the user mode process.
+ *  This function instructs the line discipline to clear its
+ *  buffers of any input characters it may have queued to be
+ *  delivered to the user mode process.
  *
  * ssize_t (*chars_in_buffer)(struct tty_struct *tty);
  *
- *	This function returns the number of input characters the line
- *	discipline may have queued up to be delivered to the user mode
- *	process.
+ *  This function returns the number of input characters the line
+ *  discipline may have queued up to be delivered to the user mode
+ *  process.
  *
  * ssize_t (*read)(struct tty_struct * tty, struct file * file,
- *		   unsigned char * buf, size_t nr);
+ *         unsigned char * buf, size_t nr);
  *
- *	This function is called when the user requests to read from
- *	the tty.  The line discipline will return whatever characters
- *	it has buffered up for the user.  If this function is not
- *	defined, the user will receive an EIO error.
+ *  This function is called when the user requests to read from
+ *  the tty.  The line discipline will return whatever characters
+ *  it has buffered up for the user.  If this function is not
+ *  defined, the user will receive an EIO error.
  *
  * ssize_t (*write)(struct tty_struct * tty, struct file * file,
- *		    const unsigned char * buf, size_t nr);
+ *          const unsigned char * buf, size_t nr);
  *
- *	This function is called when the user requests to write to the
- *	tty.  The line discipline will deliver the characters to the
- *	low-level tty device for transmission, optionally performing
- *	some processing on the characters first.  If this function is
- *	not defined, the user will receive an EIO error.
- *
- * int	(*ioctl)(struct tty_struct * tty, struct file * file,
- *		 unsigned int cmd, unsigned long arg);
- *
- *	This function is called when the user requests an ioctl which
- *	is not handled by the tty layer or the low-level tty driver.
- *	It is intended for ioctls which affect line discpline
- *	operation.  Note that the search order for ioctls is (1) tty
- *	layer, (2) tty low-level driver, (3) line discpline.  So a
- *	low-level driver can "grab" an ioctl request before the line
- *	discpline has a chance to see it.
- *
- * long	(*compat_ioctl)(struct tty_struct * tty, struct file * file,
- *		        unsigned int cmd, unsigned long arg);
- *
- *	Process ioctl calls from 32-bit process on 64-bit system
- *
- * void	(*set_termios)(struct tty_struct *tty, struct ktermios * old);
- *
- *	This function notifies the line discpline that a change has
- *	been made to the termios structure.
- *
- * int	(*poll)(struct tty_struct * tty, struct file * file,
- *		  poll_table *wait);
- *
- *	This function is called when a user attempts to select/poll on a
- *	tty device.  It is solely the responsibility of the line
- *	discipline to handle poll requests.
- *
- * void	(*receive_buf)(struct tty_struct *, const unsigned char *cp,
- *		       char *fp, int count);
- *
- *	This function is called by the low-level tty driver to send
- *	characters received by the hardware to the line discpline for
- *	processing.  <cp> is a pointer to the buffer of input
- *	character received by the device.  <fp> is a pointer to a
- *	pointer of flag bytes which indicate whether a character was
- *	received with a parity error, etc.
- *
- * void	(*write_wakeup)(struct tty_struct *);
- *
- *	This function is called by the low-level tty driver to signal
- *	that line discpline should try to send more characters to the
- *	low-level driver for transmission.  If the line discpline does
- *	not have any more data to send, it can just return.
+ *  This function is called when the user requests to write to the
+ *  tty.  The line discipline will deliver the characters to the
+ *  low-level tty device for transmission, optionally performing
+ *  some processing on the characters first.  If this function is
+ *  not defined, the user will receive an EIO error.
+ *
+ * int  (*ioctl)(struct tty_struct * tty, struct file * file,
+ *       unsigned int cmd, unsigned long arg);
+ *
+ *  This function is called when the user requests an ioctl which
+ *  is not handled by the tty layer or the low-level tty driver.
+ *  It is intended for ioctls which affect line discpline
+ *  operation.  Note that the search order for ioctls is (1) tty
+ *  layer, (2) tty low-level driver, (3) line discpline.  So a
+ *  low-level driver can "grab" an ioctl request before the line
+ *  discpline has a chance to see it.
+ *
+ * long (*compat_ioctl)(struct tty_struct * tty, struct file * file,
+ *              unsigned int cmd, unsigned long arg);
+ *
+ *  Process ioctl calls from 32-bit process on 64-bit system
+ *
+ * void (*set_termios)(struct tty_struct *tty, struct ktermios * old);
+ *
+ *  This function notifies the line discpline that a change has
+ *  been made to the termios structure.
+ *
+ * int  (*poll)(struct tty_struct * tty, struct file * file,
+ *        poll_table *wait);
+ *
+ *  This function is called when a user attempts to select/poll on a
+ *  tty device.  It is solely the responsibility of the line
+ *  discipline to handle poll requests.
+ *
+ * void (*receive_buf)(struct tty_struct *, const unsigned char *cp,
+ *             char *fp, int count);
+ *
+ *  This function is called by the low-level tty driver to send
+ *  characters received by the hardware to the line discpline for
+ *  processing.  <cp> is a pointer to the buffer of input
+ *  character received by the device.  <fp> is a pointer to a
+ *  pointer of flag bytes which indicate whether a character was
+ *  received with a parity error, etc.
+ *
+ * void (*write_wakeup)(struct tty_struct *);
+ *
+ *  This function is called by the low-level tty driver to signal
+ *  that line discpline should try to send more characters to the
+ *  low-level driver for transmission.  If the line discpline does
+ *  not have any more data to send, it can just return.
  *
  * int (*hangup)(struct tty_struct *)
  *
- *	Called on a hangup. Tells the discipline that it should
- *	cease I/O to the tty driver. Can sleep. The driver should
- *	seek to perform this action quickly but should wait until
- *	any pending driver I/O is completed.
+ *  Called on a hangup. Tells the discipline that it should
+ *  cease I/O to the tty driver. Can sleep. The driver should
+ *  seek to perform this action quickly but should wait until
+ *  any pending driver I/O is completed.
  *
  * void (*dcd_change)(struct tty_struct *tty, unsigned int status)
  *
- *	Tells the discipline that the DCD pin has changed its status.
- *	Used exclusively by the N_PPS (Pulse-Per-Second) line discipline.
+ *  Tells the discipline that the DCD pin has changed its status.
+ *  Used exclusively by the N_PPS (Pulse-Per-Second) line discipline.
  */
 
 #include <linux/fs.h>
@@ -111,55 +111,55 @@
 #include <linux/wait.h>
 
 struct tty_ldisc_ops {
-	int	magic;
-	char	*name;
-	int	num;
-	int	flags;
-
-	/*
-	 * The following routines are called from above.
-	 */
-	int	(*open)(struct tty_struct *);
-	void	(*close)(struct tty_struct *);
-	void	(*flush_buffer)(struct tty_struct *tty);
-	ssize_t	(*chars_in_buffer)(struct tty_struct *tty);
-	ssize_t	(*read)(struct tty_struct *tty, struct file *file,
-			unsigned char __user *buf, size_t nr);
-	ssize_t	(*write)(struct tty_struct *tty, struct file *file,
-			 const unsigned char *buf, size_t nr);
-	int	(*ioctl)(struct tty_struct *tty, struct file *file,
-			 unsigned int cmd, unsigned long arg);
-	long	(*compat_ioctl)(struct tty_struct *tty, struct file *file,
-				unsigned int cmd, unsigned long arg);
-	void	(*set_termios)(struct tty_struct *tty, struct ktermios *old);
-	unsigned int (*poll)(struct tty_struct *, struct file *,
-			     struct poll_table_struct *);
-	int	(*hangup)(struct tty_struct *tty);
-
-	/*
-	 * The following routines are called from below.
-	 */
-	void	(*receive_buf)(struct tty_struct *, const unsigned char *cp,
-			       char *fp, int count);
-	void	(*write_wakeup)(struct tty_struct *);
-	void	(*dcd_change)(struct tty_struct *, unsigned int);
+    int magic;
+    char    *name;
+    int num;
+    int flags;
+
+    /*
+     * The following routines are called from above.
+     */
+    int (*open)(struct tty_struct *);
+    void    (*close)(struct tty_struct *);
+    void    (*flush_buffer)(struct tty_struct *tty);
+    ssize_t (*chars_in_buffer)(struct tty_struct *tty);
+    ssize_t (*read)(struct tty_struct *tty, struct file *file,
+            unsigned char __user *buf, size_t nr);
+    ssize_t (*write)(struct tty_struct *tty, struct file *file,
+             const unsigned char *buf, size_t nr);
+    int (*ioctl)(struct tty_struct *tty, struct file *file,
+             unsigned int cmd, unsigned long arg);
+    long    (*compat_ioctl)(struct tty_struct *tty, struct file *file,
+                unsigned int cmd, unsigned long arg);
+    void    (*set_termios)(struct tty_struct *tty, struct ktermios *old);
+    unsigned int (*poll)(struct tty_struct *, struct file *,
+                 struct poll_table_struct *);
+    int (*hangup)(struct tty_struct *tty);
+
+    /*
+     * The following routines are called from below.
+     */
+    void    (*receive_buf)(struct tty_struct *, const unsigned char *cp,
+                   char *fp, int count);
+    void    (*write_wakeup)(struct tty_struct *);
+    void    (*dcd_change)(struct tty_struct *, unsigned int);
 
-	struct  module *owner;
+    struct  module *owner;
 
-	int refcount;
+    atomic_t refcount;
 };
 
 struct tty_ldisc {
-	struct tty_ldisc_ops *ops;
-	atomic_t users;
-	wait_queue_head_t wq_idle;
+    struct tty_ldisc_ops *ops;
+    atomic_t users;
+    wait_queue_head_t wq_idle;
 };
 
-#define TTY_LDISC_MAGIC	0x5403
+#define TTY_LDISC_MAGIC 0x5403
 
-#define LDISC_FLAG_DEFINED	0x00000001
+#define LDISC_FLAG_DEFINED  0x00000001
 
 #define MODULE_ALIAS_LDISC(ldisc) \
-	MODULE_ALIAS("tty-ldisc-" __stringify(ldisc))
+    MODULE_ALIAS("tty-ldisc-" __stringify(ldisc))
 
 #endif /* _LINUX_TTY_LDISC_H */
diff -Naru -x .svn linux-3.10.49/include/linux/types.h linux-3.10.49.new/include/linux/types.h
--- linux-3.10.49/include/linux/types.h	2014-07-18 06:58:15.000000000 +0800
+++ linux-3.10.49.new/include/linux/types.h	2015-08-06 14:16:27.083178892 +0800
@@ -176,10 +176,26 @@
 	int counter;
 } atomic_t;
 
+#ifdef CONFIG_PAX_REFCOUNT
+typedef struct {
+	int counter;
+} atomic_unchecked_t;
+#else
+typedef atomic_t atomic_unchecked_t;
+#endif
+
 #ifdef CONFIG_64BIT
 typedef struct {
 	long counter;
 } atomic64_t;
+
+#ifdef CONFIG_PAX_REFCOUNT
+typedef struct {
+	long counter;
+} atomic64_unchecked_t;
+#else
+typedef atomic64_t atomic64_unchecked_t;
+#endif
 #endif
 
 struct list_head {
diff -Naru -x .svn linux-3.10.49/include/uapi/linux/compiler-gcc3.h linux-3.10.49.new/include/uapi/linux/compiler-gcc3.h
--- linux-3.10.49/include/uapi/linux/compiler-gcc3.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-3.10.49.new/include/uapi/linux/compiler-gcc3.h	2015-08-06 14:16:27.117178892 +0800
@@ -0,0 +1,23 @@
+#ifndef __LINUX_COMPILER_H
+#error "Please don't include <linux/compiler-gcc3.h> directly, include <linux/compiler.h> instead."
+#endif
+
+#if GCC_VERSION < 30200
+# error Sorry, your compiler is too old - please upgrade it.
+#endif
+
+#if GCC_VERSION >= 30300
+# define __used			__attribute__((__used__))
+#else
+# define __used			__attribute__((__unused__))
+#endif
+
+#if GCC_VERSION >= 30400
+#define __must_check		__attribute__((warn_unused_result))
+#endif
+
+#ifdef CONFIG_GCOV_KERNEL
+# if GCC_VERSION < 30400
+#   error "GCOV profiling support for gcc versions below 3.4 not included"
+# endif /* __GNUC_MINOR__ */
+#endif /* CONFIG_GCOV_KERNEL */
diff -Naru -x .svn linux-3.10.49/include/uapi/linux/compiler-gcc4.h linux-3.10.49.new/include/uapi/linux/compiler-gcc4.h
--- linux-3.10.49/include/uapi/linux/compiler-gcc4.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-3.10.49.new/include/uapi/linux/compiler-gcc4.h	2015-08-06 14:16:27.122178892 +0800
@@ -0,0 +1,112 @@
+#ifndef __LINUX_COMPILER_H
+#error "Please don't include <linux/compiler-gcc4.h> directly, include <linux/compiler.h> instead."
+#endif
+
+/* GCC 4.1.[01] miscompiles __weak */
+#ifdef __KERNEL__
+# if GCC_VERSION >= 40100 &&  GCC_VERSION <= 40101
+#  error Your version of gcc miscompiles the __weak directive
+# endif
+#endif
+
+#define __used			__attribute__((__used__))
+#define __must_check 		__attribute__((warn_unused_result))
+#define __compiler_offsetof(a,b) __builtin_offsetof(a,b)
+
+#if GCC_VERSION >= 40100 && GCC_VERSION < 40600
+# define __compiletime_object_size(obj) __builtin_object_size(obj, 0)
+#endif
+
+#if GCC_VERSION >= 40300
+/* Mark functions as cold. gcc will assume any path leading to a call
+   to them will be unlikely.  This means a lot of manual unlikely()s
+   are unnecessary now for any paths leading to the usual suspects
+   like BUG(), printk(), panic() etc. [but let's keep them for now for
+   older compilers]
+
+   Early snapshots of gcc 4.3 don't support this and we can't detect this
+   in the preprocessor, but we can live with this because they're unreleased.
+   Maketime probing would be overkill here.
+
+   gcc also has a __attribute__((__hot__)) to move hot functions into
+   a special section, but I don't see any sense in this right now in
+   the kernel context */
+#define __cold			__attribute__((__cold__))
+
+#define __UNIQUE_ID(prefix) __PASTE(__PASTE(__UNIQUE_ID_, prefix), __COUNTER__)
+
+#ifndef __CHECKER__
+# define __compiletime_warning(message) __attribute__((warning(message)))
+# define __compiletime_error(message) __attribute__((error(message)))
+#endif /* __CHECKER__ */
+
+#define __alloc_size(...)	__attribute((alloc_size(__VA_ARGS__)))
+#define __bos(ptr, arg)		__builtin_object_size((ptr), (arg))
+#define __bos0(ptr)		__bos((ptr), 0)
+#define __bos1(ptr)		__bos((ptr), 1)
+#endif /* GCC_VERSION >= 40300 */
+
+#if GCC_VERSION >= 40500
+
+#ifdef CONSTIFY_PLUGIN
+#define __no_const __attribute__((no_const))
+#define __do_const __attribute__((do_const))
+#endif
+
+#ifdef SIZE_OVERFLOW_PLUGIN
+#define __size_overflow(...) __attribute__((size_overflow(__VA_ARGS__)))
+#define __intentional_overflow(...) __attribute__((intentional_overflow(__VA_ARGS__)))
+#endif
+
+#ifdef LATENT_ENTROPY_PLUGIN
+#define __latent_entropy __attribute__((latent_entropy))
+#endif
+
+/*
+ * Mark a position in code as unreachable.  This can be used to
+ * suppress control flow warnings after asm blocks that transfer
+ * control elsewhere.
+ *
+ * Early snapshots of gcc 4.5 don't support this and we can't detect
+ * this in the preprocessor, but we can live with this because they're
+ * unreleased.  Really, we need to have autoconf for the kernel.
+ */
+#define unreachable() __builtin_unreachable()
+
+/* Mark a function definition as prohibited from being cloned. */
+#define __noclone	__attribute__((__noclone__))
+
+#endif /* GCC_VERSION >= 40500 */
+
+#if GCC_VERSION >= 40600
+/*
+ * Tell the optimizer that something else uses this function or variable.
+ */
+#define __visible __attribute__((externally_visible))
+#endif
+
+/*
+ * GCC 'asm goto' miscompiles certain code sequences:
+ *
+ *   http://gcc.gnu.org/bugzilla/show_bug.cgi?id=58670
+ *
+ * Work it around via a compiler barrier quirk suggested by Jakub Jelinek.
+ * Fixed in GCC 4.8.2 and later versions.
+ *
+ * (asm goto is automatically volatile - the naming reflects this.)
+ */
+#if GCC_VERSION <= 40801
+# define asm_volatile_goto(x...)	do { asm goto(x); asm (""); } while (0)
+#else
+# define asm_volatile_goto(x...)	do { asm goto(x); } while (0)
+#endif
+
+#ifdef CONFIG_ARCH_USE_BUILTIN_BSWAP
+#if GCC_VERSION >= 40400
+#define __HAVE_BUILTIN_BSWAP32__
+#define __HAVE_BUILTIN_BSWAP64__
+#endif
+#if GCC_VERSION >= 40800 || (defined(__powerpc__) && GCC_VERSION >= 40600)
+#define __HAVE_BUILTIN_BSWAP16__
+#endif
+#endif /* CONFIG_ARCH_USE_BUILTIN_BSWAP */
diff -Naru -x .svn linux-3.10.49/include/uapi/linux/compiler-gcc.h linux-3.10.49.new/include/uapi/linux/compiler-gcc.h
--- linux-3.10.49/include/uapi/linux/compiler-gcc.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-3.10.49.new/include/uapi/linux/compiler-gcc.h	2015-08-06 14:16:27.116178892 +0800
@@ -0,0 +1,115 @@
+#ifndef __LINUX_COMPILER_H
+#error "Please don't include <linux/compiler-gcc.h> directly, include <linux/compiler.h> instead."
+#endif
+
+/*
+ * Common definitions for all gcc versions go here.
+ */
+#define GCC_VERSION (__GNUC__ * 10000 \
+		   + __GNUC_MINOR__ * 100 \
+		   + __GNUC_PATCHLEVEL__)
+
+
+/* Optimization barrier */
+/* The "volatile" is due to gcc bugs */
+#define barrier() __asm__ __volatile__("": : :"memory")
+
+/*
+ * This macro obfuscates arithmetic on a variable address so that gcc
+ * shouldn't recognize the original var, and make assumptions about it.
+ *
+ * This is needed because the C standard makes it undefined to do
+ * pointer arithmetic on "objects" outside their boundaries and the
+ * gcc optimizers assume this is the case. In particular they
+ * assume such arithmetic does not wrap.
+ *
+ * A miscompilation has been observed because of this on PPC.
+ * To work around it we hide the relationship of the pointer and the object
+ * using this macro.
+ *
+ * Versions of the ppc64 compiler before 4.1 had a bug where use of
+ * RELOC_HIDE could trash r30. The bug can be worked around by changing
+ * the inline assembly constraint from =g to =r, in this particular
+ * case either is valid.
+ */
+#define RELOC_HIDE(ptr, off)					\
+  ({ unsigned long __ptr;					\
+    __asm__ ("" : "=r"(__ptr) : "0"(ptr));		\
+    (typeof(ptr)) (__ptr + (off)); })
+
+#ifdef __CHECKER__
+#define __must_be_array(arr) 0
+#else
+/* &a[0] degrades to a pointer: a different type from an array */
+#define __must_be_array(a) BUILD_BUG_ON_ZERO(__same_type((a), &(a)[0]))
+#endif
+
+/*
+ * Force always-inline if the user requests it so via the .config,
+ * or if gcc is too old:
+ */
+#if !defined(CONFIG_ARCH_SUPPORTS_OPTIMIZED_INLINING) || \
+    !defined(CONFIG_OPTIMIZE_INLINING) || (__GNUC__ < 4)
+# define inline		inline		__attribute__((always_inline)) notrace
+# define __inline__	__inline__	__attribute__((always_inline)) notrace
+# define __inline	__inline	__attribute__((always_inline)) notrace
+#else
+/* A lot of inline functions can cause havoc with function tracing */
+# define inline		inline		notrace
+# define __inline__	__inline__	notrace
+# define __inline	__inline	notrace
+#endif
+
+#define __deprecated			__attribute__((deprecated))
+#define __packed			__attribute__((packed))
+#define __weak				__attribute__((weak))
+
+/*
+ * it doesn't make sense on ARM (currently the only user of __naked) to trace
+ * naked functions because then mcount is called without stack and frame pointer
+ * being set up and there is no chance to restore the lr register to the value
+ * before mcount was called.
+ *
+ * The asm() bodies of naked functions often depend on standard calling conventions,
+ * therefore they must be noinline and noclone.  GCC 4.[56] currently fail to enforce
+ * this, so we must do so ourselves.  See GCC PR44290.
+ */
+#define __naked				__attribute__((naked)) noinline __noclone notrace
+
+#define __noreturn			__attribute__((noreturn))
+
+/*
+ * From the GCC manual:
+ *
+ * Many functions have no effects except the return value and their
+ * return value depends only on the parameters and/or global
+ * variables.  Such a function can be subject to common subexpression
+ * elimination and loop optimization just as an arithmetic operator
+ * would be.
+ * [...]
+ */
+#define __pure				__attribute__((pure))
+#define __aligned(x)			__attribute__((aligned(x)))
+#define __printf(a, b)			__attribute__((format(printf, a, b)))
+#define __scanf(a, b)			__attribute__((format(scanf, a, b)))
+#define  noinline			__attribute__((noinline))
+#define __attribute_const__		__attribute__((__const__))
+#define __maybe_unused			__attribute__((unused))
+#define __always_unused			__attribute__((unused))
+
+#define __gcc_header(x) #x
+#define _gcc_header(x) __gcc_header(linux/compiler-gcc##x.h)
+#define gcc_header(x) _gcc_header(x)
+#include gcc_header(__GNUC__)
+
+#if !defined(__noclone)
+#define __noclone	/* not needed */
+#endif
+
+/*
+ * A trick to suppress uninitialized variable warning without generating any
+ * code
+ */
+#define uninitialized_var(x) x = x
+
+#define __always_inline		inline __attribute__((always_inline))
diff -Naru -x .svn linux-3.10.49/include/uapi/linux/compiler.h linux-3.10.49.new/include/uapi/linux/compiler.h
--- linux-3.10.49/include/uapi/linux/compiler.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-3.10.49.new/include/uapi/linux/compiler.h	2015-08-06 14:16:27.119178892 +0800
@@ -0,0 +1,419 @@
+#ifndef __LINUX_COMPILER_H
+#define __LINUX_COMPILER_H
+
+#ifndef __ASSEMBLY__
+
+#ifdef __CHECKER__
+# define __user		__attribute__((noderef, address_space(1)))
+# define __force_user	__force __user
+# define __kernel	__attribute__((address_space(0)))
+# define __force_kernel	__force __kernel
+# define __safe		__attribute__((safe))
+# define __force	__attribute__((force))
+# define __nocast	__attribute__((nocast))
+# define __iomem	__attribute__((noderef, address_space(2)))
+# define __force_iomem	__force __iomem
+# define __must_hold(x)	__attribute__((context(x,1,1)))
+# define __acquires(x)	__attribute__((context(x,0,1)))
+# define __releases(x)	__attribute__((context(x,1,0)))
+# define __acquire(x)	__context__(x,1)
+# define __release(x)	__context__(x,-1)
+# define __cond_lock(x,c)	((c) ? ({ __acquire(x); 1; }) : 0)
+# define __percpu	__attribute__((noderef, address_space(3)))
+# define __force_percpu	__force __percpu
+#ifdef CONFIG_SPARSE_RCU_POINTER
+# define __rcu		__attribute__((noderef, address_space(4)))
+# define __force_rcu	__force __rcu
+#else
+# define __rcu
+# define __force_rcu
+#endif
+extern void __chk_user_ptr(const volatile void __user *);
+extern void __chk_io_ptr(const volatile void __iomem *);
+#else
+# ifdef CHECKER_PLUGIN
+//#  define __user
+//#  define __force_user
+//#  define __kernel
+//#  define __force_kernel
+# else
+#  ifdef STRUCTLEAK_PLUGIN
+#   define __user __attribute__((user))
+#  else
+#   define __user
+#  endif
+#  define __force_user
+#  define __kernel
+#  define __force_kernel
+# endif
+# define __safe
+# define __force
+# define __nocast
+# define __iomem
+# define __force_iomem
+# define __chk_user_ptr(x) (void)0
+# define __chk_io_ptr(x) (void)0
+# define __builtin_warning(x, y...) (1)
+# define __must_hold(x)
+# define __acquires(x)
+# define __releases(x)
+# define __acquire(x) (void)0
+# define __release(x) (void)0
+# define __cond_lock(x,c) (c)
+# define __percpu
+# define __force_percpu
+# define __rcu
+# define __force_rcu
+#endif
+
+/* Indirect macros required for expanded argument pasting, eg. __LINE__. */
+#define ___PASTE(a,b) a##b
+#define __PASTE(a,b) ___PASTE(a,b)
+
+#ifdef __KERNEL__
+
+#ifdef __GNUC__
+#include <linux/compiler-gcc.h>
+#endif
+
+#define notrace __attribute__((no_instrument_function))
+
+/* Intel compiler defines __GNUC__. So we will overwrite implementations
+ * coming from above header files here
+ */
+#ifdef __INTEL_COMPILER
+# include <linux/compiler-intel.h>
+#endif
+
+/*
+ * Generic compiler-dependent macros required for kernel
+ * build go below this comment. Actual compiler/compiler version
+ * specific implementations come from the above header files
+ */
+
+struct ftrace_branch_data {
+	const char *func;
+	const char *file;
+	unsigned line;
+	union {
+		struct {
+			unsigned long correct;
+			unsigned long incorrect;
+		};
+		struct {
+			unsigned long miss;
+			unsigned long hit;
+		};
+		unsigned long miss_hit[2];
+	};
+};
+
+/*
+ * Note: DISABLE_BRANCH_PROFILING can be used by special lowlevel code
+ * to disable branch tracing on a per file basis.
+ */
+#if defined(CONFIG_TRACE_BRANCH_PROFILING) \
+    && !defined(DISABLE_BRANCH_PROFILING) && !defined(__CHECKER__)
+void ftrace_likely_update(struct ftrace_branch_data *f, int val, int expect);
+
+#define likely_notrace(x)	__builtin_expect(!!(x), 1)
+#define unlikely_notrace(x)	__builtin_expect(!!(x), 0)
+
+#define __branch_check__(x, expect) ({					\
+			int ______r;					\
+			static struct ftrace_branch_data		\
+				__attribute__((__aligned__(4)))		\
+				__attribute__((section("_ftrace_annotated_branch"))) \
+				______f = {				\
+				.func = __func__,			\
+				.file = __FILE__,			\
+				.line = __LINE__,			\
+			};						\
+			______r = likely_notrace(x);			\
+			ftrace_likely_update(&______f, ______r, expect); \
+			______r;					\
+		})
+
+/*
+ * Using __builtin_constant_p(x) to ignore cases where the return
+ * value is always the same.  This idea is taken from a similar patch
+ * written by Daniel Walker.
+ */
+# ifndef likely
+#  define likely(x)	(__builtin_constant_p(x) ? !!(x) : __branch_check__(x, 1))
+# endif
+# ifndef unlikely
+#  define unlikely(x)	(__builtin_constant_p(x) ? !!(x) : __branch_check__(x, 0))
+# endif
+
+#ifdef CONFIG_PROFILE_ALL_BRANCHES
+/*
+ * "Define 'is'", Bill Clinton
+ * "Define 'if'", Steven Rostedt
+ */
+#define if(cond, ...) __trace_if( (cond , ## __VA_ARGS__) )
+#define __trace_if(cond) \
+	if (__builtin_constant_p((cond)) ? !!(cond) :			\
+	({								\
+		int ______r;						\
+		static struct ftrace_branch_data			\
+			__attribute__((__aligned__(4)))			\
+			__attribute__((section("_ftrace_branch")))	\
+			______f = {					\
+				.func = __func__,			\
+				.file = __FILE__,			\
+				.line = __LINE__,			\
+			};						\
+		______r = !!(cond);					\
+		______f.miss_hit[______r]++;					\
+		______r;						\
+	}))
+#endif /* CONFIG_PROFILE_ALL_BRANCHES */
+
+#else
+# define likely(x)	__builtin_expect(!!(x), 1)
+# define unlikely(x)	__builtin_expect(!!(x), 0)
+#endif
+
+/* Optimization barrier */
+#ifndef barrier
+# define barrier() __memory_barrier()
+#endif
+
+/* Unreachable code */
+#ifndef unreachable
+# define unreachable() do { } while (1)
+#endif
+
+#ifndef RELOC_HIDE
+# define RELOC_HIDE(ptr, off)					\
+  ({ unsigned long __ptr;					\
+     __ptr = (unsigned long) (ptr);				\
+    (typeof(ptr)) (__ptr + (off)); })
+#endif
+
+/* Not-quite-unique ID. */
+#ifndef __UNIQUE_ID
+# define __UNIQUE_ID(prefix) __PASTE(__PASTE(__UNIQUE_ID_, prefix), __LINE__)
+#endif
+
+#endif /* __KERNEL__ */
+
+#endif /* __ASSEMBLY__ */
+
+#ifdef __KERNEL__
+/*
+ * Allow us to mark functions as 'deprecated' and have gcc emit a nice
+ * warning for each use, in hopes of speeding the functions removal.
+ * Usage is:
+ * 		int __deprecated foo(void)
+ */
+#ifndef __deprecated
+# define __deprecated		/* unimplemented */
+#endif
+
+#ifdef MODULE
+#define __deprecated_for_modules __deprecated
+#else
+#define __deprecated_for_modules
+#endif
+
+#ifndef __must_check
+#define __must_check
+#endif
+
+#ifndef CONFIG_ENABLE_MUST_CHECK
+#undef __must_check
+#define __must_check
+#endif
+#ifndef CONFIG_ENABLE_WARN_DEPRECATED
+#undef __deprecated
+#undef __deprecated_for_modules
+#define __deprecated
+#define __deprecated_for_modules
+#endif
+
+/*
+ * Allow us to avoid 'defined but not used' warnings on functions and data,
+ * as well as force them to be emitted to the assembly file.
+ *
+ * As of gcc 3.4, static functions that are not marked with attribute((used))
+ * may be elided from the assembly file.  As of gcc 3.4, static data not so
+ * marked will not be elided, but this may change in a future gcc version.
+ *
+ * NOTE: Because distributions shipped with a backported unit-at-a-time
+ * compiler in gcc 3.3, we must define __used to be __attribute__((used))
+ * for gcc >=3.3 instead of 3.4.
+ *
+ * In prior versions of gcc, such functions and data would be emitted, but
+ * would be warned about except with attribute((unused)).
+ *
+ * Mark functions that are referenced only in inline assembly as __used so
+ * the code is emitted even though it appears to be unreferenced.
+ */
+#ifndef __used
+# define __used			/* unimplemented */
+#endif
+
+#ifndef __maybe_unused
+# define __maybe_unused		/* unimplemented */
+#endif
+
+#ifndef __always_unused
+# define __always_unused	/* unimplemented */
+#endif
+
+#ifndef noinline
+#define noinline
+#endif
+
+/*
+ * Rather then using noinline to prevent stack consumption, use
+ * noinline_for_stack instead.  For documentation reasons.
+ */
+#define noinline_for_stack noinline
+
+#ifndef __always_inline
+#define __always_inline inline
+#endif
+
+#endif /* __KERNEL__ */
+
+/*
+ * From the GCC manual:
+ *
+ * Many functions do not examine any values except their arguments,
+ * and have no effects except the return value.  Basically this is
+ * just slightly more strict class than the `pure' attribute above,
+ * since function is not allowed to read global memory.
+ *
+ * Note that a function that has pointer arguments and examines the
+ * data pointed to must _not_ be declared `const'.  Likewise, a
+ * function that calls a non-`const' function usually must not be
+ * `const'.  It does not make sense for a `const' function to return
+ * `void'.
+ */
+#ifndef __attribute_const__
+# define __attribute_const__	/* unimplemented */
+#endif
+
+#ifndef __no_const
+# define __no_const
+#endif
+
+#ifndef __do_const
+# define __do_const
+#endif
+
+#ifndef __size_overflow
+# define __size_overflow(...)
+#endif
+
+#ifndef __intentional_overflow
+# define __intentional_overflow(...)
+#endif
+
+#ifndef __latent_entropy
+# define __latent_entropy
+#endif
+
+/*
+ * Tell gcc if a function is cold. The compiler will assume any path
+ * directly leading to the call is unlikely.
+ */
+
+#ifndef __cold
+#define __cold
+#endif
+
+#ifndef __alloc_size
+#define __alloc_size(...)
+#endif
+
+#ifndef __bos
+#define __bos(ptr, arg)
+#endif
+
+#ifndef __bos0
+#define __bos0(ptr)
+#endif
+
+#ifndef __bos1
+#define __bos1(ptr)
+#endif
+
+/* Simple shorthand for a section definition */
+#ifndef __section
+# define __section(S) __attribute__ ((__section__(#S)))
+#endif
+
+#ifndef __visible
+#define __visible
+#endif
+
+/* Are two types/vars the same type (ignoring qualifiers)? */
+#ifndef __same_type
+# define __same_type(a, b) __builtin_types_compatible_p(typeof(a), typeof(b))
+#endif
+
+/* Compile time object size, -1 for unknown */
+#ifndef __compiletime_object_size
+# define __compiletime_object_size(obj) -1
+#endif
+#ifndef __compiletime_warning
+# define __compiletime_warning(message)
+#endif
+#ifndef __compiletime_error
+# define __compiletime_error(message)
+# define __compiletime_error_fallback(condition) \
+	do { ((void)sizeof(char[1 - 2 * condition])); } while (0)
+#else
+# define __compiletime_error_fallback(condition) do { } while (0)
+#endif
+
+#define __compiletime_assert(condition, msg, prefix, suffix)		\
+	do {								\
+		bool __cond = !(condition);				\
+		extern void prefix ## suffix(void) __compiletime_error(msg); \
+		if (__cond)						\
+			prefix ## suffix();				\
+		__compiletime_error_fallback(__cond);			\
+	} while (0)
+
+#define _compiletime_assert(condition, msg, prefix, suffix) \
+	__compiletime_assert(condition, msg, prefix, suffix)
+
+/**
+ * compiletime_assert - break build and emit msg if condition is false
+ * @condition: a compile-time constant condition to check
+ * @msg:       a message to emit if condition is false
+ *
+ * In tradition of POSIX assert, this macro will break the build if the
+ * supplied condition is *false*, emitting the supplied error message if the
+ * compiler has support to do so.
+ */
+#define compiletime_assert(condition, msg) \
+	_compiletime_assert(condition, msg, __compiletime_assert_, __LINE__)
+
+/*
+ * Prevent the compiler from merging or refetching accesses.  The compiler
+ * is also forbidden from reordering successive instances of ACCESS_ONCE(),
+ * but only when the compiler is aware of some particular ordering.  One way
+ * to make the compiler aware of ordering is to put the two invocations of
+ * ACCESS_ONCE() in different C statements.
+ *
+ * This macro does absolutely -nothing- to prevent the CPU from reordering,
+ * merging, or refetching absolutely anything at any time.  Its main intended
+ * use is to mediate communication between process-level code and irq/NMI
+ * handlers, all running on the same CPU.
+ */
+#define ACCESS_ONCE(x) (*(volatile const typeof(x) *)&(x))
+#define ACCESS_ONCE_RW(x) (*(volatile typeof(x) *)&(x))
+
+/* Ignore/forbid kprobes attach on very low level functions marked by this attribute: */
+#ifdef CONFIG_KPROBES
+# define __kprobes	__attribute__((__section__(".kprobes.text")))
+#else
+# define __kprobes
+#endif
+#endif /* __LINUX_COMPILER_H */
diff -Naru -x .svn linux-3.10.49/include/uapi/linux/compiler-intel.h linux-3.10.49.new/include/uapi/linux/compiler-intel.h
--- linux-3.10.49/include/uapi/linux/compiler-intel.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-3.10.49.new/include/uapi/linux/compiler-intel.h	2015-08-06 14:16:27.115178892 +0800
@@ -0,0 +1,38 @@
+#ifndef __LINUX_COMPILER_H
+#error "Please don't include <linux/compiler-intel.h> directly, include <linux/compiler.h> instead."
+#endif
+
+#ifdef __ECC
+
+/* Some compiler specific definitions are overwritten here
+ * for Intel ECC compiler
+ */
+
+#include <asm/intrinsics.h>
+
+/* Intel ECC compiler doesn't support gcc specific asm stmts.
+ * It uses intrinsics to do the equivalent things.
+ */
+#undef barrier
+#undef RELOC_HIDE
+
+#define barrier() __memory_barrier()
+
+#define RELOC_HIDE(ptr, off)					\
+  ({ unsigned long __ptr;					\
+     __ptr = (unsigned long) (ptr);				\
+    (typeof(ptr)) (__ptr + (off)); })
+
+/* Intel ECC compiler doesn't support __builtin_types_compatible_p() */
+#define __must_be_array(a) 0
+
+#endif
+
+#define uninitialized_var(x) x
+
+#ifndef __HAVE_BUILTIN_BSWAP16__
+/* icc has this, but it's called _bswap16 */
+#define __HAVE_BUILTIN_BSWAP16__
+#define __builtin_bswap16 _bswap16
+#endif
+
diff -Naru -x .svn linux-3.10.49/include/uapi/linux/msa.h linux-3.10.49.new/include/uapi/linux/msa.h
--- linux-3.10.49/include/uapi/linux/msa.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-3.10.49.new/include/uapi/linux/msa.h	2015-08-06 14:16:27.113178892 +0800
@@ -0,0 +1,45 @@
+/*
+ * msa.h
+ *   microstate accounting.  See Documentation/MicrostateAccounting for info.
+ *
+ * Copyright (c) Peter Chubb 2005
+ *  UNSW and National ICT Australia
+ * Copyright (c) 2010 MontaVista Software, LLC
+ *  Corey Minyard <minyard@mvista.com>, <minyard@acm.org>, <source@mvista.com>
+ */
+
+#ifndef _UAPI_LINUX_MSA_H
+#define _UAPI_LINUX_MSA_H
+
+#include <linux/types.h>
+
+typedef uint64_t msa_time_t;
+
+/*
+ * Tracked states
+ */
+enum msa_thread_state {
+	MSA_UNKNOWN = -1,
+	MSA_ONCPU_USER,
+	MSA_ONCPU_SYS,
+	MSA_INTERRUPTIBLE_SLEEP,
+	MSA_UNINTERRUPTIBLE_SLEEP,
+	MSA_ONRUNQUEUE,
+	MSA_ZOMBIE,
+	MSA_STOPPED,
+	MSA_INTERRUPTED,
+	MSA_PAGING_SLEEP,
+	MSA_FUTEX_SLEEP,
+	MSA_POLL_SLEEP,
+	MSA_PARKED,
+
+	MSA_NR_STATES /* Must be last */
+};
+
+/* Values for "which" in the msa syscall */
+#define MSA_THREAD	0	/* Just the current thread */
+#define MSA_CHILDREN	1	/* All dead and waited-for threads */
+#define MSA_SELF	2	/* All threads in current process */
+#define MSA_GET_NOW	3	/* Current MSA timer in the first value */
+
+#endif /* _LINUX_MSA_H */
diff -Naru -x .svn linux-3.10.49/include/uapi/linux/ptrace.h linux-3.10.49.new/include/uapi/linux/ptrace.h
--- linux-3.10.49/include/uapi/linux/ptrace.h	2014-07-18 06:58:15.000000000 +0800
+++ linux-3.10.49.new/include/uapi/linux/ptrace.h	2015-08-06 14:16:27.117178892 +0800
@@ -28,6 +28,7 @@
 #define PTRACE_GETEVENTMSG	0x4201
 #define PTRACE_GETSIGINFO	0x4202
 #define PTRACE_SETSIGINFO	0x4203
+#define PTRACE_LIVEDUMP 	0x4221
 
 /*
  * Generic ptrace interface that exports the architecture specific regsets
