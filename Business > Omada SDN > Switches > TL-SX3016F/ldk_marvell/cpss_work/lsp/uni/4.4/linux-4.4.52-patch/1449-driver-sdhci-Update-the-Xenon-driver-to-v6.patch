From b72f0364391ea9f6f00b9334e12960c155b0809e Mon Sep 17 00:00:00 2001
From: Konstantin Porotchkin <kostap@marvell.com>
Date: Thu, 9 Mar 2017 15:07:15 +0200
Subject: [PATCH 1449/2241] driver: sdhci: Update the Xenon driver to v6

Update the Xenon driver code to version v6.
Add missing function from kernel 4.10 to mmc code code.

Change-Id: I992c25f87500a9c158f49fdc57e69e036e08751c
Signed-off-by: Konstantin Porotchkin <kostap@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/37357
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Reviewed-by: Omri Itach <omrii@marvell.com>
Reviewed-by: Hanna Hawa <hannah@marvell.com>
---
 .../bindings/mmc/marvell,xenon-sdhci.txt           |  75 +--
 drivers/mmc/core/mmc.c                             |  24 +
 drivers/mmc/host/sdhci-xenon-phy.c                 | 519 +++++++++------------
 drivers/mmc/host/sdhci-xenon.c                     | 202 ++++----
 drivers/mmc/host/sdhci-xenon.h                     |  80 ++--
 include/linux/mmc/core.h                           |   2 +
 6 files changed, 419 insertions(+), 483 deletions(-)

diff --git a/Documentation/devicetree/bindings/mmc/marvell,xenon-sdhci.txt b/Documentation/devicetree/bindings/mmc/marvell,xenon-sdhci.txt
index c935a67..eabee8b 100644
--- a/Documentation/devicetree/bindings/mmc/marvell,xenon-sdhci.txt
+++ b/Documentation/devicetree/bindings/mmc/marvell,xenon-sdhci.txt
@@ -9,9 +9,10 @@ Each SDHC should have an independent device tree node.
 
 Required Properties:
 - compatible: should be one of the following
-  - "marvell,armada-3700-sdhci": For controllers on Armada-3700 SOC.
+  - "marvell,armada-3700-sdhci": For controllers on Armada-3700 SoC.
   Must provide a second register area and marvell,pad-type.
-  - "marvell,armada8k-sdhci": For controllers on Armada 7K/8K SOC.
+  - "marvell,armada-ap806-sdhci": For controllers on Armada AP806.
+  - "marvell,armada-cp110-sdhci": For controllers on Armada CP110.
 
 - clocks:
   Array of clocks required for SDHC.
@@ -23,7 +24,7 @@ Required Properties:
 
 - reg:
   * For "marvell,armada-3700-sdhci", two register areas.
-    The first one for Xenon IP register. The second one for the Armada 3700 SOC
+    The first one for Xenon IP register. The second one for the Armada 3700 SoC
     PHY PAD Voltage Control register.
     Please follow the examples with compatible "marvell,armada-3700-sdhci"
     in below.
@@ -32,30 +33,6 @@ Required Properties:
   * For other compatible strings, one register area for Xenon IP.
 
 Optional Properties:
-- mmc-card:
-  mmc-card child node must be provided when current SDHC is for eMMC.
-  Xenon SDHC often can support both SD and eMMC. This child node indicates that
-  current SDHC is for eMMC card. Thus Xenon eMMC specific configuration and
-  operations can be enabled prior to eMMC init sequence.
-  Please refer to Documentation/devicetree/bindings/mmc/mmc-card.txt.
-  This child node should not be set if current Xenon SDHC is for SD/SDIO.
-
-- bus-width:
-  When 8-bit data bus width is in use for eMMC, this property should be
-  explicitly provided and set as 8.
-  It is optional when data bus width is 4-bit or 1-bit.
-
-- mmc-ddr-1_8v:
-  Select this property when eMMC HS DDR is supported on SDHC side.
-
-- mmc-hs400-1_8v:
-  Select this property when eMMC HS400 is supported on SDHC side.
-
-- no-1-8-v:
-  Select this property when 1.8V signaling voltage supply is unavailable.
-  When this property is enabled, both mmc-ddr-1_8v and mmc-hs400-1_8v should be
-  cleared.
-
 - marvell,xenon-sdhc-id:
   Indicate the corresponding bit index of current SDHC in
   SDHC System Operation Control Register Bit[7:0].
@@ -63,7 +40,7 @@ Optional Properties:
   If Xenon IP contains only one SDHC, this property is optional.
 
 - marvell,xenon-phy-type:
-  Xenon support mutilple types of PHYs.
+  Xenon support multiple types of PHYs.
   To select eMMC 5.1 PHY, set:
   marvell,xenon-phy-type = "emmc 5.1 phy"
   eMMC 5.1 PHY is the default choice if this property is not provided.
@@ -73,24 +50,24 @@ Optional Properties:
   All those types of PHYs can support eMMC, SD and SDIO.
   Please note that this property only presents the type of PHY.
   It doesn't stand for the entire SDHC type or property.
-  For example, "emmc 5.1 phy" doesn't mean that this Xenon SDHC only supports
-  eMMC 5.1.
+  For example, "emmc 5.1 phy" doesn't mean that this Xenon SDHC only
+  supports eMMC 5.1.
 
 - marvell,xenon-phy-znr:
   Set PHY ZNR value.
-  Only available for eMMC PHY 5.1 and eMMC PHY 5.0.
+  Only available for eMMC PHY.
   Valid range = [0:0x1F].
   ZNR is set as 0xF by default if this property is not provided.
 
 - marvell,xenon-phy-zpr:
   Set PHY ZPR value.
-  Only available for eMMC PHY 5.1 and eMMC PHY 5.0.
+  Only available for eMMC PHY.
   Valid range = [0:0x1F].
   ZPR is set as 0xF by default if this property is not provided.
 
 - marvell,xenon-phy-nr-success-tun:
-  Set the number of required consecutive successful sampling points used to
-  identify a valid sampling window, in tuning process.
+  Set the number of required consecutive successful sampling points
+  used to identify a valid sampling window, in tuning process.
   Valid range = [1:7].
   Set as 0x4 by default if this property is not provided.
 
@@ -100,24 +77,25 @@ Optional Properties:
 
 - marvell,xenon-phy-slow-mode:
   If this property is selected, transfers will bypass PHY.
-  Only available when bus frequency lower than 55MHz in SDR mde.
-  Disabled by default. Please only try this property if timing issues always
-  occur with PHY enabled in eMMC HS SDR, SD SDR12, SD SDR25, SD SDR50 mode.
+  Only available when bus frequency lower than 55MHz in SDR mode.
+  Disabled by default. Please only try this property if timing issues
+  always occur with PHY enabled in eMMC HS SDR, SD SDR12, SD SDR25,
+  SD Default Speed and HS mode and eMMC legacy speed mode.
 
 - marvell,xenon-tun-count:
-  Xenon SDHC SOC usually doesn't provide re-tuning counter in
+  Xenon SDHC SoC usually doesn't provide re-tuning counter in
   Capabilities Register 3 Bit[11:8].
   This property provides the re-tuning counter.
   If this property is not set, default re-tuning counter will
   be set as 0x9 in driver.
 
 - marvell,pad-type:
-  Type of Armada 3700 SOC PHY PAD Voltage Controller register.
+  Type of Armada 3700 SoC PHY PAD Voltage Controller register.
   Only valid when "marvell,armada-3700-sdhci" is selected.
   Two types: "sd" and "fixed-1-8v".
-  If "sd" is slected, SOC PHY PAD is set as 3.3V at the beginning and is
-  switched to 1.8V when SD in UHS-I.
-  If "fixed-1-8v" is slected, SOC PHY PAD is fixed 1.8V, such as for eMMC.
+  If "sd" is selected, SoC PHY PAD is set as 3.3V at the beginning and is
+  switched to 1.8V when later in higher speed mode.
+  If "fixed-1-8v" is selected, SoC PHY PAD is fixed 1.8V, such as for eMMC.
   Please follow the examples with compatible "marvell,armada-3700-sdhci"
   in below.
 
@@ -125,21 +103,18 @@ Example:
 - For eMMC:
 
 	sdhci@aa0000 {
-		compatible = "marvell,armada8k-sdhci";
+		compatible = "marvell,armada-ap806-sdhci";
 		reg = <0xaa0000 0x1000>;
 		interrupts = <GIC_SPI 13 IRQ_TYPE_LEVEL_HIGH>
 		clocks = <&emmc_clk>;
 		clock-names = "core";
-		bus-width = <8>;
-		mmc-ddr-1_8v;
-		mmc-hs400-1_8v;
-		marvell,xenon-sdhc-id = <0>;
-		marvell,xenon-phy-type = "emmc 5.1 phy";
+		bus-width = <4>;
+		marvell,xenon-phy-slow-mode;
 		marvell,xenon-tun-count = <11>;
 
 		#address-cells = <1>;
 		#size-cells = <0>;
-		mmccard: mmccard@0 {
+		apm_mmccard: mmccard@0 {
 			compatible = "mmc-card";
 			reg = <0>;
 		};
@@ -148,7 +123,7 @@ Example:
 - For SD/SDIO:
 
 	sdhci@ab0000 {
-		compatible = "marvell,armada8k-sdhci";
+		compatible = "marvell,armada-cp110-sdhci";
 		reg = <0xab0000 0x1000>;
 		interrupts = <GIC_SPI 55 IRQ_TYPE_LEVEL_HIGH>
 		vqmmc-supply = <&sd_regulator>;
diff --git a/drivers/mmc/core/mmc.c b/drivers/mmc/core/mmc.c
index 79a0c26..c5b9c22 100644
--- a/drivers/mmc/core/mmc.c
+++ b/drivers/mmc/core/mmc.c
@@ -2004,6 +2004,30 @@ static const struct mmc_bus_ops mmc_ops = {
 };
 
 /*
+ * Parse mmc-card dt sub-node and set eMMC common caps
+ * if mmc-card exists.
+ * If mmc-card is detected, return true.
+ * Otherwise, return false.
+ */
+bool mmc_of_parse_mmc_card(struct mmc_host *host)
+{
+	struct device_node *np;
+	bool ret = false;
+
+	np = mmc_of_find_child_device(host, 0);
+	if (np && of_device_is_compatible(np, "mmc-card")) {
+		/* mmc-card sub-node indicates eMMC card is in use. */
+		host->caps |= MMC_CAP_NONREMOVABLE;
+		host->caps2 |= MMC_CAP2_NO_SDIO | MMC_CAP2_NO_SD;
+		ret = true;
+	}
+
+	of_node_put(np);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(mmc_of_parse_mmc_card);
+
+/*
  * Starting point for MMC card init.
  */
 int mmc_attach_mmc(struct mmc_host *host)
diff --git a/drivers/mmc/host/sdhci-xenon-phy.c b/drivers/mmc/host/sdhci-xenon-phy.c
index 42ef3ad..c3b7e9a 100644
--- a/drivers/mmc/host/sdhci-xenon-phy.c
+++ b/drivers/mmc/host/sdhci-xenon-phy.c
@@ -19,102 +19,97 @@
 #include "sdhci-xenon.h"
 
 /* Register base for eMMC PHY 5.0 Version */
-#define SDHCI_EMMC_5_0_PHY_REG_BASE		0x0160
+#define XENON_EMMC_5_0_PHY_REG_BASE		0x0160
 /* Register base for eMMC PHY 5.1 Version */
-#define SDHCI_EMMC_PHY_REG_BASE			0x0170
-
-#define SDHCI_EMMC_PHY_TIMING_ADJUST		SDHCI_EMMC_PHY_REG_BASE
-#define SDHCI_EMMC_5_0_PHY_TIMING_ADJUST	SDHCI_EMMC_5_0_PHY_REG_BASE
-#define SDHCI_TIMING_ADJUST_SLOW_MODE		BIT(29)
-#define SDHCI_TIMING_ADJUST_SDIO_MODE		BIT(28)
-#define SDHCI_OUTPUT_QSN_PHASE_SELECT		BIT(17)
-#define SDHCI_SAMPL_INV_QSP_PHASE_SELECT	BIT(18)
-#define SDHCI_SAMPL_INV_QSP_PHASE_SELECT_SHIFT	18
-#define SDHCI_PHY_INITIALIZAION			BIT(31)
-#define SDHCI_WAIT_CYCLE_BEFORE_USING_MASK	0xF
-#define SDHCI_WAIT_CYCLE_BEFORE_USING_SHIFT	12
-#define SDHCI_FC_SYNC_EN_DURATION_MASK		0xF
-#define SDHCI_FC_SYNC_EN_DURATION_SHIFT		8
-#define SDHCI_FC_SYNC_RST_EN_DURATION_MASK	0xF
-#define SDHCI_FC_SYNC_RST_EN_DURATION_SHIFT	4
-#define SDHCI_FC_SYNC_RST_DURATION_MASK		0xF
-#define SDHCI_FC_SYNC_RST_DURATION_SHIFT	0
-
-#define SDHCI_EMMC_PHY_FUNC_CONTROL		(SDHCI_EMMC_PHY_REG_BASE + 0x4)
-#define SDHCI_EMMC_5_0_PHY_FUNC_CONTROL		\
-	(SDHCI_EMMC_5_0_PHY_REG_BASE + 0x4)
-#define SDHCI_ASYNC_DDRMODE_MASK		BIT(23)
-#define SDHCI_ASYNC_DDRMODE_SHIFT		23
-#define SDHCI_CMD_DDR_MODE			BIT(16)
-#define SDHCI_DQ_DDR_MODE_SHIFT			8
-#define SDHCI_DQ_DDR_MODE_MASK			0xFF
-#define SDHCI_DQ_ASYNC_MODE			BIT(4)
-
-#define SDHCI_EMMC_PHY_PAD_CONTROL		(SDHCI_EMMC_PHY_REG_BASE + 0x8)
-#define SDHCI_EMMC_5_0_PHY_PAD_CONTROL		\
-	(SDHCI_EMMC_5_0_PHY_REG_BASE + 0x8)
-#define SDHCI_REC_EN_SHIFT			24
-#define SDHCI_REC_EN_MASK			0xF
-#define SDHCI_FC_DQ_RECEN			BIT(24)
-#define SDHCI_FC_CMD_RECEN			BIT(25)
-#define SDHCI_FC_QSP_RECEN			BIT(26)
-#define SDHCI_FC_QSN_RECEN			BIT(27)
-#define SDHCI_OEN_QSN				BIT(28)
-#define SDHCI_AUTO_RECEN_CTRL			BIT(30)
-#define SDHCI_FC_ALL_CMOS_RECEIVER		0xF000
-
-#define SDHCI_EMMC5_FC_QSP_PD			BIT(18)
-#define SDHCI_EMMC5_FC_QSP_PU			BIT(22)
-#define SDHCI_EMMC5_FC_CMD_PD			BIT(17)
-#define SDHCI_EMMC5_FC_CMD_PU			BIT(21)
-#define SDHCI_EMMC5_FC_DQ_PD			BIT(16)
-#define SDHCI_EMMC5_FC_DQ_PU			BIT(20)
-
-#define SDHCI_EMMC_PHY_PAD_CONTROL1		(SDHCI_EMMC_PHY_REG_BASE + 0xC)
-#define SDHCI_EMMC5_1_FC_QSP_PD			BIT(9)
-#define SDHCI_EMMC5_1_FC_QSP_PU			BIT(25)
-#define SDHCI_EMMC5_1_FC_CMD_PD			BIT(8)
-#define SDHCI_EMMC5_1_FC_CMD_PU			BIT(24)
-#define SDHCI_EMMC5_1_FC_DQ_PD			0xFF
-#define SDHCI_EMMC5_1_FC_DQ_PU			(0xFF << 16)
-
-#define SDHCI_EMMC_PHY_PAD_CONTROL2		(SDHCI_EMMC_PHY_REG_BASE + 0x10)
-#define SDHCI_EMMC_5_0_PHY_PAD_CONTROL2		\
-	(SDHCI_EMMC_5_0_PHY_REG_BASE + 0xC)
-#define SDHCI_ZNR_MASK				0x1F
-#define SDHCI_ZNR_SHIFT				8
-#define SDHCI_ZPR_MASK				0x1F
-/* Perferred ZNR and ZPR value vary between different boards.
+#define XENON_EMMC_PHY_REG_BASE			0x0170
+
+#define XENON_EMMC_PHY_TIMING_ADJUST		XENON_EMMC_PHY_REG_BASE
+#define XENON_EMMC_5_0_PHY_TIMING_ADJUST	XENON_EMMC_5_0_PHY_REG_BASE
+#define XENON_TIMING_ADJUST_SLOW_MODE		BIT(29)
+#define XENON_TIMING_ADJUST_SDIO_MODE		BIT(28)
+#define XENON_OUTPUT_QSN_PHASE_SELECT		BIT(17)
+#define XENON_SAMPL_INV_QSP_PHASE_SELECT	BIT(18)
+#define XENON_SAMPL_INV_QSP_PHASE_SELECT_SHIFT	18
+#define XENON_PHY_INITIALIZAION			BIT(31)
+#define XENON_WAIT_CYCLE_BEFORE_USING_MASK	0xF
+#define XENON_WAIT_CYCLE_BEFORE_USING_SHIFT	12
+#define XENON_FC_SYNC_EN_DURATION_MASK		0xF
+#define XENON_FC_SYNC_EN_DURATION_SHIFT		8
+#define XENON_FC_SYNC_RST_EN_DURATION_MASK	0xF
+#define XENON_FC_SYNC_RST_EN_DURATION_SHIFT	4
+#define XENON_FC_SYNC_RST_DURATION_MASK		0xF
+#define XENON_FC_SYNC_RST_DURATION_SHIFT	0
+
+#define XENON_EMMC_PHY_FUNC_CONTROL		(XENON_EMMC_PHY_REG_BASE + 0x4)
+#define XENON_EMMC_5_0_PHY_FUNC_CONTROL		\
+	(XENON_EMMC_5_0_PHY_REG_BASE + 0x4)
+#define XENON_ASYNC_DDRMODE_MASK		BIT(23)
+#define XENON_ASYNC_DDRMODE_SHIFT		23
+#define XENON_CMD_DDR_MODE			BIT(16)
+#define XENON_DQ_DDR_MODE_SHIFT			8
+#define XENON_DQ_DDR_MODE_MASK			0xFF
+#define XENON_DQ_ASYNC_MODE			BIT(4)
+
+#define XENON_EMMC_PHY_PAD_CONTROL		(XENON_EMMC_PHY_REG_BASE + 0x8)
+#define XENON_EMMC_5_0_PHY_PAD_CONTROL		\
+	(XENON_EMMC_5_0_PHY_REG_BASE + 0x8)
+#define XENON_REC_EN_SHIFT			24
+#define XENON_REC_EN_MASK			0xF
+#define XENON_FC_DQ_RECEN			BIT(24)
+#define XENON_FC_CMD_RECEN			BIT(25)
+#define XENON_FC_QSP_RECEN			BIT(26)
+#define XENON_FC_QSN_RECEN			BIT(27)
+#define XENON_OEN_QSN				BIT(28)
+#define XENON_AUTO_RECEN_CTRL			BIT(30)
+#define XENON_FC_ALL_CMOS_RECEIVER		0xF000
+
+#define XENON_EMMC5_FC_QSP_PD			BIT(18)
+#define XENON_EMMC5_FC_QSP_PU			BIT(22)
+#define XENON_EMMC5_FC_CMD_PD			BIT(17)
+#define XENON_EMMC5_FC_CMD_PU			BIT(21)
+#define XENON_EMMC5_FC_DQ_PD			BIT(16)
+#define XENON_EMMC5_FC_DQ_PU			BIT(20)
+
+#define XENON_EMMC_PHY_PAD_CONTROL1		(XENON_EMMC_PHY_REG_BASE + 0xC)
+#define XENON_EMMC5_1_FC_QSP_PD			BIT(9)
+#define XENON_EMMC5_1_FC_QSP_PU			BIT(25)
+#define XENON_EMMC5_1_FC_CMD_PD			BIT(8)
+#define XENON_EMMC5_1_FC_CMD_PU			BIT(24)
+#define XENON_EMMC5_1_FC_DQ_PD			0xFF
+#define XENON_EMMC5_1_FC_DQ_PU			(0xFF << 16)
+
+#define XENON_EMMC_PHY_PAD_CONTROL2		(XENON_EMMC_PHY_REG_BASE + 0x10)
+#define XENON_EMMC_5_0_PHY_PAD_CONTROL2		\
+	(XENON_EMMC_5_0_PHY_REG_BASE + 0xC)
+#define XENON_ZNR_MASK				0x1F
+#define XENON_ZNR_SHIFT				8
+#define XENON_ZPR_MASK				0x1F
+/* Preferred ZNR and ZPR value vary between different boards.
  * The specific ZNR and ZPR value should be defined here
  * according to board actual timing.
  */
-#define SDHCI_ZNR_DEF_VALUE			0xF
-#define SDHCI_ZPR_DEF_VALUE			0xF
-
-#define SDHCI_EMMC_PHY_DLL_CONTROL		(SDHCI_EMMC_PHY_REG_BASE + 0x14)
-#define SDHCI_EMMC_5_0_PHY_DLL_CONTROL		\
-	(SDHCI_EMMC_5_0_PHY_REG_BASE + 0x10)
-#define SDHCI_DLL_ENABLE			BIT(31)
-#define SDHCI_DLL_UPDATE_STROBE_5_0		BIT(30)
-#define SDHCI_DLL_REFCLK_SEL			BIT(30)
-#define SDHCI_DLL_UPDATE			BIT(23)
-#define SDHCI_DLL_PHSEL1_SHIFT			24
-#define SDHCI_DLL_PHSEL0_SHIFT			16
-#define SDHCI_DLL_PHASE_MASK			0x3F
-#define SDHCI_DLL_PHASE_90_DEGREE		0x1F
-#define SDHCI_DLL_FAST_LOCK			BIT(5)
-#define SDHCI_DLL_GAIN2X			BIT(3)
-#define SDHCI_DLL_BYPASS_EN			BIT(0)
-
-#define SDHCI_EMMC_5_0_PHY_LOGIC_TIMING_ADJUST	\
-	(SDHCI_EMMC_5_0_PHY_REG_BASE + 0x14)
-#define SDHCI_EMMC_PHY_LOGIC_TIMING_ADJUST	(SDHCI_EMMC_PHY_REG_BASE + 0x18)
-#define SDHCI_LOGIC_TIMING_VALUE		0x00AA8977
-
-enum soc_pad_ctrl_type {
-	SOC_PAD_SD,
-	SOC_PAD_FIXED_1_8V,
-};
+#define XENON_ZNR_DEF_VALUE			0xF
+#define XENON_ZPR_DEF_VALUE			0xF
+
+#define XENON_EMMC_PHY_DLL_CONTROL		(XENON_EMMC_PHY_REG_BASE + 0x14)
+#define XENON_EMMC_5_0_PHY_DLL_CONTROL		\
+	(XENON_EMMC_5_0_PHY_REG_BASE + 0x10)
+#define XENON_DLL_ENABLE			BIT(31)
+#define XENON_DLL_UPDATE_STROBE_5_0		BIT(30)
+#define XENON_DLL_REFCLK_SEL			BIT(30)
+#define XENON_DLL_UPDATE			BIT(23)
+#define XENON_DLL_PHSEL1_SHIFT			24
+#define XENON_DLL_PHSEL0_SHIFT			16
+#define XENON_DLL_PHASE_MASK			0x3F
+#define XENON_DLL_PHASE_90_DEGREE		0x1F
+#define XENON_DLL_FAST_LOCK			BIT(5)
+#define XENON_DLL_GAIN2X			BIT(3)
+#define XENON_DLL_BYPASS_EN			BIT(0)
+
+#define XENON_EMMC_5_0_PHY_LOGIC_TIMING_ADJUST	\
+	(XENON_EMMC_5_0_PHY_REG_BASE + 0x14)
+#define XENON_EMMC_PHY_LOGIC_TIMING_ADJUST	(XENON_EMMC_PHY_REG_BASE + 0x18)
+#define XENON_LOGIC_TIMING_VALUE		0x00AA8977
 
 /*
  * List offset of PHY registers and some special register values
@@ -148,6 +143,11 @@ enum phy_type_enum {
 	NR_PHY_TYPES
 };
 
+enum soc_pad_ctrl_type {
+	SOC_PAD_SD,
+	SOC_PAD_FIXED_1_8V,
+};
+
 struct soc_pad_ctrl_table {
 	const char *soc;
 	void (*set_soc_pad)(struct sdhci_host *host,
@@ -155,33 +155,33 @@ struct soc_pad_ctrl_table {
 };
 
 struct soc_pad_ctrl {
-	/* Register address of SOC PHY PAD ctrl */
+	/* Register address of SoC PHY PAD ctrl */
 	void __iomem	*reg;
-	/* SOC PHY PAD ctrl type */
+	/* SoC PHY PAD ctrl type */
 	enum soc_pad_ctrl_type pad_type;
-	/* SOC specific operation to set SOC PHY PAD */
+	/* SoC specific operation to set SoC PHY PAD */
 	void (*set_soc_pad)(struct sdhci_host *host,
 			    unsigned char signal_voltage);
 };
 
 static struct xenon_emmc_phy_regs xenon_emmc_5_0_phy_regs = {
-	.timing_adj	= SDHCI_EMMC_5_0_PHY_TIMING_ADJUST,
-	.func_ctrl	= SDHCI_EMMC_5_0_PHY_FUNC_CONTROL,
-	.pad_ctrl	= SDHCI_EMMC_5_0_PHY_PAD_CONTROL,
-	.pad_ctrl2	= SDHCI_EMMC_5_0_PHY_PAD_CONTROL2,
-	.dll_ctrl	= SDHCI_EMMC_5_0_PHY_DLL_CONTROL,
-	.logic_timing_adj = SDHCI_EMMC_5_0_PHY_LOGIC_TIMING_ADJUST,
-	.dll_update	= SDHCI_DLL_UPDATE_STROBE_5_0,
+	.timing_adj	= XENON_EMMC_5_0_PHY_TIMING_ADJUST,
+	.func_ctrl	= XENON_EMMC_5_0_PHY_FUNC_CONTROL,
+	.pad_ctrl	= XENON_EMMC_5_0_PHY_PAD_CONTROL,
+	.pad_ctrl2	= XENON_EMMC_5_0_PHY_PAD_CONTROL2,
+	.dll_ctrl	= XENON_EMMC_5_0_PHY_DLL_CONTROL,
+	.logic_timing_adj = XENON_EMMC_5_0_PHY_LOGIC_TIMING_ADJUST,
+	.dll_update	= XENON_DLL_UPDATE_STROBE_5_0,
 };
 
 static struct xenon_emmc_phy_regs xenon_emmc_5_1_phy_regs = {
-	.timing_adj	= SDHCI_EMMC_PHY_TIMING_ADJUST,
-	.func_ctrl	= SDHCI_EMMC_PHY_FUNC_CONTROL,
-	.pad_ctrl	= SDHCI_EMMC_PHY_PAD_CONTROL,
-	.pad_ctrl2	= SDHCI_EMMC_PHY_PAD_CONTROL2,
-	.dll_ctrl	= SDHCI_EMMC_PHY_DLL_CONTROL,
-	.logic_timing_adj = SDHCI_EMMC_PHY_LOGIC_TIMING_ADJUST,
-	.dll_update	= SDHCI_DLL_UPDATE,
+	.timing_adj	= XENON_EMMC_PHY_TIMING_ADJUST,
+	.func_ctrl	= XENON_EMMC_PHY_FUNC_CONTROL,
+	.pad_ctrl	= XENON_EMMC_PHY_PAD_CONTROL,
+	.pad_ctrl2	= XENON_EMMC_PHY_PAD_CONTROL2,
+	.dll_ctrl	= XENON_EMMC_PHY_DLL_CONTROL,
+	.logic_timing_adj = XENON_EMMC_PHY_LOGIC_TIMING_ADJUST,
+	.dll_update	= XENON_DLL_UPDATE,
 };
 
 /*
@@ -221,7 +221,7 @@ static int alloc_emmc_phy(struct sdhci_xenon_priv *priv)
 /*
  * eMMC 5.0/5.1 PHY init/re-init.
  * eMMC PHY init should be executed after:
- * 1. SDCLK frequecny changes.
+ * 1. SDCLK frequency changes.
  * 2. SDCLK is stopped and re-enabled.
  * 3. config in emmc_phy_regs->timing_adj and emmc_phy_regs->func_ctrl
  * are changed
@@ -233,34 +233,31 @@ static int emmc_phy_init(struct sdhci_host *host)
 	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
 	struct sdhci_xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);
 	struct xenon_emmc_phy_regs *phy_regs = priv->emmc_phy_regs;
-	struct emmc_phy_params *params = priv->phy_params;
 
 	reg = sdhci_readl(host, phy_regs->timing_adj);
-	reg |= SDHCI_PHY_INITIALIZAION;
-	if (params->slow_mode)
-		reg |= SDHCI_TIMING_ADJUST_SLOW_MODE;
+	reg |= XENON_PHY_INITIALIZAION;
 	sdhci_writel(host, reg, phy_regs->timing_adj);
 
 	/* Add duration of FC_SYNC_RST */
-	wait = ((reg >> SDHCI_FC_SYNC_RST_DURATION_SHIFT) &
-			SDHCI_FC_SYNC_RST_DURATION_MASK);
+	wait = ((reg >> XENON_FC_SYNC_RST_DURATION_SHIFT) &
+			XENON_FC_SYNC_RST_DURATION_MASK);
 	/* Add interval between FC_SYNC_EN and FC_SYNC_RST */
-	wait += ((reg >> SDHCI_FC_SYNC_RST_EN_DURATION_SHIFT) &
-			SDHCI_FC_SYNC_RST_EN_DURATION_MASK);
+	wait += ((reg >> XENON_FC_SYNC_RST_EN_DURATION_SHIFT) &
+			XENON_FC_SYNC_RST_EN_DURATION_MASK);
 	/* Add duration of asserting FC_SYNC_EN */
-	wait += ((reg >> SDHCI_FC_SYNC_EN_DURATION_SHIFT) &
-			SDHCI_FC_SYNC_EN_DURATION_MASK);
+	wait += ((reg >> XENON_FC_SYNC_EN_DURATION_SHIFT) &
+			XENON_FC_SYNC_EN_DURATION_MASK);
 	/* Add duration of waiting for PHY */
-	wait += ((reg >> SDHCI_WAIT_CYCLE_BEFORE_USING_SHIFT) &
-			SDHCI_WAIT_CYCLE_BEFORE_USING_MASK);
-	/* 4 addtional bus clock and 4 AXI bus clock are required */
+	wait += ((reg >> XENON_WAIT_CYCLE_BEFORE_USING_SHIFT) &
+			XENON_WAIT_CYCLE_BEFORE_USING_MASK);
+	/* 4 additional bus clock and 4 AXI bus clock are required */
 	wait += 8;
 	wait <<= 20;
 
 	clock = host->clock;
 	if (!clock)
 		/* Use the possibly slowest bus frequency value */
-		clock = SDHCI_LOWEST_SDCLK_FREQ;
+		clock = XENON_LOWEST_SDCLK_FREQ;
 	/* get the wait time */
 	wait /= clock;
 	wait++;
@@ -268,7 +265,7 @@ static int emmc_phy_init(struct sdhci_host *host)
 	udelay(wait);
 
 	reg = sdhci_readl(host, phy_regs->timing_adj);
-	reg &= SDHCI_PHY_INITIALIZAION;
+	reg &= XENON_PHY_INITIALIZAION;
 	if (reg) {
 		dev_err(mmc_dev(host->mmc), "eMMC PHY init cannot complete after %d us\n",
 			wait);
@@ -299,9 +296,9 @@ static void armada_3700_soc_pad_voltage_set(struct sdhci_host *host,
 }
 
 /*
- * Set SOC PHY voltage PAD control register,
+ * Set SoC PHY voltage PAD control register,
  * according to the operation voltage on PAD.
- * The detailed operation depends on SOC implementaion.
+ * The detailed operation depends on SoC implementation.
  */
 static void emmc_phy_set_soc_pad(struct sdhci_host *host,
 				 unsigned char signal_voltage)
@@ -328,43 +325,39 @@ static int emmc_phy_enable_dll(struct sdhci_host *host)
 	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
 	struct sdhci_xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);
 	struct xenon_emmc_phy_regs *phy_regs = priv->emmc_phy_regs;
-	struct emmc_phy_params *params = priv->phy_params;
 	u8 timeout;
 
-	if (params->slow_mode && (host->clock <= MMC_HIGH_52_MAX_DTR))
-		return 0;
-
 	if (WARN_ON(host->clock <= MMC_HIGH_52_MAX_DTR))
 		return -EINVAL;
 
 	reg = sdhci_readl(host, phy_regs->dll_ctrl);
-	if (reg & SDHCI_DLL_ENABLE)
+	if (reg & XENON_DLL_ENABLE)
 		return 0;
 
 	/* Enable DLL */
 	reg = sdhci_readl(host, phy_regs->dll_ctrl);
-	reg |= (SDHCI_DLL_ENABLE | SDHCI_DLL_FAST_LOCK);
+	reg |= (XENON_DLL_ENABLE | XENON_DLL_FAST_LOCK);
 
 	/*
 	 * Set Phase as 90 degree, which is most common value.
 	 * Might set another value if necessary.
 	 * The granularity is 1 degree.
 	 */
-	reg &= ~((SDHCI_DLL_PHASE_MASK << SDHCI_DLL_PHSEL0_SHIFT) |
-		 (SDHCI_DLL_PHASE_MASK << SDHCI_DLL_PHSEL1_SHIFT));
-	reg |= ((SDHCI_DLL_PHASE_90_DEGREE << SDHCI_DLL_PHSEL0_SHIFT) |
-		(SDHCI_DLL_PHASE_90_DEGREE << SDHCI_DLL_PHSEL1_SHIFT));
+	reg &= ~((XENON_DLL_PHASE_MASK << XENON_DLL_PHSEL0_SHIFT) |
+		 (XENON_DLL_PHASE_MASK << XENON_DLL_PHSEL1_SHIFT));
+	reg |= ((XENON_DLL_PHASE_90_DEGREE << XENON_DLL_PHSEL0_SHIFT) |
+		(XENON_DLL_PHASE_90_DEGREE << XENON_DLL_PHSEL1_SHIFT));
 
-	reg &= ~SDHCI_DLL_BYPASS_EN;
+	reg &= ~XENON_DLL_BYPASS_EN;
 	reg |= phy_regs->dll_update;
 	if (priv->phy_type == EMMC_5_1_PHY)
-		reg &= ~SDHCI_DLL_REFCLK_SEL;
+		reg &= ~XENON_DLL_REFCLK_SEL;
 	sdhci_writel(host, reg, phy_regs->dll_ctrl);
 
 	/* Wait max 32 ms */
 	timeout = 32;
-	while (!(sdhci_readw(host, SDHCI_SLOT_EXT_PRESENT_STATE) &
-		SDHCI_DLL_LOCK_STATE)) {
+	while (!(sdhci_readw(host, XENON_SLOT_EXT_PRESENT_STATE) &
+		XENON_DLL_LOCK_STATE)) {
 		if (!timeout) {
 			dev_err(mmc_dev(host->mmc), "Wait for DLL Lock time-out\n");
 			return -ETIMEDOUT;
@@ -388,10 +381,7 @@ static int emmc_phy_config_tuning(struct sdhci_host *host)
 	int ret;
 	unsigned long flags;
 
-	if (params->slow_mode && (host->clock <= MMC_HIGH_52_MAX_DTR))
-		return 0;
-
-	if (WARN_ON(host->clock <= MMC_HIGH_52_MAX_DTR))
+	if (host->clock <= MMC_HIGH_52_MAX_DTR)
 		return -EINVAL;
 
 	spin_lock_irqsave(&host->lock, flags);
@@ -402,24 +392,24 @@ static int emmc_phy_config_tuning(struct sdhci_host *host)
 		return ret;
 	}
 
-	/* Achieve TUNGING_STEP with HW DLL help */
-	reg = sdhci_readl(host, SDHCI_SLOT_DLL_CUR_DLY_VAL);
+	/* Achieve TUNING_STEP with HW DLL help */
+	reg = sdhci_readl(host, XENON_SLOT_DLL_CUR_DLY_VAL);
 	tuning_step = reg / params->tun_step_divider;
-	if (unlikely(tuning_step > SDHCI_TUNING_STEP_MASK)) {
+	if (unlikely(tuning_step > XENON_TUNING_STEP_MASK)) {
 		dev_warn(mmc_dev(host->mmc),
 			 "HS200 TUNING_STEP %d is larger than MAX value\n",
 			 tuning_step);
-		tuning_step = SDHCI_TUNING_STEP_MASK;
+		tuning_step = XENON_TUNING_STEP_MASK;
 	}
 
 	/* Set TUNING_STEP for later tuning */
-	reg = sdhci_readl(host, SDHCI_SLOT_OP_STATUS_CTRL);
-	reg &= ~(SDHCI_TUN_CONSECUTIVE_TIMES_MASK <<
-		 SDHCI_TUN_CONSECUTIVE_TIMES_SHIFT);
-	reg |= (params->nr_tun_times << SDHCI_TUN_CONSECUTIVE_TIMES_SHIFT);
-	reg &= ~(SDHCI_TUNING_STEP_MASK << SDHCI_TUNING_STEP_SHIFT);
-	reg |= (tuning_step << SDHCI_TUNING_STEP_SHIFT);
-	sdhci_writel(host, reg, SDHCI_SLOT_OP_STATUS_CTRL);
+	reg = sdhci_readl(host, XENON_SLOT_OP_STATUS_CTRL);
+	reg &= ~(XENON_TUN_CONSECUTIVE_TIMES_MASK <<
+		 XENON_TUN_CONSECUTIVE_TIMES_SHIFT);
+	reg |= (params->nr_tun_times << XENON_TUN_CONSECUTIVE_TIMES_SHIFT);
+	reg &= ~(XENON_TUNING_STEP_MASK << XENON_TUNING_STEP_SHIFT);
+	reg |= (tuning_step << XENON_TUNING_STEP_SHIFT);
+	sdhci_writel(host, reg, XENON_SLOT_OP_STATUS_CTRL);
 
 	spin_unlock_irqrestore(&host->lock, flags);
 	return 0;
@@ -430,9 +420,9 @@ static void __emmc_phy_disable_data_strobe(struct sdhci_host *host)
 	u32 reg;
 
 	/* Disable SDHC Data Strobe */
-	reg = sdhci_readl(host, SDHCI_SLOT_EMMC_CTRL);
-	reg &= ~SDHCI_ENABLE_DATA_STROBE;
-	sdhci_writel(host, reg, SDHCI_SLOT_EMMC_CTRL);
+	reg = sdhci_readl(host, XENON_SLOT_EMMC_CTRL);
+	reg &= ~XENON_ENABLE_DATA_STROBE;
+	sdhci_writel(host, reg, XENON_SLOT_EMMC_CTRL);
 }
 
 /* Set HS400 Data Strobe */
@@ -456,67 +446,28 @@ static void emmc_phy_strobe_delay_adj(struct sdhci_host *host)
 	emmc_phy_enable_dll(host);
 
 	/* Enable SDHC Data Strobe */
-	reg = sdhci_readl(host, SDHCI_SLOT_EMMC_CTRL);
-	reg |= SDHCI_ENABLE_DATA_STROBE;
-	sdhci_writel(host, reg, SDHCI_SLOT_EMMC_CTRL);
+	reg = sdhci_readl(host, XENON_SLOT_EMMC_CTRL);
+	reg |= XENON_ENABLE_DATA_STROBE;
+	sdhci_writel(host, reg, XENON_SLOT_EMMC_CTRL);
 
 	/* Set Data Strobe Pull down */
 	if (priv->phy_type == EMMC_5_0_PHY) {
-		reg = sdhci_readl(host, SDHCI_EMMC_5_0_PHY_PAD_CONTROL);
-		reg |= SDHCI_EMMC5_FC_QSP_PD;
-		reg &= ~SDHCI_EMMC5_FC_QSP_PU;
-		sdhci_writel(host, reg, SDHCI_EMMC_5_0_PHY_PAD_CONTROL);
+		reg = sdhci_readl(host, XENON_EMMC_5_0_PHY_PAD_CONTROL);
+		reg |= XENON_EMMC5_FC_QSP_PD;
+		reg &= ~XENON_EMMC5_FC_QSP_PU;
+		sdhci_writel(host, reg, XENON_EMMC_5_0_PHY_PAD_CONTROL);
 	} else {
-		reg = sdhci_readl(host, SDHCI_EMMC_PHY_PAD_CONTROL1);
-		reg |= SDHCI_EMMC5_1_FC_QSP_PD;
-		reg &= ~SDHCI_EMMC5_1_FC_QSP_PU;
-		sdhci_writel(host, reg, SDHCI_EMMC_PHY_PAD_CONTROL1);
+		reg = sdhci_readl(host, XENON_EMMC_PHY_PAD_CONTROL1);
+		reg |= XENON_EMMC5_1_FC_QSP_PD;
+		reg &= ~XENON_EMMC5_1_FC_QSP_PU;
+		sdhci_writel(host, reg, XENON_EMMC_PHY_PAD_CONTROL1);
 	}
 	spin_unlock_irqrestore(&host->lock, flags);
 }
 
-static inline bool temp_stage_hs200_to_hs400(struct sdhci_host *host,
-					     struct sdhci_xenon_priv *priv)
-{
-	/*
-	 * Tmep stages from HS200 to HS400
-	 * from HS200 to HS in 200MHz
-	 * from 200MHz to 52MHz
-	 */
-	if (((priv->timing == MMC_TIMING_MMC_HS200) &&
-	     (host->timing == MMC_TIMING_MMC_HS)) ||
-	    ((host->timing == MMC_TIMING_MMC_HS) &&
-	     (priv->clock > host->clock)))
-		return true;
-
-	return false;
-}
-
-static inline bool temp_stage_hs400_to_h200(struct sdhci_host *host,
-					    struct sdhci_xenon_priv *priv)
-{
-	/*
-	 * Temp stages from HS400 t0 HS200:
-	 * from 200MHz to 52MHz in HS400
-	 * from HS400 to HS DDR in 52MHz
-	 * from HS DDR to HS in 52MHz
-	 * from HS to HS200 in 52MHz
-	 */
-	if (((priv->timing == MMC_TIMING_MMC_HS400) &&
-	     ((host->clock == MMC_HIGH_52_MAX_DTR) ||
-	      (host->timing == MMC_TIMING_MMC_DDR52))) ||
-	    ((priv->timing == MMC_TIMING_MMC_DDR52) &&
-	     (host->timing == MMC_TIMING_MMC_HS)) ||
-	    ((host->timing == MMC_TIMING_MMC_HS200) &&
-	     (host->clock == MMC_HIGH_52_MAX_DTR)))
-		return true;
-
-	return false;
-}
-
 /*
- * If eMMC PHY Slow Mode is required in lower speed mode in SDR mode
- * (SDLCK < 55MHz), enable Slow Mode to bypass eMMC PHY.
+ * If eMMC PHY Slow Mode is required in lower speed mode (SDCLK < 55MHz)
+ * in SDR mode, enable Slow Mode to bypass eMMC PHY.
  * SDIO slower SDR mode also requires Slow Mode.
  *
  * If Slow Mode is enabled, return true.
@@ -531,12 +482,7 @@ static bool emmc_phy_slow_mode(struct sdhci_host *host,
 	struct xenon_emmc_phy_regs *phy_regs = priv->emmc_phy_regs;
 	u32 reg;
 
-	/* Skip temp stages from HS200 to HS400 */
-	if (temp_stage_hs200_to_hs400(host, priv))
-		return false;
-
-	/* Skip temp stages from HS400 t0 HS200 */
-	if (temp_stage_hs400_to_h200(host, priv))
+	if (host->clock > MMC_HIGH_52_MAX_DTR)
 		return false;
 
 	reg = sdhci_readl(host, phy_regs->timing_adj);
@@ -544,33 +490,30 @@ static bool emmc_phy_slow_mode(struct sdhci_host *host,
 	if ((priv->init_card_type == MMC_TYPE_SDIO) &&
 	    ((timing == MMC_TIMING_UHS_SDR25) ||
 	     (timing == MMC_TIMING_UHS_SDR12) ||
-	     (timing == MMC_TIMING_SD_HS) ||
-	     (timing == MMC_TIMING_LEGACY))) {
-		reg |= SDHCI_TIMING_ADJUST_SLOW_MODE;
+	     (timing == MMC_TIMING_SD_HS))) {
+		reg |= XENON_TIMING_ADJUST_SLOW_MODE;
 		sdhci_writel(host, reg, phy_regs->timing_adj);
 		return true;
 	}
 
 	/* Check if Slow Mode is required in lower speed mode in SDR mode */
-	if (((timing == MMC_TIMING_UHS_SDR50) ||
-	     (timing == MMC_TIMING_UHS_SDR25) ||
+	if (((timing == MMC_TIMING_UHS_SDR25) ||
 	     (timing == MMC_TIMING_UHS_SDR12) ||
 	     (timing == MMC_TIMING_SD_HS) ||
-	     (timing == MMC_TIMING_MMC_HS) ||
-	     (timing == MMC_TIMING_LEGACY)) && params->slow_mode) {
-		reg |= SDHCI_TIMING_ADJUST_SLOW_MODE;
+	     (timing == MMC_TIMING_MMC_HS)) && params->slow_mode) {
+		reg |= XENON_TIMING_ADJUST_SLOW_MODE;
 		sdhci_writel(host, reg, phy_regs->timing_adj);
 		return true;
 	}
 
-	reg &= ~SDHCI_TIMING_ADJUST_SLOW_MODE;
+	reg &= ~XENON_TIMING_ADJUST_SLOW_MODE;
 	sdhci_writel(host, reg, phy_regs->timing_adj);
 	return false;
 }
 
 /*
  * Set-up eMMC 5.0/5.1 PHY.
- * Specific onfiguration depends on the current speed mode in use.
+ * Specific configuration depends on the current speed mode in use.
  */
 static void emmc_phy_set(struct sdhci_host *host,
 			 unsigned char timing)
@@ -586,33 +529,39 @@ static void emmc_phy_set(struct sdhci_host *host,
 
 	spin_lock_irqsave(&host->lock, flags);
 
-	reg = sdhci_readl(host, SDHCI_SYS_EXT_OP_CTRL);
-	reg |= SDHCI_MASK_CMD_CONFLICT_ERROR;
-	sdhci_writel(host, reg, SDHCI_SYS_EXT_OP_CTRL);
-
 	/* Setup pad, set bit[28] and bits[26:24] */
 	reg = sdhci_readl(host, phy_regs->pad_ctrl);
-	reg |= (SDHCI_FC_DQ_RECEN | SDHCI_FC_CMD_RECEN |
-		SDHCI_FC_QSP_RECEN | SDHCI_OEN_QSN);
+	reg |= (XENON_FC_DQ_RECEN | XENON_FC_CMD_RECEN |
+		XENON_FC_QSP_RECEN | XENON_OEN_QSN);
 	/* All FC_XX_RECEIVCE should be set as CMOS Type */
-	reg |= SDHCI_FC_ALL_CMOS_RECEIVER;
+	reg |= XENON_FC_ALL_CMOS_RECEIVER;
 	sdhci_writel(host, reg, phy_regs->pad_ctrl);
 
 	/* Set CMD and DQ Pull Up */
 	if (priv->phy_type == EMMC_5_0_PHY) {
-		reg = sdhci_readl(host, SDHCI_EMMC_5_0_PHY_PAD_CONTROL);
-		reg |= (SDHCI_EMMC5_FC_CMD_PU | SDHCI_EMMC5_FC_DQ_PU);
-		reg &= ~(SDHCI_EMMC5_FC_CMD_PD | SDHCI_EMMC5_FC_DQ_PD);
-		sdhci_writel(host, reg, SDHCI_EMMC_5_0_PHY_PAD_CONTROL);
+		reg = sdhci_readl(host, XENON_EMMC_5_0_PHY_PAD_CONTROL);
+		reg |= (XENON_EMMC5_FC_CMD_PU | XENON_EMMC5_FC_DQ_PU);
+		reg &= ~(XENON_EMMC5_FC_CMD_PD | XENON_EMMC5_FC_DQ_PD);
+		sdhci_writel(host, reg, XENON_EMMC_5_0_PHY_PAD_CONTROL);
 	} else {
-		reg = sdhci_readl(host, SDHCI_EMMC_PHY_PAD_CONTROL1);
-		reg |= (SDHCI_EMMC5_1_FC_CMD_PU | SDHCI_EMMC5_1_FC_DQ_PU);
-		reg &= ~(SDHCI_EMMC5_1_FC_CMD_PD | SDHCI_EMMC5_1_FC_DQ_PD);
-		sdhci_writel(host, reg, SDHCI_EMMC_PHY_PAD_CONTROL1);
+		reg = sdhci_readl(host, XENON_EMMC_PHY_PAD_CONTROL1);
+		reg |= (XENON_EMMC5_1_FC_CMD_PU | XENON_EMMC5_1_FC_DQ_PU);
+		reg &= ~(XENON_EMMC5_1_FC_CMD_PD | XENON_EMMC5_1_FC_DQ_PD);
+		sdhci_writel(host, reg, XENON_EMMC_PHY_PAD_CONTROL1);
 	}
 
-	if (timing == MMC_TIMING_LEGACY)
+	if (timing == MMC_TIMING_LEGACY) {
+		/*
+		 * If Slow Mode is required, enable Slow Mode by default
+		 * in early init phase to avoid any potential issue.
+		 */
+		if (params->slow_mode) {
+			reg = sdhci_readl(host, phy_regs->timing_adj);
+			reg |= XENON_TIMING_ADJUST_SLOW_MODE;
+			sdhci_writel(host, reg, phy_regs->timing_adj);
+		}
 		goto phy_init;
+	}
 
 	/*
 	 * FIXME: should depends on the specific board timing.
@@ -625,7 +574,7 @@ static void emmc_phy_set(struct sdhci_host *host,
 	    (timing == MMC_TIMING_UHS_SDR25) ||
 	    (timing == MMC_TIMING_MMC_DDR52)) {
 		reg = sdhci_readl(host, phy_regs->timing_adj);
-		reg &= ~SDHCI_OUTPUT_QSN_PHASE_SELECT;
+		reg &= ~XENON_OUTPUT_QSN_PHASE_SELECT;
 		sdhci_writel(host, reg, phy_regs->timing_adj);
 	}
 
@@ -635,9 +584,9 @@ static void emmc_phy_set(struct sdhci_host *host,
 	 */
 	reg = sdhci_readl(host, phy_regs->timing_adj);
 	if (priv->init_card_type == MMC_TYPE_SDIO)
-		reg |= SDHCI_TIMING_ADJUST_SDIO_MODE;
+		reg |= XENON_TIMING_ADJUST_SDIO_MODE;
 	else
-		reg &= ~SDHCI_TIMING_ADJUST_SDIO_MODE;
+		reg &= ~XENON_TIMING_ADJUST_SDIO_MODE;
 	sdhci_writel(host, reg, phy_regs->timing_adj);
 
 	if (emmc_phy_slow_mode(host, timing))
@@ -649,8 +598,8 @@ static void emmc_phy_set(struct sdhci_host *host,
 	 * Define them both in sdhci-xenon-emmc-phy.h.
 	 */
 	reg = sdhci_readl(host, phy_regs->pad_ctrl2);
-	reg &= ~((SDHCI_ZNR_MASK << SDHCI_ZNR_SHIFT) | SDHCI_ZPR_MASK);
-	reg |= ((params->znr << SDHCI_ZNR_SHIFT) | params->zpr);
+	reg &= ~((XENON_ZNR_MASK << XENON_ZNR_SHIFT) | XENON_ZPR_MASK);
+	reg |= ((params->znr << XENON_ZNR_SHIFT) | params->zpr);
 	sdhci_writel(host, reg, phy_regs->pad_ctrl2);
 
 	/*
@@ -665,16 +614,16 @@ static void emmc_phy_set(struct sdhci_host *host,
 	if ((timing == MMC_TIMING_UHS_DDR50) ||
 	    (timing == MMC_TIMING_MMC_HS400) ||
 	    (timing == MMC_TIMING_MMC_DDR52))
-		reg |= (SDHCI_DQ_DDR_MODE_MASK << SDHCI_DQ_DDR_MODE_SHIFT) |
-		       SDHCI_CMD_DDR_MODE;
+		reg |= (XENON_DQ_DDR_MODE_MASK << XENON_DQ_DDR_MODE_SHIFT) |
+		       XENON_CMD_DDR_MODE;
 	else
-		reg &= ~((SDHCI_DQ_DDR_MODE_MASK << SDHCI_DQ_DDR_MODE_SHIFT) |
-			 SDHCI_CMD_DDR_MODE);
+		reg &= ~((XENON_DQ_DDR_MODE_MASK << XENON_DQ_DDR_MODE_SHIFT) |
+			 XENON_CMD_DDR_MODE);
 
 	if (timing == MMC_TIMING_MMC_HS400)
-		reg &= ~SDHCI_DQ_ASYNC_MODE;
+		reg &= ~XENON_DQ_ASYNC_MODE;
 	else
-		reg |= SDHCI_DQ_ASYNC_MODE;
+		reg |= XENON_DQ_ASYNC_MODE;
 	sdhci_writel(host, reg, phy_regs->func_ctrl);
 
 	/* Enable bus clock */
@@ -684,7 +633,7 @@ static void emmc_phy_set(struct sdhci_host *host,
 
 	if (timing == MMC_TIMING_MMC_HS400)
 		/* Hardware team recommend a value for HS400 */
-		sdhci_writel(host, SDHCI_LOGIC_TIMING_VALUE,
+		sdhci_writel(host, XENON_LOGIC_TIMING_VALUE,
 			     phy_regs->logic_timing_adj);
 	else
 		__emmc_phy_disable_data_strobe(host);
@@ -711,7 +660,7 @@ static int get_dt_pad_ctrl_data(struct sdhci_host *host,
 		return 0;
 
 	if (of_address_to_resource(np, 1, &iomem)) {
-		dev_err(mmc_dev(host->mmc), "Unable to find SOC PAD ctrl register address for %s\n",
+		dev_err(mmc_dev(host->mmc), "Unable to find SoC PAD ctrl register address for %s\n",
 			np->name);
 		return -EINVAL;
 	}
@@ -719,14 +668,14 @@ static int get_dt_pad_ctrl_data(struct sdhci_host *host,
 	params->pad_ctrl.reg = devm_ioremap_resource(mmc_dev(host->mmc),
 						     &iomem);
 	if (IS_ERR(params->pad_ctrl.reg)) {
-		dev_err(mmc_dev(host->mmc), "Unable to get SOC PHY PAD ctrl regiser for %s\n",
+		dev_err(mmc_dev(host->mmc), "Unable to get SoC PHY PAD ctrl register for %s\n",
 			np->name);
 		return PTR_ERR(params->pad_ctrl.reg);
 	}
 
 	ret = of_property_read_string(np, "marvell,pad-type", &name);
 	if (ret) {
-		dev_err(mmc_dev(host->mmc), "Unable to determine SOC PHY PAD ctrl type\n");
+		dev_err(mmc_dev(host->mmc), "Unable to determine SoC PHY PAD ctrl type\n");
 		return ret;
 	}
 	if (!strcmp(name, "sd")) {
@@ -734,7 +683,7 @@ static int get_dt_pad_ctrl_data(struct sdhci_host *host,
 	} else if (!strcmp(name, "fixed-1-8v")) {
 		params->pad_ctrl.pad_type = SOC_PAD_FIXED_1_8V;
 	} else {
-		dev_err(mmc_dev(host->mmc), "Unsupported SOC PHY PAD ctrl type %s\n",
+		dev_err(mmc_dev(host->mmc), "Unsupported SoC PHY PAD ctrl type %s\n",
 			name);
 		return -EINVAL;
 	}
@@ -754,31 +703,31 @@ static int emmc_phy_parse_param_dt(struct sdhci_host *host,
 		params->slow_mode = false;
 
 	if (!of_property_read_u32(np, "marvell,xenon-phy-znr", &value))
-		params->znr = value & SDHCI_ZNR_MASK;
+		params->znr = value & XENON_ZNR_MASK;
 	else
-		params->znr = SDHCI_ZNR_DEF_VALUE;
+		params->znr = XENON_ZNR_DEF_VALUE;
 
 	if (!of_property_read_u32(np, "marvell,xenon-phy-zpr", &value))
-		params->zpr = value & SDHCI_ZPR_MASK;
+		params->zpr = value & XENON_ZPR_MASK;
 	else
-		params->zpr = SDHCI_ZPR_DEF_VALUE;
+		params->zpr = XENON_ZPR_DEF_VALUE;
 
 	if (!of_property_read_u32(np, "marvell,xenon-phy-nr-success-tun",
 				  &value))
-		params->nr_tun_times = value & SDHCI_TUN_CONSECUTIVE_TIMES_MASK;
+		params->nr_tun_times = value & XENON_TUN_CONSECUTIVE_TIMES_MASK;
 	else
-		params->nr_tun_times = SDHCI_TUN_CONSECUTIVE_TIMES;
+		params->nr_tun_times = XENON_TUN_CONSECUTIVE_TIMES;
 
 	if (!of_property_read_u32(np, "marvell,xenon-phy-tun-step-divider",
 				  &value))
 		params->tun_step_divider = value & 0xFF;
 	else
-		params->tun_step_divider = SDHCI_TUNING_STEP_DIVIDER;
+		params->tun_step_divider = XENON_TUNING_STEP_DIVIDER;
 
 	return get_dt_pad_ctrl_data(host, np, params);
 }
 
-/* Set SOC PHY Voltage PAD */
+/* Set SoC PHY Voltage PAD */
 void xenon_soc_pad_ctrl(struct sdhci_host *host,
 			unsigned char signal_voltage)
 {
@@ -794,7 +743,7 @@ static int xenon_hs_delay_adj(struct sdhci_host *host)
 {
 	int ret = 0;
 
-	if (WARN_ON(host->clock <= SDHCI_DEFAULT_SDCLK_FREQ))
+	if (WARN_ON(host->clock <= XENON_DEFAULT_SDCLK_FREQ))
 		return -EINVAL;
 
 	if (host->timing == MMC_TIMING_MMC_HS400) {
@@ -803,11 +752,8 @@ static int xenon_hs_delay_adj(struct sdhci_host *host)
 	}
 
 	if ((host->timing == MMC_TIMING_MMC_HS200) ||
-	    (host->timing == MMC_TIMING_UHS_SDR104)) {
-		ret = emmc_phy_config_tuning(host);
-		if (!ret)
-			return 0;
-	}
+	    (host->timing == MMC_TIMING_UHS_SDR104))
+		return emmc_phy_config_tuning(host);
 
 	/*
 	 * DDR Mode requires driver to scan Sampling Fixed Delay Line,
@@ -817,12 +763,12 @@ static int xenon_hs_delay_adj(struct sdhci_host *host)
 	 * Thus so far just keep PHY Sampling Fixed Delay in default value
 	 * in DDR mode.
 	 *
-	 * If any timing issue occrus in DDR mode on Marvell products,
+	 * If any timing issue occurs in DDR mode on Marvell products,
 	 * please contact maintainer to ask for internal support in Marvell.
 	 */
 	if ((host->timing == MMC_TIMING_MMC_DDR52) ||
 	    (host->timing == MMC_TIMING_UHS_DDR50))
-		dev_warn(mmc_dev(host->mmc), "Timing issue might occur in DDR mode\n");
+		dev_warn_once(mmc_dev(host->mmc), "Timing issue might occur in DDR mode\n");
 	return ret;
 }
 
@@ -830,7 +776,7 @@ static int xenon_hs_delay_adj(struct sdhci_host *host)
  * Adjust PHY setting.
  * PHY setting should be adjusted when SDCLK frequency, Bus Width
  * or Speed Mode is changed.
- * Addtional config are required when card is working in High Speed mode,
+ * Additional config are required when card is working in High Speed mode,
  * after leaving Legacy Mode.
  */
 int xenon_phy_adj(struct sdhci_host *host, struct mmc_ios *ios)
@@ -859,14 +805,6 @@ int xenon_phy_adj(struct sdhci_host *host, struct mmc_ios *ios)
 	/* Update the record */
 	priv->bus_width = ios->bus_width;
 
-	/* Skip temp stages from HS200 to HS400 */
-	if (temp_stage_hs200_to_hs400(host, priv))
-		return 0;
-
-	/* Skip temp stages from HS400 t0 HS200 */
-	if (temp_stage_hs400_to_h200(host, priv))
-		return 0;
-
 	priv->timing = ios->timing;
 	priv->clock = host->clock;
 
@@ -874,11 +812,16 @@ int xenon_phy_adj(struct sdhci_host *host, struct mmc_ios *ios)
 	if (ios->timing == MMC_TIMING_LEGACY)
 		return 0;
 
-	if (host->clock > SDHCI_DEFAULT_SDCLK_FREQ)
+	if (host->clock > XENON_DEFAULT_SDCLK_FREQ)
 		ret = xenon_hs_delay_adj(host);
 	return ret;
 }
 
+static void clean_emmc_phy(struct sdhci_xenon_priv *priv)
+{
+	kfree(priv->phy_params);
+}
+
 static int add_xenon_phy(struct device_node *np, struct sdhci_host *host,
 			 const char *phy_name)
 {
@@ -903,7 +846,11 @@ static int add_xenon_phy(struct device_node *np, struct sdhci_host *host,
 	if (ret)
 		return ret;
 
-	return emmc_phy_parse_param_dt(host, np, priv->phy_params);
+	ret = emmc_phy_parse_param_dt(host, np, priv->phy_params);
+	if (ret)
+		clean_emmc_phy(priv);
+
+	return ret;
 }
 
 int xenon_phy_parse_dt(struct device_node *np, struct sdhci_host *host)
diff --git a/drivers/mmc/host/sdhci-xenon.c b/drivers/mmc/host/sdhci-xenon.c
index a770a7e..19b3224 100644
--- a/drivers/mmc/host/sdhci-xenon.c
+++ b/drivers/mmc/host/sdhci-xenon.c
@@ -52,15 +52,15 @@ static void xenon_set_sdclk_off_idle(struct sdhci_host *host,
 	u32 reg;
 	u32 mask;
 
-	reg = sdhci_readl(host, SDHCI_SYS_OP_CTRL);
+	reg = sdhci_readl(host, XENON_SYS_OP_CTRL);
 	/* Get the bit shift basing on the SDHC index */
-	mask = (0x1 << (SDHCI_SDCLK_IDLEOFF_ENABLE_SHIFT + sdhc_id));
+	mask = (0x1 << (XENON_SDCLK_IDLEOFF_ENABLE_SHIFT + sdhc_id));
 	if (enable)
 		reg |= mask;
 	else
 		reg &= ~mask;
 
-	sdhci_writel(host, reg, SDHCI_SYS_OP_CTRL);
+	sdhci_writel(host, reg, XENON_SYS_OP_CTRL);
 }
 
 /* Enable/Disable the Auto Clock Gating function */
@@ -68,12 +68,12 @@ static void xenon_set_acg(struct sdhci_host *host, bool enable)
 {
 	u32 reg;
 
-	reg = sdhci_readl(host, SDHCI_SYS_OP_CTRL);
+	reg = sdhci_readl(host, XENON_SYS_OP_CTRL);
 	if (enable)
-		reg &= ~SDHCI_AUTO_CLKGATE_DISABLE_MASK;
+		reg &= ~XENON_AUTO_CLKGATE_DISABLE_MASK;
 	else
-		reg |= SDHCI_AUTO_CLKGATE_DISABLE_MASK;
-	sdhci_writel(host, reg, SDHCI_SYS_OP_CTRL);
+		reg |= XENON_AUTO_CLKGATE_DISABLE_MASK;
+	sdhci_writel(host, reg, XENON_SYS_OP_CTRL);
 }
 
 /* Enable this SDHC */
@@ -82,9 +82,9 @@ static void xenon_enable_sdhc(struct sdhci_host *host,
 {
 	u32 reg;
 
-	reg = sdhci_readl(host, SDHCI_SYS_OP_CTRL);
-	reg |= (BIT(sdhc_id) << SDHCI_SLOT_ENABLE_SHIFT);
-	sdhci_writel(host, reg, SDHCI_SYS_OP_CTRL);
+	reg = sdhci_readl(host, XENON_SYS_OP_CTRL);
+	reg |= (BIT(sdhc_id) << XENON_SLOT_ENABLE_SHIFT);
+	sdhci_writel(host, reg, XENON_SYS_OP_CTRL);
 
 	/*
 	 * Manually set the flag which all the card types require,
@@ -99,9 +99,9 @@ static void xenon_disable_sdhc(struct sdhci_host *host,
 {
 	u32 reg;
 
-	reg = sdhci_readl(host, SDHCI_SYS_OP_CTRL);
-	reg &= ~(BIT(sdhc_id) << SDHCI_SLOT_ENABLE_SHIFT);
-	sdhci_writel(host, reg, SDHCI_SYS_OP_CTRL);
+	reg = sdhci_readl(host, XENON_SYS_OP_CTRL);
+	reg &= ~(BIT(sdhc_id) << XENON_SLOT_ENABLE_SHIFT);
+	sdhci_writel(host, reg, XENON_SYS_OP_CTRL);
 }
 
 /* Enable Parallel Transfer Mode */
@@ -110,26 +110,39 @@ static void xenon_enable_sdhc_parallel_tran(struct sdhci_host *host,
 {
 	u32 reg;
 
-	reg = sdhci_readl(host, SDHCI_SYS_EXT_OP_CTRL);
+	reg = sdhci_readl(host, XENON_SYS_EXT_OP_CTRL);
 	reg |= BIT(sdhc_id);
-	sdhci_writel(host, reg, SDHCI_SYS_EXT_OP_CTRL);
+	sdhci_writel(host, reg, XENON_SYS_EXT_OP_CTRL);
 }
 
-static void xenon_sdhc_tuning_setup(struct sdhci_host *host)
+/* Mask command conflict error */
+static void xenon_mask_cmd_conflict_err(struct sdhci_host *host)
+{
+	u32  reg;
+
+	reg = sdhci_readl(host, XENON_SYS_EXT_OP_CTRL);
+	reg |= XENON_MASK_CMD_CONFLICT_ERR;
+	sdhci_writel(host, reg, XENON_SYS_EXT_OP_CTRL);
+}
+
+static void xenon_sdhc_retune_setup(struct sdhci_host *host)
 {
 	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
 	struct sdhci_xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);
 	u32 reg;
 
 	/* Disable the Re-Tuning Request functionality */
-	reg = sdhci_readl(host, SDHCI_SLOT_RETUNING_REQ_CTRL);
-	reg &= ~SDHCI_RETUNING_COMPATIBLE;
-	sdhci_writel(host, reg, SDHCI_SLOT_RETUNING_REQ_CTRL);
+	reg = sdhci_readl(host, XENON_SLOT_RETUNING_REQ_CTRL);
+	reg &= ~XENON_RETUNING_COMPATIBLE;
+	sdhci_writel(host, reg, XENON_SLOT_RETUNING_REQ_CTRL);
 
-	/* Disable the Re-tuning Event Signal Enable */
+	/* Disable the Re-tuning Interrupt */
 	reg = sdhci_readl(host, SDHCI_SIGNAL_ENABLE);
 	reg &= ~SDHCI_INT_RETUNE;
 	sdhci_writel(host, reg, SDHCI_SIGNAL_ENABLE);
+	reg = sdhci_readl(host, SDHCI_INT_ENABLE);
+	reg &= ~SDHCI_INT_RETUNE;
+	sdhci_writel(host, reg, SDHCI_INT_ENABLE);
 
 	/* Force to use Tuning Mode 1 */
 	host->tuning_mode = SDHCI_TUNING_MODE_1;
@@ -149,11 +162,13 @@ static void sdhci_xenon_reset_exit(struct sdhci_host *host,
 		return;
 
 	/* Disable tuning request and auto-retuning again */
-	xenon_sdhc_tuning_setup(host);
+	xenon_sdhc_retune_setup(host);
 
 	xenon_set_acg(host, true);
 
 	xenon_set_sdclk_off_idle(host, sdhc_id, false);
+
+	xenon_mask_cmd_conflict_err(host);
 }
 
 static void sdhci_xenon_reset(struct sdhci_host *host, u8 mask)
@@ -178,7 +193,7 @@ static void xenon_set_uhs_signaling(struct sdhci_host *host,
 	/* Select Bus Speed Mode for host */
 	ctrl_2 &= ~SDHCI_CTRL_UHS_MASK;
 	if (timing == MMC_TIMING_MMC_HS200)
-		ctrl_2 |= SDHCI_XENON_CTRL_HS200;
+		ctrl_2 |= XENON_CTRL_HS200;
 	else if (timing == MMC_TIMING_UHS_SDR104)
 		ctrl_2 |= SDHCI_CTRL_UHS_SDR104;
 	else if (timing == MMC_TIMING_UHS_SDR12)
@@ -191,7 +206,7 @@ static void xenon_set_uhs_signaling(struct sdhci_host *host,
 		 (timing == MMC_TIMING_MMC_DDR52))
 		ctrl_2 |= SDHCI_CTRL_UHS_DDR50;
 	else if (timing == MMC_TIMING_MMC_HS400)
-		ctrl_2 |= SDHCI_XENON_CTRL_HS400;
+		ctrl_2 |= XENON_CTRL_HS400;
 	sdhci_writew(host, ctrl_2, SDHCI_HOST_CONTROL2);
 }
 
@@ -234,6 +249,7 @@ static void xenon_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 	    (ios->timing == MMC_TIMING_MMC_HS)) {
 		host->preset_enabled = false;
 		host->quirks2 |= SDHCI_QUIRK2_PRESET_VALUE_BROKEN;
+		host->flags &= ~SDHCI_PV_ENABLED;
 
 		reg = sdhci_readw(host, SDHCI_HOST_CONTROL2);
 		reg &= ~SDHCI_CTRL_PRESET_VAL_ENABLE;
@@ -246,7 +262,7 @@ static void xenon_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 	sdhci_set_ios(mmc, ios);
 	xenon_phy_adj(host, ios);
 
-	if (host->clock > SDHCI_DEFAULT_SDCLK_FREQ) {
+	if (host->clock > XENON_DEFAULT_SDCLK_FREQ) {
 		spin_lock_irqsave(&host->lock, flags);
 		xenon_set_sdclk_off_idle(host, priv->sdhc_id, true);
 		spin_unlock_irqrestore(&host->lock, flags);
@@ -264,26 +280,26 @@ static int xenon_emmc_signal_voltage_switch(struct mmc_host *mmc,
 	if ((voltage == MMC_SIGNAL_VOLTAGE_330) ||
 	    (voltage == MMC_SIGNAL_VOLTAGE_180)) {
 		if (voltage == MMC_SIGNAL_VOLTAGE_330)
-			voltage_code = SDHCI_EMMC_VCCQ_3_3V;
+			voltage_code = XENON_EMMC_VCCQ_3_3V;
 		else if (voltage == MMC_SIGNAL_VOLTAGE_180)
-			voltage_code = SDHCI_EMMC_VCCQ_1_8V;
+			voltage_code = XENON_EMMC_VCCQ_1_8V;
 
 		/*
 		 * This host is for eMMC, XENON self-defined
 		 * eMMC control register should be accessed
 		 * instead of Host Control 2
 		 */
-		ctrl = sdhci_readl(host, SDHCI_SLOT_EMMC_CTRL);
-		ctrl &= ~SDHCI_EMMC_VCCQ_MASK;
+		ctrl = sdhci_readl(host, XENON_SLOT_EMMC_CTRL);
+		ctrl &= ~XENON_EMMC_VCCQ_MASK;
 		ctrl |= voltage_code;
-		sdhci_writel(host, ctrl, SDHCI_SLOT_EMMC_CTRL);
+		sdhci_writel(host, ctrl, XENON_SLOT_EMMC_CTRL);
 
 		/* There is no standard to determine this waiting period */
 		usleep_range(1000, 2000);
 
 		/* Check whether io voltage switch is done */
-		ctrl = sdhci_readl(host, SDHCI_SLOT_EMMC_CTRL);
-		ctrl &= SDHCI_EMMC_VCCQ_MASK;
+		ctrl = sdhci_readl(host, XENON_SLOT_EMMC_CTRL);
+		ctrl &= XENON_EMMC_VCCQ_MASK;
 		/*
 		 * This bit is set only when regulator feeds back
 		 * the voltage switch results to Xenon SDHC.
@@ -351,6 +367,14 @@ static int xenon_execute_tuning(struct mmc_host *mmc, u32 opcode)
 	if (host->timing == MMC_TIMING_UHS_DDR50)
 		return 0;
 
+	/*
+	 * Currently force Xenon driver back to support mode 1 only,
+	 * even though Xenon might claim to support mode 2 or mode 3.
+	 * It requires more time to test mode 2/mode 3 on more platforms.
+	 */
+	if (host->tuning_mode != SDHCI_TUNING_MODE_1)
+		xenon_sdhc_retune_setup(host);
+
 	return sdhci_execute_tuning(mmc, opcode);
 }
 
@@ -369,14 +393,14 @@ static void xenon_enable_sdio_irq(struct mmc_host *mmc, int enable)
 		 * Set SDIO Card Inserted indication
 		 * to enable detecting SDIO async irq.
 		 */
-		reg = sdhci_readl(host, SDHCI_SYS_CFG_INFO);
-		reg |= (1 << (sdhc_id + SDHCI_SLOT_TYPE_SDIO_SHIFT));
-		sdhci_writel(host, reg, SDHCI_SYS_CFG_INFO);
+		reg = sdhci_readl(host, XENON_SYS_CFG_INFO);
+		reg |= (1 << (sdhc_id + XENON_SLOT_TYPE_SDIO_SHIFT));
+		sdhci_writel(host, reg, XENON_SYS_CFG_INFO);
 	} else {
 		/* Clear SDIO Card Inserted indication */
-		reg = sdhci_readl(host, SDHCI_SYS_CFG_INFO);
-		reg &= ~(1 << (sdhc_id + SDHCI_SLOT_TYPE_SDIO_SHIFT));
-		sdhci_writel(host, reg, SDHCI_SYS_CFG_INFO);
+		reg = sdhci_readl(host, XENON_SYS_CFG_INFO);
+		reg &= ~(1 << (sdhc_id + XENON_SLOT_TYPE_SDIO_SHIFT));
+		sdhci_writel(host, reg, XENON_SYS_CFG_INFO);
 	}
 }
 
@@ -391,46 +415,12 @@ static void xenon_replace_mmc_host_ops(struct sdhci_host *host)
 }
 
 /*
- * Parse child node in Xenon DT.
- * Search for the following item(s):
- * - eMMC card type
+ * Parse Xenon specific DT properties:
+ * init_card_type: check whether this SDHC is for eMMC
+ * sdhc-id: the index of current SDHC.
+ *	    Refer to XENON_SYS_CFG_INFO register
+ * tun-count: the interval between re-tuning
  */
-static int xenon_child_node_of_parse(struct platform_device *pdev)
-{
-	struct device_node *np = pdev->dev.of_node;
-	struct sdhci_host *host = platform_get_drvdata(pdev);
-	struct mmc_host *mmc = host->mmc;
-	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
-	struct sdhci_xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);
-	struct device_node *child;
-	int nr_child;
-
-	priv->init_card_type = SDHCI_CARD_TYPE_UNKNOWN;
-
-	nr_child = of_get_child_count(np);
-	if (!nr_child)
-		return 0;
-
-	for_each_child_of_node(np, child) {
-		if (of_device_is_compatible(child, "mmc-card"))	{
-			priv->init_card_type = MMC_TYPE_MMC;
-			mmc->caps |= MMC_CAP_NONREMOVABLE;
-
-			/*
-			 * Force to clear BUS_TEST to
-			 * skip bus_test_pre and bus_test_post
-			 */
-			mmc->caps &= ~MMC_CAP_BUS_WIDTH_TEST;
-			mmc->caps2 |= MMC_CAP2_HC_ERASE_SZ |
-				      MMC_CAP2_PACKED_CMD |
-				      MMC_CAP2_NO_SD |
-				      MMC_CAP2_NO_SDIO;
-		}
-	}
-
-	return 0;
-}
-
 static int xenon_probe_dt(struct platform_device *pdev)
 {
 	struct device_node *np = pdev->dev.of_node;
@@ -438,34 +428,28 @@ static int xenon_probe_dt(struct platform_device *pdev)
 	struct mmc_host *mmc = host->mmc;
 	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
 	struct sdhci_xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);
-	int err;
 	u32 sdhc_id, nr_sdhc;
 	u32 tuning_count;
 
-	/* Standard MMC property */
-	err = mmc_of_parse(mmc);
-	if (err)
-		return err;
+	/* Disable HS200 on Armada AP806 */
+	if (of_device_is_compatible(np, "marvell,armada-ap806-sdhci"))
+		host->quirks2 |= SDHCI_QUIRK2_BROKEN_HS200;
 
-	/* Standard SDHCI property */
-	sdhci_get_of_property(pdev);
-
-	/*
-	 * Xenon Specific property:
-	 * init_card_type: check whether this SDHC is for eMMC
-	 * sdhc-id: the index of current SDHC.
-	 *	    Refer to SDHCI_SYS_CFG_INFO register
-	 * tun-count: the interval between re-tuning
-	 */
-	/* Parse child node, including checking emmc type */
-	err = xenon_child_node_of_parse(pdev);
-	if (err)
-		return err;
+	priv->init_card_type = XENON_CARD_TYPE_UNKNOWN;
+	/* Check if mmc-card sub-node exists */
+	if (mmc_of_parse_mmc_card(mmc)) {
+		priv->init_card_type = MMC_TYPE_MMC;
+		/*
+		 * Force to clear BUS_TEST to
+		 * skip bus_test_pre and bus_test_post
+		 */
+		mmc->caps &= ~MMC_CAP_BUS_WIDTH_TEST;
+	}
 
 	priv->sdhc_id = 0x0;
 	if (!of_property_read_u32(np, "marvell,xenon-sdhc-id", &sdhc_id)) {
-		nr_sdhc = sdhci_readl(host, SDHCI_SYS_CFG_INFO);
-		nr_sdhc &= SDHCI_NR_SUPPORTED_SLOT_MASK;
+		nr_sdhc = sdhci_readl(host, XENON_SYS_CFG_INFO);
+		nr_sdhc &= XENON_NR_SUPPORTED_SLOT_MASK;
 		if (unlikely(sdhc_id > nr_sdhc)) {
 			dev_err(mmc_dev(mmc), "SDHC Index %d exceeds Number of SDHCs %d\n",
 				sdhc_id, nr_sdhc);
@@ -473,13 +457,13 @@ static int xenon_probe_dt(struct platform_device *pdev)
 		}
 	}
 
-	tuning_count = SDHCI_DEF_TUNING_COUNT;
+	tuning_count = XENON_DEF_TUNING_COUNT;
 	if (!of_property_read_u32(np, "marvell,xenon-tun-count",
 				  &tuning_count)) {
-		if (unlikely(tuning_count >= SDHCI_TMR_RETUN_NO_PRESENT)) {
+		if (unlikely(tuning_count >= XENON_TMR_RETUN_NO_PRESENT)) {
 			dev_err(mmc_dev(mmc), "Wrong Re-tuning Count. Set default value %d\n",
-				SDHCI_DEF_TUNING_COUNT);
-			tuning_count = SDHCI_DEF_TUNING_COUNT;
+				XENON_DEF_TUNING_COUNT);
+			tuning_count = XENON_DEF_TUNING_COUNT;
 		}
 	}
 	priv->tuning_count = tuning_count;
@@ -502,8 +486,7 @@ static int xenon_sdhc_probe(struct sdhci_host *host)
 	/* Enable Parallel Transfer Mode */
 	xenon_enable_sdhc_parallel_tran(host, sdhc_id);
 
-	/* Set tuning functionality of this SDHC */
-	xenon_sdhc_tuning_setup(host);
+	xenon_mask_cmd_conflict_err(host);
 
 	return 0;
 }
@@ -551,6 +534,13 @@ static int sdhci_xenon_probe(struct platform_device *pdev)
 	if (err)
 		goto free_pltfm;
 
+	err = mmc_of_parse(host->mmc);
+	if (err)
+		goto err_clk;
+
+	sdhci_get_of_property(pdev);
+
+	/* Xenon specific dt parse */
 	err = xenon_probe_dt(pdev);
 	if (err)
 		goto err_clk;
@@ -578,11 +568,10 @@ static int sdhci_xenon_remove(struct platform_device *pdev)
 {
 	struct sdhci_host *host = platform_get_drvdata(pdev);
 	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
-	int dead = (readl(host->ioaddr + SDHCI_INT_STATUS) == 0xFFFFFFFF);
 
 	xenon_sdhc_remove(host);
 
-	sdhci_remove_host(host, dead);
+	sdhci_remove_host(host, 0);
 
 	clk_disable_unprepare(pltfm_host->clk);
 
@@ -634,7 +623,8 @@ static const struct dev_pm_ops sdhci_xenon_pmops = {
 #endif
 
 static const struct of_device_id sdhci_xenon_dt_ids[] = {
-	{ .compatible = "marvell,armada8k-sdhci",},
+	{ .compatible = "marvell,armada-ap806-sdhci",},
+	{ .compatible = "marvell,armada-cp110-sdhci",},
 	{ .compatible = "marvell,armada-3700-sdhci",},
 	{}
 };
diff --git a/drivers/mmc/host/sdhci-xenon.h b/drivers/mmc/host/sdhci-xenon.h
index a8312e3..57e7cb4 100644
--- a/drivers/mmc/host/sdhci-xenon.h
+++ b/drivers/mmc/host/sdhci-xenon.h
@@ -11,57 +11,56 @@
 #ifndef SDHCI_XENON_H_
 #define SDHCI_XENON_H_
 
-
 /* Register Offset of Xenon SDHC self-defined register */
-#define SDHCI_SYS_CFG_INFO			0x0104
-#define SDHCI_SLOT_TYPE_SDIO_SHIFT		24
-#define SDHCI_NR_SUPPORTED_SLOT_MASK		0x7
-
-#define SDHCI_SYS_OP_CTRL			0x0108
-#define SDHCI_AUTO_CLKGATE_DISABLE_MASK		BIT(20)
-#define SDHCI_SDCLK_IDLEOFF_ENABLE_SHIFT	8
-#define SDHCI_SLOT_ENABLE_SHIFT			0
-
-#define SDHCI_SYS_EXT_OP_CTRL			0x010C
-#define SDHCI_MASK_CMD_CONFLICT_ERROR		BIT(8)
-
-#define SDHCI_SLOT_OP_STATUS_CTRL		0x0128
-
-#define SDHCI_TUN_CONSECUTIVE_TIMES_SHIFT	16
-#define SDHCI_TUN_CONSECUTIVE_TIMES_MASK	0x7
-#define SDHCI_TUN_CONSECUTIVE_TIMES		0x4
-#define SDHCI_TUNING_STEP_SHIFT			12
-#define SDHCI_TUNING_STEP_MASK			0xF
-#define SDHCI_TUNING_STEP_DIVIDER		BIT(6)
-
-#define SDHCI_SLOT_EMMC_CTRL			0x0130
-#define SDHCI_ENABLE_DATA_STROBE		BIT(24)
-#define SDHCI_EMMC_VCCQ_MASK			0x3
-#define SDHCI_EMMC_VCCQ_1_8V			0x1
-#define SDHCI_EMMC_VCCQ_3_3V			0x3
-
-#define SDHCI_SLOT_RETUNING_REQ_CTRL		0x0144
+#define XENON_SYS_CFG_INFO			0x0104
+#define XENON_SLOT_TYPE_SDIO_SHIFT		24
+#define XENON_NR_SUPPORTED_SLOT_MASK		0x7
+
+#define XENON_SYS_OP_CTRL			0x0108
+#define XENON_AUTO_CLKGATE_DISABLE_MASK		BIT(20)
+#define XENON_SDCLK_IDLEOFF_ENABLE_SHIFT	8
+#define XENON_SLOT_ENABLE_SHIFT			0
+
+#define XENON_SYS_EXT_OP_CTRL			0x010C
+#define XENON_MASK_CMD_CONFLICT_ERR		BIT(8)
+
+#define XENON_SLOT_OP_STATUS_CTRL		0x0128
+
+#define XENON_TUN_CONSECUTIVE_TIMES_SHIFT	16
+#define XENON_TUN_CONSECUTIVE_TIMES_MASK	0x7
+#define XENON_TUN_CONSECUTIVE_TIMES		0x4
+#define XENON_TUNING_STEP_SHIFT			12
+#define XENON_TUNING_STEP_MASK			0xF
+#define XENON_TUNING_STEP_DIVIDER		BIT(6)
+
+#define XENON_SLOT_EMMC_CTRL			0x0130
+#define XENON_ENABLE_DATA_STROBE		BIT(24)
+#define XENON_EMMC_VCCQ_MASK			0x3
+#define XENON_EMMC_VCCQ_1_8V			0x1
+#define XENON_EMMC_VCCQ_3_3V			0x3
+
+#define XENON_SLOT_RETUNING_REQ_CTRL		0x0144
 /* retuning compatible */
-#define SDHCI_RETUNING_COMPATIBLE		0x1
+#define XENON_RETUNING_COMPATIBLE		0x1
 
-#define SDHCI_SLOT_EXT_PRESENT_STATE		0x014C
-#define SDHCI_DLL_LOCK_STATE			0x1
+#define XENON_SLOT_EXT_PRESENT_STATE		0x014C
+#define XENON_DLL_LOCK_STATE			0x1
 
-#define SDHCI_SLOT_DLL_CUR_DLY_VAL		0x0150
+#define XENON_SLOT_DLL_CUR_DLY_VAL		0x0150
 
 /* Tuning Parameter */
-#define SDHCI_TMR_RETUN_NO_PRESENT		0xF
-#define SDHCI_DEF_TUNING_COUNT			0x9
+#define XENON_TMR_RETUN_NO_PRESENT		0xF
+#define XENON_DEF_TUNING_COUNT			0x9
 
-#define SDHCI_DEFAULT_SDCLK_FREQ		(400000)
-#define SDHCI_LOWEST_SDCLK_FREQ			(100000)
+#define XENON_DEFAULT_SDCLK_FREQ		400000
+#define XENON_LOWEST_SDCLK_FREQ			100000
 
 /* Xenon specific Mode Select value */
-#define SDHCI_XENON_CTRL_HS200			0x5
-#define SDHCI_XENON_CTRL_HS400			0x6
+#define XENON_CTRL_HS200			0x5
+#define XENON_CTRL_HS400			0x6
 
 /* Indicate Card Type is not clear yet */
-#define SDHCI_CARD_TYPE_UNKNOWN			0xF
+#define XENON_CARD_TYPE_UNKNOWN			0xF
 
 struct sdhci_xenon_priv {
 	unsigned char	tuning_count;
@@ -102,7 +101,6 @@ struct sdhci_xenon_priv {
 	struct xenon_emmc_phy_regs *emmc_phy_regs;
 };
 
-
 int xenon_phy_adj(struct sdhci_host *host, struct mmc_ios *ios);
 int xenon_phy_parse_dt(struct device_node *np,
 		       struct sdhci_host *host);
diff --git a/include/linux/mmc/core.h b/include/linux/mmc/core.h
index 37967b6..5266090 100644
--- a/include/linux/mmc/core.h
+++ b/include/linux/mmc/core.h
@@ -211,4 +211,6 @@ struct device_node;
 extern u32 mmc_vddrange_to_ocrmask(int vdd_min, int vdd_max);
 extern int mmc_of_parse_voltage(struct device_node *np, u32 *mask);
 
+extern bool mmc_of_parse_mmc_card(struct mmc_host *host);
+
 #endif /* LINUX_MMC_CORE_H */
-- 
2.7.4

