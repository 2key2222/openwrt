From 5c79d8cea75cb795d06f5fa9f4bb1428359d4220 Mon Sep 17 00:00:00 2001
From: Victor Gu <xigu@marvell.com>
Date: Thu, 25 Aug 2016 00:53:42 +0800
Subject: [PATCH 0875/2241] mmc: sdhci-xenon: add support of tuning times in
 DTS

The number of required consecutive successful sampling points used to
identify a valid sampling window in tuning process.
It might be different between different SoC, and be 0x4 by default if
this property is not set in DTS.

Change-Id: I2b62edbef95f162996c76f185a22ba0d99555fd4
Signed-off-by: Victor Gu <xigu@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/32167
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Wilson Ding <dingwei@marvell.com>
---
 .../devicetree/bindings/mmc/marvell,xenon-sdhci.txt        |  6 ++++++
 drivers/mmc/host/sdhci-xenon-phy.c                         | 14 ++++++++++++--
 drivers/mmc/host/sdhci-xenon.h                             |  2 +-
 3 files changed, 19 insertions(+), 3 deletions(-)

diff --git a/Documentation/devicetree/bindings/mmc/marvell,xenon-sdhci.txt b/Documentation/devicetree/bindings/mmc/marvell,xenon-sdhci.txt
index f980436..8c0d56a 100644
--- a/Documentation/devicetree/bindings/mmc/marvell,xenon-sdhci.txt
+++ b/Documentation/devicetree/bindings/mmc/marvell,xenon-sdhci.txt
@@ -52,6 +52,12 @@ Optional Properties:
   voltage.
   - xenon,fixed-1-8v-pad-ctrl;
 
+  Number of successful tuning times
+  Set the number of required consecutive successful sampling points used to
+  identify a valid sampling window, in tuning process.
+  Valid range = [1:7]. Set as 0x4 by default if this property is not provided.
+  - xenon,phy-nr-tun-times = <nr_times>;
+
 - Re-tuning Counter
   Xenon SDHC SOC usually doesn't provide re-tuning counter in
   Capabilities Register 3 Bit[11:8].
diff --git a/drivers/mmc/host/sdhci-xenon-phy.c b/drivers/mmc/host/sdhci-xenon-phy.c
index 842e815..51dc8bd6 100644
--- a/drivers/mmc/host/sdhci-xenon-phy.c
+++ b/drivers/mmc/host/sdhci-xenon-phy.c
@@ -62,6 +62,9 @@ struct emmc_phy_params {
 
 	/* MMC PAD address */
 	void __iomem *pad_ctrl_addr;
+
+	/* Number of consecutive Sampling Points of a Valid Sampling Window */
+	u8 nr_tun_times;
 };
 
 static void xenon_emmc_phy_strobe_delay_adj(struct sdhci_host *host,
@@ -124,9 +127,13 @@ static int emmc_phy_parse_param_dt(struct device_node *np,
 	if (IS_ERR(params->pad_ctrl_addr))
 		params->pad_ctrl_addr = 0;
 
+	if (!of_property_read_u32(np, "xenon,phy-nr-tun-times", &value))
+		params->nr_tun_times = value & TUN_CONSECUTIVE_TIMES_MASK;
+	else
+		params->nr_tun_times = TUN_CONSECUTIVE_TIMES;
+
 	return 0;
 }
-
 static int xenon_emmc_phy_init(struct sdhci_host *host)
 {
 	u32 reg;
@@ -454,6 +461,9 @@ static int xenon_emmc_phy_enable_dll(struct sdhci_host *host)
 
 static void xenon_emmc_phy_config_tuning(struct sdhci_host *host)
 {
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);
+	struct emmc_phy_params *params = priv->phy_params;
 	u32 reg, tuning_step;
 	int ret;
 	unsigned long flags;
@@ -480,7 +490,7 @@ static void xenon_emmc_phy_config_tuning(struct sdhci_host *host)
 
 	reg = sdhci_readl(host, SDHC_SLOT_OP_STATUS_CTRL);
 	reg &= ~(TUN_CONSECUTIVE_TIMES_MASK << TUN_CONSECUTIVE_TIMES_SHIFT);
-	reg |= (TUN_CONSECUTIVE_TIMES << TUN_CONSECUTIVE_TIMES_SHIFT);
+	reg |= (params->nr_tun_times << TUN_CONSECUTIVE_TIMES_SHIFT);
 	reg &= ~(TUNING_STEP_MASK << TUNING_STEP_SHIFT);
 	reg |= (tuning_step << TUNING_STEP_SHIFT);
 	sdhci_writel(host, reg, SDHC_SLOT_OP_STATUS_CTRL);
diff --git a/drivers/mmc/host/sdhci-xenon.h b/drivers/mmc/host/sdhci-xenon.h
index 2415a00..07fac3a 100644
--- a/drivers/mmc/host/sdhci-xenon.h
+++ b/drivers/mmc/host/sdhci-xenon.h
@@ -43,7 +43,7 @@
 
 #define TUN_CONSECUTIVE_TIMES_SHIFT		16
 #define TUN_CONSECUTIVE_TIMES_MASK		0x7
-#define TUN_CONSECUTIVE_TIMES			0x7
+#define TUN_CONSECUTIVE_TIMES			0x4
 #define TUNING_STEP_SHIFT			12
 #define TUNING_STEP_MASK			0xf
 
-- 
2.7.4

