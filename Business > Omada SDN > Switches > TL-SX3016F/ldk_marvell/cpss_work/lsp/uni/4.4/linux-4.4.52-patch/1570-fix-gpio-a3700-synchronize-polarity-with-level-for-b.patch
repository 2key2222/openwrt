From aa31fb1a05990c0819a9d532b815a19a966e37b5 Mon Sep 17 00:00:00 2001
From: Ken Ma <make@marvell.com>
Date: Wed, 12 Apr 2017 10:22:55 +0800
Subject: [PATCH 1570/2241] fix: gpio: a3700: synchronize polarity with level
 for both-edge irqs in resume

- Currently SD card could not be detected properly if the card is
  plugged out during suspend; the reason is that SD's card detect gpio
  is used as both-edge irq, and in suspend the cd-gpio level changes to
  high when plug-out, but its polarity is not updated accordingly and
  kept as "Detect rising edge" since interrupts are not handled in
  suspend, then when SD card is plugged in after resume, cd-gpio level
  changes to low from high, it does not match the "Detect rising edge"
  polarity, then no interrupt is reported and SD card is not detected;
- This patch synchronizes polarity with level for both-edge irqs in
  resume to fix the issue.

Change-Id: Ie14b7326f213a292a089becf2e6d345d136d27bb
Signed-off-by: Ken Ma <make@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/38655
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Reviewed-by: Victor Gu <xigu@marvell.com>
---
 drivers/gpio/gpio-armada-3700.c | 32 ++++++++++++++++++++++++++++++--
 1 file changed, 30 insertions(+), 2 deletions(-)

diff --git a/drivers/gpio/gpio-armada-3700.c b/drivers/gpio/gpio-armada-3700.c
index b86adb5..71ee28f 100644
--- a/drivers/gpio/gpio-armada-3700.c
+++ b/drivers/gpio/gpio-armada-3700.c
@@ -487,6 +487,9 @@ static int mvebu_gpio_suspend(struct platform_device *pdev, pm_message_t state)
 static int mvebu_gpio_resume(struct platform_device *pdev)
 {
 	struct mvebu_gpio_chip *mvchip = platform_get_drvdata(pdev);
+	u32 i, mask, type, level;
+	u32 *polarity;
+	int irq;
 
 	/*
 	 * There are 36 GPIO pin for A3700, so there are two registers holding
@@ -496,12 +499,37 @@ static int mvebu_gpio_resume(struct platform_device *pdev)
 	writel(mvchip->io_conf_reg, mvebu_gpioreg_io_conf(mvchip, 0));
 	writel(mvchip->out_reg_hi, mvebu_gpioreg_out(mvchip, GPIO_IO_BITWIDTH));
 	writel(mvchip->io_conf_reg_hi, mvebu_gpioreg_io_conf(mvchip, GPIO_IO_BITWIDTH));
-	writel(mvchip->irq_pol_reg, mvebu_gpioreg_int_pol(mvchip, 0));
-	writel(mvchip->irq_pol_reg_hi, mvebu_gpioreg_int_pol(mvchip, GPIO_IO_BITWIDTH));
 	writel(mvchip->edge_mask_regs[0], mvebu_gpioreg_edge_mask(mvchip, 0));
 	if (mvchip->chip.ngpio > GPIO_IO_BITWIDTH)
 		writel(mvchip->edge_mask_regs[1], mvebu_gpioreg_edge_mask(mvchip, GPIO_IO_BITWIDTH));
 
+	/*
+	* For the gpios which are used for both-edge irqs, in system suspend
+	* their input levels may be changed but their polarities are not updated
+	* accordingly since interrupts are not handled in suspend; then in resume
+	* their polarities needs to be synchronized with their levels.
+	*/
+	for (i = 0; i < mvchip->chip.ngpio; i++) {
+		irq = mvchip->irqbase + i;
+		mask = mvchip->edge_mask_regs[i / GPIO_IO_BITWIDTH];
+		type = irq_get_trigger_type(irq);
+
+		if (!(mask & (1 << GPIO_REG_PIN_OFF(i))))
+			continue;
+
+		if ((type & IRQ_TYPE_SENSE_MASK) == IRQ_TYPE_EDGE_BOTH) {
+			level = readl_relaxed(mvebu_gpioreg_data_in(mvchip, i));
+			polarity = &mvchip->irq_pol_reg + i / GPIO_IO_BITWIDTH;
+
+			if ((*polarity ^ level) & (1 << GPIO_REG_PIN_OFF(i))) {
+				/* Synchronize gpio polarity with level for both-edge irqs */
+				*polarity ^= 1 << i;
+			}
+		}
+	}
+	writel(mvchip->irq_pol_reg, mvebu_gpioreg_int_pol(mvchip, 0));
+	writel(mvchip->irq_pol_reg_hi, mvebu_gpioreg_int_pol(mvchip, GPIO_IO_BITWIDTH));
+
 	return 0;
 }
 
-- 
2.7.4

