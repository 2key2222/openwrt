From 52da48fd5240d3cbb418dfbe5a721792950f83f3 Mon Sep 17 00:00:00 2001
From: allen yan <yanwei@marvell.com>
Date: Tue, 7 Mar 2017 21:52:44 +0800
Subject: [PATCH 1414/2241] uart: a3700: save and restore uart registers for
 low power mode

- In the original uart driver, it doesn't save the uart
  registers status before system suspend and it also
  doesn't restore the uart registers status after system
  resume. It may cause the uart ports can't work properly.
  This patch  add the uart registers save and restore
  in suspend and resume function and the uart ports can
  work well.
- This patch add uart_int_type to save the settings of the
  uart's interrupts trigger type and restore it after resume.
- This patch use uart_over_sample to restore the Progammable
  Oversampling Stack register which was setted in U-BOOT. It
  needs to restore because it will be changed after suspend
  and resume, but uart default use 16X scheme. If doesn't
  restore it, the baudrate settings will be affected.

Change-Id: I3c39223eeb4ff550e3c58a476fbec67aee988669
Signed-off-by: allen yan <yanwei@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/37254
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Reviewed-by: Victor Gu <xigu@marvell.com>
---
 drivers/tty/serial/mvebu-uart.c | 55 +++++++++++++++++++++++++++++++++++++++++
 1 file changed, 55 insertions(+)

diff --git a/drivers/tty/serial/mvebu-uart.c b/drivers/tty/serial/mvebu-uart.c
index bd35658..ebac09f 100644
--- a/drivers/tty/serial/mvebu-uart.c
+++ b/drivers/tty/serial/mvebu-uart.c
@@ -48,6 +48,7 @@ struct uart_regs_layout {
 	unsigned int uart_tsh;
 	unsigned int uart_brdv;
 	unsigned int uart_stat;
+	unsigned int uart_over_sample;
 };
 /* Register Map */
 
@@ -103,6 +104,8 @@ struct uart_regs_layout {
 #define  BAUD_MASK		0x000003ff
 #define  BAUD_OFFSET		0
 
+#define UART_OSAMP		0x14
+
 /* REG_UART_A3700_EXT */
 #define UART_EXT_CTRL		0x04
 
@@ -112,6 +115,8 @@ struct uart_regs_layout {
 
 #define UART_EXT_BRDV		0x10
 
+#define UART_EXT_OSAMP		0x14
+
 #define UART_EXT_RBR_1BYTE	0x18
 
 #define UART_EXT_TSH_1BYTE	0x1c
@@ -147,6 +152,7 @@ static struct uart_regs_layout uart_regs_layout[] = {
 		.uart_tsh  = UART_TSH,
 		.uart_brdv = UART_BRDV,
 		.uart_stat = UART_STAT,
+		.uart_over_sample = UART_OSAMP,
 	},
 	[REG_UART_A3700_EXT] = {
 		.uart_ctrl  = UART_EXT_CTRL,
@@ -155,6 +161,7 @@ static struct uart_regs_layout uart_regs_layout[] = {
 		.uart_tsh   = UART_EXT_TSH_1BYTE,
 		.uart_brdv  = UART_EXT_BRDV,
 		.uart_stat  = UART_EXT_STAT,
+		.uart_over_sample = UART_EXT_OSAMP,
 	},
 };
 
@@ -171,6 +178,13 @@ struct mvebu_uart_data {
 	struct uart_regs_layout *regs;
 	enum reg_uart_type       reg_type;
 
+#ifdef CONFIG_PM
+	/* Used to restore the uart registers status*/
+	struct uart_regs_layout pm_reg_value;
+	/* Used to restore the uart interrupt type */
+	unsigned int		uart_ext_int_type;
+#endif
+
 	struct {
 		unsigned int (*ctrl_rx_rdy_int)(struct mvebu_uart_data *data);
 		unsigned int (*ctrl_tx_rdy_int)(struct mvebu_uart_data *data);
@@ -204,6 +218,8 @@ struct mvebu_uart_data {
 #define REG_TSH(uart_data)	((uart_data)->regs->uart_tsh)
 #define REG_BRDV(uart_data)	((uart_data)->regs->uart_brdv)
 #define REG_STAT(uart_data)	((uart_data)->regs->uart_stat)
+#define REG_OSAMP(uart_data)	((uart_data)->regs->uart_over_sample)
+
 
 /* helper functions for 1-byte transfer */
 static inline unsigned int get_ctrl_rx_1byte_rdy_int(struct mvebu_uart_data *data)
@@ -990,10 +1006,47 @@ static int mvebu_uart_remove(struct platform_device *pdev)
 }
 
 #ifdef CONFIG_PM
+
+/* Uart registers status save in suspend process*/
+static int mvebu_uart_reg_save(struct mvebu_uart_data *data)
+{
+	data->pm_reg_value.uart_ctrl = readl(data->port->membase + REG_CTRL(data));
+
+	if (data->reg_type == REG_UART_A3700_EXT)
+		data->pm_reg_value.uart_ctrl2 = readl(data->port->membase + REG_CTRL2(data));
+
+	data->pm_reg_value.uart_tsh = readl(data->port->membase + REG_TSH(data));
+	data->pm_reg_value.uart_brdv = readl(data->port->membase + REG_BRDV(data));
+	data->pm_reg_value.uart_over_sample = readl(data->port->membase + REG_OSAMP(data));
+	if (!IS_ERR_OR_NULL(data->intr.uart_int_base))
+		data->uart_ext_int_type = readl(data->intr.uart_int_base + NORTH_BRIDGE_UART_EXT_INT_SEL);
+
+	return 0;
+}
+
+/* Uart registers status restore in resume process*/
+static int mvebu_uart_reg_restore(struct mvebu_uart_data *data)
+{
+	writel(data->pm_reg_value.uart_ctrl, data->port->membase + REG_CTRL(data));
+
+	if (data->reg_type == REG_UART_A3700_EXT)
+		writel(data->pm_reg_value.uart_ctrl2, data->port->membase + REG_CTRL2(data));
+
+	writel(data->pm_reg_value.uart_tsh, data->port->membase + REG_TSH(data));
+	writel(data->pm_reg_value.uart_brdv, data->port->membase + REG_BRDV(data));
+	writel(data->pm_reg_value.uart_over_sample, data->port->membase + REG_OSAMP(data));
+	if (!IS_ERR_OR_NULL(data->intr.uart_int_base))
+		writel(data->uart_ext_int_type, data->intr.uart_int_base + NORTH_BRIDGE_UART_EXT_INT_SEL);
+
+	return 0;
+}
+
 static int mvebu_uart_suspend(struct device *dev)
 {
 	struct mvebu_uart_data *data = dev_get_drvdata(dev);
 
+	mvebu_uart_reg_save(data);
+
 	if (data->port)
 		uart_suspend_port(&mvebu_uart_driver, data->port);
 
@@ -1006,6 +1059,8 @@ static int mvebu_uart_resume(struct device *dev)
 {
 	struct mvebu_uart_data *data = dev_get_drvdata(dev);
 
+	mvebu_uart_reg_restore(data);
+
 	if (data->port)
 		uart_resume_port(&mvebu_uart_driver, data->port);
 
-- 
2.7.4

