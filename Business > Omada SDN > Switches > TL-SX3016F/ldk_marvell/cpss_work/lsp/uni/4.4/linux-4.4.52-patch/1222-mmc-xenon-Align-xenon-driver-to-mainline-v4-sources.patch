From 2fa1914142a49104bab0dbf8d2cb339f23fe28f9 Mon Sep 17 00:00:00 2001
From: Konstantin Porotchkin <kostap@marvell.com>
Date: Thu, 22 Dec 2016 13:35:52 +0200
Subject: [PATCH 1222/2241] mmc: xenon: Align xenon driver to mainline v4
 sources

Align the Xenon driver with mainline sources v4
The existing driver is based on the mainline sources v1.
The new v4 version is the most updated one and currently
in a final submission state on the kernel mailing list.

Change-Id: I52d33e81104e663c9fdfa4916c3045ed4766e559
Signed-off-by: Konstantin Porotchkin <kostap@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/34941
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Reviewed-by: Hanna Hawa <hannah@marvell.com>
Reviewed-by: Omri Itach <omrii@marvell.com>
---
 .../bindings/mmc/marvell,xenon-sdhci.txt           |  227 +++-
 drivers/mmc/core/sd.c                              |    3 +-
 drivers/mmc/host/Makefile                          |    3 +-
 drivers/mmc/host/sdhci-xenon-phy.c                 | 1350 +++++++++-----------
 drivers/mmc/host/sdhci-xenon-phy.h                 |  132 --
 drivers/mmc/host/sdhci-xenon.c                     |  541 ++++----
 drivers/mmc/host/sdhci-xenon.h                     |  177 +--
 drivers/mmc/host/sdhci.c                           |    7 +-
 drivers/mmc/host/sdhci.h                           |    2 +
 include/linux/mmc/host.h                           |    5 +-
 10 files changed, 1106 insertions(+), 1341 deletions(-)
 delete mode 100644 drivers/mmc/host/sdhci-xenon-phy.h

diff --git a/Documentation/devicetree/bindings/mmc/marvell,xenon-sdhci.txt b/Documentation/devicetree/bindings/mmc/marvell,xenon-sdhci.txt
index bcdc70a..c935a67 100644
--- a/Documentation/devicetree/bindings/mmc/marvell,xenon-sdhci.txt
+++ b/Documentation/devicetree/bindings/mmc/marvell,xenon-sdhci.txt
@@ -1,106 +1,197 @@
-Marvell's Xenon SDHCI Controller device tree bindings
+Marvell Xenon SDHCI Controller device tree bindings
 This file documents differences between the core mmc properties
 described by mmc.txt and the properties used by the Xenon implementation.
 
+Multiple SDHCs might be put into a single Xenon IP, to save size and cost.
+Each SDHC is independent and owns independent resources, such as register sets,
+clock and PHY.
+Each SDHC should have an independent device tree node.
+
 Required Properties:
-- compatible: should be "marvell,xenon-sdhci"
+- compatible: should be one of the following
+  - "marvell,armada-3700-sdhci": For controllers on Armada-3700 SOC.
+  Must provide a second register area and marvell,pad-type.
+  - "marvell,armada8k-sdhci": For controllers on Armada 7K/8K SOC.
+
+- clocks:
+  Array of clocks required for SDHC.
+  Require at least input clock for Xenon IP core.
 
-- Input Clock Name
-  Some SOCs require additional clock for AXI bus.
+- clock-names:
+  Array of names corresponding to clocks property.
   The input clock for Xenon IP core should be named as "core".
-  The optional AXI clock should be named as "axi".
-  - clocks = <&core_clk>, <&axi_clock>;
-  - clock-names = "core", "axi";
 
-- Register Set Size
-  Different Xenon SDHC release has different register set size.
-  The specific size should refer to the SOC implementation.
+- reg:
+  * For "marvell,armada-3700-sdhci", two register areas.
+    The first one for Xenon IP register. The second one for the Armada 3700 SOC
+    PHY PAD Voltage Control register.
+    Please follow the examples with compatible "marvell,armada-3700-sdhci"
+    in below.
+    Please also check property marvell,pad-type in below.
+
+  * For other compatible strings, one register area for Xenon IP.
 
 Optional Properties:
-- Slot Index
-  Xenon can supports multiple slots in a single IP.
-  Each SDHC slot has its own setting bit.
-  The specific slot index in Xenon IP should be provided.
-  - xenon,slotno = <slot_index>;
-  If this property is not provided, slot index will be set as 0 by defalut.
-
-- PHY Type
+- mmc-card:
+  mmc-card child node must be provided when current SDHC is for eMMC.
+  Xenon SDHC often can support both SD and eMMC. This child node indicates that
+  current SDHC is for eMMC card. Thus Xenon eMMC specific configuration and
+  operations can be enabled prior to eMMC init sequence.
+  Please refer to Documentation/devicetree/bindings/mmc/mmc-card.txt.
+  This child node should not be set if current Xenon SDHC is for SD/SDIO.
+
+- bus-width:
+  When 8-bit data bus width is in use for eMMC, this property should be
+  explicitly provided and set as 8.
+  It is optional when data bus width is 4-bit or 1-bit.
+
+- mmc-ddr-1_8v:
+  Select this property when eMMC HS DDR is supported on SDHC side.
+
+- mmc-hs400-1_8v:
+  Select this property when eMMC HS400 is supported on SDHC side.
+
+- no-1-8-v:
+  Select this property when 1.8V signaling voltage supply is unavailable.
+  When this property is enabled, both mmc-ddr-1_8v and mmc-hs400-1_8v should be
+  cleared.
+
+- marvell,xenon-sdhc-id:
+  Indicate the corresponding bit index of current SDHC in
+  SDHC System Operation Control Register Bit[7:0].
+  Set/clear the corresponding bit to enable/disable current SDHC.
+  If Xenon IP contains only one SDHC, this property is optional.
+
+- marvell,xenon-phy-type:
   Xenon support mutilple types of PHYs.
   To select eMMC 5.1 PHY, set:
-  - xenon,phy-type = "emmc 5.1 phy"
+  marvell,xenon-phy-type = "emmc 5.1 phy"
   eMMC 5.1 PHY is the default choice if this property is not provided.
   To select eMMC 5.0 PHY, set:
-  - xenon,phy-type = "emmc 5.0 phy"
-  To select SDH PHY, set:
-  - xenon,phy-type = "sdh phy"
-
-- Customized PHY Parameters
-  Some boards require different values of some specific PHY parameters.
-  These properties enable diverse boards to customize the PHY parameters.
-  The supported eMMC PHY parameters are listed in below:
-  - ZNR
-  xenon,phy-znr = <value>;
-  - ZPR
-  xenon,phy-zpr = <value>;
-  - Disable Hardware DLL tuning
-  xenon,phy-no-dll-tuning;
-
-  SoC specific PHY PAD voltage setting for fixed 1.8V
-  The PHY PAD setting is only available for specific SOC such as Armada 3700.
-  Always set corresponding PHY PAD as 1.8V.
-  It is used for eMMC and some SDIO devices which always work in 1.8v signal
-  voltage.
-  - xenon,fixed-1-8v-pad-ctrl;
-
-  Number of successful tuning times
+  marvell,xenon-phy-type = "emmc 5.0 phy"
+
+  All those types of PHYs can support eMMC, SD and SDIO.
+  Please note that this property only presents the type of PHY.
+  It doesn't stand for the entire SDHC type or property.
+  For example, "emmc 5.1 phy" doesn't mean that this Xenon SDHC only supports
+  eMMC 5.1.
+
+- marvell,xenon-phy-znr:
+  Set PHY ZNR value.
+  Only available for eMMC PHY 5.1 and eMMC PHY 5.0.
+  Valid range = [0:0x1F].
+  ZNR is set as 0xF by default if this property is not provided.
+
+- marvell,xenon-phy-zpr:
+  Set PHY ZPR value.
+  Only available for eMMC PHY 5.1 and eMMC PHY 5.0.
+  Valid range = [0:0x1F].
+  ZPR is set as 0xF by default if this property is not provided.
+
+- marvell,xenon-phy-nr-success-tun:
   Set the number of required consecutive successful sampling points used to
   identify a valid sampling window, in tuning process.
-  Valid range = [1:7]. Set as 0x4 by default if this property is not provided.
-  - xenon,phy-nr-tun-times = <nr_times>;
+  Valid range = [1:7].
+  Set as 0x4 by default if this property is not provided.
 
-  Divider for TUN_STEP
+- marvell,xenon-phy-tun-step-divider:
   Set the divider for calculating TUN_STEP.
   Set as 64 by default if this property is not provided.
-  HW DLL will generate the tuning step value, then the driver applies it to
-  tuning step register after divider. The divider value is based on testing.                                                                                    Now all the SoC using XENON IP work at common divider value 64.
-  However since the timing is also relevant to board, it is better to
-  provide this configuration in DTS for customer to test and find the right
-  divider value if the common divider value 64 does not work on their platform.
-  - xenon,phy-tun-step-divider = <divider>;
-
-  Force PHY into slow mode.
-  Only available when bus frequency is not more than 50MHz in SDR mode.
-  Disabled by default. Enable phy-slow-mode only if normal mode doesn't work.
-  - xenon,phy-slow-mode;
-
-- Re-tuning Counter
+
+- marvell,xenon-phy-slow-mode:
+  If this property is selected, transfers will bypass PHY.
+  Only available when bus frequency lower than 55MHz in SDR mde.
+  Disabled by default. Please only try this property if timing issues always
+  occur with PHY enabled in eMMC HS SDR, SD SDR12, SD SDR25, SD SDR50 mode.
+
+- marvell,xenon-tun-count:
   Xenon SDHC SOC usually doesn't provide re-tuning counter in
   Capabilities Register 3 Bit[11:8].
   This property provides the re-tuning counter.
-  xenon,tuning-count = <count>;
   If this property is not set, default re-tuning counter will
   be set as 0x9 in driver.
 
+- marvell,pad-type:
+  Type of Armada 3700 SOC PHY PAD Voltage Controller register.
+  Only valid when "marvell,armada-3700-sdhci" is selected.
+  Two types: "sd" and "fixed-1-8v".
+  If "sd" is slected, SOC PHY PAD is set as 3.3V at the beginning and is
+  switched to 1.8V when SD in UHS-I.
+  If "fixed-1-8v" is slected, SOC PHY PAD is fixed 1.8V, such as for eMMC.
+  Please follow the examples with compatible "marvell,armada-3700-sdhci"
+  in below.
+
 Example:
-- For eMMC slot:
+- For eMMC:
 
 	sdhci@aa0000 {
-		compatible = "marvell,xenon-sdhci";
+		compatible = "marvell,armada8k-sdhci";
 		reg = <0xaa0000 0x1000>;
 		interrupts = <GIC_SPI 13 IRQ_TYPE_LEVEL_HIGH>
+		clocks = <&emmc_clk>;
+		clock-names = "core";
+		bus-width = <8>;
+		mmc-ddr-1_8v;
+		mmc-hs400-1_8v;
+		marvell,xenon-sdhc-id = <0>;
+		marvell,xenon-phy-type = "emmc 5.1 phy";
+		marvell,xenon-tun-count = <11>;
+
+		#address-cells = <1>;
+		#size-cells = <0>;
+		mmccard: mmccard@0 {
+			compatible = "mmc-card";
+			reg = <0>;
+		};
+	};
+
+- For SD/SDIO:
+
+	sdhci@ab0000 {
+		compatible = "marvell,armada8k-sdhci";
+		reg = <0xab0000 0x1000>;
+		interrupts = <GIC_SPI 55 IRQ_TYPE_LEVEL_HIGH>
+		vqmmc-supply = <&sd_regulator>;
+		clocks = <&sdclk>;
+		clock-names = "core";
+		bus-width = <4>;
+		marvell,xenon-tun-count = <9>;
+	};
+
+- For eMMC with compatible "marvell,armada-3700-sdhci":
+
+	sdhci@aa0000 {
+		compatible = "marvell,armada-3700-sdhci";
+		reg = <0xaa0000 0x1000>,
+		      <phy_addr 0x4>;
+		interrupts = <GIC_SPI 13 IRQ_TYPE_LEVEL_HIGH>
 		clocks = <&emmcclk>;
-		xenon,slotno = <0>;
-		xenon,phy-type = "emmc 5.1 phy";
+		clock-names = "core";
 		bus-width = <8>;
-		tuning-count = <11>;
+		mmc-ddr-1_8v;
+		mmc-hs400-1_8v;
+
+		marvell,pad-type = "fixed-1-8v";
+
+		#address-cells = <1>;
+		#size-cells = <0>;
+		mmccard: mmccard@0 {
+			compatible = "mmc-card";
+			reg = <0>;
+		};
 	};
 
-- For SD/SDIO slot:
+- For SD/SDIO with compatible "marvell,armada-3700-sdhci":
 
 	sdhci@ab0000 {
-		compatible = "marvell,xenon-sdhci";
-		reg = <0xaa0000 0x1000>;
+		compatible = "marvell,armada-3700-sdhci";
+		reg = <0xab0000 0x1000>,
+		      <phy_addr 0x4>;
 		interrupts = <GIC_SPI 55 IRQ_TYPE_LEVEL_HIGH>
+		vqmmc-supply = <&sd_regulator>;
 		clocks = <&sdclk>;
+		clock-names = "core";
 		bus-width = <4>;
-	}
+
+		marvell,pad-type = "sd";
+	};
diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 183f5a7..967535d 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -627,8 +627,7 @@ static int mmc_sd_init_uhs_card(struct mmc_card *card)
 	 */
 	if (!mmc_host_is_spi(card->host) &&
 		(card->host->ios.timing == MMC_TIMING_UHS_SDR50 ||
-		 (!(card->host->caps2 & MMC_CAP2_NO_DDR50_TUNING) &&
-		 (card->host->ios.timing == MMC_TIMING_UHS_DDR50)) ||
+		 card->host->ios.timing == MMC_TIMING_UHS_DDR50 ||
 		 card->host->ios.timing == MMC_TIMING_UHS_SDR104)) {
 		err = mmc_execute_tuning(card);
 
diff --git a/drivers/mmc/host/Makefile b/drivers/mmc/host/Makefile
index 749e925..da23a81 100644
--- a/drivers/mmc/host/Makefile
+++ b/drivers/mmc/host/Makefile
@@ -80,4 +80,5 @@ ifeq ($(CONFIG_CB710_DEBUG),y)
 	CFLAGS-cb710-mmc	+= -DDEBUG
 endif
 
-obj-$(CONFIG_MMC_SDHCI_XENON)		+= sdhci-xenon.o sdhci-xenon-phy.o
+obj-$(CONFIG_MMC_SDHCI_XENON)	+= sdhci-xenon-driver.o
+sdhci-xenon-driver-y		+= sdhci-xenon.o sdhci-xenon-phy.o
diff --git a/drivers/mmc/host/sdhci-xenon-phy.c b/drivers/mmc/host/sdhci-xenon-phy.c
index 80dab4f..8b06bad 100644
--- a/drivers/mmc/host/sdhci-xenon-phy.c
+++ b/drivers/mmc/host/sdhci-xenon-phy.c
@@ -4,480 +4,375 @@
  * Copyright (C) 2016 Marvell, All Rights Reserved.
  *
  * Author:	Hu Ziji <huziji@marvell.com>
- * Date:		2016-7-30
+ * Date:	2016-8-24
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
  * published by the Free Software Foundation version 2.
  */
 
-#include <linux/kernel.h>
-#include <linux/delay.h>
-#include <linux/device.h>
-#include <linux/err.h>
-#include <linux/string.h>
-#include <linux/bitmap.h>
-#include <linux/bitops.h>
 #include <linux/slab.h>
-#include <linux/irq.h>
-#include <linux/mmc/host.h>
-#include <linux/mmc/mmc.h>
-#include <linux/mmc/card.h>
+#include <linux/delay.h>
 #include <linux/of_address.h>
 
-#include "../core/core.h"
-#include "../core/sdio_ops.h"
-#include "../core/mmc_ops.h"
-
-#include "sdhci.h"
 #include "sdhci-pltfm.h"
 #include "sdhci-xenon.h"
 
+/* Register base for eMMC PHY 5.0 Version */
+#define SDHCI_EMMC_5_0_PHY_REG_BASE		0x0160
+/* Register base for eMMC PHY 5.1 Version */
+#define SDHCI_EMMC_PHY_REG_BASE			0x0170
+
+#define SDHCI_EMMC_PHY_TIMING_ADJUST		SDHCI_EMMC_PHY_REG_BASE
+#define SDHCI_EMMC_5_0_PHY_TIMING_ADJUST	SDHCI_EMMC_5_0_PHY_REG_BASE
+#define SDHCI_TIMING_ADJUST_SLOW_MODE		BIT(29)
+#define SDHCI_TIMING_ADJUST_SDIO_MODE		BIT(28)
+#define SDHCI_OUTPUT_QSN_PHASE_SELECT		BIT(17)
+#define SDHCI_SAMPL_INV_QSP_PHASE_SELECT	BIT(18)
+#define SDHCI_SAMPL_INV_QSP_PHASE_SELECT_SHIFT	18
+#define SDHCI_PHY_INITIALIZAION			BIT(31)
+#define SDHCI_WAIT_CYCLE_BEFORE_USING_MASK	0xF
+#define SDHCI_WAIT_CYCLE_BEFORE_USING_SHIFT	12
+#define SDHCI_FC_SYNC_EN_DURATION_MASK		0xF
+#define SDHCI_FC_SYNC_EN_DURATION_SHIFT		8
+#define SDHCI_FC_SYNC_RST_EN_DURATION_MASK	0xF
+#define SDHCI_FC_SYNC_RST_EN_DURATION_SHIFT	4
+#define SDHCI_FC_SYNC_RST_DURATION_MASK		0xF
+#define SDHCI_FC_SYNC_RST_DURATION_SHIFT	0
+
+#define SDHCI_EMMC_PHY_FUNC_CONTROL		(SDHCI_EMMC_PHY_REG_BASE + 0x4)
+#define SDHCI_EMMC_5_0_PHY_FUNC_CONTROL		\
+	(SDHCI_EMMC_5_0_PHY_REG_BASE + 0x4)
+#define SDHCI_ASYNC_DDRMODE_MASK		BIT(23)
+#define SDHCI_ASYNC_DDRMODE_SHIFT		23
+#define SDHCI_CMD_DDR_MODE			BIT(16)
+#define SDHCI_DQ_DDR_MODE_SHIFT			8
+#define SDHCI_DQ_DDR_MODE_MASK			0xFF
+#define SDHCI_DQ_ASYNC_MODE			BIT(4)
+
+#define SDHCI_EMMC_PHY_PAD_CONTROL		(SDHCI_EMMC_PHY_REG_BASE + 0x8)
+#define SDHCI_EMMC_5_0_PHY_PAD_CONTROL		\
+	(SDHCI_EMMC_5_0_PHY_REG_BASE + 0x8)
+#define SDHCI_REC_EN_SHIFT			24
+#define SDHCI_REC_EN_MASK			0xF
+#define SDHCI_FC_DQ_RECEN			BIT(24)
+#define SDHCI_FC_CMD_RECEN			BIT(25)
+#define SDHCI_FC_QSP_RECEN			BIT(26)
+#define SDHCI_FC_QSN_RECEN			BIT(27)
+#define SDHCI_OEN_QSN				BIT(28)
+#define SDHCI_AUTO_RECEN_CTRL			BIT(30)
+#define SDHCI_FC_ALL_CMOS_RECEIVER		0xF000
+
+#define SDHCI_EMMC5_FC_QSP_PD			BIT(18)
+#define SDHCI_EMMC5_FC_QSP_PU			BIT(22)
+#define SDHCI_EMMC5_FC_CMD_PD			BIT(17)
+#define SDHCI_EMMC5_FC_CMD_PU			BIT(21)
+#define SDHCI_EMMC5_FC_DQ_PD			BIT(16)
+#define SDHCI_EMMC5_FC_DQ_PU			BIT(20)
+
+#define SDHCI_EMMC_PHY_PAD_CONTROL1		(SDHCI_EMMC_PHY_REG_BASE + 0xC)
+#define SDHCI_EMMC5_1_FC_QSP_PD			BIT(9)
+#define SDHCI_EMMC5_1_FC_QSP_PU			BIT(25)
+#define SDHCI_EMMC5_1_FC_CMD_PD			BIT(8)
+#define SDHCI_EMMC5_1_FC_CMD_PU			BIT(24)
+#define SDHCI_EMMC5_1_FC_DQ_PD			0xFF
+#define SDHCI_EMMC5_1_FC_DQ_PU			(0xFF << 16)
+
+#define SDHCI_EMMC_PHY_PAD_CONTROL2		(SDHCI_EMMC_PHY_REG_BASE + 0x10)
+#define SDHCI_EMMC_5_0_PHY_PAD_CONTROL2		\
+	(SDHCI_EMMC_5_0_PHY_REG_BASE + 0xC)
+#define SDHCI_ZNR_MASK				0x1F
+#define SDHCI_ZNR_SHIFT				8
+#define SDHCI_ZPR_MASK				0x1F
+/* Perferred ZNR and ZPR value vary between different boards.
+ * The specific ZNR and ZPR value should be defined here
+ * according to board actual timing.
+ */
+#define SDHCI_ZNR_DEF_VALUE			0xF
+#define SDHCI_ZPR_DEF_VALUE			0xF
+
+#define SDHCI_EMMC_PHY_DLL_CONTROL		(SDHCI_EMMC_PHY_REG_BASE + 0x14)
+#define SDHCI_EMMC_5_0_PHY_DLL_CONTROL		\
+	(SDHCI_EMMC_5_0_PHY_REG_BASE + 0x10)
+#define SDHCI_DLL_ENABLE			BIT(31)
+#define SDHCI_DLL_UPDATE_STROBE_5_0		BIT(30)
+#define SDHCI_DLL_REFCLK_SEL			BIT(30)
+#define SDHCI_DLL_UPDATE			BIT(23)
+#define SDHCI_DLL_PHSEL1_SHIFT			24
+#define SDHCI_DLL_PHSEL0_SHIFT			16
+#define SDHCI_DLL_PHASE_MASK			0x3F
+#define SDHCI_DLL_PHASE_90_DEGREE		0x1F
+#define SDHCI_DLL_FAST_LOCK			BIT(5)
+#define SDHCI_DLL_GAIN2X			BIT(3)
+#define SDHCI_DLL_BYPASS_EN			BIT(0)
+
+#define SDHCI_EMMC_5_0_PHY_LOGIC_TIMING_ADJUST	\
+	(SDHCI_EMMC_5_0_PHY_REG_BASE + 0x14)
+#define SDHCI_EMMC_PHY_LOGIC_TIMING_ADJUST	(SDHCI_EMMC_PHY_REG_BASE + 0x18)
+#define SDHCI_LOGIC_TIMING_VALUE		0x00AA8977
+
+enum soc_pad_ctrl_type {
+	SOC_PAD_SD,
+	SOC_PAD_FIXED_1_8V,
+};
+
+/*
+ * List offset of PHY registers and some special register values
+ * in eMMC PHY 5.0 or eMMC PHY 5.1
+ */
+struct xenon_emmc_phy_regs {
+	/* Offset of Timing Adjust register */
+	u16 timing_adj;
+	/* Offset of Func Control register */
+	u16 func_ctrl;
+	/* Offset of Pad Control register */
+	u16 pad_ctrl;
+	/* Offset of Pad Control register 2 */
+	u16 pad_ctrl2;
+	/* Offset of DLL Control register */
+	u16 dll_ctrl;
+	/* Offset of Logic Timing Adjust register */
+	u16 logic_timing_adj;
+	/* DLL Update Enable bit */
+	u32 dll_update;
+};
+
 static const char * const phy_types[] = {
-	"sdh phy",
 	"emmc 5.0 phy",
 	"emmc 5.1 phy"
 };
 
 enum phy_type_enum {
-	SDH_PHY,
 	EMMC_5_0_PHY,
 	EMMC_5_1_PHY,
 	NR_PHY_TYPES
 };
 
-static int xenon_delay_adj_test(struct mmc_card *card);
+struct soc_pad_ctrl_table {
+	const char *soc;
+	void (*set_soc_pad)(struct sdhci_host *host,
+			    unsigned char signal_voltage);
+};
+
+struct soc_pad_ctrl {
+	/* Register address of SOC PHY PAD ctrl */
+	void __iomem	*reg;
+	/* SOC PHY PAD ctrl type */
+	enum soc_pad_ctrl_type pad_type;
+	/* SOC specific operation to set SOC PHY PAD */
+	void (*set_soc_pad)(struct sdhci_host *host,
+			    unsigned char signal_voltage);
+};
+
+static struct xenon_emmc_phy_regs xenon_emmc_5_0_phy_regs = {
+	.timing_adj	= SDHCI_EMMC_5_0_PHY_TIMING_ADJUST,
+	.func_ctrl	= SDHCI_EMMC_5_0_PHY_FUNC_CONTROL,
+	.pad_ctrl	= SDHCI_EMMC_5_0_PHY_PAD_CONTROL,
+	.pad_ctrl2	= SDHCI_EMMC_5_0_PHY_PAD_CONTROL2,
+	.dll_ctrl	= SDHCI_EMMC_5_0_PHY_DLL_CONTROL,
+	.logic_timing_adj = SDHCI_EMMC_5_0_PHY_LOGIC_TIMING_ADJUST,
+	.dll_update	= SDHCI_DLL_UPDATE_STROBE_5_0,
+};
+
+static struct xenon_emmc_phy_regs xenon_emmc_5_1_phy_regs = {
+	.timing_adj	= SDHCI_EMMC_PHY_TIMING_ADJUST,
+	.func_ctrl	= SDHCI_EMMC_PHY_FUNC_CONTROL,
+	.pad_ctrl	= SDHCI_EMMC_PHY_PAD_CONTROL,
+	.pad_ctrl2	= SDHCI_EMMC_PHY_PAD_CONTROL2,
+	.dll_ctrl	= SDHCI_EMMC_PHY_DLL_CONTROL,
+	.logic_timing_adj = SDHCI_EMMC_PHY_LOGIC_TIMING_ADJUST,
+	.dll_update	= SDHCI_DLL_UPDATE,
+};
 
 /*
  * eMMC PHY configuration and operations
  */
-
 struct emmc_phy_params {
 	bool	slow_mode;
 
-	u8 znr;
-	u8 zpr;
-	bool no_dll_tuning;
-
-	/* Set SOC PHY PAD ctrl to fixed 1.8V */
-	bool fixed_1_8v_pad_ctrl;
-
-	/* MMC PAD address */
-	void __iomem *pad_ctrl_addr;
-
-	/* Number of consecutive Sampling Points of a Valid Sampling Window */
-	u8 nr_tun_times;
+	u8	znr;
+	u8	zpr;
 
+	/* Nr of consecutive Sampling Points of a Valid Sampling Window */
+	u8	nr_tun_times;
 	/* Divider for calculating Tuning Step */
-	u8 tun_step_divider;
-};
+	u8	tun_step_divider;
 
-static void xenon_emmc_phy_strobe_delay_adj(struct sdhci_host *host,
-					struct mmc_card *card);
-static int xenon_emmc_phy_fix_sampl_delay_adj(struct sdhci_host *host,
-					struct mmc_card *card);
-static void xenon_emmc_phy_set(struct sdhci_host *host,
-					unsigned char timing);
-static void xenon_emmc_phy_config_tuning(struct sdhci_host *host);
-static void xenon_emmc_soc_pad_ctrl(struct sdhci_host *host,
-					unsigned char signal_voltage);
-
-static const struct xenon_phy_ops emmc_phy_ops = {
-	.strobe_delay_adj = xenon_emmc_phy_strobe_delay_adj,
-	.fix_sampl_delay_adj = xenon_emmc_phy_fix_sampl_delay_adj,
-	.phy_set = xenon_emmc_phy_set,
-	.config_tuning = xenon_emmc_phy_config_tuning,
-	.soc_pad_ctrl = xenon_emmc_soc_pad_ctrl,
+	struct soc_pad_ctrl pad_ctrl;
 };
 
 static int alloc_emmc_phy(struct sdhci_xenon_priv *priv)
 {
 	struct emmc_phy_params *params;
 
-	params = kzalloc(sizeof(struct emmc_phy_params), GFP_KERNEL);
+	params = kzalloc(sizeof(*params), GFP_KERNEL);
 	if (!params)
 		return -ENOMEM;
 
 	priv->phy_params = params;
-	priv->phy_ops = emmc_phy_ops;
-	return 0;
-}
-
-static int emmc_phy_parse_param_dt(struct device_node *np,
-						struct emmc_phy_params *params)
-{
-	u32 value;
-
-	if (of_property_read_bool(np, "xenon,phy-slow-mode"))
-		params->slow_mode = true;
-	else
-		params->slow_mode = false;
-
-	if (of_get_property(np, "xenon,phy-no-dll-tuning", NULL))
-		params->no_dll_tuning = true;
-	else
-		params->no_dll_tuning = false;
-
-	if (!of_property_read_u32(np, "xenon,phy-znr", &value))
-		params->znr = value & ZNR_MASK;
-	else
-		params->znr = ZNR_DEF_VALUE;
-
-	if (!of_property_read_u32(np, "xenon,phy-zpr", &value))
-		params->zpr = value & ZPR_MASK;
-	else
-		params->zpr = ZPR_DEF_VALUE;
-
-	if (of_property_read_bool(np, "xenon,fixed-1-8v-pad-ctrl"))
-		params->fixed_1_8v_pad_ctrl = true;
-	else
-		params->fixed_1_8v_pad_ctrl = false;
-
-	params->pad_ctrl_addr = of_iomap(np, 1);
-	if (IS_ERR(params->pad_ctrl_addr))
-		params->pad_ctrl_addr = 0;
-
-	if (!of_property_read_u32(np, "xenon,phy-nr-tun-times", &value))
-		params->nr_tun_times = value & TUN_CONSECUTIVE_TIMES_MASK;
-	else
-		params->nr_tun_times = TUN_CONSECUTIVE_TIMES;
-
-	if (!of_property_read_u32(np, "xenon,phy-tun-step-divider", &value))
-		params->tun_step_divider = value & 0xFF;
+	if (priv->phy_type == EMMC_5_0_PHY)
+		priv->emmc_phy_regs = &xenon_emmc_5_0_phy_regs;
 	else
-		params->tun_step_divider = TUNING_STEP_DIVIDER;
+		priv->emmc_phy_regs = &xenon_emmc_5_1_phy_regs;
 
 	return 0;
 }
-static int xenon_emmc_phy_init(struct sdhci_host *host)
+
+/*
+ * eMMC 5.0/5.1 PHY init/re-init.
+ * eMMC PHY init should be executed after:
+ * 1. SDCLK frequecny changes.
+ * 2. SDCLK is stopped and re-enabled.
+ * 3. config in emmc_phy_regs->timing_adj and emmc_phy_regs->func_ctrl
+ * are changed
+ */
+static int emmc_phy_init(struct sdhci_host *host)
 {
 	u32 reg;
 	u32 wait, clock;
 	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
 	struct sdhci_xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);
-	struct emmc_phy_params *params = priv->phy_params;
-	int timing_adj_reg;
-
-	if (priv->phy_type == EMMC_5_0_PHY)
-		timing_adj_reg = EMMC_5_0_PHY_TIMING_ADJUST;
-	else
-		timing_adj_reg = EMMC_PHY_TIMING_ADJUST;
+	struct xenon_emmc_phy_regs *phy_regs = priv->emmc_phy_regs;
 
-	reg = sdhci_readl(host, timing_adj_reg);
-	reg |= PHY_INITIALIZAION;
-	if (params->slow_mode)
-		reg |= TIMING_ADJUST_SLOW_MODE | OUTPUT_QSN_PHASE_SELECT;
-	sdhci_writel(host, reg, timing_adj_reg);
+	reg = sdhci_readl(host, phy_regs->timing_adj);
+	reg |= SDHCI_PHY_INITIALIZAION;
+	sdhci_writel(host, reg, phy_regs->timing_adj);
 
 	/* Add duration of FC_SYNC_RST */
-	wait = ((reg >> FC_SYNC_RST_DURATION_SHIFT) &
-			FC_SYNC_RST_DURATION_MASK);
+	wait = ((reg >> SDHCI_FC_SYNC_RST_DURATION_SHIFT) &
+			SDHCI_FC_SYNC_RST_DURATION_MASK);
 	/* Add interval between FC_SYNC_EN and FC_SYNC_RST */
-	wait += ((reg >> FC_SYNC_RST_EN_DURATION_SHIFT) &
-			FC_SYNC_RST_EN_DURATION_MASK);
+	wait += ((reg >> SDHCI_FC_SYNC_RST_EN_DURATION_SHIFT) &
+			SDHCI_FC_SYNC_RST_EN_DURATION_MASK);
 	/* Add duration of asserting FC_SYNC_EN */
-	wait += ((reg >> FC_SYNC_EN_DURATION_SHIFT) &
-			FC_SYNC_EN_DURATION_MASK);
+	wait += ((reg >> SDHCI_FC_SYNC_EN_DURATION_SHIFT) &
+			SDHCI_FC_SYNC_EN_DURATION_MASK);
 	/* Add duration of waiting for PHY */
-	wait += ((reg >> WAIT_CYCLE_BEFORE_USING_SHIFT) &
-			WAIT_CYCLE_BEFORE_USING_MASK);
-	/*
-	 * According to Moyang, 4 addtional bus clock
-	 * and 4 AXI bus clock are required
-	 */
+	wait += ((reg >> SDHCI_WAIT_CYCLE_BEFORE_USING_SHIFT) &
+			SDHCI_WAIT_CYCLE_BEFORE_USING_MASK);
+	/* 4 addtional bus clock and 4 AXI bus clock are required */
 	wait += 8;
-	/* left shift 20 bits */
 	wait <<= 20;
 
 	clock = host->clock;
 	if (!clock)
 		/* Use the possibly slowest bus frequency value */
-		clock = 100000;
+		clock = SDHCI_LOWEST_SDCLK_FREQ;
 	/* get the wait time */
 	wait /= clock;
 	wait++;
 	/* wait for host eMMC PHY init completes */
 	udelay(wait);
 
-	reg = sdhci_readl(host, timing_adj_reg);
-	reg &= PHY_INITIALIZAION;
+	reg = sdhci_readl(host, phy_regs->timing_adj);
+	reg &= SDHCI_PHY_INITIALIZAION;
 	if (reg) {
-		pr_err("%s: eMMC PHY init cannot complete after %d us\n",
-			mmc_hostname(host->mmc), wait);
-		return -EIO;
+		dev_err(mmc_dev(host->mmc), "eMMC PHY init cannot complete after %d us\n",
+			wait);
+		return -ETIMEDOUT;
 	}
 
 	return 0;
 }
 
-static inline void soc_pad_voltage_set(void __iomem *pad_ctrl,
-					unsigned char signal_voltage)
-{
-	if (!pad_ctrl)
-		return;
-
-	if (signal_voltage == MMC_SIGNAL_VOLTAGE_180)
-		writel(SOC_PAD_1_8V, pad_ctrl);
-	else if (signal_voltage == MMC_SIGNAL_VOLTAGE_330)
-		writel(SOC_PAD_3_3V, pad_ctrl);
-}
+#define ARMADA_3700_SOC_PAD_1_8V	0x1
+#define ARMADA_3700_SOC_PAD_3_3V	0x0
 
-static void xenon_emmc_soc_pad_ctrl(struct sdhci_host *host,
-					unsigned char signal_voltage)
+static void armada_3700_soc_pad_voltage_set(struct sdhci_host *host,
+					    unsigned char signal_voltage)
 {
 	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
 	struct sdhci_xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);
 	struct emmc_phy_params *params = priv->phy_params;
 
-	if (params->fixed_1_8v_pad_ctrl)
-		soc_pad_voltage_set(params->pad_ctrl_addr,
-					MMC_SIGNAL_VOLTAGE_180);
-	else
-		soc_pad_voltage_set(params->pad_ctrl_addr,
-					signal_voltage);
-}
-
-static int xenon_emmc_phy_set_fix_sampl_delay(struct sdhci_host *host,
-			unsigned int delay, bool invert, bool delay_90_degree)
-{
-	u32 reg;
-	unsigned long flags;
-	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
-	struct sdhci_xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);
-	int timing_adj_reg;
-	u32 delay_mask;
-	int ret = 0;
-
-	spin_lock_irqsave(&host->lock, flags);
-
-	if (priv->phy_type == EMMC_5_0_PHY) {
-		timing_adj_reg = EMMC_5_0_PHY_TIMING_ADJUST;
-		delay_mask = EMMC_5_0_PHY_FIXED_DELAY_MASK;
-	} else {
-		timing_adj_reg = EMMC_PHY_TIMING_ADJUST;
-		delay_mask = EMMC_PHY_FIXED_DELAY_MASK;
-	}
-
-	/* Setup Sampling fix delay */
-	reg = sdhci_readl(host, SDHC_SLOT_OP_STATUS_CTRL);
-	reg &= ~delay_mask;
-	reg |= delay & delay_mask;
-	sdhci_writel(host, reg, SDHC_SLOT_OP_STATUS_CTRL);
-
-	if (priv->phy_type == EMMC_5_0_PHY) {
-		/* set 90 degree phase if necessary */
-		reg &= ~DELAY_90_DEGREE_MASK_EMMC5;
-		reg |= (delay_90_degree << DELAY_90_DEGREE_SHIFT_EMMC5);
-		sdhci_writel(host, reg, SDHC_SLOT_OP_STATUS_CTRL);
+	if (params->pad_ctrl.pad_type == SOC_PAD_FIXED_1_8V) {
+		writel(ARMADA_3700_SOC_PAD_1_8V, params->pad_ctrl.reg);
+	} else if (params->pad_ctrl.pad_type == SOC_PAD_SD) {
+		if (signal_voltage == MMC_SIGNAL_VOLTAGE_180)
+			writel(ARMADA_3700_SOC_PAD_1_8V, params->pad_ctrl.reg);
+		else if (signal_voltage == MMC_SIGNAL_VOLTAGE_330)
+			writel(ARMADA_3700_SOC_PAD_3_3V, params->pad_ctrl.reg);
 	}
-
-	/* Disable SDCLK */
-	reg = sdhci_readl(host, SDHCI_CLOCK_CONTROL);
-	reg &= ~(SDHCI_CLOCK_CARD_EN | SDHCI_CLOCK_INT_EN);
-	sdhci_writel(host, reg, SDHCI_CLOCK_CONTROL);
-
-	udelay(200);
-
-	if (priv->phy_type == EMMC_5_1_PHY) {
-		/* set 90 degree phase if necessary */
-		reg = sdhci_readl(host, EMMC_PHY_FUNC_CONTROL);
-		reg &= ~ASYNC_DDRMODE_MASK;
-		reg |= (delay_90_degree << ASYNC_DDRMODE_SHIFT);
-		sdhci_writel(host, reg, EMMC_PHY_FUNC_CONTROL);
-	}
-
-	/* Setup Inversion of Sampling edge */
-	reg = sdhci_readl(host, timing_adj_reg);
-	reg &= ~SAMPL_INV_QSP_PHASE_SELECT;
-	reg |= (invert << SAMPL_INV_QSP_PHASE_SELECT_SHIFT);
-	sdhci_writel(host, reg, timing_adj_reg);
-
-	/* Enable SD internal clock */
-	ret = enable_xenon_internal_clk(host);
-	if (ret)
-		goto out;
-
-	/* Enable SDCLK */
-	reg = sdhci_readl(host, SDHCI_CLOCK_CONTROL);
-	reg |= SDHCI_CLOCK_CARD_EN;
-	sdhci_writel(host, reg, SDHCI_CLOCK_CONTROL);
-
-	udelay(200);
-
-	/*
-	 * Has to re-initialize eMMC PHY here to active PHY
-	 * because later get status cmd will be issued.
-	 */
-	ret = xenon_emmc_phy_init(host);
-
-out:
-	spin_unlock_irqrestore(&host->lock, flags);
-	return ret;
-}
-
-static int xenon_emmc_phy_do_fix_sampl_delay(struct sdhci_host *host,
-			struct mmc_card *card, unsigned int delay,
-			bool invert, bool quarter)
-{
-	int ret;
-
-	xenon_emmc_phy_set_fix_sampl_delay(host, delay, invert, quarter);
-
-	ret = xenon_delay_adj_test(card);
-	if (ret) {
-		pr_debug("Xenon fail when sampling fix delay = %d, phase = %d degree\n",
-				delay, invert * 180 + quarter * 90);
-		return -1;
-	}
-	return 0;
 }
 
-static int xenon_emmc_phy_fix_sampl_delay_adj(struct sdhci_host *host,
-					struct mmc_card *card)
+/*
+ * Set SOC PHY voltage PAD control register,
+ * according to the operation voltage on PAD.
+ * The detailed operation depends on SOC implementaion.
+ */
+static void emmc_phy_set_soc_pad(struct sdhci_host *host,
+				 unsigned char signal_voltage)
 {
-	enum sampl_fix_delay_phase phase;
-	int idx, nr_pair;
-	int ret;
-	unsigned int delay;
-	unsigned int min_delay, max_delay;
-	bool invert, quarter;
 	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
 	struct sdhci_xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);
-	u32 delay_mask, coarse_step, fine_step;
-	/*
-	 * Pairs to set the delay edge
-	 * First column is the inversion sequence.
-	 * Second column indicates delay 90 degree or not
-	 */
-	const enum sampl_fix_delay_phase delay_edge[] = {
-		PHASE_0_DEGREE,
-		PHASE_180_DEGREE,
-		PHASE_90_DEGREE,
-		PHASE_270_DEGREE
-	};
-
-	if (priv->phy_type == EMMC_5_0_PHY)
-		delay_mask = EMMC_5_0_PHY_FIXED_DELAY_MASK;
-	else
-		delay_mask = EMMC_PHY_FIXED_DELAY_MASK;
-	coarse_step = delay_mask >> 1;
-	fine_step = coarse_step >> 2;
-
-	nr_pair = ARRAY_SIZE(delay_edge);
-
-	for (idx = 0; idx < nr_pair; idx++) {
-		phase = delay_edge[idx];
-		invert = (phase & 0x2) ? true : false;
-		quarter = (phase & 0x1) ? true : false;
-
-		/* increase dly value to get fix delay */
-		for (min_delay = 0; min_delay <= delay_mask;
-				min_delay += coarse_step) {
-			ret = xenon_emmc_phy_do_fix_sampl_delay(host, card,
-					min_delay, invert, quarter);
-			if (!ret)
-				break;
-		}
-
-		if (ret) {
-			pr_debug("Fail to set Sampling Fixed Delay with phase = %d degree\n",
-					phase * 90);
-			continue;
-		}
-
-		for (max_delay = min_delay + fine_step;
-			max_delay < delay_mask;
-			max_delay += fine_step) {
-			ret = xenon_emmc_phy_do_fix_sampl_delay(host, card,
-					max_delay, invert, quarter);
-			if (ret) {
-				max_delay -= fine_step;
-				break;
-			}
-		}
-
-		if (!ret) {
-			ret = xenon_emmc_phy_do_fix_sampl_delay(host, card,
-					delay_mask, invert, quarter);
-			if (!ret)
-				max_delay = delay_mask;
-		}
-
-		/*
-		 * Sampling Fixed Delay line window shoul be larger enough,
-		 * thus the sampling point (the middle of the window)
-		 * can work when environment varies.
-		 * However, there is no clear conclusoin how large the window
-		 * should be.
-		 */
-		if ((max_delay - min_delay) <=
-				EMMC_PHY_FIXED_DELAY_WINDOW_MIN) {
-			pr_info("The window size %d when phase = %d degree cannot meet timing requiremnt\n",
-				max_delay - min_delay, phase * 90);
-			continue;
-		}
+	struct emmc_phy_params *params = priv->phy_params;
 
-		delay = (min_delay + max_delay) / 2;
-		xenon_emmc_phy_set_fix_sampl_delay(host, delay, invert,
-					quarter);
-		pr_debug("Xenon sampling fix delay = %d with phase = %d degree\n",
-				delay, phase * 90);
-		return 0;
-	}
+	if (!params->pad_ctrl.reg)
+		return;
 
-	return -EIO;
+	if (params->pad_ctrl.set_soc_pad)
+		params->pad_ctrl.set_soc_pad(host, signal_voltage);
 }
 
-static int xenon_emmc_phy_enable_dll(struct sdhci_host *host)
+/*
+ * Enable eMMC PHY HW DLL
+ * DLL should be enabled and stable before HS200/SDR104 tuning,
+ * and before HS400 data strobe setting.
+ */
+static int emmc_phy_enable_dll(struct sdhci_host *host)
 {
 	u32 reg;
 	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
 	struct sdhci_xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);
-	int dll_ctrl;
-	u32 dll_update;
+	struct xenon_emmc_phy_regs *phy_regs = priv->emmc_phy_regs;
+	u8 timeout;
 
-	WARN_ON(host->clock <= MMC_HIGH_52_MAX_DTR);
-	if (host->clock <= MMC_HIGH_52_MAX_DTR)
+	if (WARN_ON(host->clock <= MMC_HIGH_52_MAX_DTR))
 		return -EINVAL;
 
-	if (priv->phy_type == EMMC_5_0_PHY) {
-		dll_ctrl = EMMC_5_0_PHY_DLL_CONTROL;
-		dll_update = DLL_UPDATE_STROBE_5_0;
-	} else {
-		dll_ctrl = EMMC_PHY_DLL_CONTROL;
-		dll_update = DLL_UPDATE;
-	}
-
-	reg = sdhci_readl(host, dll_ctrl);
-	if (reg & DLL_ENABLE)
+	reg = sdhci_readl(host, phy_regs->dll_ctrl);
+	if (reg & SDHCI_DLL_ENABLE)
 		return 0;
 
 	/* Enable DLL */
-	reg = sdhci_readl(host, dll_ctrl);
-	reg |= (DLL_ENABLE | DLL_FAST_LOCK);
+	reg = sdhci_readl(host, phy_regs->dll_ctrl);
+	reg |= (SDHCI_DLL_ENABLE | SDHCI_DLL_FAST_LOCK);
 
 	/*
 	 * Set Phase as 90 degree, which is most common value.
 	 * Might set another value if necessary.
 	 * The granularity is 1 degree.
 	 */
-	reg &= ~((DLL_PHASE_MASK << DLL_PHSEL0_SHIFT) |
-			(DLL_PHASE_MASK << DLL_PHSEL1_SHIFT));
-	reg |= ((DLL_PHASE_90_DEGREE << DLL_PHSEL0_SHIFT) |
-			(DLL_PHASE_90_DEGREE << DLL_PHSEL1_SHIFT));
+	reg &= ~((SDHCI_DLL_PHASE_MASK << SDHCI_DLL_PHSEL0_SHIFT) |
+		 (SDHCI_DLL_PHASE_MASK << SDHCI_DLL_PHSEL1_SHIFT));
+	reg |= ((SDHCI_DLL_PHASE_90_DEGREE << SDHCI_DLL_PHSEL0_SHIFT) |
+		(SDHCI_DLL_PHASE_90_DEGREE << SDHCI_DLL_PHSEL1_SHIFT));
 
-	reg &= ~DLL_BYPASS_EN;
-	reg |= dll_update;
+	reg &= ~SDHCI_DLL_BYPASS_EN;
+	reg |= phy_regs->dll_update;
 	if (priv->phy_type == EMMC_5_1_PHY)
-		reg &= ~DLL_REFCLK_SEL;
-	sdhci_writel(host, reg, dll_ctrl);
-
-	/* Wait max 5 ms */
-	mdelay(5);
+		reg &= ~SDHCI_DLL_REFCLK_SEL;
+	sdhci_writel(host, reg, phy_regs->dll_ctrl);
+
+	/* Wait max 32 ms */
+	timeout = 32;
+	while (!(sdhci_readw(host, SDHCI_SLOT_EXT_PRESENT_STATE) &
+		SDHCI_DLL_LOCK_STATE)) {
+		if (!timeout) {
+			dev_err(mmc_dev(host->mmc), "Wait for DLL Lock time-out\n");
+			return -ETIMEDOUT;
+		}
+		timeout--;
+		mdelay(1);
+	}
 	return 0;
 }
 
-static void xenon_emmc_phy_config_tuning(struct sdhci_host *host)
+/*
+ * Config to eMMC PHY to prepare for tuning.
+ * Enable HW DLL and set the TUNING_STEP
+ */
+static int emmc_phy_config_tuning(struct sdhci_host *host)
 {
 	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
 	struct sdhci_xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);
@@ -486,176 +381,267 @@ static void xenon_emmc_phy_config_tuning(struct sdhci_host *host)
 	int ret;
 	unsigned long flags;
 
-	if (!params->slow_mode)
-		WARN_ON(host->clock <= MMC_HIGH_52_MAX_DTR);
-	if (host->clock <= MMC_HIGH_52_MAX_DTR)
-		return;
+	if (WARN_ON(host->clock <= MMC_HIGH_52_MAX_DTR))
+		return -EINVAL;
 
 	spin_lock_irqsave(&host->lock, flags);
 
-	ret = xenon_emmc_phy_enable_dll(host);
+	ret = emmc_phy_enable_dll(host);
 	if (ret) {
 		spin_unlock_irqrestore(&host->lock, flags);
-		return;
+		return ret;
 	}
 
-	reg = sdhci_readl(host, SDHC_SLOT_DLL_CUR_DLY_VAL);
+	/* Achieve TUNGING_STEP with HW DLL help */
+	reg = sdhci_readl(host, SDHCI_SLOT_DLL_CUR_DLY_VAL);
 	tuning_step = reg / params->tun_step_divider;
-	if (unlikely(tuning_step > TUNING_STEP_MASK)) {
-		WARN("%s: HS200 TUNING_STEP %d is larger than MAX value\n",
-					mmc_hostname(host->mmc), tuning_step);
-		tuning_step = TUNING_STEP_MASK;
+	if (unlikely(tuning_step > SDHCI_TUNING_STEP_MASK)) {
+		dev_warn(mmc_dev(host->mmc),
+			 "HS200 TUNING_STEP %d is larger than MAX value\n",
+			 tuning_step);
+		tuning_step = SDHCI_TUNING_STEP_MASK;
 	}
 
-	reg = sdhci_readl(host, SDHC_SLOT_OP_STATUS_CTRL);
-	reg &= ~(TUN_CONSECUTIVE_TIMES_MASK << TUN_CONSECUTIVE_TIMES_SHIFT);
-	reg |= (params->nr_tun_times << TUN_CONSECUTIVE_TIMES_SHIFT);
-	reg &= ~(TUNING_STEP_MASK << TUNING_STEP_SHIFT);
-	reg |= (tuning_step << TUNING_STEP_SHIFT);
-	sdhci_writel(host, reg, SDHC_SLOT_OP_STATUS_CTRL);
+	/* Set TUNING_STEP for later tuning */
+	reg = sdhci_readl(host, SDHCI_SLOT_OP_STATUS_CTRL);
+	reg &= ~(SDHCI_TUN_CONSECUTIVE_TIMES_MASK <<
+		 SDHCI_TUN_CONSECUTIVE_TIMES_SHIFT);
+	reg |= (params->nr_tun_times << SDHCI_TUN_CONSECUTIVE_TIMES_SHIFT);
+	reg &= ~(SDHCI_TUNING_STEP_MASK << SDHCI_TUNING_STEP_SHIFT);
+	reg |= (tuning_step << SDHCI_TUNING_STEP_SHIFT);
+	sdhci_writel(host, reg, SDHCI_SLOT_OP_STATUS_CTRL);
 
 	spin_unlock_irqrestore(&host->lock, flags);
+	return 0;
 }
 
-static void xenon_emmc_phy_strobe_delay_adj(struct sdhci_host *host,
-					struct mmc_card *card)
+static void __emmc_phy_disable_data_strobe(struct sdhci_host *host)
 {
 	u32 reg;
+
+	/* Disable SDHC Data Strobe */
+	reg = sdhci_readl(host, SDHCI_SLOT_EMMC_CTRL);
+	reg &= ~SDHCI_ENABLE_DATA_STROBE;
+	sdhci_writel(host, reg, SDHCI_SLOT_EMMC_CTRL);
+}
+
+/* Set HS400 Data Strobe */
+static void emmc_phy_strobe_delay_adj(struct sdhci_host *host)
+{
 	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
 	struct sdhci_xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);
 	unsigned long flags;
+	u32 reg;
+
+	if (WARN_ON(host->timing != MMC_TIMING_MMC_HS400))
+		return;
 
 	if (host->clock <= MMC_HIGH_52_MAX_DTR)
 		return;
 
-	pr_debug("%s: starts HS400 strobe delay adjustment\n",
-				mmc_hostname(host->mmc));
+	dev_dbg(mmc_dev(host->mmc), "starts HS400 strobe delay adjustment\n");
 
 	spin_lock_irqsave(&host->lock, flags);
 
-	xenon_emmc_phy_enable_dll(host);
+	emmc_phy_enable_dll(host);
 
 	/* Enable SDHC Data Strobe */
-	reg = sdhci_readl(host, SDHC_SLOT_eMMC_CTRL);
-	reg |= ENABLE_DATA_STROBE;
-	sdhci_writel(host, reg, SDHC_SLOT_eMMC_CTRL);
+	reg = sdhci_readl(host, SDHCI_SLOT_EMMC_CTRL);
+	reg |= SDHCI_ENABLE_DATA_STROBE;
+	sdhci_writel(host, reg, SDHCI_SLOT_EMMC_CTRL);
 
 	/* Set Data Strobe Pull down */
 	if (priv->phy_type == EMMC_5_0_PHY) {
-		reg = sdhci_readl(host, EMMC_5_0_PHY_PAD_CONTROL);
-		reg |= EMMC5_FC_QSP_PD;
-		reg &= ~EMMC5_FC_QSP_PU;
-		sdhci_writel(host, reg, EMMC_5_0_PHY_PAD_CONTROL);
+		reg = sdhci_readl(host, SDHCI_EMMC_5_0_PHY_PAD_CONTROL);
+		reg |= SDHCI_EMMC5_FC_QSP_PD;
+		reg &= ~SDHCI_EMMC5_FC_QSP_PU;
+		sdhci_writel(host, reg, SDHCI_EMMC_5_0_PHY_PAD_CONTROL);
 	} else {
-		reg = sdhci_readl(host, EMMC_PHY_PAD_CONTROL1);
-		reg |= EMMC5_1_FC_QSP_PD;
-		reg &= ~EMMC5_1_FC_QSP_PU;
-		sdhci_writel(host, reg, EMMC_PHY_PAD_CONTROL1);
+		reg = sdhci_readl(host, SDHCI_EMMC_PHY_PAD_CONTROL1);
+		reg |= SDHCI_EMMC5_1_FC_QSP_PD;
+		reg &= ~SDHCI_EMMC5_1_FC_QSP_PU;
+		sdhci_writel(host, reg, SDHCI_EMMC_PHY_PAD_CONTROL1);
 	}
 	spin_unlock_irqrestore(&host->lock, flags);
 }
 
-#define LOGIC_TIMING_VALUE	0x00aa8977
+static inline bool temp_stage_hs200_to_hs400(struct sdhci_host *host,
+					     struct sdhci_xenon_priv *priv)
+{
+	/*
+	 * Tmep stages from HS200 to HS400
+	 * from HS200 to HS in 200MHz
+	 * from 200MHz to 52MHz
+	 */
+	if (((priv->timing == MMC_TIMING_MMC_HS200) &&
+	     (host->timing == MMC_TIMING_MMC_HS)) ||
+	    ((host->timing == MMC_TIMING_MMC_HS) &&
+	     (priv->clock > host->clock)))
+		return true;
+
+	return false;
+}
 
-static void xenon_emmc_phy_set(struct sdhci_host *host,
-					unsigned char timing)
+static inline bool temp_stage_hs400_to_h200(struct sdhci_host *host,
+					    struct sdhci_xenon_priv *priv)
+{
+	/*
+	 * Temp stages from HS400 t0 HS200:
+	 * from 200MHz to 52MHz in HS400
+	 * from HS400 to HS DDR in 52MHz
+	 * from HS DDR to HS in 52MHz
+	 * from HS to HS200 in 52MHz
+	 */
+	if (((priv->timing == MMC_TIMING_MMC_HS400) &&
+	     ((host->clock == MMC_HIGH_52_MAX_DTR) ||
+	      (host->timing == MMC_TIMING_MMC_DDR52))) ||
+	    ((priv->timing == MMC_TIMING_MMC_DDR52) &&
+	     (host->timing == MMC_TIMING_MMC_HS)) ||
+	    ((host->timing == MMC_TIMING_MMC_HS200) &&
+	     (host->clock == MMC_HIGH_52_MAX_DTR)))
+		return true;
+
+	return false;
+}
+
+/*
+ * If eMMC PHY Slow Mode is required in lower speed mode in SDR mode
+ * (SDLCK < 55MHz), enable Slow Mode to bypass eMMC PHY.
+ * SDIO slower SDR mode also requires Slow Mode.
+ *
+ * If Slow Mode is enabled, return true.
+ * Otherwise, return false.
+ */
+static bool emmc_phy_slow_mode(struct sdhci_host *host,
+			       unsigned char timing)
 {
-	u32 reg;
 	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
 	struct sdhci_xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);
 	struct emmc_phy_params *params = priv->phy_params;
-	struct mmc_card *card = priv->card_candidate;
-	int pad_ctrl, timing_adj, pad_ctrl2, func_ctrl, logic_timing_adj;
-	unsigned long flags;
+	struct xenon_emmc_phy_regs *phy_regs = priv->emmc_phy_regs;
+	u32 reg;
 
-	pr_debug("%s: eMMC PHY setting starts\n", mmc_hostname(host->mmc));
+	/* Skip temp stages from HS200 to HS400 */
+	if (temp_stage_hs200_to_hs400(host, priv))
+		return false;
+
+	/* Skip temp stages from HS400 t0 HS200 */
+	if (temp_stage_hs400_to_h200(host, priv))
+		return false;
+
+	reg = sdhci_readl(host, phy_regs->timing_adj);
+	/* Enable Slow Mode for SDIO in slower SDR mode */
+	if ((priv->init_card_type == MMC_TYPE_SDIO) &&
+	    ((timing == MMC_TIMING_UHS_SDR25) ||
+	     (timing == MMC_TIMING_UHS_SDR12) ||
+	     (timing == MMC_TIMING_SD_HS) ||
+	     (timing == MMC_TIMING_LEGACY))) {
+		reg |= SDHCI_TIMING_ADJUST_SLOW_MODE;
+		sdhci_writel(host, reg, phy_regs->timing_adj);
+		return true;
+	}
 
-	if (priv->phy_type == EMMC_5_0_PHY) {
-		pad_ctrl = EMMC_5_0_PHY_PAD_CONTROL;
-		timing_adj = EMMC_5_0_PHY_TIMING_ADJUST;
-		pad_ctrl2 = EMMC_5_0_PHY_PAD_CONTROL2;
-		func_ctrl = EMMC_5_0_PHY_FUNC_CONTRL;
-		logic_timing_adj = EMMC_5_0_PHY_LOGIC_TIMING_ADJUST;
-	} else {
-		pad_ctrl = EMMC_PHY_PAD_CONTROL;
-		timing_adj = EMMC_PHY_TIMING_ADJUST;
-		pad_ctrl2 = EMMC_PHY_PAD_CONTROL2;
-		func_ctrl = EMMC_PHY_FUNC_CONTROL;
-		logic_timing_adj = EMMC_PHY_LOGIC_TIMING_ADJUST;
+	/* Check if Slow Mode is required in lower speed mode in SDR mode */
+	if (((timing == MMC_TIMING_UHS_SDR50) ||
+	     (timing == MMC_TIMING_UHS_SDR25) ||
+	     (timing == MMC_TIMING_UHS_SDR12) ||
+	     (timing == MMC_TIMING_SD_HS) ||
+	     (timing == MMC_TIMING_MMC_HS) ||
+	     (timing == MMC_TIMING_LEGACY)) && params->slow_mode) {
+		reg |= SDHCI_TIMING_ADJUST_SLOW_MODE;
+		sdhci_writel(host, reg, phy_regs->timing_adj);
+		return true;
 	}
 
+	reg &= ~SDHCI_TIMING_ADJUST_SLOW_MODE;
+	sdhci_writel(host, reg, phy_regs->timing_adj);
+	return false;
+}
+
+/*
+ * Set-up eMMC 5.0/5.1 PHY.
+ * Specific onfiguration depends on the current speed mode in use.
+ */
+static void emmc_phy_set(struct sdhci_host *host,
+			 unsigned char timing)
+{
+	u32 reg;
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);
+	struct emmc_phy_params *params = priv->phy_params;
+	struct xenon_emmc_phy_regs *phy_regs = priv->emmc_phy_regs;
+	unsigned long flags;
+
+	dev_dbg(mmc_dev(host->mmc), "eMMC PHY setting starts\n");
+
 	spin_lock_irqsave(&host->lock, flags);
 
+	reg = sdhci_readl(host, SDHCI_SYS_EXT_OP_CTRL);
+	reg |= SDHCI_MASK_CMD_CONFLICT_ERROR;
+	sdhci_writel(host, reg, SDHCI_SYS_EXT_OP_CTRL);
+
 	/* Setup pad, set bit[28] and bits[26:24] */
-	reg = sdhci_readl(host, pad_ctrl);
-	reg |= (FC_DQ_RECEN | FC_CMD_RECEN | FC_QSP_RECEN | OEN_QSN);
-	/*
-	 * All FC_XX_RECEIVCE should be set as CMOS Type
-	 */
-	reg |= FC_ALL_CMOS_RECEIVER;
-	sdhci_writel(host, reg, pad_ctrl);
+	reg = sdhci_readl(host, phy_regs->pad_ctrl);
+	reg |= (SDHCI_FC_DQ_RECEN | SDHCI_FC_CMD_RECEN |
+		SDHCI_FC_QSP_RECEN | SDHCI_OEN_QSN);
+	/* All FC_XX_RECEIVCE should be set as CMOS Type */
+	reg |= SDHCI_FC_ALL_CMOS_RECEIVER;
+	sdhci_writel(host, reg, phy_regs->pad_ctrl);
 
 	/* Set CMD and DQ Pull Up */
 	if (priv->phy_type == EMMC_5_0_PHY) {
-		reg = sdhci_readl(host, EMMC_5_0_PHY_PAD_CONTROL);
-		reg |= (EMMC5_FC_CMD_PU | EMMC5_FC_DQ_PU);
-		reg &= ~(EMMC5_FC_CMD_PD | EMMC5_FC_DQ_PD);
-		sdhci_writel(host, reg, EMMC_5_0_PHY_PAD_CONTROL);
+		reg = sdhci_readl(host, SDHCI_EMMC_5_0_PHY_PAD_CONTROL);
+		reg |= (SDHCI_EMMC5_FC_CMD_PU | SDHCI_EMMC5_FC_DQ_PU);
+		reg &= ~(SDHCI_EMMC5_FC_CMD_PD | SDHCI_EMMC5_FC_DQ_PD);
+		sdhci_writel(host, reg, SDHCI_EMMC_5_0_PHY_PAD_CONTROL);
 	} else {
-		reg = sdhci_readl(host, EMMC_PHY_PAD_CONTROL1);
-		reg |= (EMMC5_1_FC_CMD_PU | EMMC5_1_FC_DQ_PU);
-		reg &= ~(EMMC5_1_FC_CMD_PD | EMMC5_1_FC_DQ_PD);
-		sdhci_writel(host, reg, EMMC_PHY_PAD_CONTROL1);
+		reg = sdhci_readl(host, SDHCI_EMMC_PHY_PAD_CONTROL1);
+		reg |= (SDHCI_EMMC5_1_FC_CMD_PU | SDHCI_EMMC5_1_FC_DQ_PU);
+		reg &= ~(SDHCI_EMMC5_1_FC_CMD_PD | SDHCI_EMMC5_1_FC_DQ_PD);
+		sdhci_writel(host, reg, SDHCI_EMMC_PHY_PAD_CONTROL1);
 	}
 
-	if ((timing == MMC_TIMING_LEGACY) || !card)
+	if (timing == MMC_TIMING_LEGACY)
 		goto phy_init;
 
 	/*
 	 * FIXME: should depends on the specific board timing.
 	 */
 	if ((timing == MMC_TIMING_MMC_HS400) ||
-		(timing == MMC_TIMING_MMC_HS200) ||
-		(timing == MMC_TIMING_UHS_SDR50) ||
-		(timing == MMC_TIMING_UHS_SDR104) ||
-		(timing == MMC_TIMING_UHS_DDR50) ||
-		(timing == MMC_TIMING_UHS_SDR25) ||
-		(timing == MMC_TIMING_MMC_DDR52)) {
-		reg = sdhci_readl(host, timing_adj);
-		reg &= ~OUTPUT_QSN_PHASE_SELECT;
-		sdhci_writel(host, reg, timing_adj);
+	    (timing == MMC_TIMING_MMC_HS200) ||
+	    (timing == MMC_TIMING_UHS_SDR50) ||
+	    (timing == MMC_TIMING_UHS_SDR104) ||
+	    (timing == MMC_TIMING_UHS_DDR50) ||
+	    (timing == MMC_TIMING_UHS_SDR25) ||
+	    (timing == MMC_TIMING_MMC_DDR52)) {
+		reg = sdhci_readl(host, phy_regs->timing_adj);
+		reg &= ~SDHCI_OUTPUT_QSN_PHASE_SELECT;
+		sdhci_writel(host, reg, phy_regs->timing_adj);
 	}
 
 	/*
 	 * If SDIO card, set SDIO Mode
-	 * Otherwise, clear SDIO Mode and Slow Mode
+	 * Otherwise, clear SDIO Mode
 	 */
-	if (mmc_card_sdio(card)) {
-		reg = sdhci_readl(host, timing_adj);
-		reg |= TIMING_ADJUST_SDIO_MODE;
-
-		if ((timing == MMC_TIMING_UHS_SDR25) ||
-			(timing == MMC_TIMING_UHS_SDR12) ||
-			(timing == MMC_TIMING_SD_HS) ||
-			(timing == MMC_TIMING_LEGACY))
-			reg |= TIMING_ADJUST_SLOW_MODE;
+	reg = sdhci_readl(host, phy_regs->timing_adj);
+	if (priv->init_card_type == MMC_TYPE_SDIO)
+		reg |= SDHCI_TIMING_ADJUST_SDIO_MODE;
+	else
+		reg &= ~SDHCI_TIMING_ADJUST_SDIO_MODE;
+	sdhci_writel(host, reg, phy_regs->timing_adj);
 
-		sdhci_writel(host, reg, timing_adj);
-	} else {
-		reg = sdhci_readl(host, timing_adj);
-		reg &= ~(TIMING_ADJUST_SDIO_MODE | TIMING_ADJUST_SLOW_MODE);
-		sdhci_writel(host, reg, timing_adj);
-	}
+	if (emmc_phy_slow_mode(host, timing))
+		goto phy_init;
 
 	/*
 	 * Set preferred ZNR and ZPR value
 	 * The ZNR and ZPR value vary between different boards.
 	 * Define them both in sdhci-xenon-emmc-phy.h.
 	 */
-	reg = sdhci_readl(host, pad_ctrl2);
-	reg &= ~((ZNR_MASK << ZNR_SHIFT) | ZPR_MASK);
-	reg |= ((params->znr << ZNR_SHIFT) | params->zpr);
-	sdhci_writel(host, reg, pad_ctrl2);
+	reg = sdhci_readl(host, phy_regs->pad_ctrl2);
+	reg &= ~((SDHCI_ZNR_MASK << SDHCI_ZNR_SHIFT) | SDHCI_ZPR_MASK);
+	reg |= ((params->znr << SDHCI_ZNR_SHIFT) | params->zpr);
+	sdhci_writel(host, reg, phy_regs->pad_ctrl2);
 
 	/*
 	 * When setting EMMC_PHY_FUNC_CONTROL register,
@@ -665,19 +651,21 @@ static void xenon_emmc_phy_set(struct sdhci_host *host,
 	reg &= ~SDHCI_CLOCK_CARD_EN;
 	sdhci_writew(host, reg, SDHCI_CLOCK_CONTROL);
 
+	reg = sdhci_readl(host, phy_regs->func_ctrl);
 	if ((timing == MMC_TIMING_UHS_DDR50) ||
-		(timing == MMC_TIMING_MMC_HS400) ||
-		(timing == MMC_TIMING_MMC_DDR52)) {
-		reg = sdhci_readl(host, func_ctrl);
-		reg |= (DQ_DDR_MODE_MASK << DQ_DDR_MODE_SHIFT) | CMD_DDR_MODE;
-		sdhci_writel(host, reg, func_ctrl);
-	}
+	    (timing == MMC_TIMING_MMC_HS400) ||
+	    (timing == MMC_TIMING_MMC_DDR52))
+		reg |= (SDHCI_DQ_DDR_MODE_MASK << SDHCI_DQ_DDR_MODE_SHIFT) |
+		       SDHCI_CMD_DDR_MODE;
+	else
+		reg &= ~((SDHCI_DQ_DDR_MODE_MASK << SDHCI_DQ_DDR_MODE_SHIFT) |
+			 SDHCI_CMD_DDR_MODE);
 
-	if (timing == MMC_TIMING_MMC_HS400) {
-		reg = sdhci_readl(host, func_ctrl);
-		reg &= ~DQ_ASYNC_MODE;
-		sdhci_writel(host, reg, func_ctrl);
-	}
+	if (timing == MMC_TIMING_MMC_HS400)
+		reg &= ~SDHCI_DQ_ASYNC_MODE;
+	else
+		reg |= SDHCI_DQ_ASYNC_MODE;
+	sdhci_writel(host, reg, phy_regs->func_ctrl);
 
 	/* Enable bus clock */
 	reg = sdhci_readl(host, SDHCI_CLOCK_CONTROL);
@@ -686,308 +674,163 @@ static void xenon_emmc_phy_set(struct sdhci_host *host,
 
 	if (timing == MMC_TIMING_MMC_HS400)
 		/* Hardware team recommend a value for HS400 */
-		sdhci_writel(host, LOGIC_TIMING_VALUE, logic_timing_adj);
+		sdhci_writel(host, SDHCI_LOGIC_TIMING_VALUE,
+			     phy_regs->logic_timing_adj);
+	else
+		__emmc_phy_disable_data_strobe(host);
 
 phy_init:
-	xenon_emmc_phy_init(host);
+	emmc_phy_init(host);
 
 	spin_unlock_irqrestore(&host->lock, flags);
 
-	pr_debug("%s: eMMC PHY setting completes\n", mmc_hostname(host->mmc));
+	dev_dbg(mmc_dev(host->mmc), "eMMC PHY setting completes\n");
 }
 
-/*
- * SDH PHY configuration and operations
- */
-static int xenon_sdh_phy_set_fix_sampl_delay(struct sdhci_host *host,
-					unsigned int delay, bool invert)
+static int get_dt_pad_ctrl_data(struct sdhci_host *host,
+				struct device_node *np,
+				struct emmc_phy_params *params)
 {
-	u32 reg;
-	unsigned long flags;
-	int ret;
+	int ret = 0;
+	const char *name;
+	struct resource iomem;
 
-	if (invert)
-		invert = 0x1;
+	if (of_device_is_compatible(np, "marvell,armada-3700-sdhci"))
+		params->pad_ctrl.set_soc_pad = armada_3700_soc_pad_voltage_set;
 	else
-		invert = 0x0;
-
-	spin_lock_irqsave(&host->lock, flags);
-
-	/* Disable SDCLK */
-	reg = sdhci_readl(host, SDHCI_CLOCK_CONTROL);
-	reg &= ~(SDHCI_CLOCK_CARD_EN | SDHCI_CLOCK_INT_EN);
-	sdhci_writel(host, reg, SDHCI_CLOCK_CONTROL);
-
-	udelay(200);
-
-	/* Setup Sampling fix delay */
-	reg = sdhci_readl(host, SDHC_SLOT_OP_STATUS_CTRL);
-	reg &= ~(SDH_PHY_FIXED_DELAY_MASK |
-			(0x1 << FORCE_SEL_INVERSE_CLK_SHIFT));
-	reg |= ((delay & SDH_PHY_FIXED_DELAY_MASK) |
-			(invert << FORCE_SEL_INVERSE_CLK_SHIFT));
-	sdhci_writel(host, reg, SDHC_SLOT_OP_STATUS_CTRL);
-
-	/* Enable SD internal clock */
-	ret = enable_xenon_internal_clk(host);
-
-	/* Enable SDCLK */
-	reg = sdhci_readl(host, SDHCI_CLOCK_CONTROL);
-	reg |= SDHCI_CLOCK_CARD_EN;
-	sdhci_writel(host, reg, SDHCI_CLOCK_CONTROL);
-
-	udelay(200);
-
-	spin_unlock_irqrestore(&host->lock, flags);
-	return ret;
-}
-
-static int xenon_sdh_phy_do_fix_sampl_delay(struct sdhci_host *host,
-		struct mmc_card *card, unsigned int delay, bool invert)
-{
-	int ret;
-
-	xenon_sdh_phy_set_fix_sampl_delay(host, delay, invert);
+		return 0;
 
-	ret = xenon_delay_adj_test(card);
-	if (ret) {
-		pr_debug("Xenon fail when sampling fix delay = %d, phase = %d degree\n",
-				delay, invert * 180);
-		return -1;
+	if (of_address_to_resource(np, 1, &iomem)) {
+		dev_err(mmc_dev(host->mmc), "Unable to find SOC PAD ctrl register address for %s\n",
+			np->name);
+		return -EINVAL;
 	}
-	return 0;
-}
-
-#define SDH_PHY_COARSE_FIX_DELAY		(SDH_PHY_FIXED_DELAY_MASK / 2)
-#define SDH_PHY_FINE_FIX_DELAY			(SDH_PHY_COARSE_FIX_DELAY / 4)
 
-static int xenon_sdh_phy_fix_sampl_delay_adj(struct sdhci_host *host,
-					struct mmc_card *card)
-{
-	u32 reg;
-	bool dll_enable = false;
-	unsigned int min_delay, max_delay, delay;
-	const bool sampl_edge[] = {
-		false,
-		true,
-	};
-	int i, nr;
-	int ret;
-
-	if (host->clock > HIGH_SPEED_MAX_DTR) {
-		/* Enable DLL when SDCLK is higher than 50MHz */
-		reg = sdhci_readl(host, SDH_PHY_SLOT_DLL_CTRL);
-		if (!(reg & SDH_PHY_ENABLE_DLL)) {
-			reg |= (SDH_PHY_ENABLE_DLL | SDH_PHY_FAST_LOCK_EN);
-			sdhci_writel(host, reg, SDH_PHY_SLOT_DLL_CTRL);
-			mdelay(1);
-
-			reg = sdhci_readl(host, SDH_PHY_SLOT_DLL_PHASE_SEL);
-			reg |= SDH_PHY_DLL_UPDATE_TUNING;
-			sdhci_writel(host, reg, SDH_PHY_SLOT_DLL_PHASE_SEL);
-		}
-		dll_enable = true;
+	params->pad_ctrl.reg = devm_ioremap_resource(mmc_dev(host->mmc),
+						     &iomem);
+	if (IS_ERR(params->pad_ctrl.reg)) {
+		dev_err(mmc_dev(host->mmc), "Unable to get SOC PHY PAD ctrl regiser for %s\n",
+			np->name);
+		return PTR_ERR(params->pad_ctrl.reg);
 	}
 
-	nr = dll_enable ? ARRAY_SIZE(sampl_edge) : 1;
-	for (i = 0; i < nr; i++) {
-		for (min_delay = 0; min_delay <= SDH_PHY_FIXED_DELAY_MASK;
-				min_delay += SDH_PHY_COARSE_FIX_DELAY) {
-			ret = xenon_sdh_phy_do_fix_sampl_delay(host, card,
-						min_delay, sampl_edge[i]);
-			if (!ret)
-				break;
-		}
-
-		if (ret) {
-			pr_debug("Fail to set Fixed Sampling Delay with %s edge\n",
-				sampl_edge[i] ? "negative" : "positive");
-			continue;
-		}
-
-		for (max_delay = min_delay + SDH_PHY_FINE_FIX_DELAY;
-				max_delay < SDH_PHY_FIXED_DELAY_MASK;
-				max_delay += SDH_PHY_FINE_FIX_DELAY) {
-			ret = xenon_sdh_phy_do_fix_sampl_delay(host, card,
-						max_delay, sampl_edge[i]);
-			if (ret) {
-				max_delay -= SDH_PHY_FINE_FIX_DELAY;
-				break;
-			}
-		}
-
-		if (!ret) {
-			ret = xenon_sdh_phy_do_fix_sampl_delay(host, card,
-				SDH_PHY_FIXED_DELAY_MASK, sampl_edge[i]);
-			if (!ret)
-				max_delay = SDH_PHY_FIXED_DELAY_MASK;
-		}
-
-		if ((max_delay - min_delay) <= SDH_PHY_FIXED_DELAY_WINDOW_MIN) {
-			pr_info("The window size %d when %s edge cannot meet timing requiremnt\n",
-				max_delay - min_delay,
-				sampl_edge[i] ? "negative" : "positive");
-			continue;
-		}
-
-		delay = (min_delay + max_delay) / 2;
-		xenon_sdh_phy_set_fix_sampl_delay(host, delay, sampl_edge[i]);
-		pr_debug("Xenon sampling fix delay = %d with %s edge\n",
-			delay, sampl_edge[i] ? "negative" : "positive");
-		return 0;
+	ret = of_property_read_string(np, "marvell,pad-type", &name);
+	if (ret) {
+		dev_err(mmc_dev(host->mmc), "Unable to determine SOC PHY PAD ctrl type\n");
+		return ret;
+	}
+	if (!strcmp(name, "sd")) {
+		params->pad_ctrl.pad_type = SOC_PAD_SD;
+	} else if (!strcmp(name, "fixed-1-8v")) {
+		params->pad_ctrl.pad_type = SOC_PAD_FIXED_1_8V;
+	} else {
+		dev_err(mmc_dev(host->mmc), "Unsupported SOC PHY PAD ctrl type %s\n",
+			name);
+		return -EINVAL;
 	}
-	return -EIO;
-}
-
-static const struct xenon_phy_ops sdh_phy_ops = {
-	.fix_sampl_delay_adj = xenon_sdh_phy_fix_sampl_delay_adj,
-};
-
-static int alloc_sdh_phy(struct sdhci_xenon_priv *priv)
-{
-	priv->phy_params = NULL;
-	priv->phy_ops = sdh_phy_ops;
-	return 0;
-}
-
-/*
- * Common functions for all PHYs
- */
-void xenon_soc_pad_ctrl(struct sdhci_host *host,
-			unsigned char signal_voltage)
-{
-	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
-	struct sdhci_xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);
-
-	if (priv->phy_ops.soc_pad_ctrl)
-		priv->phy_ops.soc_pad_ctrl(host, signal_voltage);
-}
-
-static int __xenon_emmc_delay_adj_test(struct mmc_card *card)
-{
-	int err;
-	u8 *ext_csd = NULL;
-
-	err = mmc_get_ext_csd(card, &ext_csd);
-	kfree(ext_csd);
-
-	return err;
-}
-
-static int __xenon_sdio_delay_adj_test(struct mmc_card *card)
-{
-	u8 reg;
 
-	return mmc_io_rw_direct(card, 0, 0, 0, 0, &reg);
+	return ret;
 }
 
-static int __xenon_sd_delay_adj_test(struct mmc_card *card)
+static int emmc_phy_parse_param_dt(struct sdhci_host *host,
+				   struct device_node *np,
+				   struct emmc_phy_params *params)
 {
-	return mmc_send_status(card, NULL);
-}
+	u32 value;
 
-static int xenon_delay_adj_test(struct mmc_card *card)
-{
-	if (mmc_card_mmc(card))
-		return __xenon_emmc_delay_adj_test(card);
-	else if (mmc_card_sd(card))
-		return __xenon_sd_delay_adj_test(card);
-	else if (mmc_card_sdio(card))
-		return __xenon_sdio_delay_adj_test(card);
+	if (of_property_read_bool(np, "marvell,xenon-phy-slow-mode"))
+		params->slow_mode = true;
 	else
-		return -EINVAL;
-}
+		params->slow_mode = false;
 
-static void xenon_phy_set(struct sdhci_host *host,
-		struct sdhci_xenon_priv *priv, unsigned char timing)
-{
-	if (priv->phy_ops.phy_set)
-		priv->phy_ops.phy_set(host, timing);
-}
+	if (!of_property_read_u32(np, "marvell,xenon-phy-znr", &value))
+		params->znr = value & SDHCI_ZNR_MASK;
+	else
+		params->znr = SDHCI_ZNR_DEF_VALUE;
 
-static void xenon_hs400_strobe_delay_adj(struct sdhci_host *host,
-					struct mmc_card *card,
-					struct sdhci_xenon_priv *priv)
-{
-	WARN_ON(!mmc_card_hs400(card));
-	if (!mmc_card_hs400(card))
-		return;
+	if (!of_property_read_u32(np, "marvell,xenon-phy-zpr", &value))
+		params->zpr = value & SDHCI_ZPR_MASK;
+	else
+		params->zpr = SDHCI_ZPR_DEF_VALUE;
 
-	/* Enable the DLL to automatically adjust HS400 strobe delay.
-	 */
-	if (priv->phy_ops.strobe_delay_adj)
-		priv->phy_ops.strobe_delay_adj(host, card);
-}
+	if (!of_property_read_u32(np, "marvell,xenon-phy-nr-success-tun",
+				  &value))
+		params->nr_tun_times = value & SDHCI_TUN_CONSECUTIVE_TIMES_MASK;
+	else
+		params->nr_tun_times = SDHCI_TUN_CONSECUTIVE_TIMES;
 
-static int xenon_fix_sampl_delay_adj(struct sdhci_host *host,
-				struct mmc_card *card,
-				struct sdhci_xenon_priv *priv)
-{
-	if (priv->phy_ops.fix_sampl_delay_adj)
-		return priv->phy_ops.fix_sampl_delay_adj(host, card);
+	if (!of_property_read_u32(np, "marvell,xenon-phy-tun-step-divider",
+				  &value))
+		params->tun_step_divider = value & 0xFF;
+	else
+		params->tun_step_divider = SDHCI_TUNING_STEP_DIVIDER;
 
-	return 0;
+	return get_dt_pad_ctrl_data(host, np, params);
 }
 
-static void xenon_phy_config_tuning(struct sdhci_host *host,
-				struct sdhci_xenon_priv *priv)
+/* Set SOC PHY Voltage PAD */
+void xenon_soc_pad_ctrl(struct sdhci_host *host,
+			unsigned char signal_voltage)
 {
-	if (priv->phy_ops.config_tuning)
-		return priv->phy_ops.config_tuning(host);
+	emmc_phy_set_soc_pad(host, signal_voltage);
 }
 
 /*
- * xenon_delay_adj should not be called inside IRQ context,
- * either Hard IRQ or Softirq.
+ * Setting PHY when card is working in High Speed Mode.
+ * HS400 set data strobe line.
+ * HS200/SDR104 set tuning config to prepare for tuning.
  */
-static int xenon_hs_delay_adj(struct mmc_host *mmc, struct mmc_card *card,
-			struct sdhci_xenon_priv *priv)
+static int xenon_hs_delay_adj(struct sdhci_host *host)
 {
 	int ret = 0;
-	struct sdhci_host *host = mmc_priv(mmc);
-	struct emmc_phy_params *params = priv->phy_params;
 
-	WARN_ON(host->clock <= DEFAULT_SDCLK_FREQ);
-	if (host->clock <= DEFAULT_SDCLK_FREQ)
+	if (WARN_ON(host->clock <= SDHCI_DEFAULT_SDCLK_FREQ))
 		return -EINVAL;
 
-	if (mmc_card_hs400(card)) {
-		xenon_hs400_strobe_delay_adj(host, card, priv);
+	if (host->timing == MMC_TIMING_MMC_HS400) {
+		emmc_phy_strobe_delay_adj(host);
 		return 0;
 	}
 
-	if (!params->no_dll_tuning && ((priv->phy_type == EMMC_5_1_PHY) ||
-		(priv->phy_type == EMMC_5_0_PHY)) &&
-		(mmc_card_hs200(card) ||
-		(host->timing == MMC_TIMING_UHS_SDR104))) {
-		xenon_phy_config_tuning(host, priv);
-		return 0;
+	if ((host->timing == MMC_TIMING_MMC_HS200) ||
+	    (host->timing == MMC_TIMING_UHS_SDR104)) {
+		ret = emmc_phy_config_tuning(host);
+		if (!ret)
+			return 0;
 	}
 
-	ret = xenon_fix_sampl_delay_adj(host, card, priv);
-	if (ret)
-		pr_err("%s: fails sampling fixed delay adjustment\n",
-			mmc_hostname(mmc));
+	/*
+	 * DDR Mode requires driver to scan Sampling Fixed Delay Line,
+	 * to find out a perfect operation sampling point.
+	 * It is hard to implement such a scan in host driver since initiating
+	 * commands by host driver is not safe.
+	 * Thus so far just keep PHY Sampling Fixed Delay in default value
+	 * in DDR mode.
+	 *
+	 * If any timing issue occrus in DDR mode on Marvell products,
+	 * please contact maintainer to ask for internal support in Marvell.
+	 */
+	if ((host->timing == MMC_TIMING_MMC_DDR52) ||
+	    (host->timing == MMC_TIMING_UHS_DDR50))
+		dev_warn(mmc_dev(host->mmc), "Timing issue might occur in DDR mode\n");
 	return ret;
 }
 
+/*
+ * Adjust PHY setting.
+ * PHY setting should be adjusted when SDCLK frequency, Bus Width
+ * or Speed Mode is changed.
+ * Addtional config are required when card is working in High Speed mode,
+ * after leaving Legacy Mode.
+ */
 int xenon_phy_adj(struct sdhci_host *host, struct mmc_ios *ios)
 {
-	struct mmc_host *mmc = host->mmc;
-	struct mmc_card *card;
-	int ret = 0;
 	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
 	struct sdhci_xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);
+	int ret = 0;
 
-	if (!host->clock)
-		return 0;
-
-	if ((ios->timing != priv->timing) || (ios->clock != priv->clock))
-		xenon_phy_set(host, priv, ios->timing);
-
-	/* Legacy mode is a special case */
-	if (ios->timing == MMC_TIMING_LEGACY) {
-		priv->timing = ios->timing;
+	if (!host->clock) {
+		priv->clock = 0;
 		return 0;
 	}
 
@@ -997,38 +840,40 @@ int xenon_phy_adj(struct sdhci_host *host, struct mmc_ios *ios)
 	 * and adjust Xenon SDHC delay.
 	 */
 	if ((host->clock == priv->clock) &&
-		(ios->bus_width == priv->bus_width) &&
-		(ios->timing == priv->timing))
+	    (ios->bus_width == priv->bus_width) &&
+	    (ios->timing == priv->timing))
 		return 0;
 
+	emmc_phy_set(host, ios->timing);
+
 	/* Update the record */
 	priv->bus_width = ios->bus_width;
-	/* Temp stage from HS200 to HS400 */
-	if (((priv->timing == MMC_TIMING_MMC_HS200) &&
-		(ios->timing == MMC_TIMING_MMC_HS)) ||
-		((priv->timing == MMC_TIMING_MMC_HS200) &&
-		(priv->clock > host->clock))) {
-		priv->timing = ios->timing;
-		priv->clock = host->clock;
+
+	/* Skip temp stages from HS200 to HS400 */
+	if (temp_stage_hs200_to_hs400(host, priv))
 		return 0;
-	}
+
+	/* Skip temp stages from HS400 t0 HS200 */
+	if (temp_stage_hs400_to_h200(host, priv))
+		return 0;
+
 	priv->timing = ios->timing;
 	priv->clock = host->clock;
 
-	card = priv->card_candidate;
-	if (unlikely(card == NULL)) {
-		WARN("%s: card is not present\n", mmc_hostname(mmc));
-		return -EINVAL;
-	}
+	/* Legacy mode is a special case */
+	if (ios->timing == MMC_TIMING_LEGACY)
+		return 0;
 
-	if (host->clock > DEFAULT_SDCLK_FREQ)
-		ret = xenon_hs_delay_adj(mmc, card, priv);
+	if (host->clock > SDHCI_DEFAULT_SDCLK_FREQ)
+		ret = xenon_hs_delay_adj(host);
 	return ret;
 }
 
-static int add_xenon_phy(struct device_node *np, struct sdhci_xenon_priv *priv,
-			const char *phy_name)
+static int add_xenon_phy(struct device_node *np, struct sdhci_host *host,
+			 const char *phy_name)
 {
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);
 	int i, ret;
 
 	for (i = 0; i < NR_PHY_TYPES; i++) {
@@ -1038,31 +883,26 @@ static int add_xenon_phy(struct device_node *np, struct sdhci_xenon_priv *priv,
 		}
 	}
 	if (i == NR_PHY_TYPES) {
-		pr_err("Unable to determine PHY name %s. Use default eMMC 5.1 PHY\n",
+		dev_err(mmc_dev(host->mmc),
+			"Unable to determine PHY name %s. Use default eMMC 5.1 PHY\n",
 			phy_name);
 		priv->phy_type = EMMC_5_1_PHY;
 	}
 
-	if (priv->phy_type == SDH_PHY)
-		return alloc_sdh_phy(priv);
-	else if ((priv->phy_type == EMMC_5_0_PHY) ||
-			(priv->phy_type == EMMC_5_1_PHY)) {
-		ret = alloc_emmc_phy(priv);
-		if (ret)
-			return ret;
-		return emmc_phy_parse_param_dt(np, priv->phy_params);
-	}
+	ret = alloc_emmc_phy(priv);
+	if (ret)
+		return ret;
 
-	return -EINVAL;
+	return emmc_phy_parse_param_dt(host, np, priv->phy_params);
 }
 
-int xenon_phy_parse_dt(struct device_node *np, struct sdhci_xenon_priv *priv)
+int xenon_phy_parse_dt(struct device_node *np, struct sdhci_host *host)
 {
 	const char *phy_type = NULL;
 
-	if (!of_property_read_string(np, "xenon,phy-type", &phy_type))
-		return add_xenon_phy(np, priv, phy_type);
+	if (!of_property_read_string(np, "marvell,xenon-phy-type", &phy_type))
+		return add_xenon_phy(np, host, phy_type);
 
-	pr_err("Fail to get Xenon PHY type. Use default eMMC 5.1 PHY\n");
-	return add_xenon_phy(np, priv, "emmc 5.1 phy");
+	dev_info(mmc_dev(host->mmc), "Fail to get Xenon PHY type. Use default eMMC 5.1 PHY\n");
+	return add_xenon_phy(np, host, "emmc 5.1 phy");
 }
diff --git a/drivers/mmc/host/sdhci-xenon-phy.h b/drivers/mmc/host/sdhci-xenon-phy.h
deleted file mode 100644
index 0f9009b..0000000
--- a/drivers/mmc/host/sdhci-xenon-phy.h
+++ /dev/null
@@ -1,132 +0,0 @@
-/* linux/drivers/mmc/host/sdhci-xenon-emmc-phy.h
- *
- * Author: Hu Ziji <huziji@marvell.com>
- * Date:		2016-6-31
- *
- *  Copyright (C) 2016 Marvell, All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or (at
- * your option) any later version.
- */
-#ifndef SDHCI_XENON_PHY_H_
-#define SDHCI_XENON_PHY_H_
-
-#include <linux/types.h>
-#include "sdhci.h"
-
-/* Register base for eMMC PHY 5.0 Version */
-#define EMMC_5_0_PHY_REG_BASE			0x160
-/* Register base for eMMC PHY 5.1 Version */
-#define EMMC_PHY_REG_BASE			0x170
-
-#define EMMC_PHY_TIMING_ADJUST			EMMC_PHY_REG_BASE
-#define EMMC_5_0_PHY_TIMING_ADJUST		EMMC_5_0_PHY_REG_BASE
-#define TIMING_ADJUST_SLOW_MODE			(1 << 29)
-#define TIMING_ADJUST_SDIO_MODE			(1 << 28)
-#define OUTPUT_QSN_PHASE_SELECT			(1 << 17)
-#define SAMPL_INV_QSP_PHASE_SELECT		(1 << 18)
-#define SAMPL_INV_QSP_PHASE_SELECT_SHIFT	18
-#define PHY_INITIALIZAION			(1 << 31)
-#define WAIT_CYCLE_BEFORE_USING_MASK		0xf
-#define WAIT_CYCLE_BEFORE_USING_SHIFT		12
-#define FC_SYNC_EN_DURATION_MASK		0xf
-#define FC_SYNC_EN_DURATION_SHIFT		8
-#define FC_SYNC_RST_EN_DURATION_MASK		0xf
-#define FC_SYNC_RST_EN_DURATION_SHIFT		4
-#define FC_SYNC_RST_DURATION_MASK		0xf
-#define FC_SYNC_RST_DURATION_SHIFT		0
-
-#define EMMC_PHY_FUNC_CONTROL			(EMMC_PHY_REG_BASE + 0x4)
-#define EMMC_5_0_PHY_FUNC_CONTRL		(EMMC_5_0_PHY_REG_BASE + 0x4)
-#define ASYNC_DDRMODE_MASK			(1 << 23)
-#define ASYNC_DDRMODE_SHIFT			23
-#define CMD_DDR_MODE				(1 << 16)
-#define DQ_DDR_MODE_SHIFT			8
-#define DQ_DDR_MODE_MASK			0xff
-#define DQ_ASYNC_MODE				(1 << 4)
-
-#define EMMC_PHY_PAD_CONTROL			(EMMC_PHY_REG_BASE + 0x8)
-#define EMMC_5_0_PHY_PAD_CONTROL		(EMMC_5_0_PHY_REG_BASE + 0x8)
-#define REC_EN_SHIFT				24
-#define REC_EN_MASK				0xf
-#define FC_DQ_RECEN				(1 << 24)
-#define FC_CMD_RECEN				(1 << 25)
-#define FC_QSP_RECEN				(1 << 26)
-#define FC_QSN_RECEN				(1 << 27)
-#define OEN_QSN					(1 << 28)
-#define AUTO_RECEN_CTRL				(1 << 30)
-#define FC_ALL_CMOS_RECEIVER			0xf000
-
-#define EMMC5_FC_QSP_PD				(1 << 18)
-#define EMMC5_FC_QSP_PU				(1 << 22)
-#define EMMC5_FC_CMD_PD				(1 << 17)
-#define EMMC5_FC_CMD_PU				(1 << 21)
-#define EMMC5_FC_DQ_PD				(1 << 16)
-#define EMMC5_FC_DQ_PU				(1 << 20)
-
-#define EMMC_PHY_PAD_CONTROL1			(EMMC_PHY_REG_BASE + 0xc)
-#define EMMC5_1_FC_QSP_PD			(1 << 9)
-#define EMMC5_1_FC_QSP_PU			(1 << 25)
-#define EMMC5_1_FC_CMD_PD			(1 << 8)
-#define EMMC5_1_FC_CMD_PU			(1 << 24)
-#define EMMC5_1_FC_DQ_PD			0xff
-#define EMMC5_1_FC_DQ_PU			(0xff << 16)
-
-#define EMMC_PHY_PAD_CONTROL2			(EMMC_PHY_REG_BASE + 0x10)
-#define EMMC_5_0_PHY_PAD_CONTROL2		(EMMC_5_0_PHY_REG_BASE + 0xc)
-#define ZNR_MASK				0x1f
-#define ZNR_SHIFT				8
-#define ZPR_MASK				0x1f
-/* Perferred ZNR and ZPR value vary between different boards.
- * The specific ZNR and ZPR value should be defined here
- * according to board actual timing.
- */
-#define ZNR_DEF_VALUE				0xf
-#define ZPR_DEF_VALUE				0xf
-
-#define EMMC_PHY_DLL_CONTROL			(EMMC_PHY_REG_BASE + 0x14)
-#define EMMC_5_0_PHY_DLL_CONTROL		(EMMC_5_0_PHY_REG_BASE + 0x10)
-#define DLL_ENABLE				(1 << 31)
-#define DLL_UPDATE_STROBE_5_0			(1 << 30)
-#define DLL_REFCLK_SEL				(1 << 30)
-#define DLL_UPDATE				(1 << 23)
-#define DLL_PHSEL1_SHIFT			24
-#define DLL_PHSEL0_SHIFT			16
-#define DLL_PHASE_MASK				0x3f
-#define DLL_PHASE_90_DEGREE			0x1f
-#define DLL_FAST_LOCK				(1 << 5)
-#define DLL_GAIN2X				(1 << 3)
-#define DLL_BYPASS_EN				(1 << 0)
-
-#define EMMC_5_0_PHY_LOGIC_TIMING_ADJUST	(EMMC_5_0_PHY_REG_BASE + 0x14)
-#define EMMC_PHY_LOGIC_TIMING_ADJUST		(EMMC_PHY_REG_BASE + 0x18)
-
-#define SOC_PAD_1_8V				0x1
-#define SOC_PAD_3_3V				0x0
-
-enum sampl_fix_delay_phase {
-	PHASE_0_DEGREE = 0x0,
-	PHASE_90_DEGREE = 0x1,
-	PHASE_180_DEGREE = 0x2,
-	PHASE_270_DEGREE = 0x3,
-};
-
-#define SDH_PHY_SLOT_DLL_CTRL			(0x138)
-#define SDH_PHY_ENABLE_DLL			(1 << 1)
-#define SDH_PHY_FAST_LOCK_EN			(1 << 5)
-
-#define SDH_PHY_SLOT_DLL_PHASE_SEL		(0x13C)
-#define SDH_PHY_DLL_UPDATE_TUNING		(1 << 15)
-
-struct xenon_phy_ops {
-	void (*strobe_delay_adj)(struct sdhci_host *host,
-				struct mmc_card *card);
-	int (*fix_sampl_delay_adj)(struct sdhci_host *host,
-				struct mmc_card *card);
-	void (*phy_set)(struct sdhci_host *host, unsigned char timing);
-	void (*config_tuning)(struct sdhci_host *host);
-	void (*soc_pad_ctrl)(struct sdhci_host *host, unsigned char signal_voltage);
-};
-#endif
diff --git a/drivers/mmc/host/sdhci-xenon.c b/drivers/mmc/host/sdhci-xenon.c
index 45697d8..0b693fa 100644
--- a/drivers/mmc/host/sdhci-xenon.c
+++ b/drivers/mmc/host/sdhci-xenon.c
@@ -1,10 +1,10 @@
 /*
- * Driver for Marvell SOCP Xenon SDHC as a platform device
+ * Driver for Marvell Xenon SDHC as a platform device
  *
  * Copyright (C) 2016 Marvell, All Rights Reserved.
  *
  * Author:	Hu Ziji <huziji@marvell.com>
- * Date:	2016-7-30
+ * Date:	2016-8-24
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -15,56 +15,52 @@
  */
 
 #include <linux/delay.h>
-#include <linux/err.h>
-#include <linux/io.h>
-#include <linux/mmc/host.h>
-#include <linux/mmc/mmc.h>
-#include <linux/mmc/sdio.h>
-#include <linux/mmc/card.h>
-#include <linux/mmc/host.h>
 #include <linux/module.h>
 #include <linux/of.h>
 
 #include "sdhci-pltfm.h"
-#include "sdhci.h"
 #include "sdhci-xenon.h"
 
-/*
- * Xenon Specific Initialization Operations
- */
-static inline void xenon_set_tuning_count(struct sdhci_host *host,
-				unsigned int count)
+static int enable_xenon_internal_clk(struct sdhci_host *host)
 {
-	/* A valid count value */
-	host->tuning_count = 1 << (count - 1);
-}
+	u32 reg;
+	u8 timeout;
+
+	reg = sdhci_readl(host, SDHCI_CLOCK_CONTROL);
+	reg |= SDHCI_CLOCK_INT_EN;
+	sdhci_writel(host, reg, SDHCI_CLOCK_CONTROL);
+	/* Wait max 20 ms */
+	timeout = 20;
+	while (!((reg = sdhci_readw(host, SDHCI_CLOCK_CONTROL))
+			& SDHCI_CLOCK_INT_STABLE)) {
+		if (timeout == 0) {
+			pr_err("%s: Internal clock never stabilised.\n",
+			       mmc_hostname(host->mmc));
+			return -ETIMEDOUT;
+		}
+		timeout--;
+		mdelay(1);
+	}
 
-/*
- * Current driver can only support Tuning Mode 1.
- * Tuning timer is only setup only tuning_mode == Tuning Mode 1.
- * Thus host->tuning_mode has to be forced as Tuning Mode 1.
- */
-static inline void xenon_set_tuning_mode(struct sdhci_host *host)
-{
-	host->tuning_mode = SDHCI_TUNING_MODE_1;
+	return 0;
 }
 
 /* Set SDCLK-off-while-idle */
 static void xenon_set_sdclk_off_idle(struct sdhci_host *host,
-			unsigned char slot_idx, bool enable)
+				     unsigned char sdhc_id, bool enable)
 {
 	u32 reg;
 	u32 mask;
 
-	reg = sdhci_readl(host, SDHC_SYS_OP_CTRL);
-	/* Get the bit shift basing on the slot index */
-	mask = (0x1 << (SDCLK_IDLEOFF_ENABLE_SHIFT + slot_idx));
+	reg = sdhci_readl(host, SDHCI_SYS_OP_CTRL);
+	/* Get the bit shift basing on the SDHC index */
+	mask = (0x1 << (SDHCI_SDCLK_IDLEOFF_ENABLE_SHIFT + sdhc_id));
 	if (enable)
 		reg |= mask;
 	else
 		reg &= ~mask;
 
-	sdhci_writel(host, reg, SDHC_SYS_OP_CTRL);
+	sdhci_writel(host, reg, SDHCI_SYS_OP_CTRL);
 }
 
 /* Enable/Disable the Auto Clock Gating function */
@@ -72,71 +68,73 @@ static void xenon_set_acg(struct sdhci_host *host, bool enable)
 {
 	u32 reg;
 
-	reg = sdhci_readl(host, SDHC_SYS_OP_CTRL);
+	reg = sdhci_readl(host, SDHCI_SYS_OP_CTRL);
 	if (enable)
-		reg &= ~AUTO_CLKGATE_DISABLE_MASK;
+		reg &= ~SDHCI_AUTO_CLKGATE_DISABLE_MASK;
 	else
-		reg |= AUTO_CLKGATE_DISABLE_MASK;
-	sdhci_writel(host, reg, SDHC_SYS_OP_CTRL);
+		reg |= SDHCI_AUTO_CLKGATE_DISABLE_MASK;
+	sdhci_writel(host, reg, SDHCI_SYS_OP_CTRL);
 }
 
-/* Enable this slot */
-static void xenon_enable_slot(struct sdhci_host *host,
-			unsigned char slot_idx)
+/* Enable this SDHC */
+static void xenon_enable_sdhc(struct sdhci_host *host,
+			      unsigned char sdhc_id)
 {
 	u32 reg;
 
-	reg = sdhci_readl(host, SDHC_SYS_OP_CTRL);
-	reg |= ((0x1 << slot_idx) << SLOT_ENABLE_SHIFT);
-	sdhci_writel(host, reg, SDHC_SYS_OP_CTRL);
+	reg = sdhci_readl(host, SDHCI_SYS_OP_CTRL);
+	reg |= (BIT(sdhc_id) << SDHCI_SLOT_ENABLE_SHIFT);
+	sdhci_writel(host, reg, SDHCI_SYS_OP_CTRL);
 
 	/*
-	 * Manually set the flag which all the slots require,
+	 * Manually set the flag which all the card types require,
 	 * including SD, eMMC, SDIO
 	 */
 	host->mmc->caps |= MMC_CAP_WAIT_WHILE_BUSY;
 }
 
-/* Disable this slot */
-static void xenon_disable_slot(struct sdhci_host *host,
-			unsigned char slot_idx)
+/* Disable this SDHC */
+static void xenon_disable_sdhc(struct sdhci_host *host,
+			       unsigned char sdhc_id)
 {
 	u32 reg;
 
-	reg = sdhci_readl(host, SDHC_SYS_OP_CTRL);
-	reg &= ~((0x1 << slot_idx) << SLOT_ENABLE_SHIFT);
-	sdhci_writel(host, reg, SDHC_SYS_OP_CTRL);
+	reg = sdhci_readl(host, SDHCI_SYS_OP_CTRL);
+	reg &= ~(BIT(sdhc_id) << SDHCI_SLOT_ENABLE_SHIFT);
+	sdhci_writel(host, reg, SDHCI_SYS_OP_CTRL);
 }
 
 /* Enable Parallel Transfer Mode */
-static void xenon_enable_slot_parallel_tran(struct sdhci_host *host,
-			unsigned char slot_idx)
+static void xenon_enable_sdhc_parallel_tran(struct sdhci_host *host,
+					    unsigned char sdhc_id)
 {
 	u32 reg;
 
-	reg = sdhci_readl(host, SDHC_SYS_EXT_OP_CTRL);
-	reg |= (0x1 << slot_idx);
-	sdhci_writel(host, reg, SDHC_SYS_EXT_OP_CTRL);
+	reg = sdhci_readl(host, SDHCI_SYS_EXT_OP_CTRL);
+	reg |= BIT(sdhc_id);
+	sdhci_writel(host, reg, SDHCI_SYS_EXT_OP_CTRL);
 }
 
-static void xenon_slot_tuning_setup(struct sdhci_host *host)
+static void xenon_sdhc_tuning_setup(struct sdhci_host *host)
 {
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);
 	u32 reg;
 
 	/* Disable the Re-Tuning Request functionality */
-	reg = sdhci_readl(host, SDHC_SLOT_RETUNING_REQ_CTRL);
-	reg &= ~RETUNING_COMPATIBLE;
-	sdhci_writel(host, reg, SDHC_SLOT_RETUNING_REQ_CTRL);
+	reg = sdhci_readl(host, SDHCI_SLOT_RETUNING_REQ_CTRL);
+	reg &= ~SDHCI_RETUNING_COMPATIBLE;
+	sdhci_writel(host, reg, SDHCI_SLOT_RETUNING_REQ_CTRL);
 
-	/* Disbale the Re-tuning Event Signal Enable */
+	/* Disable the Re-tuning Event Signal Enable */
 	reg = sdhci_readl(host, SDHCI_SIGNAL_ENABLE);
 	reg &= ~SDHCI_INT_RETUNE;
 	sdhci_writel(host, reg, SDHCI_SIGNAL_ENABLE);
 
-	/* Disable Auto-retuning */
-	reg = sdhci_readl(host, SDHC_SLOT_AUTO_RETUNING_CTRL);
-	reg &= ~ENABLE_AUTO_RETUNING;
-	sdhci_writel(host, reg, SDHC_SLOT_AUTO_RETUNING_CTRL);
+	/* Force to use Tuning Mode 1 */
+	host->tuning_mode = SDHCI_TUNING_MODE_1;
+	/* Set re-tuning period */
+	host->tuning_count = 1 << (priv->tuning_count - 1);
 }
 
 /*
@@ -144,18 +142,18 @@ static void xenon_slot_tuning_setup(struct sdhci_host *host)
  */
 /* Recover the Register Setting cleared during SOFTWARE_RESET_ALL */
 static void sdhci_xenon_reset_exit(struct sdhci_host *host,
-					unsigned char slot_idx, u8 mask)
+				   unsigned char sdhc_id, u8 mask)
 {
 	/* Only SOFTWARE RESET ALL will clear the register setting */
 	if (!(mask & SDHCI_RESET_ALL))
 		return;
 
-	/* Disable tuning request and auto-retuing again */
-	xenon_slot_tuning_setup(host);
+	/* Disable tuning request and auto-retuning again */
+	xenon_sdhc_tuning_setup(host);
 
 	xenon_set_acg(host, true);
 
-	xenon_set_sdclk_off_idle(host, slot_idx, false);
+	xenon_set_sdclk_off_idle(host, sdhc_id, false);
 }
 
 static void sdhci_xenon_reset(struct sdhci_host *host, u8 mask)
@@ -164,20 +162,15 @@ static void sdhci_xenon_reset(struct sdhci_host *host, u8 mask)
 	struct sdhci_xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);
 
 	sdhci_reset(host, mask);
-	sdhci_xenon_reset_exit(host, priv->slot_idx, mask);
-}
-
-static void xenon_platform_init(struct sdhci_host *host)
-{
-	xenon_set_acg(host, false);
+	sdhci_xenon_reset_exit(host, priv->sdhc_id, mask);
 }
 
 /*
- * Xenon defines different values for HS200 and SDR104
+ * Xenon defines different values for HS200 and HS400
  * in Host_Control_2
  */
 static void xenon_set_uhs_signaling(struct sdhci_host *host,
-				unsigned int timing)
+				    unsigned int timing)
 {
 	u16 ctrl_2;
 
@@ -185,7 +178,7 @@ static void xenon_set_uhs_signaling(struct sdhci_host *host,
 	/* Select Bus Speed Mode for host */
 	ctrl_2 &= ~SDHCI_CTRL_UHS_MASK;
 	if (timing == MMC_TIMING_MMC_HS200)
-		ctrl_2 |= XENON_SDHCI_CTRL_HS200;
+		ctrl_2 |= SDHCI_XENON_CTRL_HS200;
 	else if (timing == MMC_TIMING_UHS_SDR104)
 		ctrl_2 |= SDHCI_CTRL_UHS_SDR104;
 	else if (timing == MMC_TIMING_UHS_SDR12)
@@ -198,7 +191,7 @@ static void xenon_set_uhs_signaling(struct sdhci_host *host,
 		 (timing == MMC_TIMING_MMC_DDR52))
 		ctrl_2 |= SDHCI_CTRL_UHS_DDR50;
 	else if (timing == MMC_TIMING_MMC_HS400)
-		ctrl_2 |= XENON_SDHCI_CTRL_HS400;
+		ctrl_2 |= SDHCI_XENON_CTRL_HS400;
 	sdhci_writew(host, ctrl_2, SDHCI_HOST_CONTROL2);
 }
 
@@ -207,20 +200,14 @@ static const struct sdhci_ops sdhci_xenon_ops = {
 	.set_bus_width		= sdhci_set_bus_width,
 	.reset			= sdhci_xenon_reset,
 	.set_uhs_signaling	= xenon_set_uhs_signaling,
-	.platform_init		= xenon_platform_init,
 	.get_max_clock		= sdhci_pltfm_clk_get_max_clock,
 };
 
 static const struct sdhci_pltfm_data sdhci_xenon_pdata = {
 	.ops = &sdhci_xenon_ops,
 	.quirks = SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC |
-			SDHCI_QUIRK_MULTIBLOCK_READ_ACMD12 |
-			SDHCI_QUIRK_NO_SIMULT_VDD_AND_POWER |
-			SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN,
-	/*
-	 * Add SOC specific quirks in the above .quirks, .quirks2
-	 * fields.
-	 */
+		  SDHCI_QUIRK_NO_SIMULT_VDD_AND_POWER |
+		  SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN,
 };
 
 /*
@@ -232,6 +219,7 @@ static void xenon_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
 	struct sdhci_xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);
 	unsigned long flags;
+	u32 reg;
 
 	/*
 	 * HS400/HS200/eMMC HS doesn't have Preset Value register.
@@ -242,77 +230,76 @@ static void xenon_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 	 */
 	spin_lock_irqsave(&host->lock, flags);
 	if ((ios->timing == MMC_TIMING_MMC_HS400) ||
-		(ios->timing == MMC_TIMING_MMC_HS200) ||
-		(ios->timing == MMC_TIMING_MMC_HS)) {
+	    (ios->timing == MMC_TIMING_MMC_HS200) ||
+	    (ios->timing == MMC_TIMING_MMC_HS)) {
 		host->preset_enabled = false;
 		host->quirks2 |= SDHCI_QUIRK2_PRESET_VALUE_BROKEN;
-	} else
+
+		reg = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+		reg &= ~SDHCI_CTRL_PRESET_VAL_ENABLE;
+		sdhci_writew(host, reg, SDHCI_HOST_CONTROL2);
+	} else {
 		host->quirks2 &= ~SDHCI_QUIRK2_PRESET_VALUE_BROKEN;
+	}
 	spin_unlock_irqrestore(&host->lock, flags);
 
 	sdhci_set_ios(mmc, ios);
 	xenon_phy_adj(host, ios);
 
-	if (host->clock > DEFAULT_SDCLK_FREQ)
-		xenon_set_sdclk_off_idle(host, priv->slot_idx, true);
+	if (host->clock > SDHCI_DEFAULT_SDCLK_FREQ) {
+		spin_lock_irqsave(&host->lock, flags);
+		xenon_set_sdclk_off_idle(host, priv->sdhc_id, true);
+		spin_unlock_irqrestore(&host->lock, flags);
+	}
 }
 
-static int __emmc_signal_voltage_switch(struct mmc_host *mmc,
-				const unsigned char signal_voltage)
+static int xenon_emmc_signal_voltage_switch(struct mmc_host *mmc,
+					    struct mmc_ios *ios)
 {
-	u32 ctrl;
-	unsigned char voltage_code;
+	unsigned char voltage = ios->signal_voltage;
 	struct sdhci_host *host = mmc_priv(mmc);
+	unsigned char voltage_code;
+	u32 ctrl;
 
-	if (signal_voltage == MMC_SIGNAL_VOLTAGE_330)
-		voltage_code = eMMC_VCCQ_3_3V;
-	else if (signal_voltage == MMC_SIGNAL_VOLTAGE_180)
-		voltage_code = eMMC_VCCQ_1_8V;
-	else
-		return -EINVAL;
-
-	/*
-	 * This host is for eMMC, XENON self-defined
-	 * eMMC slot control register should be accessed
-	 * instead of Host Control 2
-	 */
-	ctrl = sdhci_readl(host, SDHC_SLOT_eMMC_CTRL);
-	ctrl &= ~eMMC_VCCQ_MASK;
-	ctrl |= voltage_code;
-	sdhci_writel(host, ctrl, SDHC_SLOT_eMMC_CTRL);
-
-	/* There is no standard to determine this waiting period */
-	usleep_range(1000, 2000);
+	if ((voltage == MMC_SIGNAL_VOLTAGE_330) ||
+	    (voltage == MMC_SIGNAL_VOLTAGE_180)) {
+		if (voltage == MMC_SIGNAL_VOLTAGE_330)
+			voltage_code = SDHCI_EMMC_VCCQ_3_3V;
+		else if (voltage == MMC_SIGNAL_VOLTAGE_180)
+			voltage_code = SDHCI_EMMC_VCCQ_1_8V;
 
-	/* Check whether io voltage switch is done */
-	ctrl = sdhci_readl(host, SDHC_SLOT_eMMC_CTRL);
-	ctrl &= eMMC_VCCQ_MASK;
-	/*
-	 * This bit is set only when regulator feedbacks the voltage switch
-	 * results to Xenon SDHC.
-	 * However, in actaul implementation, regulator might not provide
-	 * this feedback.
-	 * Thus we shall not rely on this bit to determine if switch failed.
-	 * If the bit is not set, just throw a warning.
-	 * Besides, error code should neither be returned.
-	 */
-	if (ctrl != voltage_code)
-		pr_info("%s: Xenon fail to detect eMMC signal voltage stable\n",
-					mmc_hostname(mmc));
-	return 0;
-}
+		/*
+		 * This host is for eMMC, XENON self-defined
+		 * eMMC control register should be accessed
+		 * instead of Host Control 2
+		 */
+		ctrl = sdhci_readl(host, SDHCI_SLOT_EMMC_CTRL);
+		ctrl &= ~SDHCI_EMMC_VCCQ_MASK;
+		ctrl |= voltage_code;
+		sdhci_writel(host, ctrl, SDHCI_SLOT_EMMC_CTRL);
 
-static int xenon_emmc_signal_voltage_switch(struct mmc_host *mmc,
-					struct mmc_ios *ios)
-{
-	unsigned char voltage = ios->signal_voltage;
+		/* There is no standard to determine this waiting period */
+		usleep_range(1000, 2000);
 
-	if ((voltage == MMC_SIGNAL_VOLTAGE_330) ||
-		(voltage == MMC_SIGNAL_VOLTAGE_180))
-		return __emmc_signal_voltage_switch(mmc, voltage);
+		/* Check whether io voltage switch is done */
+		ctrl = sdhci_readl(host, SDHCI_SLOT_EMMC_CTRL);
+		ctrl &= SDHCI_EMMC_VCCQ_MASK;
+		/*
+		 * This bit is set only when regulator feeds back
+		 * the voltage switch results to Xenon SDHC.
+		 * However, in actaul implementation, regulator might not
+		 * provide this feedback.
+		 * Thus we shall not rely on this bit to determine
+		 * if switch failed.
+		 * If the bit is not set, just throw a message.
+		 * Besides, error code should not be returned.
+		 */
+		if (ctrl != voltage_code)
+			dev_info(mmc_dev(mmc), "fail to detect eMMC signal voltage stable\n");
+		return 0;
+	}
 
-	pr_err("%s: Xenon Unsupported signal voltage: %d\n",
-				mmc_hostname(mmc), voltage);
+	dev_err(mmc_dev(mmc), "Unsupported signal voltage: %d\n", voltage);
 	return -EINVAL;
 }
 
@@ -330,82 +317,66 @@ static int xenon_start_signal_voltage_switch(struct mmc_host *mmc,
 	 * If Internal clock is disabled, the 3.3V/1.8V bit can not be updated.
 	 * Thus here manually enable internal clock.
 	 *
-	 * After switch completes, it is unnessary to disable internal clock,
+	 * After switch completes, it is unnecessary to disable internal clock,
 	 * since keeping internal clock active obeys SD spec.
 	 */
 	enable_xenon_internal_clk(host);
 
-	if (priv->card_candidate) {
-		if (mmc_card_mmc(priv->card_candidate)) {
-			/* Set SoC PAD register for MMC PHY voltage */
-			xenon_soc_pad_ctrl(host, ios->signal_voltage);
+	xenon_soc_pad_ctrl(host, ios->signal_voltage);
 
-			return xenon_emmc_signal_voltage_switch(mmc, ios);
-		}
-	}
+	if (priv->init_card_type == MMC_TYPE_MMC)
+		return xenon_emmc_signal_voltage_switch(mmc, ios);
 
 	return sdhci_start_signal_voltage_switch(mmc, ios);
 }
 
-/* After determining the slot is used for SDIO,
- * some addtional task is required.
+/*
+ * Update card type.
+ * priv->init_card_type will be used in PHY timing adjustment.
  */
 static void xenon_init_card(struct mmc_host *mmc, struct mmc_card *card)
 {
 	struct sdhci_host *host = mmc_priv(mmc);
-	u32 reg;
-	u8 slot_idx;
 	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
 	struct sdhci_xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);
 
-	/* Link the card for delay adjustment */
-	priv->card_candidate = card;
-	/* Set Xenon tuning */
-	xenon_set_tuning_mode(host);
-	xenon_set_tuning_count(host, priv->tuning_count);
-
-	slot_idx = priv->slot_idx;
-	if (!mmc_card_sdio(card)) {
-		/* Re-enable the Auto-CMD12 cap flag. */
-		host->quirks |= SDHCI_QUIRK_MULTIBLOCK_READ_ACMD12;
-		host->flags |= SDHCI_AUTO_CMD12;
-
-		/* Clear SDIO Card Insterted indication */
-		reg = sdhci_readl(host, SDHC_SYS_CFG_INFO);
-		reg &= ~(1 << (slot_idx + SLOT_TYPE_SDIO_SHIFT));
-		sdhci_writel(host, reg, SDHC_SYS_CFG_INFO);
-
-		if (mmc_card_mmc(card)) {
-			mmc->caps |= MMC_CAP_NONREMOVABLE | MMC_CAP_1_8V_DDR;
-			/*
-			 * Force to clear BUS_TEST to
-			 * skip bus_test_pre and bus_test_post
-			 */
-			mmc->caps &= ~MMC_CAP_BUS_WIDTH_TEST;
-			mmc->caps2 |= MMC_CAP2_HS400_1_8V |
-				MMC_CAP2_HC_ERASE_SZ | MMC_CAP2_PACKED_CMD;
-		}
-		/* Xenon SD doesn't support DDR50 tuning.*/
-		if (mmc_card_sd(card))
-			mmc->caps2 |= MMC_CAP2_NO_DDR50_TUNING;
-	} else {
-		/*
-		 * Delete the Auto-CMD12 cap flag.
-		 * Otherwise, when sending multi-block CMD53,
-		 * Driver will set Transfer Mode Register to enable Auto CMD12.
-		 * However, SDIO device cannot recognize CMD12.
-		 * Thus SDHC will time-out for waiting for CMD12 response.
-		 */
-		host->quirks &= ~SDHCI_QUIRK_MULTIBLOCK_READ_ACMD12;
-		host->flags &= ~SDHCI_AUTO_CMD12;
+	/* Update card type*/
+	priv->init_card_type = card->type;
+}
+
+static int xenon_execute_tuning(struct mmc_host *mmc, u32 opcode)
+{
+	struct sdhci_host *host = mmc_priv(mmc);
+
+	if (host->timing == MMC_TIMING_UHS_DDR50)
+		return 0;
+
+	return sdhci_execute_tuning(mmc, opcode);
+}
 
+static void xenon_enable_sdio_irq(struct mmc_host *mmc, int enable)
+{
+	struct sdhci_host *host = mmc_priv(mmc);
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);
+	u32 reg;
+	u8 sdhc_id = priv->sdhc_id;
+
+	sdhci_enable_sdio_irq(mmc, enable);
+
+	if (enable) {
 		/*
-		 * Set SDIO Card Insterted indication
-		 * to inform that the current slot is for SDIO
+		 * Set SDIO Card Inserted indication
+		 * to enable detecting SDIO async irq.
 		 */
-		reg = sdhci_readl(host, SDHC_SYS_CFG_INFO);
-		reg |= (1 << (slot_idx + SLOT_TYPE_SDIO_SHIFT));
-		sdhci_writel(host, reg, SDHC_SYS_CFG_INFO);
+		reg = sdhci_readl(host, SDHCI_SYS_CFG_INFO);
+		reg |= (1 << (sdhc_id + SDHCI_SLOT_TYPE_SDIO_SHIFT));
+		sdhci_writel(host, reg, SDHCI_SYS_CFG_INFO);
+	} else {
+		/* Clear SDIO Card Inserted indication */
+		reg = sdhci_readl(host, SDHCI_SYS_CFG_INFO);
+		reg &= ~(1 << (sdhc_id + SDHCI_SLOT_TYPE_SDIO_SHIFT));
+		sdhci_writel(host, reg, SDHCI_SYS_CFG_INFO);
 	}
 }
 
@@ -415,6 +386,49 @@ static void xenon_replace_mmc_host_ops(struct sdhci_host *host)
 	host->mmc_host_ops.start_signal_voltage_switch =
 			xenon_start_signal_voltage_switch;
 	host->mmc_host_ops.init_card = xenon_init_card;
+	host->mmc_host_ops.execute_tuning = xenon_execute_tuning;
+	host->mmc_host_ops.enable_sdio_irq = xenon_enable_sdio_irq;
+}
+
+/*
+ * Parse child node in Xenon DT.
+ * Search for the following item(s):
+ * - eMMC card type
+ */
+static int xenon_child_node_of_parse(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct sdhci_host *host = platform_get_drvdata(pdev);
+	struct mmc_host *mmc = host->mmc;
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);
+	struct device_node *child;
+	int nr_child;
+
+	priv->init_card_type = SDHCI_CARD_TYPE_UNKNOWN;
+
+	nr_child = of_get_child_count(np);
+	if (!nr_child)
+		return 0;
+
+	for_each_child_of_node(np, child) {
+		if (of_device_is_compatible(child, "mmc-card"))	{
+			priv->init_card_type = MMC_TYPE_MMC;
+			mmc->caps |= MMC_CAP_NONREMOVABLE;
+
+			/*
+			 * Force to clear BUS_TEST to
+			 * skip bus_test_pre and bus_test_post
+			 */
+			mmc->caps &= ~MMC_CAP_BUS_WIDTH_TEST;
+			mmc->caps2 |= MMC_CAP2_HC_ERASE_SZ |
+				      MMC_CAP2_PACKED_CMD |
+				      MMC_CAP2_NO_SD |
+				      MMC_CAP2_NO_SDIO;
+		}
+	}
+
+	return 0;
 }
 
 static int xenon_probe_dt(struct platform_device *pdev)
@@ -425,7 +439,7 @@ static int xenon_probe_dt(struct platform_device *pdev)
 	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
 	struct sdhci_xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);
 	int err;
-	u32 slot_idx;
+	u32 sdhc_id, nr_sdhc;
 	u32 tuning_count;
 
 	/* Standard MMC property */
@@ -433,62 +447,75 @@ static int xenon_probe_dt(struct platform_device *pdev)
 	if (err)
 		return err;
 
-	/* Statndard SDHCI property */
+	/* Standard SDHCI property */
 	sdhci_get_of_property(pdev);
 
 	/*
 	 * Xenon Specific property:
-	 * slotno: the index of slot. Refer to SDHC_SYS_CFG_INFO register
-	 * tuning-count: the interval between re-tuning
-	 * PHY type: "sdhc phy", "emmc phy 5.0" or "emmc phy 5.1"
+	 * init_card_type: check whether this SDHC is for eMMC
+	 * sdhc-id: the index of current SDHC.
+	 *	    Refer to SDHCI_SYS_CFG_INFO register
+	 * tun-count: the interval between re-tuning
 	 */
-	if (!of_property_read_u32(np, "xenon,slotno", &slot_idx))
-		priv->slot_idx = slot_idx & 0xff;
-	else
-		priv->slot_idx = 0x0;
+	/* Parse child node, including checking emmc type */
+	err = xenon_child_node_of_parse(pdev);
+	if (err)
+		return err;
+
+	priv->sdhc_id = 0x0;
+	if (!of_property_read_u32(np, "marvell,xenon-sdhc-id", &sdhc_id)) {
+		nr_sdhc = sdhci_readl(host, SDHCI_SYS_CFG_INFO);
+		nr_sdhc &= SDHCI_NR_SUPPORTED_SLOT_MASK;
+		if (unlikely(sdhc_id > nr_sdhc)) {
+			dev_err(mmc_dev(mmc), "SDHC Index %d exceeds Number of SDHCs %d\n",
+				sdhc_id, nr_sdhc);
+			return -EINVAL;
+		}
+	}
 
-	if (!of_property_read_u32(np, "xenon,tuning-count", &tuning_count)) {
-		if (unlikely(tuning_count >= TMR_RETUN_NO_PRESENT)) {
-			pr_err("%s: Wrong Re-tuning Count. Set default value %d\n",
-				mmc_hostname(mmc), DEF_TUNING_COUNT);
-			tuning_count = DEF_TUNING_COUNT;
+	tuning_count = SDHCI_DEF_TUNING_COUNT;
+	if (!of_property_read_u32(np, "marvell,xenon-tun-count",
+				  &tuning_count)) {
+		if (unlikely(tuning_count >= SDHCI_TMR_RETUN_NO_PRESENT)) {
+			dev_err(mmc_dev(mmc), "Wrong Re-tuning Count. Set default value %d\n",
+				SDHCI_DEF_TUNING_COUNT);
+			tuning_count = SDHCI_DEF_TUNING_COUNT;
 		}
-		priv->tuning_count = tuning_count & 0xf;
-	} else
-		priv->tuning_count = DEF_TUNING_COUNT;
+	}
+	priv->tuning_count = tuning_count;
 
-	err = xenon_phy_parse_dt(np, priv);
-	return err;
+	return xenon_phy_parse_dt(np, host);
 }
 
-static int xenon_slot_probe(struct sdhci_host *host)
+static int xenon_sdhc_probe(struct sdhci_host *host)
 {
 	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
 	struct sdhci_xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);
-	u8 slot_idx = priv->slot_idx;
+	u8 sdhc_id = priv->sdhc_id;
 
-	/* Enable slot */
-	xenon_enable_slot(host, slot_idx);
+	/* Enable SDHC */
+	xenon_enable_sdhc(host, sdhc_id);
 
 	/* Enable ACG */
 	xenon_set_acg(host, true);
 
 	/* Enable Parallel Transfer Mode */
-	xenon_enable_slot_parallel_tran(host, slot_idx);
+	xenon_enable_sdhc_parallel_tran(host, sdhc_id);
 
-	priv->timing = MMC_TIMING_FAKE;
+	/* Set tuning functionality of this SDHC */
+	xenon_sdhc_tuning_setup(host);
 
 	return 0;
 }
 
-static void xenon_slot_remove(struct sdhci_host *host)
+static void xenon_sdhc_remove(struct sdhci_host *host)
 {
 	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
 	struct sdhci_xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);
-	u8 slot_idx = priv->slot_idx;
+	u8 sdhc_id = priv->sdhc_id;
 
-	/* disable slot */
-	xenon_disable_slot(host, slot_idx);
+	/* disable SDHC */
+	xenon_disable_sdhc(host, sdhc_id);
 }
 
 static int sdhci_xenon_probe(struct platform_device *pdev)
@@ -499,13 +526,15 @@ static int sdhci_xenon_probe(struct platform_device *pdev)
 	int err;
 
 	host = sdhci_pltfm_init(pdev, &sdhci_xenon_pdata,
-		sizeof(struct sdhci_xenon_priv));
+				sizeof(struct sdhci_xenon_priv));
 	if (IS_ERR(host))
 		return PTR_ERR(host);
 
 	pltfm_host = sdhci_priv(host);
 	priv = sdhci_pltfm_priv(pltfm_host);
 
+	xenon_set_acg(host, false);
+
 	/*
 	 * Link Xenon specific mmc_host_ops function,
 	 * to replace standard ones in sdhci_ops.
@@ -513,62 +542,33 @@ static int sdhci_xenon_probe(struct platform_device *pdev)
 	xenon_replace_mmc_host_ops(host);
 
 	pltfm_host->clk = devm_clk_get(&pdev->dev, "core");
-	if (!IS_ERR(pltfm_host->clk)) {
-		err = clk_prepare_enable(pltfm_host->clk);
-		if (err)
-			goto free_pltfm;
-	} else if (PTR_ERR(pltfm_host->clk) == -EPROBE_DEFER) {
-		err = -EPROBE_DEFER;
-		goto free_pltfm;
-	} else {
-		pr_err("%s: Failed to setup input clk.\n",
-			mmc_hostname(host->mmc));
+	if (IS_ERR(pltfm_host->clk)) {
 		err = PTR_ERR(pltfm_host->clk);
+		dev_err(&pdev->dev, "Failed to setup input clk: %d\n", err);
 		goto free_pltfm;
 	}
-
-	/*
-	 * Some SOCs require additional clock to
-	 * manage AXI bus clock.
-	 * It is optional.
-	 */
-	priv->axi_clk = devm_clk_get(&pdev->dev, "axi");
-	if (!IS_ERR(priv->axi_clk)) {
-		err = clk_prepare_enable(priv->axi_clk);
-		if (err)
-			goto err_clk;
-	}
+	err = clk_prepare_enable(pltfm_host->clk);
+	if (err)
+		goto free_pltfm;
 
 	err = xenon_probe_dt(pdev);
 	if (err)
 		goto err_clk;
 
-	err = xenon_slot_probe(host);
+	err = xenon_sdhc_probe(host);
 	if (err)
 		goto err_clk;
 
 	err = sdhci_add_host(host);
 	if (err)
-		goto remove_slot;
-
-	/* Set tuning functionality of this slot */
-	xenon_slot_tuning_setup(host);
-
-	/* Initialize SoC PAD register for MMC PHY voltage
-	 * For eMMC, it is set to 1.8V
-	 * For SD/SDIO, it is set to 3.3V
-	 */
-	xenon_soc_pad_ctrl(host, MMC_SIGNAL_VOLTAGE_330);
+		goto remove_sdhc;
 
 	return 0;
 
-remove_slot:
-	xenon_slot_remove(host);
+remove_sdhc:
+	xenon_sdhc_remove(host);
 err_clk:
-	if (!IS_ERR(pltfm_host->clk))
-		clk_disable_unprepare(pltfm_host->clk);
-	if (!IS_ERR(priv->axi_clk))
-		clk_disable_unprepare(priv->axi_clk);
+	clk_disable_unprepare(pltfm_host->clk);
 free_pltfm:
 	sdhci_pltfm_free(pdev);
 	return err;
@@ -578,15 +578,13 @@ static int sdhci_xenon_remove(struct platform_device *pdev)
 {
 	struct sdhci_host *host = platform_get_drvdata(pdev);
 	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
-	struct sdhci_xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);
-	int dead = (readl(host->ioaddr + SDHCI_INT_STATUS) == 0xffffffff);
+	int dead = (readl(host->ioaddr + SDHCI_INT_STATUS) == 0xFFFFFFFF);
 
-	xenon_slot_remove(host);
+	xenon_sdhc_remove(host);
 
 	sdhci_remove_host(host, dead);
 
 	clk_disable_unprepare(pltfm_host->clk);
-	clk_disable_unprepare(priv->axi_clk);
 
 	sdhci_pltfm_free(pdev);
 
@@ -594,16 +592,17 @@ static int sdhci_xenon_remove(struct platform_device *pdev)
 }
 
 static const struct of_device_id sdhci_xenon_dt_ids[] = {
-	{ .compatible = "marvell,xenon-sdhci",},
+	{ .compatible = "marvell,armada8k-sdhci",},
+	{ .compatible = "marvell,armada-3700-sdhci",},
 	{}
 };
 MODULE_DEVICE_TABLE(of, sdhci_xenon_dt_ids);
 
 static struct platform_driver sdhci_xenon_driver = {
 	.driver	= {
-		.name	= "mv-xenon-sdhci",
+		.name	= "xenon-sdhci",
 		.of_match_table = sdhci_xenon_dt_ids,
-		.pm = SDHCI_PLTFM_PMOPS,
+		.pm = &sdhci_pltfm_pmops,
 	},
 	.probe	= sdhci_xenon_probe,
 	.remove	= sdhci_xenon_remove,
diff --git a/drivers/mmc/host/sdhci-xenon.h b/drivers/mmc/host/sdhci-xenon.h
index 65275fe..a8312e3 100644
--- a/drivers/mmc/host/sdhci-xenon.h
+++ b/drivers/mmc/host/sdhci-xenon.h
@@ -1,8 +1,8 @@
 /*
  * Copyright (C) 2016 Marvell, All Rights Reserved.
  *
- * Author: Hu Ziji <huziji@marvell.com>
- * Date:   2016-7-30
+ * Author:	Hu Ziji <huziji@marvell.com>
+ * Date:	2016-8-24
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -11,93 +11,87 @@
 #ifndef SDHCI_XENON_H_
 #define SDHCI_XENON_H_
 
-#include <linux/clk.h>
-#include <linux/mmc/card.h>
-#include <linux/of.h>
-#include "sdhci.h"
-#include "sdhci-xenon-phy.h"
-
-/* Register Offset of SD Host Controller SOCP self-defined register */
-#define SDHC_SYS_CFG_INFO			0x0104
-#define SLOT_TYPE_SDIO_SHIFT			24
-#define SLOT_TYPE_EMMC_MASK			0xff
-#define SLOT_TYPE_EMMC_SHIFT			16
-#define SLOT_TYPE_SD_SDIO_MMC_MASK		0xff
-#define SLOT_TYPE_SD_SDIO_MMC_SHIFT		8
-
-#define SDHC_SYS_OP_CTRL			0x0108
-#define AUTO_CLKGATE_DISABLE_MASK		(0x1<<20)
-#define SDCLK_IDLEOFF_ENABLE_SHIFT		8
-#define SLOT_ENABLE_SHIFT			0
-
-#define SDHC_SYS_EXT_OP_CTRL			0x010c
-
-#define SDHC_SLOT_OP_STATUS_CTRL		0x0128
-#define DELAY_90_DEGREE_MASK_EMMC5		(1 << 7)
-#define DELAY_90_DEGREE_SHIFT_EMMC5		7
-#define EMMC_5_0_PHY_FIXED_DELAY_MASK		0x7f
-#define EMMC_PHY_FIXED_DELAY_MASK		0xff
-#define EMMC_PHY_FIXED_DELAY_WINDOW_MIN		(EMMC_PHY_FIXED_DELAY_MASK >> 3)
-#define SDH_PHY_FIXED_DELAY_MASK		0x1ff
-#define SDH_PHY_FIXED_DELAY_WINDOW_MIN		(SDH_PHY_FIXED_DELAY_MASK >> 4)
-
-#define TUN_CONSECUTIVE_TIMES_SHIFT		16
-#define TUN_CONSECUTIVE_TIMES_MASK		0x7
-#define TUN_CONSECUTIVE_TIMES			0x4
-#define TUNING_STEP_SHIFT			12
-#define TUNING_STEP_MASK			0xf
-
-#define TUNING_STEP_DIVIDER			64
-
-#define FORCE_SEL_INVERSE_CLK_SHIFT		11
-
-#define SDHC_SLOT_eMMC_CTRL			0x0130
-#define ENABLE_DATA_STROBE			(1 << 24)
-#define SET_EMMC_RSTN				(1 << 16)
-#define DISABLE_RD_DATA_CRC			(1 << 14)
-#define DISABLE_CRC_STAT_TOKEN			(1 << 13)
-#define eMMC_VCCQ_MASK				0x3
-#define eMMC_VCCQ_1_8V				0x1
-#define eMMC_VCCQ_3_3V				0x3
-
-#define SDHC_SLOT_RETUNING_REQ_CTRL		0x0144
-/* retuning compatible */
-#define RETUNING_COMPATIBLE			0x1
 
-#define SDHC_SLOT_AUTO_RETUNING_CTRL		0x0148
-#define ENABLE_AUTO_RETUNING			0x1
+/* Register Offset of Xenon SDHC self-defined register */
+#define SDHCI_SYS_CFG_INFO			0x0104
+#define SDHCI_SLOT_TYPE_SDIO_SHIFT		24
+#define SDHCI_NR_SUPPORTED_SLOT_MASK		0x7
 
-#define SDHC_SLOT_DLL_CUR_DLY_VAL		0x150
+#define SDHCI_SYS_OP_CTRL			0x0108
+#define SDHCI_AUTO_CLKGATE_DISABLE_MASK		BIT(20)
+#define SDHCI_SDCLK_IDLEOFF_ENABLE_SHIFT	8
+#define SDHCI_SLOT_ENABLE_SHIFT			0
 
-/* Tuning Parameter */
-#define TMR_RETUN_NO_PRESENT			0xf
-#define XENON_MAX_TUN_COUNT			0xe
+#define SDHCI_SYS_EXT_OP_CTRL			0x010C
+#define SDHCI_MASK_CMD_CONFLICT_ERROR		BIT(8)
+
+#define SDHCI_SLOT_OP_STATUS_CTRL		0x0128
+
+#define SDHCI_TUN_CONSECUTIVE_TIMES_SHIFT	16
+#define SDHCI_TUN_CONSECUTIVE_TIMES_MASK	0x7
+#define SDHCI_TUN_CONSECUTIVE_TIMES		0x4
+#define SDHCI_TUNING_STEP_SHIFT			12
+#define SDHCI_TUNING_STEP_MASK			0xF
+#define SDHCI_TUNING_STEP_DIVIDER		BIT(6)
+
+#define SDHCI_SLOT_EMMC_CTRL			0x0130
+#define SDHCI_ENABLE_DATA_STROBE		BIT(24)
+#define SDHCI_EMMC_VCCQ_MASK			0x3
+#define SDHCI_EMMC_VCCQ_1_8V			0x1
+#define SDHCI_EMMC_VCCQ_3_3V			0x3
 
-#define MMC_TIMING_FAKE				0xff
+#define SDHCI_SLOT_RETUNING_REQ_CTRL		0x0144
+/* retuning compatible */
+#define SDHCI_RETUNING_COMPATIBLE		0x1
+
+#define SDHCI_SLOT_EXT_PRESENT_STATE		0x014C
+#define SDHCI_DLL_LOCK_STATE			0x1
 
-#define DEF_TUNING_COUNT			0x9
+#define SDHCI_SLOT_DLL_CUR_DLY_VAL		0x0150
 
-#define DEFAULT_SDCLK_FREQ			(400000)
+/* Tuning Parameter */
+#define SDHCI_TMR_RETUN_NO_PRESENT		0xF
+#define SDHCI_DEF_TUNING_COUNT			0x9
+
+#define SDHCI_DEFAULT_SDCLK_FREQ		(400000)
+#define SDHCI_LOWEST_SDCLK_FREQ			(100000)
 
 /* Xenon specific Mode Select value */
-#define XENON_SDHCI_CTRL_HS200			0x5
-#define	XENON_SDHCI_CTRL_HS400			0x6
+#define SDHCI_XENON_CTRL_HS200			0x5
+#define SDHCI_XENON_CTRL_HS400			0x6
+
+/* Indicate Card Type is not clear yet */
+#define SDHCI_CARD_TYPE_UNKNOWN			0xF
 
 struct sdhci_xenon_priv {
+	unsigned char	tuning_count;
+	/* idx of SDHC */
+	u8		sdhc_id;
+
+	/*
+	 * eMMC/SD/SDIO require different PHY settings or
+	 * voltage control. It's necessary for Xenon driver to
+	 * recognize card type during, or even before initialization.
+	 * However, mmc_host->card is not available yet at that time.
+	 * This field records the card type during init.
+	 * For eMMC, it is updated in dt parse. For SD/SDIO, it is
+	 * updated in xenon_init_card().
+	 *
+	 * It is only valid during initialization after it is updated.
+	 * Do not access this variable in normal transfers after
+	 * initialization completes.
+	 */
+	unsigned int	init_card_type;
+
 	/*
 	 * The bus_width, timing, and clock fields in below
-	 * record the current setting of Xenon SDHC.
-	 * Driver will call a Sampling Fixed Delay Adjustment
-	 * if any setting is changed.
+	 * record the current ios setting of Xenon SDHC.
+	 * Driver will adjust PHY setting if any change to
+	 * ios affects PHY timing.
 	 */
 	unsigned char	bus_width;
 	unsigned char	timing;
-	unsigned char	tuning_count;
 	unsigned int	clock;
-	struct clk      *axi_clk;
-
-	/* Slot idx */
-	u8		slot_idx;
 
 	int		phy_type;
 	/*
@@ -105,46 +99,13 @@ struct sdhci_xenon_priv {
 	 * passed from device tree.
 	 */
 	void		*phy_params;
-	struct xenon_phy_ops phy_ops;
-
-	/*
-	 * When initializing card, Xenon has to determine card type and
-	 * adjust Sampling Fixed delay.
-	 * However, at that time, card structure is not linked to mmc_host.
-	 * Thus a card pointer is added here to provide
-	 * the delay adjustment function with the card structure
-	 * of the card during initialization
-	 */
-	struct mmc_card *card_candidate;
+	struct xenon_emmc_phy_regs *emmc_phy_regs;
 };
 
-static inline int enable_xenon_internal_clk(struct sdhci_host *host)
-{
-	u32 reg;
-	u8 timeout;
-
-	reg = sdhci_readl(host, SDHCI_CLOCK_CONTROL);
-	reg |= SDHCI_CLOCK_INT_EN;
-	sdhci_writel(host, reg, SDHCI_CLOCK_CONTROL);
-	/* Wait max 20 ms */
-	timeout = 20;
-	while (!((reg = sdhci_readw(host, SDHCI_CLOCK_CONTROL))
-			& SDHCI_CLOCK_INT_STABLE)) {
-		if (timeout == 0) {
-			pr_err("%s: Internal clock never stabilised.\n",
-					mmc_hostname(host->mmc));
-			return -EIO;
-		}
-		timeout--;
-		mdelay(1);
-	}
-
-	return 0;
-}
 
 int xenon_phy_adj(struct sdhci_host *host, struct mmc_ios *ios);
 int xenon_phy_parse_dt(struct device_node *np,
-			struct sdhci_xenon_priv *priv);
+		       struct sdhci_host *host);
 void xenon_soc_pad_ctrl(struct sdhci_host *host,
 			unsigned char signal_voltage);
 #endif
diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c
index dc4fbac..81f1a9b 100644
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@ -51,7 +51,6 @@ static unsigned int debug_quirks2;
 static void sdhci_finish_data(struct sdhci_host *);
 
 static void sdhci_finish_command(struct sdhci_host *);
-static int sdhci_execute_tuning(struct mmc_host *mmc, u32 opcode);
 static void sdhci_enable_preset_value(struct sdhci_host *host, bool enable);
 static int sdhci_pre_dma_transfer(struct sdhci_host *host,
 					struct mmc_data *data);
@@ -1754,7 +1753,7 @@ static void sdhci_enable_sdio_irq_nolock(struct sdhci_host *host, int enable)
 	}
 }
 
-static void sdhci_enable_sdio_irq(struct mmc_host *mmc, int enable)
+void sdhci_enable_sdio_irq(struct mmc_host *mmc, int enable)
 {
 	struct sdhci_host *host = mmc_priv(mmc);
 	unsigned long flags;
@@ -1772,6 +1771,7 @@ static void sdhci_enable_sdio_irq(struct mmc_host *mmc, int enable)
 
 	sdhci_runtime_pm_put(host);
 }
+EXPORT_SYMBOL_GPL(sdhci_enable_sdio_irq);
 
 static int sdhci_do_start_signal_voltage_switch(struct sdhci_host *host,
 					 struct mmc_ios *ios)
@@ -1904,7 +1904,7 @@ static int sdhci_prepare_hs400_tuning(struct mmc_host *mmc, struct mmc_ios *ios)
 	return 0;
 }
 
-static int sdhci_execute_tuning(struct mmc_host *mmc, u32 opcode)
+int sdhci_execute_tuning(struct mmc_host *mmc, u32 opcode)
 {
 	struct sdhci_host *host = mmc_priv(mmc);
 	u16 ctrl;
@@ -2123,6 +2123,7 @@ out_unlock:
 
 	return err;
 }
+EXPORT_SYMBOL_GPL(sdhci_execute_tuning);
 
 static int sdhci_select_drive_strength(struct mmc_card *card,
 				       unsigned int max_dtr, int host_drv,
diff --git a/drivers/mmc/host/sdhci.h b/drivers/mmc/host/sdhci.h
index a695d4c..479cad3 100644
--- a/drivers/mmc/host/sdhci.h
+++ b/drivers/mmc/host/sdhci.h
@@ -672,6 +672,8 @@ void sdhci_set_uhs_signaling(struct sdhci_host *host, unsigned timing);
 void sdhci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios);
 int sdhci_start_signal_voltage_switch(struct mmc_host *mmc,
 				      struct mmc_ios *ios);
+int sdhci_execute_tuning(struct mmc_host *mmc, u32 opcode);
+void sdhci_enable_sdio_irq(struct mmc_host *mmc, int enable);
 
 #ifdef CONFIG_PM
 extern int sdhci_suspend_host(struct sdhci_host *host);
diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 00be70e..258073a 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -289,7 +289,10 @@ struct mmc_host {
 #define MMC_CAP2_HSX00_1_2V	(MMC_CAP2_HS200_1_2V_SDR | MMC_CAP2_HS400_1_2V)
 #define MMC_CAP2_SDIO_IRQ_NOTHREAD (1 << 17)
 #define MMC_CAP2_NO_WRITE_PROTECT (1 << 18)	/* No physical write protect pin, assume that card is always read-write */
-#define MMC_CAP2_NO_DDR50_TUNING (1 << 20)	/* Do not execute tuning in DDR50 mode */
+#define MMC_CAP2_NO_SDIO	(1 << 19)	/* Do not send SDIO commands during initialization */
+#define MMC_CAP2_HS400_ES	(1 << 20)	/* Host supports enhanced strobe */
+#define MMC_CAP2_NO_SD		(1 << 21)	/* Do not send SD commands during initialization */
+#define MMC_CAP2_NO_MMC		(1 << 22)	/* Do not send (e)MMC commands during initialization */
 
 	mmc_pm_flag_t		pm_caps;	/* supported pm features */
 
-- 
2.7.4

