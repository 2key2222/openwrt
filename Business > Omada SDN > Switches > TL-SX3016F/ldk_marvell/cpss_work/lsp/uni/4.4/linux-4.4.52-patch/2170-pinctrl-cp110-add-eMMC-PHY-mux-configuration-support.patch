From 170a89a1ada4c01754034f79c1f1adda3de060c9 Mon Sep 17 00:00:00 2001
From: Evan Wang <xswang@marvell.com>
Date: Fri, 24 Nov 2017 15:49:28 +0800
Subject: [PATCH 2170/2241] pinctrl: cp110: add eMMC PHY mux configuration
 support

eMMC/SD PHY register responsible for muxing between MPPs
and SD/eMMC controller:
    - Bit0 enabled, SDIO/eMMC PHY is used as a MPP
      muxltiplexer.
    - Bit0 disabled, SDIO/eMMC PHY is connected to
      SDIO/eMMC controller

Before this patch the eMMC PHY mux configured is done in
uboot, and in order to remove the dependency, the kernel
should also support it.
The patch defined a generic function
'armada_cp110_mpp_mmc_mux_set' to configure eMMC PHY mux,
and implemented full eMMC PHY mux configuration on CP0.
If full implementation is needed on CP1, please refer to
CP0.

Change-Id: I9ae82e8932a8ee4eb808cba43f1492694acbe44e
Signed-off-by: Evan Wang <xswang@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/46825
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Reviewed-by: Omri Itach <omrii@marvell.com>
---
 .../pinctrl/marvell,armada-cp110-pinctrl.txt       |  6 +-
 drivers/pinctrl/mvebu/pinctrl-armada-cp110.c       | 64 +++++++++++++++++++++-
 2 files changed, 68 insertions(+), 2 deletions(-)

diff --git a/Documentation/devicetree/bindings/pinctrl/marvell,armada-cp110-pinctrl.txt b/Documentation/devicetree/bindings/pinctrl/marvell,armada-cp110-pinctrl.txt
index fb9ff40..bc8b954 100644
--- a/Documentation/devicetree/bindings/pinctrl/marvell,armada-cp110-pinctrl.txt
+++ b/Documentation/devicetree/bindings/pinctrl/marvell,armada-cp110-pinctrl.txt
@@ -10,7 +10,11 @@ Required properties:
 - compatible: "marvell,a70x0-pinctrl", "marvell,a80x0-cp0-pinctrl",
 	and "marvell,a80x0-cp1-pinctrl" depends on the specific	variant of the
 	SoC being use.
-- reg: register specifier of MPP registers
+- reg: register specifier of MPP registers, including eMMC PHY mux register with
+       name "mmcio" in property of reg-names.
+- reg-names: include the following entries:
+             "pinctrl": pinctrl registers, which is mandatory and must be first one.
+             "mmcio": eMMC PHY IO Control 0 Register, which is for eMMC PHY mux.
 
 Available MPP pins/groups and functions:
 Note: Brackets (x) are not part of the MPP name for the Marvell function and are
diff --git a/drivers/pinctrl/mvebu/pinctrl-armada-cp110.c b/drivers/pinctrl/mvebu/pinctrl-armada-cp110.c
index bab4036..299e158 100644
--- a/drivers/pinctrl/mvebu/pinctrl-armada-cp110.c
+++ b/drivers/pinctrl/mvebu/pinctrl-armada-cp110.c
@@ -21,13 +21,47 @@
 #include <linux/of_device.h>
 #include <linux/pinctrl/pinctrl.h>
 #include <linux/syscore_ops.h>
+#include <linux/of_address.h>
 
 #include "pinctrl-mvebu.h"
 
+#define CP110_0_EMMC_CLK_PIN_ID		56
+#define CP110_0_EMMC_CLK_FUNC		14
+#define EMMC_PHY_CTRL_SDPHY_EN		BIT(0)
+
 /* Global list of devices (struct mvebu_pinctrl_soc_info) */
 static LIST_HEAD(drvdata_list);
 
 static void __iomem *cp0_mpp_base;
+static void __iomem *cp0_emmc_phy_ctrl_reg;
+
+/* armada_cp110_mpp_mmc_mux_set
+ * The function implements the generic configuration for eMMC PHY mux.
+ * Input parameters:
+ * - addr, the address of eMMC/SD PHY register;
+ * - is_mpp_mux, it is a bool. If set mux as MPP muxltiplexer, it is true;
+ * If set mux to SDIO/eMMC controller, it is false.
+ * Return: void, always success.
+ */
+static void armada_cp110_mpp_mmc_mux_set(void __iomem *addr, bool is_mpp_mux)
+{
+	u32 reg;
+
+	/*
+	 * eMMC/SD PHY register responsible for muxing between MPPs and SD/eMMC
+	 * controller:
+	 * - Bit0 enabled SDIO/eMMC PHY is used as a MPP muxltiplexer,
+	 * - Bit0 disabled SDIO/eMMC PHY is connected to SDIO/eMMC controller
+	 */
+	reg = readl(addr);
+
+	if (is_mpp_mux)
+		reg |= EMMC_PHY_CTRL_SDPHY_EN; /* set mux MPP muxltiplexer */
+	else
+		reg &= ~EMMC_PHY_CTRL_SDPHY_EN; /* set mux SDIO/eMMC controller */
+
+	writel(reg, addr);
+}
 
 static int armada_cp110_0_mpp_ctrl_get(unsigned pid, unsigned long *config)
 {
@@ -36,6 +70,21 @@ static int armada_cp110_0_mpp_ctrl_get(unsigned pid, unsigned long *config)
 
 static int armada_cp110_0_mpp_ctrl_set(unsigned pid, unsigned long config)
 {
+	/*
+	 * To enable SDIO/eMMC in CP110-0, need to configure PHY mux.
+	 * If pin function is set to eMMC/SD, then configure the eMMC/SD PHY
+	 * muxltiplexer register to be on SDIO/eMMC controller
+	 * If the MPP is configured to sdio, the pin0 as clk is mandatory,
+	 * to avoid config eMMC/SD PHY register repeatly, it is ok to set the
+	 * register only when MPP pin0(pid==56) is configured as "sdio"
+	 * (config == 14).
+	 */
+	if (cp0_emmc_phy_ctrl_reg && pid == CP110_0_EMMC_CLK_PIN_ID) {
+		bool is_mpp_mux = (config == CP110_0_EMMC_CLK_FUNC) ? false : true;
+
+		armada_cp110_mpp_mmc_mux_set(cp0_emmc_phy_ctrl_reg, is_mpp_mux);
+	}
+
 	return default_mpp_ctrl_set(cp0_mpp_base, pid, config);
 }
 
@@ -666,7 +715,7 @@ static int armada_cp110_pinctrl_probe(struct platform_device *pdev)
 	struct mvebu_pinctrl_soc_info *soc;
 	const struct of_device_id *match =
 		of_match_device(armada_cp110_pinctrl_of_match, &pdev->dev);
-	struct resource *res;
+	struct resource *res, *res_mmcio;
 #ifdef CONFIG_PM
 	struct mvebu_pinctrl_pm_save *pm_save;
 #endif
@@ -689,6 +738,19 @@ static int armada_cp110_pinctrl_probe(struct platform_device *pdev)
 		cp0_mpp_base = devm_ioremap_resource(&pdev->dev, res);
 		if (IS_ERR(cp0_mpp_base))
 			return PTR_ERR(cp0_mpp_base);
+		/*
+		 * Get the eMMC PHY IO Control 0 Register base
+		 * Usage of this reg will be required in case MMC is enabled.
+		 */
+		res_mmcio = platform_get_resource_byname(pdev, IORESOURCE_MEM, "mmcio");
+		if (res_mmcio) {
+			cp0_emmc_phy_ctrl_reg = devm_ioremap_resource(&pdev->dev,
+								      res_mmcio);
+			if (IS_ERR(cp0_emmc_phy_ctrl_reg))
+				return PTR_ERR(cp0_emmc_phy_ctrl_reg);
+		} else {
+			dev_warn(&pdev->dev, "CP0 mmcio reg not present in DT\n");
+		}
 		soc->controls = armada_cp110_0_mpp_controls;
 		soc->ncontrols = ARRAY_SIZE(armada_cp110_0_mpp_controls);
 		soc->gpioranges = armada_cp110_0_mpp_gpio_ranges;
-- 
2.7.4

