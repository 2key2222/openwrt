From c89367956524a11595a320b90673294ce4658df3 Mon Sep 17 00:00:00 2001
From: Ken Ma <make@marvell.com>
Date: Sat, 11 Mar 2017 00:53:38 +0800
Subject: [PATCH 1506/2241] xhci-plat: add phy power opeartion in PM

- Add PHY power off/on to suspend/resume;
- XHCI's main hcd is for USB2 while its shared hcd is for USB3; If phys
  are separated for USB2 and USB3, then main hcd's phy represents the
  dedicated USB2 phy while shared hcd's phy represents the USB3 phy
  which is a different phy than main hcd, both phys must be powered
  off/on; otherwise the two hcds shares a same phy which is for both
  USB2 and USB3, this phy only needs to be power off/on once.

Change-Id: I9f3084496acc00d05fc6ab5c90393bbcddfc228e
Signed-off-by: Terry Zhou <bjzhou@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/34903
Reviewed-by: Victor Gu <xigu@marvell.com>
Tested-by: Victor Gu <xigu@marvell.com>
Signed-off-by: Ken Ma <make@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/37372
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Reviewed-by: Omri Itach <omrii@marvell.com>
---
 drivers/usb/host/xhci-plat.c | 63 +++++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 62 insertions(+), 1 deletion(-)

diff --git a/drivers/usb/host/xhci-plat.c b/drivers/usb/host/xhci-plat.c
index b9fbbf9..e9159dd 100644
--- a/drivers/usb/host/xhci-plat.c
+++ b/drivers/usb/host/xhci-plat.c
@@ -287,6 +287,7 @@ static int xhci_plat_suspend(struct device *dev)
 {
 	struct usb_hcd	*hcd = dev_get_drvdata(dev);
 	struct xhci_hcd	*xhci = hcd_to_xhci(hcd);
+	int ret;
 
 	/*
 	 * xhci_suspend() needs `do_wakeup` to know whether host is allowed
@@ -296,13 +297,73 @@ static int xhci_plat_suspend(struct device *dev)
 	 * reconsider this when xhci_plat_suspend enlarges its scope, e.g.,
 	 * also applies to runtime suspend.
 	 */
-	return xhci_suspend(xhci, device_may_wakeup(dev));
+	ret = xhci_suspend(xhci, device_may_wakeup(dev));
+	if (ret) {
+		dev_err(dev, "unable to suspend xhci\n");
+		return ret;
+	}
+
+	/*
+	* xhci's main hcd is for USB2 while its shared hcd is for USB3;
+	* If phys are separated for USB2 and USB3, then main hcd's phy
+	* represents the dedicated USB2 phy while shared hcd's phy
+	* represents the USB3 phy which is a different phy than main hcd, we
+	* must power off both phys; otherwise the two hcds shares a same
+	* phy which is for both USB2 and USB3, we only need to power off
+	* the phy once.
+	* Here hcd is the main hcd.
+	*/
+	phy_power_off(hcd->phy);
+	phy_exit(hcd->phy);
+
+	if (of_property_read_bool(dev->of_node, "separated-phys-for-usb2-usb3")) {
+		phy_power_off(xhci->shared_hcd->phy);
+		phy_exit(xhci->shared_hcd->phy);
+	}
+
+	return 0;
 }
 
 static int xhci_plat_resume(struct device *dev)
 {
 	struct usb_hcd	*hcd = dev_get_drvdata(dev);
 	struct xhci_hcd	*xhci = hcd_to_xhci(hcd);
+	int ret;
+
+	/*
+	* xhci's main hcd is for USB2 while its shared hcd is for USB3;
+	* If phys are separated for USB2 and USB3, then main hcd's phy
+	* represents the dedicated USB2 phy while shared hcd's phy
+	* represents the USB3 phy which is a different phy than main hcd, we
+	* must init and power on both phys; otherwise the two hcds shares
+	* a same phy which is for both USB2 and USB3, we only need to init
+	* and power on the phy once.
+	* Here hcd is the main hcd.
+	*/
+	ret = phy_init(hcd->phy);
+	if (ret)
+		return ret;
+
+	ret = phy_power_on(hcd->phy);
+	if (ret) {
+		phy_exit(hcd->phy);
+		return ret;
+	}
+
+	if (of_property_read_bool(dev->of_node, "separated-phys-for-usb2-usb3")) {
+		ret = phy_init(xhci->shared_hcd->phy);
+		if (ret)
+			return ret;
+
+		ret = phy_power_on(xhci->shared_hcd->phy);
+		if (ret) {
+			phy_exit(xhci->shared_hcd->phy);
+			/* roll back main hcd's phy */
+			phy_power_off(hcd->phy);
+			phy_exit(hcd->phy);
+			return ret;
+		}
+	}
 
 	return xhci_resume(xhci, 0);
 }
-- 
2.7.4

