From 0ea177659d4aa112902bc7d327df1f86eec78798 Mon Sep 17 00:00:00 2001
From: Ravindra <ravindra@marvell.com>
Date: Tue, 17 Jan 2017 14:55:17 +0530
Subject: [PATCH 1538/2241] net: dsa: add support for soho switches

This patch adds support for SOHO family of switches in
DSA driver. The changes enables use of 88e6190/88e6290/88e6390
switches. Driver name changed to "marvell,mv88e6xxx" from
"marvell,mv88e6085"

Change-Id: Ie406a16fa682eb890689713972ce05f491d009c4
Signed-off-by: Ravindra <ravindra@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/37436
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Reviewed-by: Stefan Chulski <stefanc@marvell.com>
Reviewed-by: Omri Itach <omrii@marvell.com>
---
 .../devicetree/bindings/net/dsa/marvell.txt        |  4 +-
 drivers/net/dsa/mv88e6xxx.c                        | 88 ++++++++++++++++------
 drivers/net/dsa/mv88e6xxx.h                        | 25 +++++-
 3 files changed, 93 insertions(+), 24 deletions(-)

diff --git a/Documentation/devicetree/bindings/net/dsa/marvell.txt b/Documentation/devicetree/bindings/net/dsa/marvell.txt
index 7629189..95ae605 100644
--- a/Documentation/devicetree/bindings/net/dsa/marvell.txt
+++ b/Documentation/devicetree/bindings/net/dsa/marvell.txt
@@ -14,7 +14,7 @@ The properties described here are those specific to Marvell devices.
 Additional required and optional properties can be found in dsa.txt.
 
 Required properties:
-- compatible           : Should be one of "marvell,mv88e6085",
+- compatible           : Should be one of "marvell,mv88e6xxx",
 - reg                  : Address on the MII bus for the switch.
 
 Optional properties:
@@ -28,7 +28,7 @@ Example:
                #size-cells = <0>;
 
                switch0: switch@0 {
-                       compatible = "marvell,mv88e6085";
+                       compatible = "marvell,mv88e6xxx";
                        reg = <0>;
 		       reset-gpios = <&gpio5 1 GPIO_ACTIVE_LOW>;
                };
diff --git a/drivers/net/dsa/mv88e6xxx.c b/drivers/net/dsa/mv88e6xxx.c
index 2738278..8957b7a 100644
--- a/drivers/net/dsa/mv88e6xxx.c
+++ b/drivers/net/dsa/mv88e6xxx.c
@@ -29,6 +29,8 @@
 #include <net/switchdev.h>
 #include "mv88e6xxx.h"
 
+static int REG_PORT_BASE = REG_PORT_BASE_LEGACY;
+
 static void assert_smi_lock(struct mv88e6xxx_priv_state *ps)
 {
 	if (unlikely(!mutex_is_locked(&ps->smi_mutex))) {
@@ -447,6 +449,11 @@ static bool mv88e6xxx_6352_family(struct mv88e6xxx_priv_state *ps)
 	return ps->info->family == MV88E6XXX_FAMILY_6352;
 }
 
+static bool mv88e6xxx_6390_family(struct mv88e6xxx_priv_state *ps)
+{
+	return ps->info->family == MV88E6XXX_FAMILY_6390;
+}
+
 static unsigned int mv88e6xxx_num_databases(struct mv88e6xxx_priv_state *ps)
 {
 	return ps->info->num_databases;
@@ -456,7 +463,8 @@ static bool mv88e6xxx_has_fid_reg(struct mv88e6xxx_priv_state *ps)
 {
 	/* Does the device have dedicated FID registers for ATU and VTU ops? */
 	if (mv88e6xxx_6097_family(ps) || mv88e6xxx_6165_family(ps) ||
-	    mv88e6xxx_6351_family(ps) || mv88e6xxx_6352_family(ps))
+	    mv88e6xxx_6351_family(ps) || mv88e6xxx_6352_family(ps) ||
+	    mv88e6xxx_6390_family(ps))
 		return true;
 
 	return false;
@@ -514,8 +522,8 @@ static void mv88e6xxx_adjust_link(struct dsa_switch *ds, int port,
 	if (phydev->duplex == DUPLEX_FULL)
 		reg |= PORT_PCS_CTRL_DUPLEX_FULL;
 
-	if ((mv88e6xxx_6352_family(ps) || mv88e6xxx_6351_family(ps)) &&
-	    (port >= ps->info->num_ports - 2)) {
+	if ((mv88e6xxx_6352_family(ps) || mv88e6xxx_6351_family(ps) ||
+	     mv88e6xxx_6390_family(ps)) && (port >= ps->info->num_ports - 2)) {
 		if (phydev->interface == PHY_INTERFACE_MODE_RGMII_RXID)
 			reg |= PORT_PCS_CTRL_RGMII_DELAY_RXCLK;
 		if (phydev->interface == PHY_INTERFACE_MODE_RGMII_TXID)
@@ -549,7 +557,8 @@ static int _mv88e6xxx_stats_snapshot(struct mv88e6xxx_priv_state *ps,
 {
 	int ret;
 
-	if (mv88e6xxx_6320_family(ps) || mv88e6xxx_6352_family(ps))
+	if (mv88e6xxx_6320_family(ps) || mv88e6xxx_6352_family(ps) ||
+	    mv88e6xxx_6390_family(ps))
 		port = (port + 1) << 5;
 
 	/* Snapshot the hardware statistics counters for this port. */
@@ -674,7 +683,8 @@ static bool mv88e6xxx_has_stat(struct mv88e6xxx_priv_state *ps,
 			mv88e6xxx_6097_family(ps) ||
 			mv88e6xxx_6165_family(ps) ||
 			mv88e6xxx_6351_family(ps) ||
-			mv88e6xxx_6352_family(ps);
+			mv88e6xxx_6352_family(ps) ||
+			mv88e6xxx_6390_family(ps);
 	}
 	return false;
 }
@@ -1936,7 +1946,8 @@ static int _mv88e6xxx_vtu_new(struct mv88e6xxx_priv_state *ps, u16 vid,
 			: GLOBAL_VTU_DATA_MEMBER_TAG_NON_MEMBER;
 
 	if (mv88e6xxx_6097_family(ps) || mv88e6xxx_6165_family(ps) ||
-	    mv88e6xxx_6351_family(ps) || mv88e6xxx_6352_family(ps)) {
+	    mv88e6xxx_6351_family(ps) || mv88e6xxx_6352_family(ps) ||
+	    mv88e6xxx_6390_family(ps)) {
 		struct mv88e6xxx_vtu_stu_entry vstp;
 
 		/* Adding a VTU entry requires a valid STU entry. As VSTP is not
@@ -2670,7 +2681,8 @@ static int mv88e6xxx_setup_port(struct mv88e6xxx_priv_state *ps, int port)
 	if (mv88e6xxx_6352_family(ps) || mv88e6xxx_6351_family(ps) ||
 	    mv88e6xxx_6165_family(ps) || mv88e6xxx_6097_family(ps) ||
 	    mv88e6xxx_6185_family(ps) || mv88e6xxx_6095_family(ps) ||
-	    mv88e6xxx_6065_family(ps) || mv88e6xxx_6320_family(ps)) {
+	    mv88e6xxx_6065_family(ps) || mv88e6xxx_6320_family(ps) ||
+	    mv88e6xxx_6390_family(ps)) {
 		/* MAC Forcing register: don't force link, speed,
 		 * duplex or flow control state to any particular
 		 * values on physical ports, but force the CPU port
@@ -2722,7 +2734,8 @@ static int mv88e6xxx_setup_port(struct mv88e6xxx_priv_state *ps, int port)
 	if (mv88e6xxx_6352_family(ps) || mv88e6xxx_6351_family(ps) ||
 	    mv88e6xxx_6165_family(ps) || mv88e6xxx_6097_family(ps) ||
 	    mv88e6xxx_6095_family(ps) || mv88e6xxx_6065_family(ps) ||
-	    mv88e6xxx_6185_family(ps) || mv88e6xxx_6320_family(ps))
+	    mv88e6xxx_6185_family(ps) || mv88e6xxx_6320_family(ps) ||
+	    mv88e6xxx_6390_family(ps))
 		reg = PORT_CONTROL_IGMP_MLD_SNOOP |
 		PORT_CONTROL_USE_TAG | PORT_CONTROL_USE_IP |
 		PORT_CONTROL_STATE_FORWARDING;
@@ -2731,7 +2744,7 @@ static int mv88e6xxx_setup_port(struct mv88e6xxx_priv_state *ps, int port)
 			reg |= PORT_CONTROL_DSA_TAG;
 		if (mv88e6xxx_6352_family(ps) || mv88e6xxx_6351_family(ps) ||
 		    mv88e6xxx_6165_family(ps) || mv88e6xxx_6097_family(ps) ||
-		    mv88e6xxx_6320_family(ps)) {
+		    mv88e6xxx_6320_family(ps) || mv88e6xxx_6390_family(ps)) {
 			reg |= PORT_CONTROL_FRAME_ETHER_TYPE_DSA |
 				PORT_CONTROL_FORWARD_UNKNOWN |
 				PORT_CONTROL_FORWARD_UNKNOWN_MC;
@@ -2740,7 +2753,8 @@ static int mv88e6xxx_setup_port(struct mv88e6xxx_priv_state *ps, int port)
 		if (mv88e6xxx_6352_family(ps) || mv88e6xxx_6351_family(ps) ||
 		    mv88e6xxx_6165_family(ps) || mv88e6xxx_6097_family(ps) ||
 		    mv88e6xxx_6095_family(ps) || mv88e6xxx_6065_family(ps) ||
-		    mv88e6xxx_6185_family(ps) || mv88e6xxx_6320_family(ps)) {
+		    mv88e6xxx_6185_family(ps) || mv88e6xxx_6320_family(ps) ||
+		    mv88e6xxx_6390_family(ps)) {
 				reg |= PORT_CONTROL_EGRESS_ADD_TAG;
 		}
 	}
@@ -2749,7 +2763,7 @@ static int mv88e6xxx_setup_port(struct mv88e6xxx_priv_state *ps, int port)
 			reg |= PORT_CONTROL_DSA_TAG;
 		if (mv88e6xxx_6352_family(ps) || mv88e6xxx_6351_family(ps) ||
 		    mv88e6xxx_6165_family(ps) || mv88e6xxx_6097_family(ps) ||
-		    mv88e6xxx_6320_family(ps)) {
+		    mv88e6xxx_6320_family(ps) || mv88e6xxx_6390_family(ps)) {
 			reg |= PORT_CONTROL_FRAME_MODE_DSA;
 		}
 
@@ -2767,7 +2781,7 @@ static int mv88e6xxx_setup_port(struct mv88e6xxx_priv_state *ps, int port)
 	/* If this port is connected to a SerDes, make sure the SerDes is not
 	 * powered down.
 	 */
-	if (mv88e6xxx_6352_family(ps)) {
+	if (mv88e6xxx_6352_family(ps) || mv88e6xxx_6390_family(ps)) {
 		ret = _mv88e6xxx_reg_read(ps, REG_PORT(port), PORT_STATUS);
 		if (ret < 0)
 			return ret;
@@ -2791,11 +2805,12 @@ static int mv88e6xxx_setup_port(struct mv88e6xxx_priv_state *ps, int port)
 	if (mv88e6xxx_6352_family(ps) || mv88e6xxx_6351_family(ps) ||
 	    mv88e6xxx_6165_family(ps) || mv88e6xxx_6097_family(ps) ||
 	    mv88e6xxx_6095_family(ps) || mv88e6xxx_6320_family(ps) ||
-	    mv88e6xxx_6185_family(ps))
+	    mv88e6xxx_6185_family(ps) || mv88e6xxx_6390_family(ps))
 		reg = PORT_CONTROL_2_MAP_DA;
 
 	if (mv88e6xxx_6352_family(ps) || mv88e6xxx_6351_family(ps) ||
-	    mv88e6xxx_6165_family(ps) || mv88e6xxx_6320_family(ps))
+	    mv88e6xxx_6165_family(ps) || mv88e6xxx_6320_family(ps) ||
+	    mv88e6xxx_6390_family(ps))
 		reg |= PORT_CONTROL_2_JUMBO_10240;
 
 	if (mv88e6xxx_6095_family(ps) || mv88e6xxx_6185_family(ps)) {
@@ -2839,7 +2854,7 @@ static int mv88e6xxx_setup_port(struct mv88e6xxx_priv_state *ps, int port)
 
 	if (mv88e6xxx_6352_family(ps) || mv88e6xxx_6351_family(ps) ||
 	    mv88e6xxx_6165_family(ps) || mv88e6xxx_6097_family(ps) ||
-	    mv88e6xxx_6320_family(ps)) {
+	    mv88e6xxx_6320_family(ps) || mv88e6xxx_6390_family(ps)) {
 		/* Do not limit the period of time that this port can
 		 * be paused for by the remote end or the period of
 		 * time that this port can pause the remote end.
@@ -2890,7 +2905,7 @@ static int mv88e6xxx_setup_port(struct mv88e6xxx_priv_state *ps, int port)
 	if (mv88e6xxx_6352_family(ps) || mv88e6xxx_6351_family(ps) ||
 	    mv88e6xxx_6165_family(ps) || mv88e6xxx_6097_family(ps) ||
 	    mv88e6xxx_6185_family(ps) || mv88e6xxx_6095_family(ps) ||
-	    mv88e6xxx_6320_family(ps)) {
+	    mv88e6xxx_6320_family(ps) || mv88e6xxx_6390_family(ps)) {
 		/* Rate Control: disable ingress rate limiting. */
 		ret = _mv88e6xxx_reg_write(ps, REG_PORT(port),
 					   PORT_RATE_CONTROL, 0x0001);
@@ -3062,7 +3077,7 @@ static int mv88e6xxx_setup_global(struct mv88e6xxx_priv_state *ps)
 
 	if (mv88e6xxx_6352_family(ps) || mv88e6xxx_6351_family(ps) ||
 	    mv88e6xxx_6165_family(ps) || mv88e6xxx_6097_family(ps) ||
-	    mv88e6xxx_6320_family(ps)) {
+	    mv88e6xxx_6320_family(ps) || mv88e6xxx_6390_family(ps)) {
 		/* Send all frames with destination addresses matching
 		 * 01:80:c2:00:00:2x to the CPU port.
 		 */
@@ -3092,7 +3107,7 @@ static int mv88e6xxx_setup_global(struct mv88e6xxx_priv_state *ps)
 	if (mv88e6xxx_6352_family(ps) || mv88e6xxx_6351_family(ps) ||
 	    mv88e6xxx_6165_family(ps) || mv88e6xxx_6097_family(ps) ||
 	    mv88e6xxx_6185_family(ps) || mv88e6xxx_6095_family(ps) ||
-	    mv88e6xxx_6320_family(ps)) {
+	    mv88e6xxx_6320_family(ps) || mv88e6xxx_6390_family(ps)) {
 		/* Disable ingress rate limiting by resetting all
 		 * ingress rate limit registers to their initial
 		 * state.
@@ -3374,7 +3389,8 @@ static int mv88e6xxx_get_temp(struct dsa_switch *ds, int *temp)
 	if (!mv88e6xxx_has(ps, MV88E6XXX_FLAG_TEMP))
 		return -EOPNOTSUPP;
 
-	if (mv88e6xxx_6320_family(ps) || mv88e6xxx_6352_family(ps))
+	if (mv88e6xxx_6320_family(ps) || mv88e6xxx_6352_family(ps) ||
+	    mv88e6xxx_6390_family(ps))
 		return mv88e63xx_get_temp(ds, temp);
 
 	return mv88e61xx_get_temp(ds, temp);
@@ -3599,6 +3615,32 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
 		.num_ports = 6,
 		.flags = MV88E6XXX_FLAGS_FAMILY_6352 | MV88E6XXX_FLAG_PHY_ADDR,
 	},
+	[MV88E6390] = {
+		.prod_num = PORT_SWITCH_ID_PROD_NUM_6390,
+		.family = MV88E6XXX_FAMILY_6390,
+		.name = "Marvell 88E6390",
+		.num_databases = 4096,
+		.num_ports = 11,
+		.flags = MV88E6XXX_FLAGS_FAMILY_6390 | MV88E6XXX_FLAG_PHY_ADDR,
+	},
+
+	[MV88E6290] = {
+		.prod_num = PORT_SWITCH_ID_PROD_NUM_6290,
+		.family = MV88E6XXX_FAMILY_6390,
+		.name = "Marvell 88E6290",
+		.num_databases = 4096,
+		.num_ports = 11,
+		.flags = MV88E6XXX_FLAGS_FAMILY_6390 | MV88E6XXX_FLAG_PHY_ADDR,
+	},
+
+	[MV88E6190] = {
+		.prod_num = PORT_SWITCH_ID_PROD_NUM_6190,
+		.family = MV88E6XXX_FAMILY_6390,
+		.name = "Marvell 88E6190",
+		.num_databases = 4096,
+		.num_ports = 11,
+		.flags = MV88E6XXX_FLAGS_FAMILY_6390 | MV88E6XXX_FLAG_PHY_ADDR,
+	},
 };
 
 static const struct mv88e6xxx_info *
@@ -3733,6 +3775,10 @@ int mv88e6xxx_probe(struct mdio_device *mdiodev)
 
 	prod_num = (id & 0xfff0) >> 4;
 	rev = id & 0x000f;
+	if ((prod_num == PORT_SWITCH_ID_PROD_NUM_6190) ||
+	    (prod_num == PORT_SWITCH_ID_PROD_NUM_6290) ||
+	    (prod_num == PORT_SWITCH_ID_PROD_NUM_6390))
+		REG_PORT_BASE = REG_PORT_BASE_PERIDOT;
 
 	ps->info = mv88e6xxx_lookup_info(prod_num, mv88e6xxx_table,
 					 ARRAY_SIZE(mv88e6xxx_table));
@@ -3786,7 +3832,7 @@ static void mv88e6xxx_remove(struct mdio_device *mdiodev)
 }
 
 static const struct of_device_id mv88e6xxx_of_match[] = {
-	{ .compatible = "marvell,mv88e6085" },
+	{ .compatible = "marvell,mv88e6xxx" },
 	{ /* sentinel */ },
 };
 
@@ -3796,7 +3842,7 @@ static struct mdio_driver mv88e6xxx_driver = {
 	.probe	= mv88e6xxx_probe,
 	.remove = mv88e6xxx_remove,
 	.mdiodrv.driver = {
-		.name = "mv88e6085",
+		.name = "mv88e6xxx",
 		.of_match_table = mv88e6xxx_of_match,
 	},
 };
diff --git a/drivers/net/dsa/mv88e6xxx.h b/drivers/net/dsa/mv88e6xxx.h
index 4572e6b..9addb3c 100644
--- a/drivers/net/dsa/mv88e6xxx.h
+++ b/drivers/net/dsa/mv88e6xxx.h
@@ -33,7 +33,9 @@
 #define REG_FIBER_SERDES	0x0f
 #define PAGE_FIBER_SERDES	0x01
 
-#define REG_PORT(p)		(0x10 + (p))
+#define REG_PORT_BASE_LEGACY 0x10
+#define REG_PORT_BASE_PERIDOT  0
+#define REG_PORT(p)		(REG_PORT_BASE + (p))
 #define PORT_STATUS		0x00
 #define PORT_STATUS_PAUSE_EN	BIT(15)
 #define PORT_STATUS_MY_PAUSE	BIT(14)
@@ -88,6 +90,9 @@
 #define PORT_SWITCH_ID_PROD_NUM_6352	0x352
 #define PORT_SWITCH_ID_PROD_NUM_6350	0x371
 #define PORT_SWITCH_ID_PROD_NUM_6351	0x375
+#define PORT_SWITCH_ID_PROD_NUM_6190	0x190
+#define PORT_SWITCH_ID_PROD_NUM_6290	0x290
+#define PORT_SWITCH_ID_PROD_NUM_6390	0x390
 #define PORT_CONTROL		0x04
 #define PORT_CONTROL_USE_CORE_TAG	BIT(15)
 #define PORT_CONTROL_DROP_ON_LOCK	BIT(14)
@@ -361,6 +366,9 @@ enum mv88e6xxx_model {
 	MV88E6350,
 	MV88E6351,
 	MV88E6352,
+	MV88E6190,
+	MV88E6290,
+	MV88E6390,
 };
 
 enum mv88e6xxx_family {
@@ -373,6 +381,7 @@ enum mv88e6xxx_family {
 	MV88E6XXX_FAMILY_6320,	/* 6320 6321 */
 	MV88E6XXX_FAMILY_6351,	/* 6171 6175 6350 6351 */
 	MV88E6XXX_FAMILY_6352,	/* 6172 6176 6240 6341 6352 */
+	MV88E6XXX_FAMILY_6390,	/* 6190 6190X 6290 6390 6390X*/
 };
 
 enum mv88e6xxx_cap {
@@ -524,6 +533,20 @@ enum mv88e6xxx_cap {
 	 MV88E6XXX_FLAG_VLANTABLE |	\
 	 MV88E6XXX_FLAG_VTU)
 
+#define MV88E6XXX_FLAGS_FAMILY_6390	\
+	(MV88E6XXX_FLAG_ATU |		\
+	 MV88E6XXX_FLAG_EEE |		\
+	 MV88E6XXX_FLAG_EEPROM |	\
+	 MV88E6XXX_FLAG_PORTSTATE |	\
+	 MV88E6XXX_FLAG_PPU_ACTIVE |	\
+	 MV88E6XXX_FLAG_SMI_PHY |	\
+	 MV88E6XXX_FLAG_STU |		\
+	 MV88E6XXX_FLAG_SWITCH_MAC |	\
+	 MV88E6XXX_FLAG_TEMP |		\
+	 MV88E6XXX_FLAG_TEMP_LIMIT |	\
+	 MV88E6XXX_FLAG_VLANTABLE |	\
+	 MV88E6XXX_FLAG_VTU)
+
 struct mv88e6xxx_info {
 	enum mv88e6xxx_family family;
 	u16 prod_num;
-- 
2.7.4

