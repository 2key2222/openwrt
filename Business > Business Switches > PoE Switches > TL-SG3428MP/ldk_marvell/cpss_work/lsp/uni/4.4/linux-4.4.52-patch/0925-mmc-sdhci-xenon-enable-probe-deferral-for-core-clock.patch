From cded3174115060dea2858e8cf4fc8773e2d8fd40 Mon Sep 17 00:00:00 2001
From: Marcin Wojtas <mw@semihalf.com>
Date: Sun, 28 Aug 2016 05:44:34 +0200
Subject: [PATCH 0925/2241] mmc: sdhci-xenon: enable probe deferral for core
 clock

Once sdhci-xenon is enabled on CP110 it is likely it would have
to defer a probe due to late enabling of CP110 system controller
clocks. This commit enables deferring and cleans up the clock
support.

result of devm_clk_get() takes possible probe deferral
into consideration, which is needed on a7k/a8k, because CP110 system
controller clocks are registered as normal driver (not using
CLK_OF_DECLARE macro for probing).

In practice, such issue is seen on the ARM64 Marvell 7K/8K platform,
where the clocks are registered by a platform driver.

This patch is part of patch-set which adds
mainline mvebu clock gating support [21/21].

Change-Id: If0f6c47d078e61510b83fcc2a548f36a87913742
Signed-off-by: Marcin Wojtas <mw@semihalf.com>
Signed-off-by: Igal Liberman <igall@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/32406
Reviewed-by: Hanna Hawa <hannah@marvell.com>
Reviewed-by: Omri Itach <omrii@marvell.com>
Tested-by: Omri Itach <omrii@marvell.com>
---
 drivers/mmc/host/sdhci-xenon.c | 32 +++++++++++++++++++-------------
 1 file changed, 19 insertions(+), 13 deletions(-)

diff --git a/drivers/mmc/host/sdhci-xenon.c b/drivers/mmc/host/sdhci-xenon.c
index a55ea3c..45697d8 100644
--- a/drivers/mmc/host/sdhci-xenon.c
+++ b/drivers/mmc/host/sdhci-xenon.c
@@ -495,7 +495,6 @@ static int sdhci_xenon_probe(struct platform_device *pdev)
 {
 	struct sdhci_pltfm_host *pltfm_host;
 	struct sdhci_host *host;
-	struct clk *clk, *axi_clk;
 	struct sdhci_xenon_priv *priv;
 	int err;
 
@@ -513,25 +512,31 @@ static int sdhci_xenon_probe(struct platform_device *pdev)
 	 */
 	xenon_replace_mmc_host_ops(host);
 
-	clk = devm_clk_get(&pdev->dev, "core");
-	if (IS_ERR(clk)) {
+	pltfm_host->clk = devm_clk_get(&pdev->dev, "core");
+	if (!IS_ERR(pltfm_host->clk)) {
+		err = clk_prepare_enable(pltfm_host->clk);
+		if (err)
+			goto free_pltfm;
+	} else if (PTR_ERR(pltfm_host->clk) == -EPROBE_DEFER) {
+		err = -EPROBE_DEFER;
+		goto free_pltfm;
+	} else {
 		pr_err("%s: Failed to setup input clk.\n",
 			mmc_hostname(host->mmc));
-		err = PTR_ERR(clk);
+		err = PTR_ERR(pltfm_host->clk);
 		goto free_pltfm;
 	}
-	clk_prepare_enable(clk);
-	pltfm_host->clk = clk;
 
 	/*
 	 * Some SOCs require additional clock to
 	 * manage AXI bus clock.
 	 * It is optional.
 	 */
-	axi_clk = devm_clk_get(&pdev->dev, "axi");
-	if (!IS_ERR(axi_clk)) {
-		clk_prepare_enable(axi_clk);
-		priv->axi_clk = axi_clk;
+	priv->axi_clk = devm_clk_get(&pdev->dev, "axi");
+	if (!IS_ERR(priv->axi_clk)) {
+		err = clk_prepare_enable(priv->axi_clk);
+		if (err)
+			goto err_clk;
 	}
 
 	err = xenon_probe_dt(pdev);
@@ -560,9 +565,10 @@ static int sdhci_xenon_probe(struct platform_device *pdev)
 remove_slot:
 	xenon_slot_remove(host);
 err_clk:
-	clk_disable_unprepare(pltfm_host->clk);
-	if (!IS_ERR(axi_clk))
-		clk_disable_unprepare(axi_clk);
+	if (!IS_ERR(pltfm_host->clk))
+		clk_disable_unprepare(pltfm_host->clk);
+	if (!IS_ERR(priv->axi_clk))
+		clk_disable_unprepare(priv->axi_clk);
 free_pltfm:
 	sdhci_pltfm_free(pdev);
 	return err;
-- 
2.7.4

