From 6fc31899509147ec3aa43d0241648b34455fd995 Mon Sep 17 00:00:00 2001
From: Ken Ma <make@marvell.com>
Date: Tue, 8 Aug 2017 15:57:27 +0800
Subject: [PATCH 1925/2241] ARM64: pinctrl: marvell: armada-37xx: clean old
 pinctrl/gpio driver

Now new pinctrl/gpio driver(pinctrl-armada-37xx.c) has taken place of
old pinctrl/gpio driver, this patch clean old pinctrl/gpio driver.

Change-Id: Icadb3789327850271d12f61b800e8e2b925f8858
Signed-off-by: Ken Ma <make@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/42784
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Reviewed-by: Victor Gu <xigu@marvell.com>
---
 .../devicetree/bindings/gpio/gpio-armada-3700.txt  |   67 --
 .../pinctrl/marvell,armada-3700-pinctrl.txt        |  165 ----
 arch/arm64/Kconfig.platforms                       |    1 -
 arch/arm64/boot/dts/marvell/armada-37xx.dtsi       |   64 --
 arch/arm64/configs/mvebu_v8_lsp_defconfig          |    1 -
 drivers/gpio/Kconfig                               |   16 -
 drivers/gpio/Makefile                              |    1 -
 drivers/gpio/gpio-armada-3700.c                    |  726 --------------
 drivers/pinctrl/mvebu/Kconfig                      |    4 -
 drivers/pinctrl/mvebu/pinctrl-armada-3700.c        | 1038 --------------------
 10 files changed, 2083 deletions(-)
 delete mode 100644 Documentation/devicetree/bindings/gpio/gpio-armada-3700.txt
 delete mode 100644 Documentation/devicetree/bindings/pinctrl/marvell,armada-3700-pinctrl.txt
 delete mode 100644 drivers/gpio/gpio-armada-3700.c
 delete mode 100644 drivers/pinctrl/mvebu/pinctrl-armada-3700.c

diff --git a/Documentation/devicetree/bindings/gpio/gpio-armada-3700.txt b/Documentation/devicetree/bindings/gpio/gpio-armada-3700.txt
deleted file mode 100644
index fd02609..0000000
--- a/Documentation/devicetree/bindings/gpio/gpio-armada-3700.txt
+++ /dev/null
@@ -1,67 +0,0 @@
-* Marvell armada-3700 GPIO controller
-
-Required properties:
-
-- compatible : Should be "marvell,armada3700-gpio".
-
-- reg: Address and length of the register set for the device. 2
-  entries are expected, one for the general registers,
-  one for the interrupt registers.
-
-- interrupts: The list of interrupts that are used for all the pins
-  managed by this GPIO bank.
-
-- interrupt-controller: Identifies the node as an interrupt controller,
-  armada3700 gpio interrupt controller are cascaded to root gic interrupt
-  controller.
-
-- #interrupt-cells: Specifies the number of cells needed to encode an
-  interrupt source. Should be two.
-  The first cell is the GPIO number.
-  The second cell is used to specify flags:
-    bits[3:0] trigger type and level flags:
-      1 = low-to-high edge triggered.
-      2 = high-to-low edge triggered.
-      4 = active high level-sensitive.
-      8 = active low level-sensitive.
-    Armada-3700 only supports edge type gpio interrupts.
-
-- gpio-controller: Marks the device node as a GPIO controller
-
-- ngpios: Number of GPIOs this controller has
-
-- #gpio-cells: Should be two. The first cell is the pin number. The
-  second cell is reserved for flags, unused at the moment.
-
-Optional:
-- gpiobase: The base of the GPIO bank, if not defined the base calculated by
-  multiplying the bank ID number by MVEBU_MAX_GPIO_PER_BANK_A3700 (36)
-  This option used in Armada-3700 SoC, because the GPIOs count is different between banks
-  In Armada-3700: north bridge has 36 GPIOs and south bridge has 30 GPIOs,
-  The base of north bridge gpio bank should be 0 and the base of south bridge gpio bank
-  should be 36
-
-Example:
-		gpio_nb: gpio@13800 {
-			compatible = "marvell,armada3700-gpio";
-			reg = <0x13800 0x30
-				0x13c00 0x20>;
-			ngpios = <36>;
-			gpiobase = <0>;
-			gpio-controller;
-			#gpio-cells = <2>;
-			interrupt-controller;
-			#interrupt-cells = <2>;
-			interrupts = <GIC_SPI 51 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 52 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 53 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 54 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 55 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 56 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 57 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 58 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 152 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 153 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 154 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 155 IRQ_TYPE_LEVEL_HIGH>;
-		};
diff --git a/Documentation/devicetree/bindings/pinctrl/marvell,armada-3700-pinctrl.txt b/Documentation/devicetree/bindings/pinctrl/marvell,armada-3700-pinctrl.txt
deleted file mode 100644
index a08cacc..0000000
--- a/Documentation/devicetree/bindings/pinctrl/marvell,armada-3700-pinctrl.txt
+++ /dev/null
@@ -1,165 +0,0 @@
-* Marvell Armada 3700 SoC pinctrl driver for mpp
-
-Please refer to marvell,mvebu-pinctrl.txt in this directory for common binding
-part and usage.
-
-Required properties:
-- compatible: "marvell,armada-3700-nb-pinctrl", "marvell,armada-3700-sb-pinctrl"
-	      "marvell,armada-3700-z1-nb-pinctrl", "marvell,armada-3700-z1-sb-pinctrl"
-- reg: register specifier of MPP registers
-
-Available mpp pins/groups and functions:
-Note: brackets (x) are not part of the mpp name for marvell,function and given
-only for more detailed description in this document. Customer should make sure
-that there are no mpps configuration conflicts.
-
-North bridge: "marvell,armada-3700-z1-nb-pinctrl"
-name          pins     functions
-================================================================================
-mpp0          0        i2c1(sck), gpio
-mpp1          1        i2c1(sda), gpio
-mpp2          2        i2c2(sck), gpio
-mpp3          3        i2c2(sda), gpio
-mpp4          4        1wire, gpio
-mpp5          5        gpio
-mpp6          6        pmic0(slp-out), gpio
-mpp7          7        pmic1(slp-out), gpio
-mpp8          8        sdio, gpio
-mpp9          9        sdio, gpio, uart2(rts)
-mpp10         10       sdio, gpio, uart2(cts)
-mpp11         11       pwm0, gpio, led0-od
-mpp12         12       pwm1, gpio, led1-od
-mpp13         13       pwm2, gpio, led2-od
-mpp14         14       pwm3, gpio, led3-od
-mpp15         15       spi-quad, gpio
-mpp16         16       spi-quad, gpio
-mpp17         17       spi-cs1, gpio
-mpp18         18       spi-cs2, gpio, uart2(tx)
-mpp19         19       spi-cs3, gpio, uart2(rx)
-mpp20         20       jtag, gpio
-mpp21         21       jtag, gpio
-mpp22         22       jtag, gpio
-mpp23         23       jtag, gpio
-mpp24         24       jtag, gpio
-mpp25         25       uart1, gpio
-mpp26         26       uart1, gpio
-mpp27         27       mmc, gpio
-mpp28         28       mmc, gpio
-mpp29         29       mmc, gpio
-mpp30         30       mmc, gpio
-mpp31         31       mmc, gpio
-mpp32         32       mmc, gpio
-mpp33         33       mmc, gpio
-mpp34         34       mmc, gpio
-mpp35         35       mmc, gpio
-mpp36         36       spi
-
-South bridge: "marvell,armada-3700-z1-sb-pinctrl"
-name          pins     functions
-================================================================================
-mpp0          0        usb32(drvvbus0), gpio
-mpp1          1        usb32(drvvbus1), gpio
-mpp2          2        gpio
-mpp3          3        pcie1(resetn), gpio
-mpp4          4        pcie1(clkreq), gpio
-mpp5          5        gpio
-mpp6          6        rgmii/mii/smi, gpio
-mpp7          7        rgmii/mii/smi, gpio
-mpp8          8        rgmii/mii/smi, gpio
-mpp9          9        rgmii/mii/smi, gpio
-mpp10         10       rgmii/mii/smi, gpio
-mpp11         11       rgmii/mii/smi, gpio
-mpp12         12       rgmii/mii/smi, gpio
-mpp13         13       rgmii/mii/smi, gpio
-mpp14         14       rgmii/mii/smi, gpio
-mpp15         15       rgmii/mii/smi, gpio
-mpp16         16       rgmii/mii/smi, gpio
-mpp17         17       rgmii/mii/smi, gpio
-mpp18         18       rgmii/mii/smi, gpio
-mpp19         19       rgmii/mii/smi, gpio
-mpp20         20       ptp/mii, gpio
-mpp21         21       ptp(clk-req), gpio, mii(tx-err)
-mpp22         22       ptp(trig-gen), gpio, mii(carrier-sense)
-mpp23         23       rgmii/mii/smi, gpio, mii(tx-err)
-mpp24         24       sdio(sd0-d2), gpio
-mpp25         25       sdio(sd0-d3), gpio
-mpp26         26       sdio(sd0-d1), gpio
-mpp27         27       sdio(sd0-d0), gpio
-mpp28         28       sdio(sd0-cmd), gpio
-mpp29         29       sdio(sd0-clk), gpio
-
-
-North bridge: "marvell,armada-3700-nb-pinctrl"
-name          pins     functions
-================================================================================
-mpp0          0        i2c1(sck), gpio
-mpp1          1        i2c1(sda), gpio
-mpp2          2        i2c2(sck), gpio
-mpp3          3        i2c2(sda), gpio
-mpp4          4        1wire, gpio
-mpp5          5        gpio
-mpp6          6        pmic0(slp-out), gpio
-mpp7          7        pmic1(slp-out), gpio
-mpp8          8        sdio, gpio
-mpp9          9        sdio, gpio, uart2(rts)
-mpp10         10       sdio, gpio, uart2(cts)
-mpp11         11       pwm0, gpio, led0-od
-mpp12         12       pwm1, gpio, led1-od
-mpp13         13       pwm2, gpio, led2-od
-mpp14         14       pwm3, gpio, led3-od
-mpp15         15       spi-quad, gpio
-mpp16         16       spi-quad, gpio
-mpp17         17       spi-cs1, gpio
-mpp18         18       spi-cs2, gpio, uart2(tx)
-mpp19         19       spi-cs3, gpio, uart2(rx)
-mpp20         20       jtag, gpio
-mpp21         21       jtag, gpio
-mpp22         22       jtag, gpio
-mpp23         23       jtag, gpio
-mpp24         24       jtag, gpio
-mpp25         25       uart1, gpio
-mpp26         26       uart1, gpio
-mpp27         27       mmc, gpio
-mpp28         28       mmc, gpio
-mpp29         29       mmc, gpio
-mpp30         30       mmc, gpio
-mpp31         31       mmc, gpio
-mpp32         32       mmc, gpio
-mpp33         33       mmc, gpio
-mpp34         34       mmc, gpio
-mpp35         35       mmc, gpio
-mpp36         36       spi
-
-South bridge: "marvell,armada-3700-sb-pinctrl"
-name          pins     functions
-================================================================================
-mpp0          0        usb32(drvvbus0), gpio
-mpp1          1        usb32(drvvbus1), gpio
-mpp2          2        gpio
-mpp3          3        pcie1(resetn), gpio
-mpp4          4        pcie1(clkreq), gpio
-mpp5          5        pcie1(wakeup), gpio
-mpp6          6        rgmii, gpio
-mpp7          7        rgmii, gpio
-mpp8          8        rgmii, gpio
-mpp9          9        rgmii, gpio
-mpp10         10       rgmii, gpio
-mpp11         11       rgmii, gpio
-mpp12         12       rgmii, gpio
-mpp13         13       rgmii, gpio
-mpp14         14       rgmii, gpio
-mpp15         15       rgmii, gpio
-mpp16         16       rgmii, gpio
-mpp17         17       rgmii, gpio
-mpp18         18       smi, gpio
-mpp19         19       smi, gpio
-mpp20         20       ptp(event-req), gpio
-mpp21         21       ptp(clk-req), gpio, mii(tx-err)
-mpp22         22       ptp(trig-gen), gpio, mii(carrier-sense)
-mpp23         23       mii(collision), gpio, mii(tx-err)
-mpp24         24       sdio(sd0-d2), gpio
-mpp25         25       sdio(sd0-d3), gpio
-mpp26         26       sdio(sd0-d1), gpio
-mpp27         27       sdio(sd0-d0), gpio
-mpp28         28       sdio(sd0-cmd), gpio
-mpp29         29       sdio(sd0-clk), gpio
\ No newline at end of file
diff --git a/arch/arm64/Kconfig.platforms b/arch/arm64/Kconfig.platforms
index aaa2410..92b3685 100644
--- a/arch/arm64/Kconfig.platforms
+++ b/arch/arm64/Kconfig.platforms
@@ -12,7 +12,6 @@ config ARCH_MVEBU
 	select GPIOLIB_IRQCHIP
 	select OF_GPIO
 	select PINCTRL
-	select PINCTRL_ARMADA_3700
 	select PINCTRL_ARMADA_37XX
 	select ARMADA_AP806_CORE_CLK
 	select ARMADA_AP806_RING_CLK
diff --git a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
index 8a98d96..d26f748 100644
--- a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
+++ b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
@@ -61,8 +61,6 @@
 		ethernet1 = &eth1;
 		serial0 = &uart0;
 		serial1 = &uart1;
-		gpio0 = &gpio_nb;
-		gpio1 = &gpio_sb;
 	};
 
 	cluster0_opp: opp_table0 {
@@ -196,16 +194,6 @@
 				clocks = <&xtalclk>;
 			};
 
-			npinctrl: north-bridge-pinctrl@13830 {
-				compatible = "marvell,armada-3700-nb-pinctrl";
-				reg = <0x13830 0x4>;
-
-				spi0_pins: spi-pins-0 {
-					marvell,pins = "mpp36";
-					marvell,function = "spi";
-				};
-			};
-
 			cpu_pm_clk: cpu-pm-clk@14018 {
 				compatible = "marvell,armada-37xx-cpu-pm-clk";
 				reg = <0x14018 0x1C>;
@@ -213,16 +201,6 @@
 				clocks = <&nb_periph_clk 16>;
 			};
 
-			spinctrl: south-bridge-pinctrl@18830 {
-				compatible = "marvell,armada-3700-sb-pinctrl";
-				reg = <0x18830 0x4>;
-
-				cd_pins: cd-pins {
-					marvell,pins = "mpp2";
-					marvell,function = "gpio";
-				};
-			};
-
 			eth0: ethernet@30000 {
 				   compatible = "marvell,armada3700-neta";
 				   reg = <0x30000 0x4000>;
@@ -363,48 +341,6 @@
 				};
 			};
 
-			gpio_nb: gpio@13800 {
-				compatible = "marvell,armada3700-gpio",
-				"syscon", "simple-mfd";
-				reg = <0x13800 0x30
-					0x13c00 0x20>;
-				ngpios = <36>;
-				gpiobase = <0>;
-				gpio-controller;
-				#gpio-cells = <2>;
-				interrupt-controller;
-				#interrupt-cells = <2>;
-				interrupts = <GIC_SPI 51 IRQ_TYPE_LEVEL_HIGH>,
-					     <GIC_SPI 52 IRQ_TYPE_LEVEL_HIGH>,
-					     <GIC_SPI 53 IRQ_TYPE_LEVEL_HIGH>,
-					     <GIC_SPI 54 IRQ_TYPE_LEVEL_HIGH>,
-					     <GIC_SPI 55 IRQ_TYPE_LEVEL_HIGH>,
-					     <GIC_SPI 56 IRQ_TYPE_LEVEL_HIGH>,
-					     <GIC_SPI 57 IRQ_TYPE_LEVEL_HIGH>,
-					     <GIC_SPI 58 IRQ_TYPE_LEVEL_HIGH>,
-					     <GIC_SPI 152 IRQ_TYPE_LEVEL_HIGH>,
-					     <GIC_SPI 153 IRQ_TYPE_LEVEL_HIGH>,
-					     <GIC_SPI 154 IRQ_TYPE_LEVEL_HIGH>,
-					     <GIC_SPI 155 IRQ_TYPE_LEVEL_HIGH>;
-			};
-
-			gpio_sb: gpio@18800 {
-				compatible = "marvell,armada3700-gpio";
-				reg = <0x18800 0x30
-					0x18c00 0x20>;
-				ngpios = <30>;
-				gpiobase = <36>;
-				gpio-controller;
-				#gpio-cells = <2>;
-				interrupt-controller;
-				#interrupt-cells = <2>;
-				interrupts = <GIC_SPI 160 IRQ_TYPE_LEVEL_HIGH>,
-					     <GIC_SPI 159 IRQ_TYPE_LEVEL_HIGH>,
-					     <GIC_SPI 158 IRQ_TYPE_LEVEL_HIGH>,
-					     <GIC_SPI 157 IRQ_TYPE_LEVEL_HIGH>,
-					     <GIC_SPI 156 IRQ_TYPE_LEVEL_HIGH>;
-			};
-
 			u3d@50000 {
 				compatible = "marvell,armada3700-u3d";
 				/* 0: 0x50000: USB 3.0 Device port 0: DEV_INFO_REG(0:15 - version_id) */
diff --git a/arch/arm64/configs/mvebu_v8_lsp_defconfig b/arch/arm64/configs/mvebu_v8_lsp_defconfig
index 4833c6a..372ba0c 100644
--- a/arch/arm64/configs/mvebu_v8_lsp_defconfig
+++ b/arch/arm64/configs/mvebu_v8_lsp_defconfig
@@ -159,7 +159,6 @@ CONFIG_SPI_PL022=y
 CONFIG_SPI_ARMADA_3700=y
 CONFIG_GPIOLIB=y
 CONFIG_GPIO_SYSFS=y
-CONFIG_GPIO_MVEBU_A3700=y
 CONFIG_GPIO_PL061=y
 CONFIG_GPIO_XGENE=y
 CONFIG_GPIO_PCA953X=y
diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
index 949f92c..785a1bb 100644
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -295,22 +295,6 @@ config GPIO_MVEBU
 	depends on OF
 	select GENERIC_IRQ_CHIP
 
-config GPIO_MVEBU_A3700
-	bool "Marvell Armada 3700 GPIO support"
-	default n
-	depends on ARCH_MVEBU
-	depends on OF
-	select GENERIC_IRQ_CHIP
-	help
-	  If you say 'Yes' to this option, it
-	  selects the armada 3700 GPIO driver.
-	  Armada 3700 GPIO has 2 registers sets
-	  - general registers set and interrupt
-	  registers set. Armada 3700 gpio only
-	  supports edge interrupts, its gpio
-	  interrupt controllers are cascaded to
-	  root gic interrupt controller.
-
 config GPIO_MXC
 	def_bool y
 	depends on ARCH_MXC
diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
index bdc4cdf..986dbd8 100644
--- a/drivers/gpio/Makefile
+++ b/drivers/gpio/Makefile
@@ -67,7 +67,6 @@ obj-$(CONFIG_GPIO_MPC5200)	+= gpio-mpc5200.o
 obj-$(CONFIG_GPIO_MPC8XXX)	+= gpio-mpc8xxx.o
 obj-$(CONFIG_GPIO_MSIC)		+= gpio-msic.o
 obj-$(CONFIG_GPIO_MVEBU)        += gpio-mvebu.o
-obj-$(CONFIG_GPIO_MVEBU_A3700)	+= gpio-armada-3700.o
 obj-$(CONFIG_GPIO_MXC)		+= gpio-mxc.o
 obj-$(CONFIG_GPIO_MXS)		+= gpio-mxs.o
 obj-$(CONFIG_GPIO_OCTEON)	+= gpio-octeon.o
diff --git a/drivers/gpio/gpio-armada-3700.c b/drivers/gpio/gpio-armada-3700.c
deleted file mode 100644
index 71ee28f..0000000
--- a/drivers/gpio/gpio-armada-3700.c
+++ /dev/null
@@ -1,726 +0,0 @@
-/*
-* ***************************************************************************
-* Copyright (C) 2016 Marvell International Ltd.
-* ***************************************************************************
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are met:
-*
-* Redistributions of source code must retain the above copyright notice, this
-* list of conditions and the following disclaimer.
-*
-* Redistributions in binary form must reproduce the above copyright notice,
-* this list of conditions and the following disclaimer in the documentation
-* and/or other materials provided with the distribution.
-*
-* Neither the name of Marvell nor the names of its contributors may be used
-* to endorse or promote products derived from this software without specific
-* prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-* ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
-* LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
-* OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-* INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-* CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-* ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-* POSSIBILITY OF SUCH DAMAGE.
-*
-***************************************************************************
-*/
-
-#include <linux/clk.h>
-#include <linux/err.h>
-#include <linux/gpio.h>
-#include <linux/io.h>
-#include <linux/irq.h>
-#include <linux/irqchip/chained_irq.h>
-#include <linux/irqdomain.h>
-#include <linux/module.h>
-#include <linux/of_irq.h>
-#include <linux/of_device.h>
-#include <linux/pinctrl/consumer.h>
-#include <linux/slab.h>
-
-/* GPIO unit register offsets for A3700. */
-#define GPIO_OUT_OFF		0x0018
-#define GPIO_IO_CONF_OFF	0x0000
-#define GPIO_DATA_IN_OFF	0x0010
-
-/* GPIO interrupt reg block, starts from 13c00/18c00 */
-#define GPIO_EDGE_MASK_OFF	0x0000
-#define GPIO_INT_POL_OFF	0x0008
-#define GPIO_EDGE_CAUSE_OFF	0x0010
-
-#define MVEBU_MAX_GPIO_PER_BANK		36
-
-#define MVEBU_GPIO_CHIP_TYPE_NUM	1
-
-/* IRQ mask type is u32 and has 32 bits, generic irq chip supports max 32 interrupts. */
-#define MVEBU_IRQ_MASK_BIT_NUM_MAX	32
-/* When a gpio bank has more than 32 gpios(e.g. a3700), we need more than 1 generic irq chip. */
-/* For a mvebu gpio bank, the max gpio number is not more than 64, so we need at most 2 generic irq chip for a bank. */
-#define MVEBU_IRQ_CHIP_NUM	2
-
-struct mvebu_gpio_chip {
-	struct gpio_chip   chip;
-	spinlock_t	   lock;
-	void __iomem	  *membase;
-	void __iomem	  *interrupt_membase;
-	int		   irqbase;
-	struct irq_domain *domain;
-
-	/* Used to preserve GPIO registers across suspend/resume. */
-	u32                out_reg;
-	u32                out_reg_hi;
-	u32                io_conf_reg;
-	u32                io_conf_reg_hi;
-	u32                irq_pol_reg;
-	u32                irq_pol_reg_hi;
-	u32                edge_mask_regs[4];
-};
-
-/*
- * Functions returning addresses of individual registers for a given
- * A3700 GPIO controller.
- *
- * There are up to 36 GPIO pin in A3700, so there are two continuous
- * registers to configure a single feature. for example, to enable
- * GPIO output, for pin 0 - 31, it is in register GPIO_OUT_OFF,
- * for pin 32 - 35, it is in register GPIO_OUT_OFF + 4.
- */
-#define GPIO_IO_BITWIDTH	32
-#define GPIO_REG_OFF(PIN)	((PIN / GPIO_IO_BITWIDTH) * sizeof(u32))
-#define GPIO_REG_PIN_OFF(PIN)	(PIN % GPIO_IO_BITWIDTH)
-
-static inline void __iomem *mvebu_gpioreg_out(struct mvebu_gpio_chip *mvchip, u32 pin)
-{
-	return mvchip->membase + GPIO_OUT_OFF + GPIO_REG_OFF(pin);
-}
-
-static inline void __iomem *mvebu_gpioreg_io_conf(struct mvebu_gpio_chip *mvchip, u32 pin)
-{
-	return mvchip->membase + GPIO_IO_CONF_OFF + GPIO_REG_OFF(pin);
-}
-
-static inline void __iomem *mvebu_gpioreg_data_in(struct mvebu_gpio_chip *mvchip, u32 pin)
-{
-	return mvchip->membase + GPIO_DATA_IN_OFF + GPIO_REG_OFF(pin);
-}
-
-static inline void __iomem *mvebu_gpioreg_int_pol(struct mvebu_gpio_chip *mvchip, u32 pin)
-{
-	return mvchip->interrupt_membase + GPIO_INT_POL_OFF + GPIO_REG_OFF(pin);
-}
-
-static inline void __iomem *mvebu_gpioreg_edge_cause(struct mvebu_gpio_chip *mvchip, u32 pin)
-{
-
-	return mvchip->interrupt_membase + GPIO_EDGE_CAUSE_OFF + GPIO_REG_OFF(pin);
-}
-
-static inline void __iomem *mvebu_gpioreg_edge_mask(struct mvebu_gpio_chip *mvchip, u32 pin)
-{
-	return mvchip->interrupt_membase + GPIO_EDGE_MASK_OFF + GPIO_REG_OFF(pin);
-}
-
-/* Functions implementing the gpio_chip methods for A3700 */
-static void mvebu_gpio_set(struct gpio_chip *chip, unsigned pin, int value)
-{
-	struct mvebu_gpio_chip *mvchip = container_of(chip, struct mvebu_gpio_chip, chip);
-	unsigned long flags;
-	void __iomem *out_reg_addr;
-	u32 u;
-
-	out_reg_addr = mvebu_gpioreg_out(mvchip, pin);
-	pin = GPIO_REG_PIN_OFF(pin);
-
-	spin_lock_irqsave(&mvchip->lock, flags);
-	u = readl_relaxed(out_reg_addr);
-	if (value)
-		u |= 1 << pin;
-	else
-		u &= ~(1 << pin);
-	writel_relaxed(u, out_reg_addr);
-	spin_unlock_irqrestore(&mvchip->lock, flags);
-}
-
-static int mvebu_gpio_get(struct gpio_chip *chip, unsigned pin)
-{
-	struct mvebu_gpio_chip *mvchip = container_of(chip, struct mvebu_gpio_chip, chip);
-	u32 u;
-
-	/*
-	 * Return value depends on PIN direction:
-	 * - output, return output value.
-	 * - input, return input value.
-	 */
-	if (readl_relaxed(mvebu_gpioreg_io_conf(mvchip, pin)) & (1 << GPIO_REG_PIN_OFF(pin)))
-		u = readl_relaxed(mvebu_gpioreg_out(mvchip, pin));
-	else
-		u = readl_relaxed(mvebu_gpioreg_data_in(mvchip, pin));
-
-	pin = GPIO_REG_PIN_OFF(pin);
-	return (u >> pin) & 1;
-}
-
-static int mvebu_gpio_direction_input(struct gpio_chip *chip, unsigned pin)
-{
-	struct mvebu_gpio_chip *mvchip = container_of(chip, struct mvebu_gpio_chip, chip);
-	unsigned long flags;
-	void __iomem *io_reg_addr;
-	int ret;
-	u32 u;
-
-	/* Check with the pinctrl driver whether this pin is usable as an input GPIO. */
-	ret = pinctrl_gpio_direction_input(chip->base + pin);
-	if (ret) {
-		dev_err(chip->cdev, "gpio_direction_input, pin (%d) is not a GPIO pin\n", pin);
-		return ret;
-	}
-
-	io_reg_addr = mvebu_gpioreg_io_conf(mvchip, pin);
-	pin = GPIO_REG_PIN_OFF(pin);
-
-	spin_lock_irqsave(&mvchip->lock, flags);
-	u = readl_relaxed(io_reg_addr);
-	u &= ~(1 << pin);
-	writel_relaxed(u, io_reg_addr);
-	spin_unlock_irqrestore(&mvchip->lock, flags);
-
-	return 0;
-}
-
-static int mvebu_gpio_direction_output(struct gpio_chip *chip, unsigned pin, int value)
-{
-	struct mvebu_gpio_chip *mvchip = container_of(chip, struct mvebu_gpio_chip, chip);
-	unsigned long flags;
-	void __iomem *io_reg_addr;
-	int ret;
-	u32 u;
-
-	/* Check with the pinctrl driver whether this pin is usable as an output GPIO. */
-	ret = pinctrl_gpio_direction_output(chip->base + pin);
-	if (ret) {
-		dev_err(chip->cdev, "gpio_direction_output, pin (%d) is not a GPIO pin\n", pin);
-		return ret;
-	}
-
-	/* Set output value first. */
-	mvebu_gpio_set(chip, pin, value);
-
-	io_reg_addr = mvebu_gpioreg_io_conf(mvchip, pin);
-	pin = GPIO_REG_PIN_OFF(pin);
-
-	spin_lock_irqsave(&mvchip->lock, flags);
-	u = readl_relaxed(io_reg_addr);
-	u |= 1 << pin;
-	writel_relaxed(u, io_reg_addr);
-	spin_unlock_irqrestore(&mvchip->lock, flags);
-
-	return 0;
-}
-
-static int mvebu_gpio_to_irq(struct gpio_chip *chip, unsigned pin)
-{
-	struct mvebu_gpio_chip *mvchip = container_of(chip, struct mvebu_gpio_chip, chip);
-
-	return irq_create_mapping(mvchip->domain, pin);
-}
-
-static void mvebu_gpio_irq_ack(struct irq_data *d)
-{
-	struct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);
-	struct mvebu_gpio_chip *mvchip = gc->private;
-	u32 pin = d->irq - mvchip->irqbase;
-	u32 mask = 1 << GPIO_REG_PIN_OFF(pin);
-
-	irq_gc_lock(gc);
-	writel_relaxed(mask, mvebu_gpioreg_edge_cause(mvchip, pin));
-	irq_gc_unlock(gc);
-}
-
-static void mvebu_gpio_edge_irq_mask(struct irq_data *d)
-{
-	struct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);
-	struct mvebu_gpio_chip *mvchip = gc->private;
-	struct irq_chip_type *ct = irq_data_get_chip_type(d);
-	u32 pin = d->irq - mvchip->irqbase;
-	u32 mask = 1 << GPIO_REG_PIN_OFF(pin);
-
-	irq_gc_lock(gc);
-	ct->mask_cache_priv &= ~mask;
-	writel_relaxed(ct->mask_cache_priv, mvebu_gpioreg_edge_mask(mvchip, pin));
-	irq_gc_unlock(gc);
-}
-
-static void mvebu_gpio_edge_irq_unmask(struct irq_data *d)
-{
-	struct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);
-	struct mvebu_gpio_chip *mvchip = gc->private;
-	struct irq_chip_type *ct = irq_data_get_chip_type(d);
-	u32 pin = d->irq - mvchip->irqbase;
-	u32 mask = 1 << GPIO_REG_PIN_OFF(pin);
-
-	irq_gc_lock(gc);
-	ct->mask_cache_priv |= mask;
-	writel_relaxed(ct->mask_cache_priv, mvebu_gpioreg_edge_mask(mvchip, pin));
-	irq_gc_unlock(gc);
-}
-
-/*****************************************************************************
- * This routine sets the flow type (IRQ_TYPE_LEVEL/etc.) of an IRQ for a3700
- *
- * GPIO_INT_POL register controls the interrupt polarity.
- *
- * Edge IRQ handlers:  Change in DATA_IN are latched in EDGE_CAUSE.
- *		       Interrupt are masked by EDGE_MASK registers.
- * Both-edge handlers: Similar to regular Edge handlers, but also swaps
- *		       the polarity to catch the next line transaction.
- *		       This is a race condition that might not perfectly
- *		       work on some use cases.
- *
- * Every eight GPIO lines are grouped (OR'ed) before going up to main
- * cause register.
- *
- *	  data-in     EDGE  cause    mask
- *     -----| |----------| |-----| |----- to main cause reg
- *	     X
- *	  polarity
- *
- ****************************************************************************/
-static int mvebu_gpio_irq_set_type(struct irq_data *d, unsigned int type)
-{
-	struct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);
-	struct irq_chip_type *ct = irq_data_get_chip_type(d);
-	struct mvebu_gpio_chip *mvchip = gc->private;
-	int pin;
-	u32 u;
-
-	pin = d->hwirq;
-
-	u = readl_relaxed(mvebu_gpioreg_io_conf(mvchip, pin)) & (1 << GPIO_REG_PIN_OFF(pin));
-	if (u)
-		return -EINVAL;
-
-	type &= IRQ_TYPE_SENSE_MASK;
-	if (type == IRQ_TYPE_NONE)
-		return -EINVAL;
-
-	/* Check if we need to change chip and handler. */
-	if (!(ct->type & type))
-		if (irq_setup_alt_chip(d, type))
-			return -EINVAL;
-
-	/* Configure interrupt polarity. */
-	switch (type) {
-	case IRQ_TYPE_EDGE_RISING:
-		u = readl_relaxed(mvebu_gpioreg_int_pol(mvchip, pin));
-		u &= ~(1 << GPIO_REG_PIN_OFF(pin));
-		writel_relaxed(u, mvebu_gpioreg_int_pol(mvchip, pin));
-		break;
-	case IRQ_TYPE_EDGE_FALLING:
-		u = readl_relaxed(mvebu_gpioreg_int_pol(mvchip, pin));
-		u |= 1 << GPIO_REG_PIN_OFF(pin);
-		writel_relaxed(u, mvebu_gpioreg_int_pol(mvchip, pin));
-		break;
-	case IRQ_TYPE_EDGE_BOTH: {
-		u32 v;
-
-		v = readl_relaxed(mvebu_gpioreg_data_in(mvchip, pin));
-
-		/* Set initial polarity based on current input level. */
-		u = readl_relaxed(mvebu_gpioreg_int_pol(mvchip, pin));
-		if (v & (1 << GPIO_REG_PIN_OFF(pin)))
-			u |= 1 << GPIO_REG_PIN_OFF(pin);		/* falling */
-		else
-			u &= ~(1 << GPIO_REG_PIN_OFF(pin));	/* rising */
-		writel_relaxed(u, mvebu_gpioreg_int_pol(mvchip, pin));
-		break;
-	}
-	default:
-		pr_err("Now a3700 only support edge IRQ types!!!");
-		return -EINVAL;
-	}
-	return 0;
-}
-
-static void mvebu_gpio_irq_handler(struct irq_desc *desc)
-{
-	struct mvebu_gpio_chip *mvchip = irq_desc_get_handler_data(desc);
-	struct irq_chip *chip = irq_desc_get_chip(desc);
-	u32 cause, type;
-	int i, start;
-
-	if (mvchip == NULL)
-		return;
-
-	chained_irq_enter(chip, desc);
-
-	for (start = 0; start < mvchip->chip.ngpio; start += GPIO_IO_BITWIDTH) {
-		cause = readl_relaxed(mvebu_gpioreg_edge_cause(mvchip, start)) &
-			readl_relaxed(mvebu_gpioreg_edge_mask(mvchip, start));
-
-		for (i = 0; (i < (mvchip->chip.ngpio - start)) && (i < GPIO_IO_BITWIDTH); i++) {
-			int irq;
-
-			irq = mvchip->irqbase + start + i;
-
-			if (!(cause & (1 << i)))
-				continue;
-
-			type = irq_get_trigger_type(irq);
-			if ((type & IRQ_TYPE_SENSE_MASK) == IRQ_TYPE_EDGE_BOTH) {
-				/* Swap polarity (race with GPIO line) */
-				u32 polarity, level;
-
-				level = readl_relaxed(mvebu_gpioreg_data_in(mvchip, start));
-				polarity = readl_relaxed(mvebu_gpioreg_int_pol(mvchip, start));
-				if ((polarity ^ level) & (1 << i)) {
-					polarity ^= 1 << i;
-					writel_relaxed(polarity, mvebu_gpioreg_int_pol(mvchip, start));
-				} else {
-					/*
-					 * For spurious irq, which gpio level is not as expected after
-					 * incoming edge, just ack the gpio irq.
-					 */
-					writel_relaxed(1 << i, mvebu_gpioreg_edge_cause(mvchip, start));
-					continue;
-				}
-			}
-
-			generic_handle_irq(irq);
-		}
-	}
-
-	chained_irq_exit(chip, desc);
-}
-
-#ifdef CONFIG_DEBUG_FS
-#include <linux/seq_file.h>
-
-static void mvebu_gpio_dbg_show(struct seq_file *s, struct gpio_chip *chip)
-{
-	struct mvebu_gpio_chip *mvchip = container_of(chip, struct mvebu_gpio_chip, chip);
-	u32 out, io_conf, data_in, int_pol, cause, edg_msk;
-	int pin;
-
-	for (pin = 0; pin < chip->ngpio; pin++) {
-		const char *label;
-		u32 msk;
-		bool is_out;
-
-		label = gpiochip_is_requested(chip, pin);
-		if (!label)
-			continue;
-
-		out	= readl_relaxed(mvebu_gpioreg_out(mvchip, pin));
-		io_conf = readl_relaxed(mvebu_gpioreg_io_conf(mvchip, pin));
-		data_in = readl_relaxed(mvebu_gpioreg_data_in(mvchip, pin));
-		int_pol	= readl_relaxed(mvebu_gpioreg_int_pol(mvchip, pin));
-		cause	= readl_relaxed(mvebu_gpioreg_edge_cause(mvchip, pin));
-		edg_msk	= readl_relaxed(mvebu_gpioreg_edge_mask(mvchip, pin));
-
-		pin = GPIO_REG_PIN_OFF(pin);
-
-		msk = 1 << pin;
-		if (io_conf & msk)
-			is_out = true;
-		else
-			is_out = false;
-
-		seq_printf(s, " gpio-%-3d (%-20.20s)", chip->base + pin, label);
-
-		if (is_out) {
-			seq_printf(s, " out %s\n",
-				   out & msk ? "hi" : "lo");
-			continue;
-		}
-
-		seq_printf(s, " in  %s (act %s) - IRQ",
-			   data_in & msk  ? "hi" : "lo",
-			   int_pol & msk ? "lo" : "hi");
-		if (!(edg_msk & msk)) {
-			seq_puts(s, " disabled\n");
-			continue;
-		}
-		if (edg_msk & msk)
-			seq_puts(s, " edge ");
-		seq_printf(s, " (%s)\n", cause & msk ? "pending" : "clear  ");
-	}
-}
-
-#else
-#define mvebu_gpio_dbg_show NULL
-#endif
-
-static const struct of_device_id mvebu_gpio_of_match[] = {
-	{ .compatible = "marvell,armada3700-gpio", },
-	{},
-};
-MODULE_DEVICE_TABLE(of, mvebu_gpio_of_match);
-
-static int mvebu_gpio_suspend(struct platform_device *pdev, pm_message_t state)
-{
-	struct mvebu_gpio_chip *mvchip = platform_get_drvdata(pdev);
-
-	/*
-	 * There are 36 GPIO pin for A3700, so there are two registers holding
-	 * values, pin 0 - 31 is at the first reg, 32 - 35 are at the second
-	 */
-	mvchip->out_reg = readl(mvebu_gpioreg_out(mvchip, 0));
-	mvchip->io_conf_reg = readl(mvebu_gpioreg_io_conf(mvchip, 0));
-	mvchip->out_reg_hi = readl(mvebu_gpioreg_out(mvchip, GPIO_IO_BITWIDTH));
-	mvchip->io_conf_reg_hi = readl(mvebu_gpioreg_io_conf(mvchip, GPIO_IO_BITWIDTH));
-	mvchip->irq_pol_reg = readl(mvebu_gpioreg_int_pol(mvchip, 0));
-	mvchip->irq_pol_reg_hi = readl(mvebu_gpioreg_int_pol(mvchip, GPIO_IO_BITWIDTH));
-	mvchip->edge_mask_regs[0] = readl(mvebu_gpioreg_edge_mask(mvchip, 0));
-	if (mvchip->chip.ngpio > GPIO_IO_BITWIDTH)
-		mvchip->edge_mask_regs[1] = readl(mvebu_gpioreg_edge_mask(mvchip, GPIO_IO_BITWIDTH));
-
-	return 0;
-}
-
-static int mvebu_gpio_resume(struct platform_device *pdev)
-{
-	struct mvebu_gpio_chip *mvchip = platform_get_drvdata(pdev);
-	u32 i, mask, type, level;
-	u32 *polarity;
-	int irq;
-
-	/*
-	 * There are 36 GPIO pin for A3700, so there are two registers holding
-	 * values, pin 0 - 31 is at the first reg, 32 - 35 are at the second
-	 */
-	writel(mvchip->out_reg, mvebu_gpioreg_out(mvchip, 0));
-	writel(mvchip->io_conf_reg, mvebu_gpioreg_io_conf(mvchip, 0));
-	writel(mvchip->out_reg_hi, mvebu_gpioreg_out(mvchip, GPIO_IO_BITWIDTH));
-	writel(mvchip->io_conf_reg_hi, mvebu_gpioreg_io_conf(mvchip, GPIO_IO_BITWIDTH));
-	writel(mvchip->edge_mask_regs[0], mvebu_gpioreg_edge_mask(mvchip, 0));
-	if (mvchip->chip.ngpio > GPIO_IO_BITWIDTH)
-		writel(mvchip->edge_mask_regs[1], mvebu_gpioreg_edge_mask(mvchip, GPIO_IO_BITWIDTH));
-
-	/*
-	* For the gpios which are used for both-edge irqs, in system suspend
-	* their input levels may be changed but their polarities are not updated
-	* accordingly since interrupts are not handled in suspend; then in resume
-	* their polarities needs to be synchronized with their levels.
-	*/
-	for (i = 0; i < mvchip->chip.ngpio; i++) {
-		irq = mvchip->irqbase + i;
-		mask = mvchip->edge_mask_regs[i / GPIO_IO_BITWIDTH];
-		type = irq_get_trigger_type(irq);
-
-		if (!(mask & (1 << GPIO_REG_PIN_OFF(i))))
-			continue;
-
-		if ((type & IRQ_TYPE_SENSE_MASK) == IRQ_TYPE_EDGE_BOTH) {
-			level = readl_relaxed(mvebu_gpioreg_data_in(mvchip, i));
-			polarity = &mvchip->irq_pol_reg + i / GPIO_IO_BITWIDTH;
-
-			if ((*polarity ^ level) & (1 << GPIO_REG_PIN_OFF(i))) {
-				/* Synchronize gpio polarity with level for both-edge irqs */
-				*polarity ^= 1 << i;
-			}
-		}
-	}
-	writel(mvchip->irq_pol_reg, mvebu_gpioreg_int_pol(mvchip, 0));
-	writel(mvchip->irq_pol_reg_hi, mvebu_gpioreg_int_pol(mvchip, GPIO_IO_BITWIDTH));
-
-	return 0;
-}
-
-static int mvebu_gpio_probe(struct platform_device *pdev)
-{
-	struct mvebu_gpio_chip *mvchip;
-	const struct of_device_id *match;
-	struct device_node *np = pdev->dev.of_node;
-	struct resource *res;
-	struct irq_chip_generic *gc;
-	struct irq_chip_generic *gcs[MVEBU_IRQ_CHIP_NUM];
-	struct irq_chip_type *ct;
-	struct clk *clk;
-	unsigned int ngpios;
-	unsigned int gpio_base = -1;
-	int i, id;
-	int err;
-	int irq_num;
-	unsigned int gc_num = 0;
-	u32 irq_mask;
-
-	match = of_match_device(mvebu_gpio_of_match, &pdev->dev);
-	if (match == NULL)
-		return -ENODEV;
-
-	mvchip = devm_kzalloc(&pdev->dev, sizeof(struct mvebu_gpio_chip),
-			      GFP_KERNEL);
-	if (!mvchip)
-		return -ENOMEM;
-
-	platform_set_drvdata(pdev, mvchip);
-
-	if (of_property_read_u32(pdev->dev.of_node, "ngpios", &ngpios)) {
-		dev_err(&pdev->dev, "Missing ngpios OF property\n");
-		return -ENODEV;
-	}
-
-	if (of_property_read_u32(pdev->dev.of_node, "gpiobase", &gpio_base))
-		gpio_base = -1;
-
-	id = of_alias_get_id(pdev->dev.of_node, "gpio");
-	if (id < 0) {
-		dev_err(&pdev->dev, "Couldn't get OF id\n");
-		return id;
-	}
-
-	clk = devm_clk_get(&pdev->dev, NULL);
-	/* Not all SoCs require a clock. */
-	if (!IS_ERR(clk))
-		clk_prepare_enable(clk);
-
-	mvchip->chip.label = dev_name(&pdev->dev);
-	mvchip->chip.parent = &pdev->dev;
-	mvchip->chip.request = gpiochip_generic_request;
-	mvchip->chip.free = gpiochip_generic_free;
-	mvchip->chip.direction_input = mvebu_gpio_direction_input;
-	mvchip->chip.get = mvebu_gpio_get;
-	mvchip->chip.direction_output = mvebu_gpio_direction_output;
-	mvchip->chip.set = mvebu_gpio_set;
-	mvchip->chip.dbg_show = mvebu_gpio_dbg_show;
-	mvchip->chip.to_irq = mvebu_gpio_to_irq;
-	mvchip->chip.ngpio = ngpios;
-	mvchip->chip.can_sleep = false;
-	mvchip->chip.of_node = np;
-	if (gpio_base != -1)
-		mvchip->chip.base = gpio_base;
-	else
-		mvchip->chip.base = id * MVEBU_MAX_GPIO_PER_BANK;
-
-	spin_lock_init(&mvchip->lock);
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	mvchip->membase = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(mvchip->membase))
-		return PTR_ERR(mvchip->membase);
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
-	mvchip->interrupt_membase = devm_ioremap_resource(&pdev->dev,
-						       res);
-	if (IS_ERR(mvchip->interrupt_membase))
-		return PTR_ERR(mvchip->interrupt_membase);
-
-	/*
-	 * Mask and clear GPIO interrupts.
-	 * a3700 interrupt status registers are RW1C.
-	 */
-	writel_relaxed(~0, mvebu_gpioreg_edge_cause(mvchip, 0));
-	writel_relaxed(0, mvebu_gpioreg_edge_mask(mvchip, 0));
-	if (ngpios > GPIO_IO_BITWIDTH) {
-		writel_relaxed(~0, mvebu_gpioreg_edge_cause(mvchip, GPIO_IO_BITWIDTH));
-		writel_relaxed(0, mvebu_gpioreg_edge_mask(mvchip, GPIO_IO_BITWIDTH));
-	}
-
-	gpiochip_add(&mvchip->chip);
-
-	/* Some gpio controllers do not provide irq support. */
-	irq_num = of_irq_count(np);
-	if (!irq_num)
-		return 0;
-
-	/* Setup the interrupt handlers. */
-	for (i = 0; i < irq_num; i++) {
-		int irq = platform_get_irq(pdev, i);
-
-		if (irq < 0)
-			continue;
-
-		irq_set_chained_handler_and_data(irq, mvebu_gpio_irq_handler, mvchip);
-	}
-
-	mvchip->irqbase = irq_alloc_descs(-1, 0, ngpios, -1);
-	if (mvchip->irqbase < 0) {
-		dev_err(&pdev->dev, "no irqs\n");
-		err = mvchip->irqbase;
-		goto err_gpio;
-	}
-
-	/*
-	 * Since irq_setup_generic_chip() can only set up max 32 interrupts,
-	 * we need to create multi generic irq chips.
-	 */
-	for (i = 0; i < ngpios; i += MVEBU_IRQ_MASK_BIT_NUM_MAX) {
-		gc = irq_alloc_generic_chip("mvebu_gpio_irq", MVEBU_GPIO_CHIP_TYPE_NUM,
-					    mvchip->irqbase + i, mvchip->membase, handle_edge_irq);
-		if (!gc) {
-			dev_err(&pdev->dev, "Can't allocate generic irq_chip\n");
-			err = -ENOMEM;
-			goto err_gpio;
-		}
-
-		if (gc_num >= MVEBU_IRQ_CHIP_NUM) {
-			dev_err(&pdev->dev, "Can't create more than %d generic irq_chips\n", MVEBU_IRQ_CHIP_NUM);
-			err = -EPERM;
-			kfree(gc);
-			goto err_gpio;
-		}
-		gcs[gc_num++] = gc;
-
-		gc->private = mvchip;
-		ct = &gc->chip_types[0];
-		ct->type = IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING;
-		ct->chip.irq_ack = mvebu_gpio_irq_ack;
-		ct->chip.irq_mask = mvebu_gpio_edge_irq_mask;
-		ct->chip.irq_unmask = mvebu_gpio_edge_irq_unmask;
-		ct->chip.irq_set_type = mvebu_gpio_irq_set_type;
-		ct->chip.name = mvchip->chip.label;
-
-		if ((i + MVEBU_IRQ_MASK_BIT_NUM_MAX) < ngpios)
-			irq_mask = IRQ_MSK(MVEBU_IRQ_MASK_BIT_NUM_MAX);
-		else
-			irq_mask = IRQ_MSK(ngpios - i);
-		irq_setup_generic_chip(gc, irq_mask, 0,
-			       IRQ_NOREQUEST, IRQ_LEVEL | IRQ_NOPROBE);
-	}
-
-	/* Setup irq domain on top of the generic chip. */
-	mvchip->domain = irq_domain_add_simple(np, mvchip->chip.ngpio,
-					       mvchip->irqbase,
-					       &irq_domain_simple_ops,
-					       mvchip);
-	if (!mvchip->domain) {
-		dev_err(&pdev->dev, "couldn't allocate irq domain %s (DT).\n",
-			mvchip->chip.label);
-		err = -ENODEV;
-		goto err_gpio;
-	}
-
-	return 0;
-
-err_gpio:
-	/* Remove the created generic irq chips. */
-	for (i = 0; i < gc_num; i++) {
-		if (((i + 1) * MVEBU_IRQ_MASK_BIT_NUM_MAX) < ngpios)
-			irq_mask = IRQ_MSK(MVEBU_IRQ_MASK_BIT_NUM_MAX);
-		else
-			irq_mask = IRQ_MSK(ngpios - i * MVEBU_IRQ_MASK_BIT_NUM_MAX);
-		irq_remove_generic_chip(gcs[i], irq_mask, IRQ_NOREQUEST, IRQ_LEVEL | IRQ_NOPROBE);
-		kfree(gcs[i]);
-	}
-
-	gpiochip_remove(&mvchip->chip);
-
-	return err;
-}
-
-static struct platform_driver mvebu_gpio_driver = {
-	.driver		= {
-		.name		= "mvebu-a3700-gpio",
-		.of_match_table = mvebu_gpio_of_match,
-	},
-	.probe		= mvebu_gpio_probe,
-	.suspend        = mvebu_gpio_suspend,
-	.resume         = mvebu_gpio_resume,
-};
-module_platform_driver(mvebu_gpio_driver);
diff --git a/drivers/pinctrl/mvebu/Kconfig b/drivers/pinctrl/mvebu/Kconfig
index 7e1abfb..cb081f9 100644
--- a/drivers/pinctrl/mvebu/Kconfig
+++ b/drivers/pinctrl/mvebu/Kconfig
@@ -3,10 +3,6 @@ config PINCTRL_MVEBU
 	select PINMUX
 	select PINCONF
 
-config PINCTRL_ARMADA_3700
-	bool
-	select PINCTRL_MVEBU
-
 config PINCTRL_ARMADA_AP806
 	bool
 	select PINCTRL_MVEBU
diff --git a/drivers/pinctrl/mvebu/pinctrl-armada-3700.c b/drivers/pinctrl/mvebu/pinctrl-armada-3700.c
deleted file mode 100644
index f08ae35..0000000
--- a/drivers/pinctrl/mvebu/pinctrl-armada-3700.c
+++ /dev/null
@@ -1,1038 +0,0 @@
-/*
- * Marvell Armada 3700 pinctrl driver based on mvebu pinctrl core
- *
- * Copyright (C) 2016 Marvell
- *
- * Terry Zhou <bjzhou@marvell.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- */
-
-#include <linux/err.h>
-#include <linux/init.h>
-#include <linux/io.h>
-#include <linux/module.h>
-#include <linux/of.h>
-#include <linux/of_device.h>
-#include <linux/platform_device.h>
-#include <linux/syscore_ops.h>
-#include <linux/pinctrl/pinctrl.h>
-#include "pinctrl-mvebu.h"
-
-/*
- * Armada3700 provides dual modes for most MPPs,
- * either gpio or the specific function.
- * But some MPPs can support up to 3 modes combined
- * with selecting the significant bits in the MPP's
- * register.
- */
-#define ARMADA_3700_MPP_MAX_CONFIG_NUM	3
-
-enum armada_3700_bridge {
-	I_NORTHBRIDGE	= 0,
-	I_SOUTHBRIDGE,
-	I_MAXCONTROLLER,
-};
-
-struct  armada_3700_mpp_setting_bitmap {
-	/*
-	 * The mask is used for read/write MPP register bits of the function seletion.
-	 * For the mpps dedicated to gpio function which is not controlled by any MPP
-	 * register bits, the mask should be set to '0'.
-	 */
-	unsigned int mask;
-	unsigned int config_num;	/* mpp configuration modes number */
-	/*
-	 * This array maps the MPP's modes into the relevant MPP's register bits. It
-	 * is indexed by MPP's modes, which is defined in armada_3700_nb/sb_mpp_modes.
-	 */
-	unsigned int configs[ARMADA_3700_MPP_MAX_CONFIG_NUM];
-};
-
-static void __iomem *mpp_base[I_MAXCONTROLLER];/* north & south bridge mpp base */
-static unsigned int mpp_saved_regs[I_MAXCONTROLLER];/* north & south bridge mpp status, for suspend/resume usage */
-
-struct  armada_3700_mpp_conf {
-	struct mvebu_pinctrl_soc_info *soc_info;
-	struct mvebu_mpp_mode *modes;
-	int nmodes;
-	struct armada_3700_mpp_setting_bitmap *bitmap;
-	int nbitmaps;
-	enum armada_3700_bridge index;
-};
-
-struct armada_3700_mpp_conf *a3700_mpp_conf_ptr[I_MAXCONTROLLER];
-
-static int armada_3700_mpp_ctrl_get(unsigned pid,
-				    struct armada_3700_mpp_setting_bitmap mpp_setting_bitmap[],
-				    void __iomem *mpp_base_addr,
-				    unsigned long *config)
-{
-	unsigned int setting_num;
-	unsigned int reg, mask, i;
-
-	setting_num = mpp_setting_bitmap[pid].config_num;
-	mask = mpp_setting_bitmap[pid].mask;
-	if (!mask) {
-		/* The empty mask means the pin has a dedicated function. */
-		*config = 0;
-		return 0;
-	}
-
-	reg = readl(mpp_base_addr) & mask;
-	for (i = 0; i < setting_num; i++)
-		if (reg == mpp_setting_bitmap[pid].configs[i])
-			break;
-
-	if (i == setting_num) {
-		pr_err("Unknown config for bridge pin %u, mpp reg value(0x%08x)!\n", pid, reg);
-		return -EFAULT;
-	}
-
-	*config = i;
-	pr_debug("%s %d pid %d config %lu mask 0x%x reg 0x%x\n", __func__, __LINE__, pid, *config, mask, reg);
-	return 0;
-}
-
-static int armada_3700_mpp_ctrl_set(unsigned pid,
-				    struct armada_3700_mpp_setting_bitmap mpp_setting_bitmap[],
-				    void __iomem *mpp_base_addr,
-				    unsigned long config)
-{
-	unsigned int setting_num;
-	unsigned int reg, mask, val;
-
-	/* check whether the config value is valid */
-	setting_num = mpp_setting_bitmap[pid].config_num;
-	if (config >= setting_num) {
-		pr_err("For bridge pin %u, invalid config %lu!\n", pid, config);
-		return -EINVAL;
-	}
-
-	mask = mpp_setting_bitmap[pid].mask;
-	if (!mask)
-		return 0;
-	val = mpp_setting_bitmap[pid].configs[config];
-	reg = readl(mpp_base_addr) & ~mask;
-	writel(reg | val, mpp_base_addr);
-
-	pr_debug("%s %d pid %d config %lu reg 0x%x\n", __func__, __LINE__, pid, config, reg | val);
-	return 0;
-}
-
-/* North bridge pin-ctl for Z1 */
-static struct mvebu_mpp_mode armada_3700_z1_nb_mpp_modes[] = {
-	MPP_MODE(0,
-	   MPP_FUNCTION(0x0, "i2c1", "sck"),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(1,
-	   MPP_FUNCTION(0x0, "i2c1", "sda"),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(2,
-	   MPP_FUNCTION(0x0, "i2c2", "sck"),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(3,
-	   MPP_FUNCTION(0x0, "i2c2", "sda"),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(4,
-	   MPP_FUNCTION(0x0, "1wire", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(5,
-	   MPP_FUNCTION(0x0, "gpio", NULL)),
-	MPP_MODE(6,
-	   MPP_FUNCTION(0x0, "pmic0", "slp-out"),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(7,
-	   MPP_FUNCTION(0x0, "pmic1", "slp-out"),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(8,
-	   MPP_FUNCTION(0x0, "sdio", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(9,
-	   MPP_FUNCTION(0x0, "sdio", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL),
-	   MPP_FUNCTION(0x2, "uart2", "rts")),
-	MPP_MODE(10,
-	   MPP_FUNCTION(0x0, "sdio", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL),
-	   MPP_FUNCTION(0x2, "uart2", "cts")),
-	MPP_MODE(11,
-	   MPP_FUNCTION(0x0, "pwm0", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL),
-	   MPP_FUNCTION(0x2, "led0-od", NULL)),
-	MPP_MODE(12,
-	   MPP_FUNCTION(0x0, "pwm1", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL),
-	   MPP_FUNCTION(0x2, "led1-od", NULL)),
-	MPP_MODE(13,
-	   MPP_FUNCTION(0x0, "pwm2", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL),
-	   MPP_FUNCTION(0x2, "led2-od", NULL)),
-	MPP_MODE(14,
-	   MPP_FUNCTION(0x0, "pwm3", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL),
-	   MPP_FUNCTION(0x2, "led3-od", NULL)),
-	MPP_MODE(15,
-	   MPP_FUNCTION(0x0, "spi-quad", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(16,
-	   MPP_FUNCTION(0x0, "spi-quad", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(17,
-	   MPP_FUNCTION(0x0, "spi-cs1", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(18,
-	   MPP_FUNCTION(0x0, "spi-cs2", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL),
-	   MPP_FUNCTION(0x2, "uart2", "tx")),
-	MPP_MODE(19,
-	   MPP_FUNCTION(0x0, "spi-cs3", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL),
-	   MPP_FUNCTION(0x2, "uart2", "rx")),
-	MPP_MODE(20,
-	   MPP_FUNCTION(0x0, "jtag", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(21,
-	   MPP_FUNCTION(0x0, "jtag", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(22,
-	   MPP_FUNCTION(0x0, "jtag", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(23,
-	   MPP_FUNCTION(0x0, "jtag", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(24,
-	   MPP_FUNCTION(0x0, "jtag", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(25,
-	   MPP_FUNCTION(0x0, "uart1", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(26,
-	   MPP_FUNCTION(0x0, "uart1", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(27,
-	   MPP_FUNCTION(0x0, "mmc", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(28,
-	   MPP_FUNCTION(0x0, "mmc", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(29,
-	   MPP_FUNCTION(0x0, "mmc", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(30,
-	   MPP_FUNCTION(0x0, "mmc", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(31,
-	   MPP_FUNCTION(0x0, "mmc", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(32,
-	   MPP_FUNCTION(0x0, "mmc", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(33,
-	   MPP_FUNCTION(0x0, "mmc", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(34,
-	   MPP_FUNCTION(0x0, "mmc", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(35,
-	   MPP_FUNCTION(0x0, "mmc", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	/*
-	 * The mpp36 is not a GPIO pin exposed to the user.
-	 * It is dedicated to spi function.
-	 */
-	MPP_MODE(36,
-	   MPP_FUNCTION(0x0, "spi", NULL)),
-};
-
-/* North bridge pins' configs setting bitmaps for Z1, this array idx is north bridge pin id. */
-static struct armada_3700_mpp_setting_bitmap armada_3700_z1_nb_mpp_bitmap[] = {
-	/* mask			config_num	configs */
-	{BIT(10),		2,		{0, BIT(10)}			},	/* pin 0 */
-	{BIT(10),		2,		{0, BIT(10)}			},	/* pin 1 */
-	{BIT(9),		2,		{0, BIT(9)}			},	/* pin 2 */
-	{BIT(9),		2,		{0, BIT(9)}			},	/* pin 3 */
-	{BIT(16),		2,		{0, BIT(16)}			},	/* pin 4 */
-	{0,			1,		{0}				},	/* pin 5 */
-	{BIT(8),		2,		{0, BIT(8)}			},	/* pin 6 */
-	{BIT(7),		2,		{0, BIT(7)}			},	/* pin 7 */
-	{BIT(1),		2,		{0, BIT(1)}			},	/* pin 8 */
-	{BIT(1) | BIT(19),	3,		{0, BIT(1), BIT(1) | BIT(19)}	},	/* pin 9 */
-	{BIT(1) | BIT(19),	3,		{0, BIT(1), BIT(1) | BIT(19)}	},	/* pin 10 */
-	{BIT(3) | BIT(20),	3,		{0, BIT(3), BIT(3) | BIT(20)}	},	/* pin 11 */
-	{BIT(4) | BIT(21),	3,		{0, BIT(4), BIT(4) | BIT(21)}	},	/* pin 12 */
-	{BIT(5) | BIT(22),	3,		{0, BIT(5), BIT(5) | BIT(22)}	},	/* pin 13 */
-	{BIT(6) | BIT(23),	3,		{0, BIT(6), BIT(6) | BIT(23)}	},	/* pin 14 */
-	{BIT(18),		2,		{0, BIT(18)}			},	/* pin 15 */
-	{BIT(18),		2,		{0, BIT(18)}			},	/* pin 16 */
-	{BIT(12),		2,		{0, BIT(12)}			},	/* pin 17 */
-	{BIT(13) | BIT(19),	3,		{0, BIT(13), BIT(19)}		},	/* pin 18 */
-	{BIT(14) | BIT(19),	3,		{0, BIT(14), BIT(19)}		},	/* pin 19 */
-	{BIT(0),		2,		{0, BIT(0)}			},	/* pin 20 */
-	{BIT(0),		2,		{0, BIT(0)}			},	/* pin 21 */
-	{BIT(0),		2,		{0, BIT(0)}			},	/* pin 22 */
-	{BIT(0),		2,		{0, BIT(0)}			},	/* pin 23 */
-	{BIT(0),		2,		{0, BIT(0)}			},	/* pin 24 */
-	{BIT(17),		2,		{0, BIT(17)}			},	/* pin 25 */
-	{BIT(17),		2,		{0, BIT(17)}			},	/* pin 26 */
-	{BIT(2),		2,		{0, BIT(2)}			},	/* pin 27 */
-	{BIT(2),		2,		{0, BIT(2)}			},	/* pin 28 */
-	{BIT(2),		2,		{0, BIT(2)}			},	/* pin 29 */
-	{BIT(2),		2,		{0, BIT(2)}			},	/* pin 30 */
-	{BIT(2),		2,		{0, BIT(2)}			},	/* pin 31 */
-	{BIT(2),		2,		{0, BIT(2)}			},	/* pin 32 */
-	{BIT(2),		2,		{0, BIT(2)}			},	/* pin 33 */
-	{BIT(2),		2,		{0, BIT(2)}			},	/* pin 34 */
-	{BIT(2),		2,		{0, BIT(2)}			},	/* pin 35 */
-	{BIT(15),		1,		{0}				},	/* pin 36 */
-};
-
-/* North bridge pin-ctl for A0 */
-static struct mvebu_mpp_mode armada_3700_nb_mpp_modes[] = {
-	MPP_MODE(0,
-	   MPP_FUNCTION(0x0, "i2c1", "sck"),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(1,
-	   MPP_FUNCTION(0x0, "i2c1", "sda"),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(2,
-	   MPP_FUNCTION(0x0, "i2c2", "sck"),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(3,
-	   MPP_FUNCTION(0x0, "i2c2", "sda"),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(4,
-	   MPP_FUNCTION(0x0, "1wire", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(5,
-	   MPP_FUNCTION(0x0, "gpio", NULL)),
-	MPP_MODE(6,
-	   MPP_FUNCTION(0x0, "pmic0", "slp-out"),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(7,
-	   MPP_FUNCTION(0x0, "pmic1", "slp-out"),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(8,
-	   MPP_FUNCTION(0x0, "sdio", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(9,
-	   MPP_FUNCTION(0x0, "sdio", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL),
-	   MPP_FUNCTION(0x2, "uart2", "rts")),
-	MPP_MODE(10,
-	   MPP_FUNCTION(0x0, "sdio", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL),
-	   MPP_FUNCTION(0x2, "uart2", "cts")),
-	MPP_MODE(11,
-	   MPP_FUNCTION(0x0, "pwm0", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL),
-	   MPP_FUNCTION(0x2, "led0-od", NULL)),
-	MPP_MODE(12,
-	   MPP_FUNCTION(0x0, "pwm1", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL),
-	   MPP_FUNCTION(0x2, "led1-od", NULL)),
-	MPP_MODE(13,
-	   MPP_FUNCTION(0x0, "pwm2", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL),
-	   MPP_FUNCTION(0x2, "led2-od", NULL)),
-	MPP_MODE(14,
-	   MPP_FUNCTION(0x0, "pwm3", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL),
-	   MPP_FUNCTION(0x2, "led3-od", NULL)),
-	MPP_MODE(15,
-	   MPP_FUNCTION(0x0, "spi-quad", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(16,
-	   MPP_FUNCTION(0x0, "spi-quad", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(17,
-	   MPP_FUNCTION(0x0, "spi-cs1", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(18,
-	   MPP_FUNCTION(0x0, "spi-cs2", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL),
-	   MPP_FUNCTION(0x2, "uart2", "tx")),
-	MPP_MODE(19,
-	   MPP_FUNCTION(0x0, "spi-cs3", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL),
-	   MPP_FUNCTION(0x2, "uart2", "rx")),
-	MPP_MODE(20,
-	   MPP_FUNCTION(0x0, "jtag", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(21,
-	   MPP_FUNCTION(0x0, "jtag", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(22,
-	   MPP_FUNCTION(0x0, "jtag", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(23,
-	   MPP_FUNCTION(0x0, "jtag", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(24,
-	   MPP_FUNCTION(0x0, "jtag", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(25,
-	   MPP_FUNCTION(0x0, "uart1", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(26,
-	   MPP_FUNCTION(0x0, "uart1", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(27,
-	   MPP_FUNCTION(0x0, "mmc", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(28,
-	   MPP_FUNCTION(0x0, "mmc", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(29,
-	   MPP_FUNCTION(0x0, "mmc", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(30,
-	   MPP_FUNCTION(0x0, "mmc", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(31,
-	   MPP_FUNCTION(0x0, "mmc", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(32,
-	   MPP_FUNCTION(0x0, "mmc", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(33,
-	   MPP_FUNCTION(0x0, "mmc", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(34,
-	   MPP_FUNCTION(0x0, "mmc", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(35,
-	   MPP_FUNCTION(0x0, "mmc", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	/*
-	 * The mpp36 is not a GPIO pin exposed to the user.
-	 * It is dedicated to spi function.
-	 */
-	MPP_MODE(36,
-	   MPP_FUNCTION(0x0, "spi", NULL)),
-};
-
-/* North bridge pins' configs setting bitmaps for A0, this array idx is north bridge pin id. */
-static struct armada_3700_mpp_setting_bitmap armada_3700_nb_mpp_bitmap[] = {
-	/* mask			config_num	configs */
-	{BIT(10),		2,		{0, BIT(10)}			},	/* pin 0 */
-	{BIT(10),		2,		{0, BIT(10)}			},	/* pin 1 */
-	{BIT(9),		2,		{0, BIT(9)}			},	/* pin 2 */
-	{BIT(9),		2,		{0, BIT(9)}			},	/* pin 3 */
-	{BIT(16),		2,		{0, BIT(16)}			},	/* pin 4 */
-	{0,			1,		{0}				},	/* pin 5 */
-	{BIT(8),		2,		{0, BIT(8)}			},	/* pin 6 */
-	{BIT(7),		2,		{0, BIT(7)}			},	/* pin 7 */
-	{BIT(1),		2,		{0, BIT(1)}			},	/* pin 8 */
-	{BIT(1) | BIT(19),	3,		{0, BIT(1), BIT(1) | BIT(19)}	},	/* pin 9 */
-	{BIT(1) | BIT(19),	3,		{0, BIT(1), BIT(1) | BIT(19)}	},	/* pin 10 */
-	{BIT(3) | BIT(20),	3,		{0, BIT(3), BIT(3) | BIT(20)}	},	/* pin 11 */
-	{BIT(4) | BIT(21),	3,		{0, BIT(4), BIT(4) | BIT(21)}	},	/* pin 12 */
-	{BIT(5) | BIT(22),	3,		{0, BIT(5), BIT(5) | BIT(22)}	},	/* pin 13 */
-	{BIT(6) | BIT(23),	3,		{0, BIT(6), BIT(6) | BIT(23)}	},	/* pin 14 */
-	{BIT(18),		2,		{0, BIT(18)}			},	/* pin 15 */
-	{BIT(18),		2,		{0, BIT(18)}			},	/* pin 16 */
-	{BIT(12),		2,		{0, BIT(12)}			},	/* pin 17 */
-	{BIT(13) | BIT(19),	3,		{0, BIT(13), BIT(19)}		},	/* pin 18 */
-	{BIT(14) | BIT(19),	3,		{0, BIT(14), BIT(19)}		},	/* pin 19 */
-	{BIT(0),		2,		{0, BIT(0)}			},	/* pin 20 */
-	{BIT(0),		2,		{0, BIT(0)}			},	/* pin 21 */
-	{BIT(0),		2,		{0, BIT(0)}			},	/* pin 22 */
-	{BIT(0),		2,		{0, BIT(0)}			},	/* pin 23 */
-	{BIT(0),		2,		{0, BIT(0)}			},	/* pin 24 */
-	{BIT(17),		2,		{0, BIT(17)}			},	/* pin 25 */
-	{BIT(17),		2,		{0, BIT(17)}			},	/* pin 26 */
-	{BIT(2),		2,		{0, BIT(2)}			},	/* pin 27 */
-	{BIT(2),		2,		{0, BIT(2)}			},	/* pin 28 */
-	{BIT(2),		2,		{0, BIT(2)}			},	/* pin 29 */
-	{BIT(2),		2,		{0, BIT(2)}			},	/* pin 30 */
-	{BIT(2),		2,		{0, BIT(2)}			},	/* pin 31 */
-	{BIT(2),		2,		{0, BIT(2)}			},	/* pin 32 */
-	{BIT(2),		2,		{0, BIT(2)}			},	/* pin 33 */
-	{BIT(2),		2,		{0, BIT(2)}			},	/* pin 34 */
-	{BIT(2),		2,		{0, BIT(2)}			},	/* pin 35 */
-	{BIT(15),		1,		{0}				},	/* pin 36 */
-};
-
-static int armada_3700_nb_mpp_ctrl_get(unsigned pid, unsigned long *config)
-{
-	int rc;
-
-	if (pid > a3700_mpp_conf_ptr[I_NORTHBRIDGE]->nmodes) {
-		pr_err("North bridge pin id %u is out of range!\n", pid);
-		return -EINVAL;
-	}
-
-	rc = armada_3700_mpp_ctrl_get(pid, a3700_mpp_conf_ptr[I_NORTHBRIDGE]->bitmap, mpp_base[I_NORTHBRIDGE], config);
-	if (rc) {
-		pr_err("Failed to get north bridge pin %d's config!\n", pid);
-		return rc;
-	}
-
-	pr_debug("%s %d pid %d config %lu\n", __func__, __LINE__, pid, *config);
-	return 0;
-}
-
-static int armada_3700_nb_mpp_ctrl_set(unsigned pid, unsigned long config)
-{
-	int rc;
-
-	if (pid > a3700_mpp_conf_ptr[I_NORTHBRIDGE]->nmodes) {
-		pr_err("North bridge Pin id %u is out of range!\n", pid);
-		return -EINVAL;
-	}
-
-	rc = armada_3700_mpp_ctrl_set(pid, a3700_mpp_conf_ptr[I_NORTHBRIDGE]->bitmap, mpp_base[I_NORTHBRIDGE], config);
-	if (rc) {
-		pr_err("Failed to set config %lu for north bridge pin %d!\n", config, pid);
-		return rc;
-	}
-
-	pr_debug("%s %d pid %d config %lu\n", __func__, __LINE__, pid, config);
-	return 0;
-}
-
-static struct mvebu_mpp_ctrl armada_3700_nb_mpp_controls[] = {
-	MPP_FUNC_CTRL(0, 36, NULL, armada_3700_nb_mpp_ctrl),
-};
-
-/* The mpp36 is not a GPIO pin exposed to the user, excluded from the GPIO range. */
-static struct pinctrl_gpio_range armada_3700_nb_mpp_gpio_ranges[] = {
-	MPP_GPIO_RANGE(0, 0, 0, 36),
-};
-
-/* south bridge pin-ctl for Z1 */
-static struct mvebu_mpp_mode armada_3700_z1_sb_mpp_modes[] = {
-	MPP_MODE(0,
-	   MPP_FUNCTION(0x0, "usb32", "drvvbus0"),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(1,
-	   MPP_FUNCTION(0x0, "usb2", "drvvbus1"),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(2,
-	   MPP_FUNCTION(0x0, "gpio", NULL)),
-	MPP_MODE(3,
-	   MPP_FUNCTION(0x0, "pcie1", "resetn"),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(4,
-	   MPP_FUNCTION(0x0, "pcie1", "clkreq"),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(5,
-	   MPP_FUNCTION(0x0, "gpio", NULL)),
-	MPP_MODE(6,
-	   MPP_FUNCTION(0x0, "rgmii/mii/smi", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(7,
-	   MPP_FUNCTION(0x0, "rgmii/mii/smi", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(8,
-	   MPP_FUNCTION(0x0, "rgmii/mii/smi", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(9,
-	   MPP_FUNCTION(0x0, "rgmii/mii/smi", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(10,
-	   MPP_FUNCTION(0x0, "rgmii/mii/smi", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(11,
-	   MPP_FUNCTION(0x0, "rgmii/mii/smi", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(12,
-	   MPP_FUNCTION(0x0, "rgmii/mii/smi", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(13,
-	   MPP_FUNCTION(0x0, "rgmii/mii/smi", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(14,
-	   MPP_FUNCTION(0x0, "rgmii/mii/smi", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(15,
-	   MPP_FUNCTION(0x0, "rgmii/mii/smi", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(16,
-	   MPP_FUNCTION(0x0, "rgmii/mii/smi", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(17,
-	   MPP_FUNCTION(0x0, "rgmii/mii/smi", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(18,
-	   MPP_FUNCTION(0x0, "rgmii/mii/smi", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(19,
-	   MPP_FUNCTION(0x0, "rgmii/mii/smi", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(20,
-	   MPP_FUNCTION(0x0, "ptp/mii", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(21,
-	   MPP_FUNCTION(0x0, "ptp", "clk-req"),
-	   MPP_FUNCTION(0x1, "gpio", NULL),
-	   MPP_FUNCTION(0x2, "mii", "tx-err")),
-	MPP_MODE(22,
-	   MPP_FUNCTION(0x0, "ptp", "trig-gen"),
-	   MPP_FUNCTION(0x1, "gpio", NULL),
-	   MPP_FUNCTION(0x2, "mii", "carrier-sense")),
-	MPP_MODE(23,
-	   MPP_FUNCTION(0x0, "rgmii/mii/smi", "mii-collision"),
-	   MPP_FUNCTION(0x1, "gpio", NULL),
-	   MPP_FUNCTION(0x2, "mii", "tx-err")),
-	MPP_MODE(24,
-	   MPP_FUNCTION(0x0, "sdio", "sd0-d2"),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(25,
-	   MPP_FUNCTION(0x0, "sdio", "sd0-d3"),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(26,
-	   MPP_FUNCTION(0x0, "sdio", "sd0-d1"),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(27,
-	   MPP_FUNCTION(0x0, "sdio", "sd0-d0"),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(28,
-	   MPP_FUNCTION(0x0, "sdio", "sd0-cmd"),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(29,
-	   MPP_FUNCTION(0x0, "sdio", "sd0-clk"),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-};
-
-/* south bridge pins' configs setting bitmaps for Z1, this array idx is south bridge pin id */
-static struct armada_3700_mpp_setting_bitmap armada_3700_z1_sb_mpp_bitmap[] = {
-	/*mask			config_num	configs*/
-	{BIT(0),		2,		{0, BIT(0)}			},	/* pin 0 */
-	{BIT(1),		2,		{0, BIT(1)}			},	/* pin 1 */
-	{0,			1,		{0}				},	/* pin 2 */
-	{BIT(4),		2,		{0, BIT(4)}			},	/* pin 3 */
-	{BIT(4),		2,		{0, BIT(4)}			},	/* pin 4 */
-	{0,			1,		{0}				},	/* pin 5 */
-	{BIT(3),		2,		{0, BIT(3)}			},	/* pin 6 */
-	{BIT(3),		2,		{0, BIT(3)}			},	/* pin 7 */
-	{BIT(3),		2,		{0, BIT(3)}			},	/* pin 8 */
-	{BIT(3),		2,		{0, BIT(3)}			},	/* pin 9 */
-	{BIT(3),		2,		{0, BIT(3)}			},	/* pin 10 */
-	{BIT(3),		2,		{0, BIT(3)}			},	/* pin 11 */
-	{BIT(3),		2,		{0, BIT(3)}			},	/* pin 12 */
-	{BIT(3),		2,		{0, BIT(3)}			},	/* pin 13 */
-	{BIT(3),		2,		{0, BIT(3)}			},	/* pin 14 */
-	{BIT(3),		2,		{0, BIT(3)}			},	/* pin 15 */
-	{BIT(3),		2,		{0, BIT(3)}			},	/* pin 16 */
-	{BIT(3),		2,		{0, BIT(3)}			},	/* pin 17 */
-	{BIT(3),		2,		{0, BIT(3)}			},	/* pin 18 */
-	{BIT(3),		2,		{0, BIT(3)}			},	/* pin 19 */
-	{BIT(5),		2,		{0, BIT(5)}			},	/* pin 20 */
-	{BIT(5) | BIT(6),	3,		{0, BIT(5), BIT(6)}		},	/* pin 21 */
-	{BIT(5) | BIT(7),	3,		{0, BIT(5), BIT(7)}		},	/* pin 22 */
-	{BIT(3) | BIT(8),	3,		{0, BIT(3), BIT(8)}		},	/* pin 23 */
-	{BIT(2),		2,		{0, BIT(2)}			},	/* pin 24 */
-	{BIT(2),		2,		{0, BIT(2)}			},	/* pin 25 */
-	{BIT(2),		2,		{0, BIT(2)}			},	/* pin 26 */
-	{BIT(2),		2,		{0, BIT(2)}			},	/* pin 27 */
-	{BIT(2),		2,		{0, BIT(2)}			},	/* pin 28 */
-	{BIT(2),		2,		{0, BIT(2)}			},	/* pin 29 */
-};
-
-/* south bridge pin-ctl for A0 */
-static struct mvebu_mpp_mode armada_3700_sb_mpp_modes[] = {
-	MPP_MODE(0,
-	   MPP_FUNCTION(0x0, "usb32", "drvvbus0"),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(1,
-	   MPP_FUNCTION(0x0, "usb2", "drvvbus1"),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(2,
-	   MPP_FUNCTION(0x0, "gpio", NULL)),
-	MPP_MODE(3,
-	   MPP_FUNCTION(0x0, "pcie1", "resetn"),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(4,
-	   MPP_FUNCTION(0x0, "pcie1", "clkreq"),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(5,
-	   MPP_FUNCTION(0x0, "pcie1", "wakeup"),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(6,
-	   MPP_FUNCTION(0x0, "rgmii", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(7,
-	   MPP_FUNCTION(0x0, "rgmii", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(8,
-	   MPP_FUNCTION(0x0, "rgmii", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(9,
-	   MPP_FUNCTION(0x0, "rgmii", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(10,
-	   MPP_FUNCTION(0x0, "rgmii", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(11,
-	   MPP_FUNCTION(0x0, "rgmii", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(12,
-	   MPP_FUNCTION(0x0, "rgmii", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(13,
-	   MPP_FUNCTION(0x0, "rgmii", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(14,
-	   MPP_FUNCTION(0x0, "rgmii", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(15,
-	   MPP_FUNCTION(0x0, "rgmii", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(16,
-	   MPP_FUNCTION(0x0, "rgmii", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(17,
-	   MPP_FUNCTION(0x0, "rgmii", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(18,
-	   MPP_FUNCTION(0x0, "smi", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(19,
-	   MPP_FUNCTION(0x0, "smi", NULL),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(20,
-	   MPP_FUNCTION(0x0, "ptp", "event-req"),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(21,
-	   MPP_FUNCTION(0x0, "ptp", "clk-req"),
-	   MPP_FUNCTION(0x1, "gpio", NULL),
-	   MPP_FUNCTION(0x2, "mii", "tx-err")),
-	MPP_MODE(22,
-	   MPP_FUNCTION(0x0, "ptp", "trig-gen"),
-	   MPP_FUNCTION(0x1, "gpio", NULL),
-	   MPP_FUNCTION(0x2, "mii", "carrier-sense")),
-	MPP_MODE(23,
-	   MPP_FUNCTION(0x0, "mii", "collision"),
-	   MPP_FUNCTION(0x1, "gpio", NULL),
-	   MPP_FUNCTION(0x2, "mii", "tx-err")),
-	MPP_MODE(24,
-	   MPP_FUNCTION(0x0, "sdio", "sd0-d2"),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(25,
-	   MPP_FUNCTION(0x0, "sdio", "sd0-d3"),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(26,
-	   MPP_FUNCTION(0x0, "sdio", "sd0-d1"),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(27,
-	   MPP_FUNCTION(0x0, "sdio", "sd0-d0"),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(28,
-	   MPP_FUNCTION(0x0, "sdio", "sd0-cmd"),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-	MPP_MODE(29,
-	   MPP_FUNCTION(0x0, "sdio", "sd0-clk"),
-	   MPP_FUNCTION(0x1, "gpio", NULL)),
-};
-
-/* south bridge pins' configs setting bitmaps for A0, this array idx is south bridge pin id */
-static struct armada_3700_mpp_setting_bitmap armada_3700_sb_mpp_bitmap[] = {
-	/*mask			config_num	configs*/
-	{BIT(0),		2,		{0, BIT(0)}			},	/* pin 0 */
-	{BIT(1),		2,		{0, BIT(1)}			},	/* pin 1 */
-	{0,			1,		{0}				},	/* pin 2 */
-	{BIT(5),		2,		{0, BIT(5)}			},	/* pin 3 */
-	{BIT(9),		2,		{0, BIT(9)}			},	/* pin 4 */
-	{BIT(10),		2,		{0, BIT(10)}			},	/* pin 5 */
-	{BIT(3),		2,		{0, BIT(3)}			},	/* pin 6 */
-	{BIT(3),		2,		{0, BIT(3)}			},	/* pin 7 */
-	{BIT(3),		2,		{0, BIT(3)}			},	/* pin 8 */
-	{BIT(3),		2,		{0, BIT(3)}			},	/* pin 9 */
-	{BIT(3),		2,		{0, BIT(3)}			},	/* pin 10 */
-	{BIT(3),		2,		{0, BIT(3)}			},	/* pin 11 */
-	{BIT(3),		2,		{0, BIT(3)}			},	/* pin 12 */
-	{BIT(3),		2,		{0, BIT(3)}			},	/* pin 13 */
-	{BIT(3),		2,		{0, BIT(3)}			},	/* pin 14 */
-	{BIT(3),		2,		{0, BIT(3)}			},	/* pin 15 */
-	{BIT(3),		2,		{0, BIT(3)}			},	/* pin 16 */
-	{BIT(3),		2,		{0, BIT(3)}			},	/* pin 17 */
-	{BIT(4),		2,		{0, BIT(4)}			},	/* pin 18 */
-	{BIT(4),		2,		{0, BIT(4)}			},	/* pin 19 */
-	{BIT(11),		2,		{0, BIT(11)}			},	/* pin 20 */
-	{BIT(12) | BIT(6),	3,		{0, BIT(12), BIT(6)}		},	/* pin 21 */
-	{BIT(13) | BIT(7),	3,		{0, BIT(13), BIT(7)}		},	/* pin 22 */
-	{BIT(14) | BIT(8),	3,		{0, BIT(14), BIT(8)}		},	/* pin 23 */
-	{BIT(2),		2,		{0, BIT(2)}			},	/* pin 24 */
-	{BIT(2),		2,		{0, BIT(2)}			},	/* pin 25 */
-	{BIT(2),		2,		{0, BIT(2)}			},	/* pin 26 */
-	{BIT(2),		2,		{0, BIT(2)}			},	/* pin 27 */
-	{BIT(2),		2,		{0, BIT(2)}			},	/* pin 28 */
-	{BIT(2),		2,		{0, BIT(2)}			},	/* pin 29 */
-};
-
-static int armada_3700_sb_mpp_ctrl_get(unsigned pid, unsigned long *config)
-{
-	int rc;
-
-	if (pid > a3700_mpp_conf_ptr[I_SOUTHBRIDGE]->nmodes) {
-		pr_err("South bridge pin id %u is out of range!\n", pid);
-		return -EINVAL;
-	}
-
-	rc = armada_3700_mpp_ctrl_get(pid, a3700_mpp_conf_ptr[I_SOUTHBRIDGE]->bitmap, mpp_base[I_SOUTHBRIDGE], config);
-	if (rc) {
-		pr_err("Failed to get south bridge pin %d's config!\n", pid);
-		return rc;
-	}
-
-	pr_debug("%s %d pid %d config %lu\n", __func__, __LINE__, pid, *config);
-	return 0;
-}
-
-static int armada_3700_sb_mpp_ctrl_set(unsigned pid, unsigned long config)
-{
-	int rc;
-
-	if (pid > a3700_mpp_conf_ptr[I_SOUTHBRIDGE]->nmodes) {
-		pr_err("South bridge Pin id %u is out of range!\n", pid);
-		return -EINVAL;
-	}
-
-	rc = armada_3700_mpp_ctrl_set(pid, a3700_mpp_conf_ptr[I_SOUTHBRIDGE]->bitmap, mpp_base[I_SOUTHBRIDGE], config);
-	if (rc) {
-		pr_err("Failed to set config %lu for south bridge pin %d!\n", config, pid);
-		return rc;
-	}
-
-	pr_debug("%s %d pid %d config %lu\n", __func__, __LINE__, pid, config);
-	return 0;
-}
-
-static unsigned int armada_3700_mpp_consistency_check(struct armada_3700_mpp_conf *mpp_conf)
-{
-	unsigned int i, bitmap_array_size, modes_array_size;
-	struct mvebu_mpp_mode *mpp_mode;
-	struct armada_3700_mpp_setting_bitmap *bit_map;
-	struct mvebu_mpp_ctrl_setting *set;
-
-	bitmap_array_size = mpp_conf->nbitmaps;
-	modes_array_size = mpp_conf->nmodes;
-	mpp_mode = mpp_conf->modes;
-	bit_map = mpp_conf->bitmap;
-
-	if (bitmap_array_size != modes_array_size) {
-		pr_err("The sizes of bitmap and modes arrays are not same for bank %d!\n", mpp_conf->index);
-		return -EFAULT;
-	}
-
-	for (i = 0; i < bitmap_array_size; i++) {
-		unsigned int setting_num = 0;
-
-		/* get mpp pin i's setting number */
-		for (set = mpp_mode[i].settings; set->name != NULL; set++)
-			setting_num++;
-
-		if (bit_map[i].config_num != setting_num) {
-			pr_err("bank %d pid %d's config num are not same in bitmap and modes arrays!\n",
-				mpp_conf->index, i);
-			return -EFAULT;
-		}
-	}
-
-	return 0;
-}
-
-static struct mvebu_mpp_ctrl armada_3700_sb_mpp_controls[] = {
-	MPP_FUNC_CTRL(0, 29, NULL, armada_3700_sb_mpp_ctrl),
-};
-
-/* south bridge gpio starts from global gpio id 36 */
-static struct pinctrl_gpio_range armada_3700_sb_mpp_gpio_ranges[] = {
-	MPP_GPIO_RANGE(0, 0, 36, 30),
-};
-static struct mvebu_pinctrl_soc_info a3700_z1_mpp_sb_soc_info = {
-	.variant = 0,
-	.controls = armada_3700_sb_mpp_controls,
-	.ncontrols = ARRAY_SIZE(armada_3700_sb_mpp_controls),
-	.modes = armada_3700_z1_sb_mpp_modes,
-	.nmodes = ARRAY_SIZE(armada_3700_z1_sb_mpp_modes),
-	.gpioranges = armada_3700_sb_mpp_gpio_ranges,
-	.ngpioranges = ARRAY_SIZE(armada_3700_sb_mpp_gpio_ranges),
-};
-
-static struct armada_3700_mpp_conf a3700_z1_mpp_sb_conf = {
-	.soc_info = &a3700_z1_mpp_sb_soc_info,
-	.modes = armada_3700_z1_sb_mpp_modes,
-	.nmodes = ARRAY_SIZE(armada_3700_z1_sb_mpp_modes),
-	.bitmap = armada_3700_z1_sb_mpp_bitmap,
-	.nbitmaps = ARRAY_SIZE(armada_3700_z1_sb_mpp_bitmap),
-	.index = I_SOUTHBRIDGE,
-};
-static struct mvebu_pinctrl_soc_info a3700_mpp_sb_soc_info = {
-	.variant = 0,
-	.controls = armada_3700_sb_mpp_controls,
-	.ncontrols = ARRAY_SIZE(armada_3700_sb_mpp_controls),
-	.modes = armada_3700_sb_mpp_modes,
-	.nmodes = ARRAY_SIZE(armada_3700_sb_mpp_modes),
-	.gpioranges = armada_3700_sb_mpp_gpio_ranges,
-	.ngpioranges = ARRAY_SIZE(armada_3700_sb_mpp_gpio_ranges),
-};
-
-static struct armada_3700_mpp_conf a3700_mpp_sb_conf = {
-	.soc_info = &a3700_mpp_sb_soc_info,
-	.modes = armada_3700_sb_mpp_modes,
-	.nmodes = ARRAY_SIZE(armada_3700_sb_mpp_modes),
-	.bitmap = armada_3700_sb_mpp_bitmap,
-	.nbitmaps = ARRAY_SIZE(armada_3700_sb_mpp_bitmap),
-	.index = I_SOUTHBRIDGE,
-};
-
-static struct mvebu_pinctrl_soc_info a3700_z1_mpp_nb_soc_info = {
-	.variant = 0,
-	.controls = armada_3700_nb_mpp_controls,
-	.ncontrols = ARRAY_SIZE(armada_3700_nb_mpp_controls),
-	.modes = armada_3700_z1_nb_mpp_modes,
-	.nmodes = ARRAY_SIZE(armada_3700_z1_nb_mpp_modes),
-	.gpioranges = armada_3700_nb_mpp_gpio_ranges,
-	.ngpioranges = ARRAY_SIZE(armada_3700_nb_mpp_gpio_ranges),
-};
-
-static struct armada_3700_mpp_conf a3700_z1_mpp_nb_conf = {
-	.soc_info = &a3700_z1_mpp_nb_soc_info,
-	.modes = armada_3700_z1_nb_mpp_modes,
-	.nmodes = ARRAY_SIZE(armada_3700_z1_nb_mpp_modes),
-	.bitmap = armada_3700_z1_nb_mpp_bitmap,
-	.nbitmaps = ARRAY_SIZE(armada_3700_z1_nb_mpp_bitmap),
-	.index = I_NORTHBRIDGE,
-};
-
-static struct mvebu_pinctrl_soc_info a3700_mpp_nb_soc_info = {
-	.variant = 0,
-	.controls = armada_3700_nb_mpp_controls,
-	.ncontrols = ARRAY_SIZE(armada_3700_nb_mpp_controls),
-	.modes = armada_3700_nb_mpp_modes,
-	.nmodes = ARRAY_SIZE(armada_3700_nb_mpp_modes),
-	.gpioranges = armada_3700_nb_mpp_gpio_ranges,
-	.ngpioranges = ARRAY_SIZE(armada_3700_nb_mpp_gpio_ranges),
-};
-
-static struct armada_3700_mpp_conf a3700_mpp_nb_conf = {
-	.soc_info = &a3700_mpp_nb_soc_info,
-	.modes = armada_3700_nb_mpp_modes,
-	.nmodes = ARRAY_SIZE(armada_3700_nb_mpp_modes),
-	.bitmap = armada_3700_nb_mpp_bitmap,
-	.nbitmaps = ARRAY_SIZE(armada_3700_nb_mpp_bitmap),
-	.index = I_NORTHBRIDGE,
-};
-
-static const struct of_device_id armada_3700_pinctrl_of_match[] = {
-	{
-		.compatible = "marvell,armada-3700-z1-nb-pinctrl",
-		.data       = (void *) &a3700_z1_mpp_nb_conf
-	},
-	{
-		.compatible = "marvell,armada-3700-z1-sb-pinctrl",
-		.data       = (void *) &a3700_z1_mpp_sb_conf,
-	},
-	{
-		.compatible = "marvell,armada-3700-nb-pinctrl",
-		.data	    = (void *) &a3700_mpp_nb_conf
-	},
-	{
-		.compatible = "marvell,armada-3700-sb-pinctrl",
-		.data	    = (void *) &a3700_mpp_sb_conf,
-	},
-	{ },
-};
-
-static int armada_3700_pinctrl_probe(struct platform_device *pdev)
-{
-	const struct of_device_id *match =
-		of_match_device(armada_3700_pinctrl_of_match, &pdev->dev);
-	struct armada_3700_mpp_conf *mpp_conf;
-	struct resource *res;
-
-	if (!match)
-		return -ENODEV;
-
-	mpp_conf = (struct armada_3700_mpp_conf *) match->data;
-	if (mpp_conf->index > I_MAXCONTROLLER) {
-		dev_err(&pdev->dev, "controller index error, index=%d max=%d\n", mpp_conf->index, I_MAXCONTROLLER);
-		return -ENODEV;
-	}
-
-	if (armada_3700_mpp_consistency_check(mpp_conf) != 0)
-		return -EFAULT;
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	mpp_base[mpp_conf->index] = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(mpp_base[mpp_conf->index]))
-		return PTR_ERR(mpp_base[mpp_conf->index]);
-
-	a3700_mpp_conf_ptr[mpp_conf->index] = mpp_conf;
-
-	pdev->dev.platform_data = mpp_conf->soc_info;
-
-	return mvebu_pinctrl_probe(pdev);
-}
-
-static int armada_3700_pinctrl_remove(struct platform_device *pdev)
-{
-	return mvebu_pinctrl_remove(pdev);
-}
-
-#ifdef CONFIG_PM
-static int armada_3700_pinctrl_suspend(void)
-{
-	int i;
-
-	for (i = 0; i < I_MAXCONTROLLER; i++)
-		if (mpp_base[i] && (!IS_ERR(mpp_base[i])))
-			mpp_saved_regs[i] = readl(mpp_base[i]);
-	return 0;
-}
-
-static void armada_3700_pinctrl_resume(void)
-{
-	int i;
-
-	for (i = 0; i < I_MAXCONTROLLER; i++)
-		if (mpp_base[i] && (!IS_ERR(mpp_base[i])))
-			writel(mpp_saved_regs[i], mpp_base[i]);
-}
-
-static struct syscore_ops armada_3700_pinctrl_syscore_ops = {
-	.suspend = armada_3700_pinctrl_suspend,
-	.resume = armada_3700_pinctrl_resume,
-};
-#endif
-
-static struct platform_driver armada_3700_pinctrl_driver = {
-	.driver = {
-		.name = "armada-3700-pinctrl",
-		.of_match_table = armada_3700_pinctrl_of_match,
-	},
-	.probe = armada_3700_pinctrl_probe,
-	.remove = armada_3700_pinctrl_remove,
-};
-
-static int __init armada_3700_pinctrl_init(void)
-{
-#ifdef CONFIG_PM
-	/*
-	 * Register syscore ops for save/restore of registers across suspend.
-	 * It's important to ensure that this driver is running at an earlier
-	 * initcall level than any arch-specific init calls.
-	 */
-	register_syscore_ops(&armada_3700_pinctrl_syscore_ops);
-#endif
-	return platform_driver_register(&armada_3700_pinctrl_driver);
-}
-
-postcore_initcall(armada_3700_pinctrl_init);
-
-static void __exit armada_3700_pinctrl_exit(void)
-{
-	platform_driver_unregister(&armada_3700_pinctrl_driver);
-}
-
-module_exit(armada_3700_pinctrl_exit);
-
-MODULE_AUTHOR("Terry Zhou <bjzhou@marvell.com>");
-MODULE_DESCRIPTION("Marvell Armada 3700 pinctrl driver");
-MODULE_LICENSE("GPL v2");
-- 
2.7.4

