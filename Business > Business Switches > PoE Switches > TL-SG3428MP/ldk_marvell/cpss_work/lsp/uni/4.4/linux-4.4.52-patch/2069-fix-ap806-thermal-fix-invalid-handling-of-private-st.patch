From b0d355b8b8189e36e1fe597686939e4da9c10106 Mon Sep 17 00:00:00 2001
From: Evan Wang <xswang@marvell.com>
Date: Tue, 19 Sep 2017 15:40:00 +0800
Subject: [PATCH 2069/2241] fix: ap806: thermal: fix invalid handling of
 private struct

AP806 thermal sensor registers as a sensor of a Device
Tree thermal zone, it's binded differently from other
thermal sensors supported by this driver, such as
armada-370/380/XP and CP110.
When sensor initialization, the required information are
stored in private struct. For SoC except AP806 the private
struct is stored in thermal struct when register, but for
AP806 it is stored in an internal struct of thermal zone.
So AP806 can not get correct private data via thermal
struct when resume, which causes callback pointer to sensor
initialization is invalid and then causes CPU stuck.

To fix the issue, this patch registers the private thermal
struct as driver data instead of just the thermal struct,
which only changed the place to store private thermal and
for other SoCs the private thermal are same. So all SoCs
including AP806 can get its own private data correctly
which is required by sensor initialization when resume.

Change-Id: I5948c7220da69a6b7bd84ec97a7c51af001843ed
Signed-off-by: Evan Wang <xswang@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/44492
Reviewed-by: Omri Itach <omrii@marvell.com>
Tested-by: Omri Itach <omrii@marvell.com>
---
 drivers/thermal/armada_thermal.c | 15 +++++++--------
 1 file changed, 7 insertions(+), 8 deletions(-)

diff --git a/drivers/thermal/armada_thermal.c b/drivers/thermal/armada_thermal.c
index 5511777..d5e7f3e 100644
--- a/drivers/thermal/armada_thermal.c
+++ b/drivers/thermal/armada_thermal.c
@@ -83,6 +83,7 @@ struct armada_thermal_priv {
 	void __iomem *dfx;
 	struct armada_thermal_data *data;
 	struct platform_device *pdev;
+	struct thermal_zone_device *thermal;
 };
 
 struct armada_thermal_data {
@@ -786,6 +787,7 @@ static int armada_thermal_probe(struct platform_device *pdev)
 			"Failed to register thermal zone device\n");
 		return PTR_ERR(thermal);
 	}
+	priv->thermal = thermal;
 
 	/* Register overheat interrupt */
 	irq = platform_get_irq(pdev, 0);
@@ -801,30 +803,27 @@ static int armada_thermal_probe(struct platform_device *pdev)
 		pr_debug("armada_thermal: no irq was assigned\n");
 	}
 
-	platform_set_drvdata(pdev, thermal);
+	platform_set_drvdata(pdev, priv);
 
 	return 0;
 }
 
 static int armada_thermal_exit(struct platform_device *pdev)
 {
-	struct thermal_zone_device *armada_thermal =
-		platform_get_drvdata(pdev);
+	struct armada_thermal_priv *priv = platform_get_drvdata(pdev);
 
 	if (of_device_is_compatible(pdev->dev.of_node,
 				    "marvell,armada-ap806-thermal"))
-		thermal_zone_of_sensor_unregister(&pdev->dev, armada_thermal);
+		thermal_zone_of_sensor_unregister(&pdev->dev, priv->thermal);
 	else
-		thermal_zone_device_unregister(armada_thermal);
+		thermal_zone_device_unregister(priv->thermal);
 
 	return 0;
 }
 
 static int armada_thermal_resume(struct platform_device *pdev)
 {
-	struct thermal_zone_device *thermal =
-		platform_get_drvdata(pdev);
-	struct armada_thermal_priv *priv = thermal->devdata;
+	struct armada_thermal_priv *priv = platform_get_drvdata(pdev);
 
 	priv->data->init_sensor(pdev, priv);
 
-- 
2.7.4

