From 02df5f0b7812788fdc72d8900c14df8f95a21cd8 Mon Sep 17 00:00:00 2001
From: Dmitri Epshtein <dima@marvell.com>
Date: Tue, 19 Dec 2017 14:47:33 +0200
Subject: [PATCH 2119/2241] fix: uio: block thread calling uio_poll() by
 updating event counter

The issue: uio_poll() function doesn't block the caller thread,
           but return immediately.
The uio_read() function works correctly.
One of the differences between implementation of these functions is
update for "listener->event_count".
uio_read() function updates the event_count after each wake up event,
while uio_poll() function never update it.
This patch causes uio_poll() to work the same way as uio_read(), i.e.
update "listener->event_count" after each wake up event.
After this patch "uio_poll()" works correctly.

Change-Id: I7c9e056db63a31bb9e9f42a676a3396a60ec782f
Signed-off-by: Dmitri Epshtein <dima@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/47800
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
Reviewed-by: Omri Itach <omrii@marvell.com>
---
 drivers/uio/uio.c | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/drivers/uio/uio.c b/drivers/uio/uio.c
index bcc1fc0..933c436 100644
--- a/drivers/uio/uio.c
+++ b/drivers/uio/uio.c
@@ -492,13 +492,17 @@ static unsigned int uio_poll(struct file *filep, poll_table *wait)
 {
 	struct uio_listener *listener = filep->private_data;
 	struct uio_device *idev = listener->dev;
+	s32 event_count;
 
 	if (!idev->info->irq)
 		return -EIO;
 
 	poll_wait(filep, &idev->wait, wait);
-	if (listener->event_count != atomic_read(&idev->event))
+	event_count = atomic_read(&idev->event);
+	if (listener->event_count != event_count) {
+		listener->event_count = event_count;
 		return POLLIN | POLLRDNORM;
+	}
 	return 0;
 }
 
-- 
2.7.4

