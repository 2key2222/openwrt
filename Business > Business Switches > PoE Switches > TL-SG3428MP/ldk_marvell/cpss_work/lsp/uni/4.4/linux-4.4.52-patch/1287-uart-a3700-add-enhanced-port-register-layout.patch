From c8097d06e45565e6f57b905ad4e0b5fb35e2a8e7 Mon Sep 17 00:00:00 2001
From: Wilson Ding <dingwei@marvell.com>
Date: Tue, 10 Jan 2017 21:07:41 +0800
Subject: [PATCH 1287/2241] uart: a3700: add enhanced port register layout

Armada3700 has an Enhanced UART port. It supports
more feature, such as CTS, RTS, 4-byte transfer and
different FIFO size other than the primary UART
port. But it has the different register layout and
register bitmaps.
This is a preliminary patch for the Enhanced UART
port. It introduced the new compatible type and
register layout - 'REG_UART_A3700_EXT'.
Now, the Enhanced port still doesn't support the
advanced features.

Change-Id: I13cbc043b6b6f3e3feded5387469b627a4887ada
Signed-off-by: Wilson Ding <dingwei@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/35438
Tested-by: iSoC Platform CI <ykjenk@marvell.com>
---
 .../devicetree/bindings/tty/serial/mvebu-uart.txt  |  5 ++
 drivers/tty/serial/mvebu-uart.c                    | 53 ++++++++++++++++++++--
 2 files changed, 55 insertions(+), 3 deletions(-)

diff --git a/Documentation/devicetree/bindings/tty/serial/mvebu-uart.txt b/Documentation/devicetree/bindings/tty/serial/mvebu-uart.txt
index d37fabe..849d9a4 100644
--- a/Documentation/devicetree/bindings/tty/serial/mvebu-uart.txt
+++ b/Documentation/devicetree/bindings/tty/serial/mvebu-uart.txt
@@ -11,3 +11,8 @@ Example:
 		reg = <0x12000 0x200>;
 		interrupts = <43>;
 	};
+	serial@12200 {
+		compatible = "marvell,armada-3700-uart-ext";
+		reg = <0x12200 0x30>,
+		status = "disabled";
+	};
\ No newline at end of file
diff --git a/drivers/tty/serial/mvebu-uart.c b/drivers/tty/serial/mvebu-uart.c
index 656e65a..a322dbaa 100644
--- a/drivers/tty/serial/mvebu-uart.c
+++ b/drivers/tty/serial/mvebu-uart.c
@@ -38,16 +38,20 @@
 
 enum reg_uart_type {
 	REG_UART_A3700,
+	REG_UART_A3700_EXT,
 };
 
 struct uart_regs_layout {
 	unsigned int uart_ctrl;
+	unsigned int uart_ctrl2;
 	unsigned int uart_rbr;
 	unsigned int uart_tsh;
 	unsigned int uart_brdv;
 	unsigned int uart_stat;
 };
 /* Register Map */
+
+/* REG_UART_A3700 */
 #define UART_RBR		0x00
 #define  RBR_BRK_DET		BIT(15)
 #define  RBR_FRM_ERR_DET	BIT(14)
@@ -97,6 +101,23 @@ struct uart_regs_layout {
 
 #define UART_BRDV		0x10
 
+/* REG_UART_A3700_EXT */
+#define UART_EXT_CTRL		0x04
+
+#define UART_EXT_STAT		0x0c
+#define  EXT_STAT_TX_RDY_1B		BIT(15)
+#define  EXT_STAT_RX_RDY_1B		BIT(14)
+
+#define UART_EXT_BRDV		0x10
+
+#define UART_EXT_RBR_1BYTE	0x18
+
+#define UART_EXT_TSH_1BYTE	0x1c
+
+#define UART_EXT_CTRL2		0x20
+#define EXT_CTRL2_TX_RDY_INT_1B	BIT(6)
+#define EXT_CTRL2_RX_RDY_INT_1B	BIT(5)
+
 /* UART register layout definitions */
 static struct uart_regs_layout uart_regs_layout[] = {
 	[REG_UART_A3700] = {
@@ -105,7 +126,15 @@ static struct uart_regs_layout uart_regs_layout[] = {
 		.uart_tsh  = UART_TSH,
 		.uart_brdv = UART_BRDV,
 		.uart_stat = UART_STAT,
-	}
+	},
+	[REG_UART_A3700_EXT] = {
+		.uart_ctrl  = UART_EXT_CTRL,
+		.uart_ctrl2 = UART_EXT_CTRL2,
+		.uart_rbr   = UART_EXT_RBR_1BYTE,
+		.uart_tsh   = UART_EXT_TSH_1BYTE,
+		.uart_brdv  = UART_EXT_BRDV,
+		.uart_stat  = UART_EXT_STAT,
+	},
 };
 
 #define MVEBU_NR_UARTS		2
@@ -134,6 +163,7 @@ struct mvebu_uart_data {
 };
 
 #define REG_CTRL(uart_data)	((uart_data)->regs->uart_ctrl)
+#define REG_CTRL2(uart_data)	((uart_data)->regs->uart_ctrl2)
 #define REG_RBR(uart_data)	((uart_data)->regs->uart_rbr)
 #define REG_TSH(uart_data)	((uart_data)->regs->uart_tsh)
 #define REG_BRDV(uart_data)	((uart_data)->regs->uart_brdv)
@@ -145,6 +175,8 @@ static inline unsigned int get_ctrl_rx_1byte_rdy_int(struct mvebu_uart_data *dat
 	switch (data->reg_type) {
 	case REG_UART_A3700:
 		return CTRL_RX_RDY_INT;
+	case REG_UART_A3700_EXT:
+		return EXT_CTRL2_RX_RDY_INT_1B;
 	default:
 		break;
 	}
@@ -156,6 +188,8 @@ static inline unsigned int get_ctrl_tx_1byte_rdy_int(struct mvebu_uart_data *dat
 	switch (data->reg_type) {
 	case REG_UART_A3700:
 		return CTRL_TX_RDY_INT;
+	case REG_UART_A3700_EXT:
+		return EXT_CTRL2_TX_RDY_INT_1B;
 	default:
 		break;
 	}
@@ -167,6 +201,8 @@ static inline unsigned int get_stat_rx_1byte_rdy(struct mvebu_uart_data *data)
 	switch (data->reg_type) {
 	case REG_UART_A3700:
 		return STAT_RX_RDY;
+	case REG_UART_A3700_EXT:
+		return EXT_STAT_RX_RDY_1B;
 	default:
 		break;
 	}
@@ -178,6 +214,8 @@ static inline unsigned int get_stat_tx_1byte_rdy(struct mvebu_uart_data *data)
 	switch (data->reg_type) {
 	case REG_UART_A3700:
 		return STAT_TX_RDY;
+	case REG_UART_A3700_EXT:
+		return EXT_STAT_TX_RDY_1B;
 	default:
 		break;
 	}
@@ -741,7 +779,15 @@ static int mvebu_uart_probe(struct platform_device *pdev)
 	data->reg_bits.stat_tx_rdy     = get_stat_tx_1byte_rdy;
 
 	/* Set interrupt registers */
-	data->intr.ctrl_reg = REG_CTRL(data);
+	/* Todo:
+	 * CTRL2 register is used for tx and rx interrupt control
+	 * ONLY in 1-byte transfer mode with REG_A3700_EXT registers
+	 * layout.
+	 */
+	if (data->reg_type == REG_UART_A3700_EXT)
+		data->intr.ctrl_reg = REG_CTRL2(data);
+	else
+		data->intr.ctrl_reg = REG_CTRL(data);
 
 	port->private_data = data;
 	platform_set_drvdata(pdev, data);
@@ -765,7 +811,8 @@ static int mvebu_uart_remove(struct platform_device *pdev)
 
 /* Match table for of_platform binding */
 static const struct of_device_id mvebu_uart_of_match[] = {
-	{ .compatible = "marvell,armada-3700-uart", .data = (void *)REG_UART_A3700 },
+	{ .compatible = "marvell,armada-3700-uart",     .data = (void *)REG_UART_A3700     },
+	{ .compatible = "marvell,armada-3700-uart-ext", .data = (void *)REG_UART_A3700_EXT },
 	{}
 };
 MODULE_DEVICE_TABLE(of, mvebu_uart_of_match);
-- 
2.7.4

