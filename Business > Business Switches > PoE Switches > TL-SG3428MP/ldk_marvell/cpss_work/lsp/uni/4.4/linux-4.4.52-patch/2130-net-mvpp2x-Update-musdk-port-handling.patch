From 94940ba959365d5b48bdff0e1ddc5ab4a71a2018 Mon Sep 17 00:00:00 2001
From: Yuval Caduri <cyuval@marvell.com>
Date: Sun, 24 Dec 2017 14:57:58 +0200
Subject: [PATCH 2130/2241] net: mvpp2x: Update musdk port handling

- Preparational stages to replace adding musdk by use of musdk_status
  in dts file, to uio based port transition.
- In this patch:
1. The ethtool_ops and netdev_ops for musdk are deleted,
   musdk ports share the same ops as regular ports.
2. Many of the ethtool_ops and netdev_ops now include
   if (port != MVPP2_F_IF_MUSDK) condition to continue.
3. For musdk_ports the tx_queues are never woken up.
 a. This is required so that Linux will not use tx_functions
    (ndo_start_xmit) on a musdk port.
 b. The more natural alternative would be to create the musdk netdevice
    with txq_count=0, this is not possible in Linux.
4.  musdk_port teardown.
 a. During teardown, some resources do not exist for musdk_ports.
 b. Instead of adding additional 'if MVPP2_F_IF_MUSDK' conditions,
    code was added to check if the resources themselves were created.
    i.e. (hrtimer_cancel, tasklet_kill).

Change-Id: Ibf938fc27ef8b41bb98fe2dba3129cc25ce7f4a4
Signed-off-by: Yuval Caduri <cyuval@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/48060
Tested-by: Omri Itach <omrii@marvell.com>
---
 drivers/net/ethernet/marvell/mvpp2x/mv_pp2x.h      |   1 +
 .../net/ethernet/marvell/mvpp2x/mv_pp2x_ethtool.c  |  45 +++------
 .../net/ethernet/marvell/mvpp2x/mv_pp2x_hw_type.h  |   1 -
 drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c | 108 ++++++++-------------
 4 files changed, 59 insertions(+), 96 deletions(-)

diff --git a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x.h b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x.h
index d22a4e7..831eeaf 100644
--- a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x.h
+++ b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x.h
@@ -687,6 +687,7 @@ struct mv_pp2x_port {
 	struct mv_pp2x_cos cos_cfg;
 	struct mv_pp2x_rss rss_cfg;
 	struct notifier_block	port_hotplug_nb;
+	bool port_hotplugged;
 	bool use_interrupts; /* Used by Netmap */
 	bool interrupt_tx_done;
 };
diff --git a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_ethtool.c b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_ethtool.c
index 6e52c26..26aadb2 100644
--- a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_ethtool.c
+++ b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_ethtool.c
@@ -769,6 +769,9 @@ static u32 mv_pp2x_ethtool_get_rxfh_indir_size(struct net_device *dev)
 	if (port->priv->pp2_version == PPV21)
 		return -EOPNOTSUPP;
 
+	if (port->flags & MVPP2_F_IF_MUSDK)
+		return -EOPNOTSUPP;
+
 	return ARRAY_SIZE(port->priv->rx_indir_table);
 }
 
@@ -810,6 +813,9 @@ static int mv_pp2x_ethtool_get_rxnfc(struct net_device *dev,
 	if (port->priv->pp2_cfg.queue_mode == MVPP2_QDIST_SINGLE_MODE)
 		return -EOPNOTSUPP;
 
+	if (port->flags & MVPP2_F_IF_MUSDK)
+		return -EOPNOTSUPP;
+
 	if (!port)
 		return -EIO;
 
@@ -878,6 +884,9 @@ static int mv_pp2x_ethtool_set_rxnfc(struct net_device *dev, struct ethtool_rxnf
 	if (port->priv->pp2_cfg.queue_mode == MVPP2_QDIST_SINGLE_MODE)
 		return -EOPNOTSUPP;
 
+	if (port->flags & MVPP2_F_IF_MUSDK)
+		return -EOPNOTSUPP;
+
 	switch (cmd->cmd) {
 	case ETHTOOL_SRXFH:
 		ret =  mv_pp2x_set_rss_hash_opt(port, cmd);
@@ -902,6 +911,9 @@ static int mv_pp2x_ethtool_get_rxfh(struct net_device *dev, u32 *indir, u8 *key,
 	if (port->priv->pp2_cfg.queue_mode == MVPP2_QDIST_SINGLE_MODE)
 		return -EOPNOTSUPP;
 
+	if (port->flags & MVPP2_F_IF_MUSDK)
+		return -EOPNOTSUPP;
+
 	if (hfunc)
 		*hfunc = ETH_RSS_HASH_TOP;
 
@@ -927,6 +939,9 @@ static int mv_pp2x_ethtool_set_rxfh(struct net_device *dev, const u32 *indir,
 	if (port->priv->pp2_cfg.queue_mode == MVPP2_QDIST_SINGLE_MODE)
 		return -EOPNOTSUPP;
 
+	if (port->flags & MVPP2_F_IF_MUSDK)
+		return -EOPNOTSUPP;
+
 	/* We require at least one supported parameter to be changed
 	 * and no change in any of the unsupported parameters
 	 */
@@ -1191,34 +1206,4 @@ void mv_pp2x_set_ethtool_ops(struct net_device *netdev)
 	netdev->ethtool_ops = &mv_pp2x_eth_tool_ops;
 }
 
-/* Following eth_tool_ops is for musdk_ports, i.e. eth_ports that have the musdk-status property in their dts. */
-static const struct ethtool_ops mv_pp2x_non_kernel_eth_tool_ops = {
-	.get_link		= ethtool_op_get_link,
-	.get_settings		= mv_pp2x_ethtool_get_settings,
-	/*.set_settings		= mv_pp2x_ethtool_set_settings,*/
-	/*.set_coalesce		= mv_pp2x_ethtool_set_coalesce,*/
-	/*.get_coalesce		= mv_pp2x_ethtool_get_coalesce,*/
-	.nway_reset		= mv_pp2x_eth_tool_nway_reset,
-	.get_drvinfo		= mv_pp2x_ethtool_get_drvinfo,
-	.get_ethtool_stats	= mv_pp2x_eth_tool_get_ethtool_stats,
-	.get_sset_count		= mv_pp2x_eth_tool_get_sset_count,
-	.get_strings		= mv_pp2x_eth_tool_get_strings,
-	/*.get_ringparam	= mv_pp2x_ethtool_get_ringparam,*/
-	/*.set_ringparam	= mv_pp2x_ethtool_set_ringparam,*/
-	.get_pauseparam		= mv_pp2x_get_pauseparam,
-	.set_pauseparam		= mv_pp2x_set_pauseparam,
-	.get_rxfh_indir_size	= mv_pp2x_ethtool_get_rxfh_indir_size,
-	.get_rxnfc		= mv_pp2x_ethtool_get_rxnfc,
-	.set_rxnfc		= mv_pp2x_ethtool_set_rxnfc,
-	.get_rxfh		= mv_pp2x_ethtool_get_rxfh,
-	.set_rxfh		= mv_pp2x_ethtool_set_rxfh,
-	.get_regs_len           = mv_pp2x_ethtool_get_regs_len,
-	.get_regs		= mv_pp2x_ethtool_get_regs,
-	.self_test		= mv_pp2x_eth_tool_diag_test,
-};
-
-void mv_pp2x_set_non_kernel_ethtool_ops(struct net_device *netdev)
-{
-	netdev->ethtool_ops = &mv_pp2x_non_kernel_eth_tool_ops;
-}
 
diff --git a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw_type.h b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw_type.h
index 1e5fd82..2d662fb 100644
--- a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw_type.h
+++ b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_hw_type.h
@@ -1284,7 +1284,6 @@
 #define MVPP2_F_LOOPBACK		BIT(0) /* Loopback port */
 #define MVPP2_F_IFCAP_NETMAP		BIT(1) /* netmap port */
 #define MVPP2_F_IF_MUSDK		BIT(2) /* musdk port */
-#define MVPP2_F_IF_MUSDK_DOWN		BIT(3) /* musdk port that has been put stopped */
 
 /* Marvell tag types */
 enum mv_pp2x_tag_type {
diff --git a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c
index 86ec86b..fa6c91a 100644
--- a/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c
+++ b/drivers/net/ethernet/marvell/mvpp2x/mv_pp2x_main.c
@@ -1788,7 +1788,8 @@ static void mv_pp22_dev_link_event(struct net_device *dev)
 			return;
 
 		netif_carrier_on(dev);
-		netif_tx_wake_all_queues(dev);
+		if (!(port->flags & MVPP2_F_IF_MUSDK))
+			netif_tx_wake_all_queues(dev);
 		netdev_info(dev, "link up\n");
 		port->mac_data.flags |= MV_EMAC_F_LINK_UP;
 	} else {
@@ -1903,7 +1904,8 @@ static void mv_pp22_link_event(struct net_device *dev)
 			mv_pp2x_egress_enable(port);
 			mv_pp2x_ingress_enable(port);
 			netif_carrier_on(dev);
-			netif_tx_wake_all_queues(dev);
+			if (!(port->flags & MVPP2_F_IF_MUSDK))
+				netif_tx_wake_all_queues(dev);
 			mv_gop110_port_events_unmask(&port->priv->hw.gop,
 						     &port->mac_data);
 			port->mac_data.flags |= MV_EMAC_F_LINK_UP;
@@ -3741,7 +3743,7 @@ void mv_pp2x_start_dev(struct mv_pp2x_port *port)
 		}
 	}
 
-	if (port->mac_data.phy_dev)
+	if (port->mac_data.phy_dev && !(port->flags & MVPP2_F_IF_MUSDK))
 		netif_tx_start_all_queues(port->dev);
 
 	mv_pp2x_egress_enable(port);
@@ -3975,6 +3977,10 @@ int mv_pp2x_open_cls(struct net_device *dev)
 		return err;
 	}
 
+	/* For musdk ports do not updated classifier/rss, only parser. */
+	if (port->flags & MVPP2_F_IF_MUSDK)
+		return 0;
+
 	err = mv_pp2x_update_flow_info(hw);
 	if (err) {
 		netdev_err(port->dev, "cannot update flow info\n");
@@ -4041,11 +4047,6 @@ int mv_pp2x_open(struct net_device *dev)
 	struct mv_pp2x_port *port = netdev_priv(dev);
 	int err;
 
-	if (port->flags & MVPP2_F_IF_MUSDK_DOWN) {
-		netdev_warn(dev, "skipping ndo_open as this port isn't really down\n");
-		return 0;
-	}
-
 	set_device_base_address(dev);
 
 	/* Allocate the Rx/Tx queues */
@@ -4066,8 +4067,10 @@ int mv_pp2x_open(struct net_device *dev)
 	}
 
 	/* Only Mvpp22 support hot plug feature */
-	if (port->priv->pp2_version == PPV22  && !(port->flags & (MVPP2_F_IF_MUSDK | MVPP2_F_LOOPBACK)))
+	if (port->priv->pp2_version == PPV22  && !(port->flags & (MVPP2_F_IF_MUSDK | MVPP2_F_LOOPBACK))) {
 		register_hotcpu_notifier(&port->port_hotplug_nb);
+		port->port_hotplugged = true;
+	}
 
 	/* In default link is down */
 	netif_carrier_off(port->dev);
@@ -4111,23 +4114,28 @@ int mv_pp2x_stop(struct net_device *dev)
 
 	mv_pp2x_stop_dev(port);
 
-	/* Mask interrupts on all CPUs */
-	on_each_cpu(mv_pp2x_interrupts_mask, port, 1);
+	if (!(port->flags & MVPP2_F_IF_MUSDK)) {
+		/* Mask interrupts on all CPUs */
+		on_each_cpu(mv_pp2x_interrupts_mask, port, 1);
 
-	/* Mask shared interrupts */
-	mv_pp2x_shared_thread_interrupts_mask(port);
+		/* Mask shared interrupts */
+		mv_pp2x_shared_thread_interrupts_mask(port);
+	}
 	mv_pp2x_cleanup_irqs(port);
 
-	if (port->priv->pp2_version == PPV22)
+	if (port->port_hotplugged)
 		unregister_hotcpu_notifier(&port->port_hotplug_nb);
-	/* Cancel tx timers in case Tx done interrupts are disabled and if port is not in Netmap mode */
-	if (!(port->flags & MVPP2_F_IFCAP_NETMAP) && !port->interrupt_tx_done)  {
-		for_each_present_cpu(cpu) {
-			port_pcpu = per_cpu_ptr(port->pcpu, cpu);
+
+	/* Cancel Initalized timers and tasklets */
+	for_each_present_cpu(cpu) {
+		port_pcpu = per_cpu_ptr(port->pcpu, cpu);
+
+		if (port_pcpu->tx_done_timer.function) {
 			hrtimer_cancel(&port_pcpu->tx_done_timer);
 			port_pcpu->timer_scheduled = false;
-			tasklet_kill(&port_pcpu->tx_done_tasklet);
 		}
+		if (port_pcpu->tx_done_tasklet.func)
+			tasklet_kill(&port_pcpu->tx_done_tasklet);
 	}
 
 	mv_pp2x_cleanup_rxqs(port);
@@ -4274,6 +4282,11 @@ static int mv_pp2x_change_mtu(struct net_device *dev, int mtu)
 		return -EPERM;
 	}
 #endif
+	if (port->flags & MVPP2_F_IF_MUSDK) {
+		netdev_err(dev, "MTU can not be modified for port in MUSDK mode\n");
+		return -EPERM;
+	}
+
 
 	mtu = mv_pp2x_check_mtu_valid(dev, mtu);
 	if (mtu < 0) {
@@ -4410,6 +4423,10 @@ static int mv_pp2x_netdev_set_features(struct net_device *dev,
 		return 0;
 
 	if (changed & NETIF_F_RXHASH) {
+		if (port->flags & MVPP2_F_IF_MUSDK) {
+			netdev_err(dev, "Hashing can not be modified for port in MUSDK mode\n");
+			return -EPERM;
+		}
 		if (features & NETIF_F_RXHASH) {
 			/* Enable RSS */
 			mv_pp22_rss_enable(port, true);
@@ -4442,28 +4459,6 @@ u16 mv_pp2x_select_queue(struct net_device *dev, struct sk_buff *skb,
 		return mv_pp2x_txq_number * fallback(dev, skb);
 }
 
-/* Dummy netdev_ops for non-kernel (i.e. musdk) network devices */
-static int mv_pp2x_dummy_change_mtu(struct net_device *dev, int mtu)
-{
-	netdev_warn(dev, "ndo_change_mtu not supported\n");
-	return 0;
-}
-
-int mv_pp2x_dummy_stop(struct net_device *dev)
-{
-	struct mv_pp2x_port *port = netdev_priv(dev);
-
-	port->flags |= MVPP2_F_IF_MUSDK_DOWN;
-	netdev_warn(dev, "ndo_stop not supported\n");
-	return 0;
-}
-
-static int mv_pp2x_dummy_tx(struct sk_buff *skb, struct net_device *dev)
-{
-	pr_debug("mv_pp2x_dummy_tx\n");
-	return NETDEV_TX_OK;
-}
-
 /* Device ops */
 static const struct net_device_ops mv_pp2x_netdev_ops = {
 	.ndo_open		= mv_pp2x_open,
@@ -4480,21 +4475,6 @@ static const struct net_device_ops mv_pp2x_netdev_ops = {
 	.ndo_vlan_rx_kill_vid	= mv_pp2x_rx_kill_vid,
 };
 
-/* musdk ports contain dummy operations for those functions that are performed in UserSpace (i.e. musdk) */
-static const struct net_device_ops mv_pp2x_non_kernel_netdev_ops = {
-	.ndo_open		= mv_pp2x_open,
-	.ndo_stop		= mv_pp2x_dummy_stop,
-	.ndo_start_xmit		= mv_pp2x_dummy_tx,
-	/*.ndo_select_queue	= mv_pp2x_select_queue,*/
-	.ndo_set_rx_mode	= mv_pp2x_set_rx_mode,
-	.ndo_set_mac_address	= mv_pp2x_set_mac_address,
-	.ndo_change_mtu		= mv_pp2x_dummy_change_mtu,
-	.ndo_get_stats64	= mv_pp2x_get_stats64,
-	.ndo_do_ioctl		= mv_pp2x_ioctl,
-	.ndo_set_features	= mv_pp2x_netdev_set_features,
-	.ndo_vlan_rx_add_vid	= mv_pp2x_rx_add_vid,
-	.ndo_vlan_rx_kill_vid	= mv_pp2x_rx_kill_vid,
-};
 
 /* Driver initialization */
 
@@ -4893,8 +4873,7 @@ static int mv_pp2x_port_hw_init(struct mv_pp2x_port *port)
 	mv_pp2x_cls_port_config(port);
 
 	/* Initialize pools for swf */
-	if (!(port->flags & MVPP2_F_IF_MUSDK))
-		err = mv_pp2x_swf_bm_pool_init(port);
+	err = mv_pp2x_swf_bm_pool_init(port);
 
 	return err;
 }
@@ -5182,14 +5161,12 @@ static int mv_pp2x_port_probe(struct platform_device *pdev,
 	if (port->flags & MVPP2_F_IF_MUSDK) {
 		port->num_tx_queues = 0;
 		port->num_rx_queues = 0;
-		dev->netdev_ops = &mv_pp2x_non_kernel_netdev_ops;
-		mv_pp2x_set_non_kernel_ethtool_ops(dev);
 	} else {
 		port->num_tx_queues = mv_pp2x_txq_number;
 		port->num_rx_queues = mv_pp2x_rxq_number;
-		dev->netdev_ops = &mv_pp2x_netdev_ops;
-		mv_pp2x_set_ethtool_ops(dev);
 	}
+	dev->netdev_ops = &mv_pp2x_netdev_ops;
+	mv_pp2x_set_ethtool_ops(dev);
 
 	if (priv->pp2_version == PPV21)
 		port->first_rxq = (port->id) * mv_pp2x_rxq_number +
@@ -5240,6 +5217,10 @@ static int mv_pp2x_port_probe(struct platform_device *pdev,
 		err = -ENOMEM;
 		goto err_free_txq_pcpu;
 	}
+	for_each_present_cpu(cpu) {
+		port_pcpu = per_cpu_ptr(port->pcpu, cpu);
+		memset(port_pcpu, 0, sizeof(struct mv_pp2x_port_pcpu));
+	}
 	if ((!(port->flags & (MVPP2_F_IF_MUSDK | MVPP2_F_LOOPBACK))) && !port->interrupt_tx_done) {
 		for_each_present_cpu(cpu) {
 			port_pcpu = per_cpu_ptr(port->pcpu, cpu);
@@ -5254,8 +5235,6 @@ static int mv_pp2x_port_probe(struct platform_device *pdev,
 		}
 	}
 
-	if (port->flags & MVPP2_F_IF_MUSDK)
-		goto skip_tso_buffers;
 	/* Init pool of external buffers for TSO, fragmentation, etc */
 	for_each_present_cpu(cpu) {
 		port_pcpu = per_cpu_ptr(port->pcpu, cpu);
@@ -5285,7 +5264,6 @@ static int mv_pp2x_port_probe(struct platform_device *pdev,
 		}
 	}
 
-skip_tso_buffers:
 	features = NETIF_F_SG;
 	dev->features = features | NETIF_F_RXCSUM | NETIF_F_IP_CSUM |
 			NETIF_F_IPV6_CSUM | NETIF_F_TSO;
-- 
2.7.4

